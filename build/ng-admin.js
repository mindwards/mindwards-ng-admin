/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "http://localhost:8000/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(30);
	module.exports = __webpack_require__(144);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _UtilsStringUtils = __webpack_require__(23);

	var _UtilsStringUtils2 = _interopRequireDefault(_UtilsStringUtils);

	var Field = (function () {
	    function Field(name) {
	        _classCallCheck(this, Field);

	        this._name = name || Math.random().toString(36).substring(7);
	        this._detailLink = name === 'id';
	        this._type = "string";
	        this._order = null;
	        this._label = null;
	        this._maps = [];
	        this._transforms = [];
	        this._attributes = {};
	        this._cssClasses = null;
	        this._validation = { required: false, minlength: 0, maxlength: 99999 };
	        this._defaultValue = null;
	        this._editable = true;
	        this._sortable = true;
	        this._detailLinkRoute = 'edit';
	        this._pinned = false;
	        this._flattenable = true;
	        this.dashboard = true;
	        this.list = true;
	        this._template = function () {
	            return '';
	        };
	        this._templateIncludesLabel = false;
	    }

	    _createClass(Field, [{
	        key: "label",
	        value: function label() {
	            if (arguments.length) {
	                this._label = arguments[0];
	                return this;
	            }

	            if (this._label === null) {
	                return _UtilsStringUtils2["default"].camelCase(this._name);
	            }

	            return this._label;
	        }
	    }, {
	        key: "type",
	        value: function type() {
	            return this._type;
	        }
	    }, {
	        key: "name",
	        value: function name() {
	            if (arguments.length) {
	                this._name = arguments[0];
	                return this;
	            }

	            return this._name;
	        }
	    }, {
	        key: "order",
	        value: function order() {
	            if (arguments.length) {
	                if (arguments[1] !== true) {
	                    console.warn('Setting order with Field.order is deprecated, order directly in fields array');
	                }
	                this._order = arguments[0];
	                return this;
	            }

	            return this._order;
	        }
	    }, {
	        key: "isDetailLink",
	        value: function isDetailLink(detailLink) {
	            if (arguments.length) {
	                this._detailLink = arguments[0];
	                return this;
	            }

	            if (this._detailLink === null) {
	                return this._name === 'id';
	            }

	            return this._detailLink;
	        }
	    }, {
	        key: "map",

	        /**
	         * Add a function to be applied to the response object to turn it into an entry
	         */
	        value: function map(fn) {
	            if (!fn) return this._maps;
	            if (typeof fn !== "function") {
	                var type = typeof fn;
	                throw new Error("Map argument should be a function, " + type + " given.");
	            }

	            this._maps.push(fn);

	            return this;
	        }
	    }, {
	        key: "hasMaps",
	        value: function hasMaps() {
	            return !!this._maps.length;
	        }
	    }, {
	        key: "getMappedValue",
	        value: function getMappedValue(value, entry) {
	            for (var i in this._maps) {
	                value = this._maps[i](value, entry);
	            }

	            return value;
	        }

	        /**
	         * Add a function to be applied to the entry to turn it into a response object
	         */
	    }, {
	        key: "transform",
	        value: function transform(fn) {
	            if (!fn) return this._transforms;
	            if (typeof fn !== "function") {
	                var type = typeof fn;
	                throw new Error("transform argument should be a function, " + type + " given.");
	            }

	            this._transforms.push(fn);

	            return this;
	        }
	    }, {
	        key: "hasTranforms",
	        value: function hasTranforms() {
	            return !!this._transforms.length;
	        }
	    }, {
	        key: "getTransformedValue",
	        value: function getTransformedValue(value, entry) {
	            for (var i in this._transforms) {
	                value = this._transforms[i](value, entry);
	            }

	            return value;
	        }
	    }, {
	        key: "attributes",
	        value: function attributes(_attributes) {
	            if (!arguments.length) {
	                return this._attributes;
	            }

	            this._attributes = _attributes;

	            return this;
	        }
	    }, {
	        key: "cssClasses",
	        value: function cssClasses(classes) {
	            if (!arguments.length) return this._cssClasses;
	            this._cssClasses = classes;
	            return this;
	        }
	    }, {
	        key: "getCssClasses",
	        value: function getCssClasses(entry) {
	            if (!this._cssClasses) {
	                return '';
	            }

	            if (this._cssClasses.constructor === Array) {
	                return this._cssClasses.join(' ');
	            }

	            if (typeof this._cssClasses === 'function') {
	                return this._cssClasses(entry);
	            }

	            return this._cssClasses;
	        }
	    }, {
	        key: "validation",
	        value: function validation(_validation) {
	            if (!arguments.length) {
	                return this._validation;
	            }

	            for (var property in _validation) {
	                if (!_validation.hasOwnProperty(property)) continue;
	                if (_validation[property] === null) {
	                    delete this._validation[property];
	                } else {
	                    this._validation[property] = _validation[property];
	                }
	            }

	            return this;
	        }
	    }, {
	        key: "defaultValue",
	        value: function defaultValue(_defaultValue) {
	            if (!arguments.length) return this._defaultValue;
	            this._defaultValue = _defaultValue;
	            return this;
	        }
	    }, {
	        key: "editable",
	        value: function editable(_editable) {
	            if (!arguments.length) return this._editable;
	            this._editable = _editable;
	            return this;
	        }
	    }, {
	        key: "sortable",
	        value: function sortable(_sortable) {
	            if (!arguments.length) return this._sortable;
	            this._sortable = _sortable;
	            return this;
	        }
	    }, {
	        key: "detailLinkRoute",
	        value: function detailLinkRoute(route) {
	            if (!arguments.length) return this._detailLinkRoute;
	            this._detailLinkRoute = route;
	            return this;
	        }
	    }, {
	        key: "pinned",
	        value: function pinned(_pinned) {
	            if (!arguments.length) return this._pinned;
	            this._pinned = _pinned;
	            return this;
	        }
	    }, {
	        key: "flattenable",
	        value: function flattenable() {
	            return this._flattenable;
	        }
	    }, {
	        key: "getTemplateValue",
	        value: function getTemplateValue(data) {
	            if (typeof this._template === 'function') {
	                return this._template(data);
	            }

	            return this._template;
	        }
	    }, {
	        key: "getTemplateValueWithLabel",
	        value: function getTemplateValueWithLabel(data) {
	            return this._templateIncludesLabel ? this.getTemplateValue(data) : false;
	        }
	    }, {
	        key: "templateIncludesLabel",
	        value: function templateIncludesLabel(_templateIncludesLabel) {
	            if (!arguments.length) return this._templateIncludesLabel;
	            this._templateIncludesLabel = _templateIncludesLabel;
	            return this;
	        }
	    }, {
	        key: "template",
	        value: function template(_template) {
	            var templateIncludesLabel = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

	            if (!arguments.length) return this._template;
	            this._template = _template;
	            this._templateIncludesLabel = templateIncludesLabel;
	            return this;
	        }
	    }, {
	        key: "detailLink",
	        set: function set(isDetailLink) {
	            return this._detailLink = isDetailLink;
	        }
	    }]);

	    return Field;
	})();

	exports["default"] = Field;
	module.exports = exports["default"];
	//# sourceMappingURL=Field.js.map

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .

	(function(mod) {
	  if (true) // CommonJS
	    module.exports = mod();
	  else if (typeof define == "function" && define.amd) // AMD
	    return define([], mod);
	  else // Plain browser env
	    (this || window).CodeMirror = mod();
	})(function() {
	  "use strict";

	  // BROWSER SNIFFING

	  // Kludges for bugs and behavior differences that can't be feature
	  // detected are enabled based on userAgent etc sniffing.
	  var userAgent = navigator.userAgent;
	  var platform = navigator.platform;

	  var gecko = /gecko\/\d/i.test(userAgent);
	  var ie_upto10 = /MSIE \d/.test(userAgent);
	  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	  var ie = ie_upto10 || ie_11up;
	  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
	  var webkit = /WebKit\//.test(userAgent);
	  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	  var chrome = /Chrome\//.test(userAgent);
	  var presto = /Opera\//.test(userAgent);
	  var safari = /Apple Computer/.test(navigator.vendor);
	  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	  var phantom = /PhantomJS/.test(userAgent);

	  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	  // This is woefully incomplete. Suggestions for alternative methods welcome.
	  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	  var mac = ios || /Mac/.test(platform);
	  var chromeOS = /\bCrOS\b/.test(userAgent);
	  var windows = /win/i.test(platform);

	  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	  if (presto_version) presto_version = Number(presto_version[1]);
	  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	  var captureRightClick = gecko || (ie && ie_version >= 9);

	  // Optimize some code when these features are not used.
	  var sawReadOnlySpans = false, sawCollapsedSpans = false;

	  // EDITOR CONSTRUCTOR

	  // A CodeMirror instance represents an editor. This is the object
	  // that user code is usually dealing with.

	  function CodeMirror(place, options) {
	    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

	    this.options = options = options ? copyObj(options) : {};
	    // Determine effective options based on given values and defaults.
	    copyObj(defaults, options, false);
	    setGuttersForLineNumbers(options);

	    var doc = options.value;
	    if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);
	    this.doc = doc;

	    var input = new CodeMirror.inputStyles[options.inputStyle](this);
	    var display = this.display = new Display(place, doc, input);
	    display.wrapper.CodeMirror = this;
	    updateGutters(this);
	    themeChanged(this);
	    if (options.lineWrapping)
	      this.display.wrapper.className += " CodeMirror-wrap";
	    if (options.autofocus && !mobile) display.input.focus();
	    initScrollbars(this);

	    this.state = {
	      keyMaps: [],  // stores maps added by addKeyMap
	      overlays: [], // highlighting overlays, as added by addOverlay
	      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	      overwrite: false,
	      delayingBlurEvent: false,
	      focused: false,
	      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
	      selectingText: false,
	      draggingText: false,
	      highlight: new Delayed(), // stores highlight worker timeout
	      keySeq: null,  // Unfinished key sequence
	      specialChars: null
	    };

	    var cm = this;

	    // Override magic textarea content restore that IE sometimes does
	    // on our hidden textarea on reload
	    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

	    registerEventHandlers(this);
	    ensureGlobalHandlers();

	    startOperation(this);
	    this.curOp.forceUpdate = true;
	    attachDoc(this, doc);

	    if ((options.autofocus && !mobile) || cm.hasFocus())
	      setTimeout(bind(onFocus, this), 20);
	    else
	      onBlur(this);

	    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
	      optionHandlers[opt](this, options[opt], Init);
	    maybeUpdateLineNumberWidth(this);
	    if (options.finishInit) options.finishInit(this);
	    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
	    endOperation(this);
	    // Suppress optimizelegibility in Webkit, since it breaks text
	    // measuring on line wrapping boundaries.
	    if (webkit && options.lineWrapping &&
	        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	      display.lineDiv.style.textRendering = "auto";
	  }

	  // DISPLAY CONSTRUCTOR

	  // The display handles the DOM integration, both for input reading
	  // and content drawing. It holds references to DOM nodes and
	  // display-related state.

	  function Display(place, doc, input) {
	    var d = this;
	    this.input = input;

	    // Covers bottom-right square when both scrollbars are present.
	    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	    d.scrollbarFiller.setAttribute("cm-not-content", "true");
	    // Covers bottom of gutter when coverGutterNextToScrollbar is on
	    // and h scrollbar is present.
	    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	    d.gutterFiller.setAttribute("cm-not-content", "true");
	    // Will contain the actual code, positioned to cover the viewport.
	    d.lineDiv = elt("div", null, "CodeMirror-code");
	    // Elements are added to these to represent selection and cursors.
	    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	    // A visibility: hidden element used to find the size of things.
	    d.measure = elt("div", null, "CodeMirror-measure");
	    // When lines outside of the viewport are measured, they are drawn in this.
	    d.lineMeasure = elt("div", null, "CodeMirror-measure");
	    // Wraps everything that needs to exist inside the vertically-padded coordinate system
	    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                      null, "position: relative; outline: none");
	    // Moved around its parent to cover visible view.
	    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
	    // Set to the height of the document, allowing scrolling.
	    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	    d.sizerWidth = null;
	    // Behavior of elts with overflow: auto and padding is
	    // inconsistent across browsers. This is used to ensure the
	    // scrollable area is big enough.
	    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	    // Will contain the gutters, if any.
	    d.gutters = elt("div", null, "CodeMirror-gutters");
	    d.lineGutter = null;
	    // Actual scrollable element.
	    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	    d.scroller.setAttribute("tabIndex", "-1");
	    // The element in which the editor lives.
	    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

	    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

	    if (place) {
	      if (place.appendChild) place.appendChild(d.wrapper);
	      else place(d.wrapper);
	    }

	    // Current rendered range (may be bigger than the view window).
	    d.viewFrom = d.viewTo = doc.first;
	    d.reportedViewFrom = d.reportedViewTo = doc.first;
	    // Information about the rendered lines.
	    d.view = [];
	    d.renderedView = null;
	    // Holds info about a single rendered line when it was rendered
	    // for measurement, while not in view.
	    d.externalMeasured = null;
	    // Empty space (in pixels) above the view
	    d.viewOffset = 0;
	    d.lastWrapHeight = d.lastWrapWidth = 0;
	    d.updateLineNumbers = null;

	    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	    d.scrollbarsClipped = false;

	    // Used to only resize the line number gutter when necessary (when
	    // the amount of lines crosses a boundary that makes its width change)
	    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	    // Set to true when a non-horizontal-scrolling line widget is
	    // added. As an optimization, line widget aligning is skipped when
	    // this is false.
	    d.alignWidgets = false;

	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

	    // Tracks the maximum line length so that the horizontal scrollbar
	    // can be kept static when scrolling.
	    d.maxLine = null;
	    d.maxLineLength = 0;
	    d.maxLineChanged = false;

	    // Used for measuring wheel scrolling granularity
	    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

	    // True when shift is held down.
	    d.shift = false;

	    // Used to track whether anything happened since the context menu
	    // was opened.
	    d.selForContextMenu = null;

	    d.activeTouch = null;

	    input.init(d);
	  }

	  // STATE UPDATES

	  // Used to get the editor into a consistent state again when options change.

	  function loadMode(cm) {
	    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
	    resetModeState(cm);
	  }

	  function resetModeState(cm) {
	    cm.doc.iter(function(line) {
	      if (line.stateAfter) line.stateAfter = null;
	      if (line.styles) line.styles = null;
	    });
	    cm.doc.frontier = cm.doc.first;
	    startWorker(cm, 100);
	    cm.state.modeGen++;
	    if (cm.curOp) regChange(cm);
	  }

	  function wrappingChanged(cm) {
	    if (cm.options.lineWrapping) {
	      addClass(cm.display.wrapper, "CodeMirror-wrap");
	      cm.display.sizer.style.minWidth = "";
	      cm.display.sizerWidth = null;
	    } else {
	      rmClass(cm.display.wrapper, "CodeMirror-wrap");
	      findMaxLine(cm);
	    }
	    estimateLineHeights(cm);
	    regChange(cm);
	    clearCaches(cm);
	    setTimeout(function(){updateScrollbars(cm);}, 100);
	  }

	  // Returns a function that estimates the height of a line, to use as
	  // first approximation until the line becomes visible (and is thus
	  // properly measurable).
	  function estimateHeight(cm) {
	    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	    return function(line) {
	      if (lineIsHidden(cm.doc, line)) return 0;

	      var widgetsHeight = 0;
	      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
	        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
	      }

	      if (wrapping)
	        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
	      else
	        return widgetsHeight + th;
	    };
	  }

	  function estimateLineHeights(cm) {
	    var doc = cm.doc, est = estimateHeight(cm);
	    doc.iter(function(line) {
	      var estHeight = est(line);
	      if (estHeight != line.height) updateLineHeight(line, estHeight);
	    });
	  }

	  function themeChanged(cm) {
	    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	    clearCaches(cm);
	  }

	  function guttersChanged(cm) {
	    updateGutters(cm);
	    regChange(cm);
	    setTimeout(function(){alignHorizontally(cm);}, 20);
	  }

	  // Rebuild the gutter elements, ensure the margin to the left of the
	  // code matches their width.
	  function updateGutters(cm) {
	    var gutters = cm.display.gutters, specs = cm.options.gutters;
	    removeChildren(gutters);
	    for (var i = 0; i < specs.length; ++i) {
	      var gutterClass = specs[i];
	      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
	      if (gutterClass == "CodeMirror-linenumbers") {
	        cm.display.lineGutter = gElt;
	        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
	      }
	    }
	    gutters.style.display = i ? "" : "none";
	    updateGutterSpace(cm);
	  }

	  function updateGutterSpace(cm) {
	    var width = cm.display.gutters.offsetWidth;
	    cm.display.sizer.style.marginLeft = width + "px";
	  }

	  // Compute the character length of a line, taking into account
	  // collapsed ranges (see markText) that might hide parts, and join
	  // other lines onto it.
	  function lineLength(line) {
	    if (line.height == 0) return 0;
	    var len = line.text.length, merged, cur = line;
	    while (merged = collapsedSpanAtStart(cur)) {
	      var found = merged.find(0, true);
	      cur = found.from.line;
	      len += found.from.ch - found.to.ch;
	    }
	    cur = line;
	    while (merged = collapsedSpanAtEnd(cur)) {
	      var found = merged.find(0, true);
	      len -= cur.text.length - found.from.ch;
	      cur = found.to.line;
	      len += cur.text.length - found.to.ch;
	    }
	    return len;
	  }

	  // Find the longest line in the document.
	  function findMaxLine(cm) {
	    var d = cm.display, doc = cm.doc;
	    d.maxLine = getLine(doc, doc.first);
	    d.maxLineLength = lineLength(d.maxLine);
	    d.maxLineChanged = true;
	    doc.iter(function(line) {
	      var len = lineLength(line);
	      if (len > d.maxLineLength) {
	        d.maxLineLength = len;
	        d.maxLine = line;
	      }
	    });
	  }

	  // Make sure the gutters options contains the element
	  // "CodeMirror-linenumbers" when the lineNumbers option is true.
	  function setGuttersForLineNumbers(options) {
	    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
	    if (found == -1 && options.lineNumbers) {
	      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
	    } else if (found > -1 && !options.lineNumbers) {
	      options.gutters = options.gutters.slice(0);
	      options.gutters.splice(found, 1);
	    }
	  }

	  // SCROLLBARS

	  // Prepare DOM reads needed to update the scrollbars. Done in one
	  // shot to minimize update/measure roundtrips.
	  function measureForScrollbars(cm) {
	    var d = cm.display, gutterW = d.gutters.offsetWidth;
	    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	    return {
	      clientHeight: d.scroller.clientHeight,
	      viewHeight: d.wrapper.clientHeight,
	      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	      viewWidth: d.wrapper.clientWidth,
	      barLeft: cm.options.fixedGutter ? gutterW : 0,
	      docHeight: docH,
	      scrollHeight: docH + scrollGap(cm) + d.barHeight,
	      nativeBarWidth: d.nativeBarWidth,
	      gutterWidth: gutterW
	    };
	  }

	  function NativeScrollbars(place, scroll, cm) {
	    this.cm = cm;
	    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	    place(vert); place(horiz);

	    on(vert, "scroll", function() {
	      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
	    });
	    on(horiz, "scroll", function() {
	      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
	    });

	    this.checkedZeroWidth = false;
	    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
	  }

	  NativeScrollbars.prototype = copyObj({
	    update: function(measure) {
	      var needsH = measure.scrollWidth > measure.clientWidth + 1;
	      var needsV = measure.scrollHeight > measure.clientHeight + 1;
	      var sWidth = measure.nativeBarWidth;

	      if (needsV) {
	        this.vert.style.display = "block";
	        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	        // A bug in IE8 can cause this value to be negative, so guard it.
	        this.vert.firstChild.style.height =
	          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	      } else {
	        this.vert.style.display = "";
	        this.vert.firstChild.style.height = "0";
	      }

	      if (needsH) {
	        this.horiz.style.display = "block";
	        this.horiz.style.right = needsV ? sWidth + "px" : "0";
	        this.horiz.style.left = measure.barLeft + "px";
	        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	        this.horiz.firstChild.style.width =
	          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	      } else {
	        this.horiz.style.display = "";
	        this.horiz.firstChild.style.width = "0";
	      }

	      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	        if (sWidth == 0) this.zeroWidthHack();
	        this.checkedZeroWidth = true;
	      }

	      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
	    },
	    setScrollLeft: function(pos) {
	      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
	      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);
	    },
	    setScrollTop: function(pos) {
	      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
	      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);
	    },
	    zeroWidthHack: function() {
	      var w = mac && !mac_geMountainLion ? "12px" : "18px";
	      this.horiz.style.height = this.vert.style.width = w;
	      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	      this.disableHoriz = new Delayed;
	      this.disableVert = new Delayed;
	    },
	    enableZeroWidthBar: function(bar, delay) {
	      bar.style.pointerEvents = "auto";
	      function maybeDisable() {
	        // To find out whether the scrollbar is still visible, we
	        // check whether the element under the pixel in the bottom
	        // left corner of the scrollbar box is the scrollbar box
	        // itself (when the bar is still visible) or its filler child
	        // (when the bar is hidden). If it is still visible, we keep
	        // it enabled, if it's hidden, we disable pointer events.
	        var box = bar.getBoundingClientRect();
	        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
	        if (elt != bar) bar.style.pointerEvents = "none";
	        else delay.set(1000, maybeDisable);
	      }
	      delay.set(1000, maybeDisable);
	    },
	    clear: function() {
	      var parent = this.horiz.parentNode;
	      parent.removeChild(this.horiz);
	      parent.removeChild(this.vert);
	    }
	  }, NativeScrollbars.prototype);

	  function NullScrollbars() {}

	  NullScrollbars.prototype = copyObj({
	    update: function() { return {bottom: 0, right: 0}; },
	    setScrollLeft: function() {},
	    setScrollTop: function() {},
	    clear: function() {}
	  }, NullScrollbars.prototype);

	  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

	  function initScrollbars(cm) {
	    if (cm.display.scrollbars) {
	      cm.display.scrollbars.clear();
	      if (cm.display.scrollbars.addClass)
	        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	    }

	    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
	      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	      // Prevent clicks in the scrollbars from killing focus
	      on(node, "mousedown", function() {
	        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
	      });
	      node.setAttribute("cm-not-content", "true");
	    }, function(pos, axis) {
	      if (axis == "horizontal") setScrollLeft(cm, pos);
	      else setScrollTop(cm, pos);
	    }, cm);
	    if (cm.display.scrollbars.addClass)
	      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	  }

	  function updateScrollbars(cm, measure) {
	    if (!measure) measure = measureForScrollbars(cm);
	    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	    updateScrollbarsInner(cm, measure);
	    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	        updateHeightsInViewport(cm);
	      updateScrollbarsInner(cm, measureForScrollbars(cm));
	      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	    }
	  }

	  // Re-synchronize the fake scrollbars with the actual size of the
	  // content.
	  function updateScrollbarsInner(cm, measure) {
	    var d = cm.display;
	    var sizes = d.scrollbars.update(measure);

	    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"

	    if (sizes.right && sizes.bottom) {
	      d.scrollbarFiller.style.display = "block";
	      d.scrollbarFiller.style.height = sizes.bottom + "px";
	      d.scrollbarFiller.style.width = sizes.right + "px";
	    } else d.scrollbarFiller.style.display = "";
	    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	      d.gutterFiller.style.display = "block";
	      d.gutterFiller.style.height = sizes.bottom + "px";
	      d.gutterFiller.style.width = measure.gutterWidth + "px";
	    } else d.gutterFiller.style.display = "";
	  }

	  // Compute the lines that are visible in a given viewport (defaults
	  // the the current scroll position). viewport may contain top,
	  // height, and ensure (see op.scrollToPos) properties.
	  function visibleLines(display, doc, viewport) {
	    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	    top = Math.floor(top - paddingTop(display));
	    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

	    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	    // forces those lines into the viewport (if possible).
	    if (viewport && viewport.ensure) {
	      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	      if (ensureFrom < from) {
	        from = ensureFrom;
	        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	        to = ensureTo;
	      }
	    }
	    return {from: from, to: Math.max(to, from + 1)};
	  }

	  // LINE NUMBERS

	  // Re-align line numbers and gutter marks to compensate for
	  // horizontal scrolling.
	  function alignHorizontally(cm) {
	    var display = cm.display, view = display.view;
	    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
	    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	    var gutterW = display.gutters.offsetWidth, left = comp + "px";
	    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
	      if (cm.options.fixedGutter) {
	        if (view[i].gutter)
	          view[i].gutter.style.left = left;
	        if (view[i].gutterBackground)
	          view[i].gutterBackground.style.left = left;
	      }
	      var align = view[i].alignable;
	      if (align) for (var j = 0; j < align.length; j++)
	        align[j].style.left = left;
	    }
	    if (cm.options.fixedGutter)
	      display.gutters.style.left = (comp + gutterW) + "px";
	  }

	  // Used to ensure that the line number gutter is still the right
	  // size for the current document size. Returns true when an update
	  // is needed.
	  function maybeUpdateLineNumberWidth(cm) {
	    if (!cm.options.lineNumbers) return false;
	    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	    if (last.length != display.lineNumChars) {
	      var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
	      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	      display.lineGutter.style.width = "";
	      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	      display.lineNumWidth = display.lineNumInnerWidth + padding;
	      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	      display.lineGutter.style.width = display.lineNumWidth + "px";
	      updateGutterSpace(cm);
	      return true;
	    }
	    return false;
	  }

	  function lineNumberFor(options, i) {
	    return String(options.lineNumberFormatter(i + options.firstLineNumber));
	  }

	  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	  // but using getBoundingClientRect to get a sub-pixel-accurate
	  // result.
	  function compensateForHScroll(display) {
	    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
	  }

	  // DISPLAY DRAWING

	  function DisplayUpdate(cm, viewport, force) {
	    var display = cm.display;

	    this.viewport = viewport;
	    // Store some values that we'll need later (but don't want to force a relayout for)
	    this.visible = visibleLines(display, cm.doc, viewport);
	    this.editorIsHidden = !display.wrapper.offsetWidth;
	    this.wrapperHeight = display.wrapper.clientHeight;
	    this.wrapperWidth = display.wrapper.clientWidth;
	    this.oldDisplayWidth = displayWidth(cm);
	    this.force = force;
	    this.dims = getDimensions(cm);
	    this.events = [];
	  }

	  DisplayUpdate.prototype.signal = function(emitter, type) {
	    if (hasHandler(emitter, type))
	      this.events.push(arguments);
	  };
	  DisplayUpdate.prototype.finish = function() {
	    for (var i = 0; i < this.events.length; i++)
	      signal.apply(null, this.events[i]);
	  };

	  function maybeClipScrollbars(cm) {
	    var display = cm.display;
	    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	      display.heightForcer.style.height = scrollGap(cm) + "px";
	      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	      display.scrollbarsClipped = true;
	    }
	  }

	  // Does the actual updating of the line display. Bails out
	  // (returning false) when there is nothing to be done and forced is
	  // false.
	  function updateDisplayIfNeeded(cm, update) {
	    var display = cm.display, doc = cm.doc;

	    if (update.editorIsHidden) {
	      resetView(cm);
	      return false;
	    }

	    // Bail out if the visible area is already rendered and nothing changed.
	    if (!update.force &&
	        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	        display.renderedView == display.view && countDirtyView(cm) == 0)
	      return false;

	    if (maybeUpdateLineNumberWidth(cm)) {
	      resetView(cm);
	      update.dims = getDimensions(cm);
	    }

	    // Compute a suitable new viewport (from & to)
	    var end = doc.first + doc.size;
	    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
	    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
	    if (sawCollapsedSpans) {
	      from = visualLineNo(cm.doc, from);
	      to = visualLineEndNo(cm.doc, to);
	    }

	    var different = from != display.viewFrom || to != display.viewTo ||
	      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	    adjustView(cm, from, to);

	    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	    // Position the mover div to align with the current scroll position
	    cm.display.mover.style.top = display.viewOffset + "px";

	    var toUpdate = countDirtyView(cm);
	    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	      return false;

	    // For big changes, we hide the enclosing element during the
	    // update, since that speeds up the operations on most browsers.
	    var focused = activeElt();
	    if (toUpdate > 4) display.lineDiv.style.display = "none";
	    patchDisplay(cm, display.updateLineNumbers, update.dims);
	    if (toUpdate > 4) display.lineDiv.style.display = "";
	    display.renderedView = display.view;
	    // There might have been a widget with a focused element that got
	    // hidden or updated, if so re-focus it.
	    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

	    // Prevent selection and cursors from interfering with the scroll
	    // width and height.
	    removeChildren(display.cursorDiv);
	    removeChildren(display.selectionDiv);
	    display.gutters.style.height = display.sizer.style.minHeight = 0;

	    if (different) {
	      display.lastWrapHeight = update.wrapperHeight;
	      display.lastWrapWidth = update.wrapperWidth;
	      startWorker(cm, 400);
	    }

	    display.updateLineNumbers = null;

	    return true;
	  }

	  function postUpdateDisplay(cm, update) {
	    var viewport = update.viewport;

	    for (var first = true;; first = false) {
	      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	        // Clip forced viewport to actual scrollable area.
	        if (viewport && viewport.top != null)
	          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
	        // Updated line heights might result in the drawn area not
	        // actually covering the viewport. Keep looping until it does.
	        update.visible = visibleLines(cm.display, cm.doc, viewport);
	        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	          break;
	      }
	      if (!updateDisplayIfNeeded(cm, update)) break;
	      updateHeightsInViewport(cm);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	    }

	    update.signal(cm, "update", cm);
	    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	    }
	  }

	  function updateDisplaySimple(cm, viewport) {
	    var update = new DisplayUpdate(cm, viewport);
	    if (updateDisplayIfNeeded(cm, update)) {
	      updateHeightsInViewport(cm);
	      postUpdateDisplay(cm, update);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	      update.finish();
	    }
	  }

	  function setDocumentHeight(cm, measure) {
	    cm.display.sizer.style.minHeight = measure.docHeight + "px";
	    cm.display.heightForcer.style.top = measure.docHeight + "px";
	    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	  }

	  // Read the actual heights of the rendered lines, and update their
	  // stored heights to match.
	  function updateHeightsInViewport(cm) {
	    var display = cm.display;
	    var prevBottom = display.lineDiv.offsetTop;
	    for (var i = 0; i < display.view.length; i++) {
	      var cur = display.view[i], height;
	      if (cur.hidden) continue;
	      if (ie && ie_version < 8) {
	        var bot = cur.node.offsetTop + cur.node.offsetHeight;
	        height = bot - prevBottom;
	        prevBottom = bot;
	      } else {
	        var box = cur.node.getBoundingClientRect();
	        height = box.bottom - box.top;
	      }
	      var diff = cur.line.height - height;
	      if (height < 2) height = textHeight(display);
	      if (diff > .001 || diff < -.001) {
	        updateLineHeight(cur.line, height);
	        updateWidgetHeight(cur.line);
	        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
	          updateWidgetHeight(cur.rest[j]);
	      }
	    }
	  }

	  // Read and store the height of line widgets associated with the
	  // given line.
	  function updateWidgetHeight(line) {
	    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
	      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
	  }

	  // Do a bulk-read of the DOM positions and sizes needed to draw the
	  // view, so that we don't interleave reading and writing to the DOM.
	  function getDimensions(cm) {
	    var d = cm.display, left = {}, width = {};
	    var gutterLeft = d.gutters.clientLeft;
	    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
	      width[cm.options.gutters[i]] = n.clientWidth;
	    }
	    return {fixedPos: compensateForHScroll(d),
	            gutterTotalWidth: d.gutters.offsetWidth,
	            gutterLeft: left,
	            gutterWidth: width,
	            wrapperWidth: d.wrapper.clientWidth};
	  }

	  // Sync the actual display DOM structure with display.view, removing
	  // nodes for lines that are no longer in view, and creating the ones
	  // that are not there yet, and updating the ones that are out of
	  // date.
	  function patchDisplay(cm, updateNumbersFrom, dims) {
	    var display = cm.display, lineNumbers = cm.options.lineNumbers;
	    var container = display.lineDiv, cur = container.firstChild;

	    function rm(node) {
	      var next = node.nextSibling;
	      // Works around a throw-scroll bug in OS X Webkit
	      if (webkit && mac && cm.display.currentWheelTarget == node)
	        node.style.display = "none";
	      else
	        node.parentNode.removeChild(node);
	      return next;
	    }

	    var view = display.view, lineN = display.viewFrom;
	    // Loop over the elements in the view, syncing cur (the DOM nodes
	    // in display.lineDiv) with the view as we go.
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (lineView.hidden) {
	      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	        var node = buildLineElement(cm, lineView, lineN, dims);
	        container.insertBefore(node, cur);
	      } else { // Already drawn
	        while (cur != lineView.node) cur = rm(cur);
	        var updateNumber = lineNumbers && updateNumbersFrom != null &&
	          updateNumbersFrom <= lineN && lineView.lineNumber;
	        if (lineView.changes) {
	          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
	          updateLineForChanges(cm, lineView, lineN, dims);
	        }
	        if (updateNumber) {
	          removeChildren(lineView.lineNumber);
	          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	        }
	        cur = lineView.node.nextSibling;
	      }
	      lineN += lineView.size;
	    }
	    while (cur) cur = rm(cur);
	  }

	  // When an aspect of a line changes, a string is added to
	  // lineView.changes. This updates the relevant part of the line's
	  // DOM structure.
	  function updateLineForChanges(cm, lineView, lineN, dims) {
	    for (var j = 0; j < lineView.changes.length; j++) {
	      var type = lineView.changes[j];
	      if (type == "text") updateLineText(cm, lineView);
	      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
	      else if (type == "class") updateLineClasses(lineView);
	      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
	    }
	    lineView.changes = null;
	  }

	  // Lines with gutter elements, widgets or a background class need to
	  // be wrapped, and have the extra elements added to the wrapper div
	  function ensureLineWrapped(lineView) {
	    if (lineView.node == lineView.text) {
	      lineView.node = elt("div", null, null, "position: relative");
	      if (lineView.text.parentNode)
	        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
	      lineView.node.appendChild(lineView.text);
	      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
	    }
	    return lineView.node;
	  }

	  function updateLineBackground(lineView) {
	    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	    if (cls) cls += " CodeMirror-linebackground";
	    if (lineView.background) {
	      if (cls) lineView.background.className = cls;
	      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	    } else if (cls) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	    }
	  }

	  // Wrapper around buildLineContent which will reuse the structure
	  // in display.externalMeasured when possible.
	  function getLineContent(cm, lineView) {
	    var ext = cm.display.externalMeasured;
	    if (ext && ext.line == lineView.line) {
	      cm.display.externalMeasured = null;
	      lineView.measure = ext.measure;
	      return ext.built;
	    }
	    return buildLineContent(cm, lineView);
	  }

	  // Redraw the line's text. Interacts with the background and text
	  // classes because the mode may output tokens that influence these
	  // classes.
	  function updateLineText(cm, lineView) {
	    var cls = lineView.text.className;
	    var built = getLineContent(cm, lineView);
	    if (lineView.text == lineView.node) lineView.node = built.pre;
	    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	    lineView.text = built.pre;
	    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	      lineView.bgClass = built.bgClass;
	      lineView.textClass = built.textClass;
	      updateLineClasses(lineView);
	    } else if (cls) {
	      lineView.text.className = cls;
	    }
	  }

	  function updateLineClasses(lineView) {
	    updateLineBackground(lineView);
	    if (lineView.line.wrapClass)
	      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
	    else if (lineView.node != lineView.text)
	      lineView.node.className = "";
	    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	    lineView.text.className = textClass || "";
	  }

	  function updateLineGutter(cm, lineView, lineN, dims) {
	    if (lineView.gutter) {
	      lineView.node.removeChild(lineView.gutter);
	      lineView.gutter = null;
	    }
	    if (lineView.gutterBackground) {
	      lineView.node.removeChild(lineView.gutterBackground);
	      lineView.gutterBackground = null;
	    }
	    if (lineView.line.gutterClass) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                      "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
	                                      "px; width: " + dims.gutterTotalWidth + "px");
	      wrap.insertBefore(lineView.gutterBackground, lineView.text);
	    }
	    var markers = lineView.line.gutterMarkers;
	    if (cm.options.lineNumbers || markers) {
	      var wrap = ensureLineWrapped(lineView);
	      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
	                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
	      cm.display.input.setUneditable(gutterWrap);
	      wrap.insertBefore(gutterWrap, lineView.text);
	      if (lineView.line.gutterClass)
	        gutterWrap.className += " " + lineView.line.gutterClass;
	      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	        lineView.lineNumber = gutterWrap.appendChild(
	          elt("div", lineNumberFor(cm.options, lineN),
	              "CodeMirror-linenumber CodeMirror-gutter-elt",
	              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
	              + cm.display.lineNumInnerWidth + "px"));
	      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
	        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
	        if (found)
	          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
	                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
	      }
	    }
	  }

	  function updateLineWidgets(cm, lineView, dims) {
	    if (lineView.alignable) lineView.alignable = null;
	    for (var node = lineView.node.firstChild, next; node; node = next) {
	      var next = node.nextSibling;
	      if (node.className == "CodeMirror-linewidget")
	        lineView.node.removeChild(node);
	    }
	    insertLineWidgets(cm, lineView, dims);
	  }

	  // Build a line's DOM representation from scratch
	  function buildLineElement(cm, lineView, lineN, dims) {
	    var built = getLineContent(cm, lineView);
	    lineView.text = lineView.node = built.pre;
	    if (built.bgClass) lineView.bgClass = built.bgClass;
	    if (built.textClass) lineView.textClass = built.textClass;

	    updateLineClasses(lineView);
	    updateLineGutter(cm, lineView, lineN, dims);
	    insertLineWidgets(cm, lineView, dims);
	    return lineView.node;
	  }

	  // A lineView may contain multiple logical lines (when merged by
	  // collapsed spans). The widgets for all of them need to be drawn.
	  function insertLineWidgets(cm, lineView, dims) {
	    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
	      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
	  }

	  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	    if (!line.widgets) return;
	    var wrap = ensureLineWrapped(lineView);
	    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
	      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
	      positionLineWidget(widget, node, lineView, dims);
	      cm.display.input.setUneditable(node);
	      if (allowAbove && widget.above)
	        wrap.insertBefore(node, lineView.gutter || lineView.text);
	      else
	        wrap.appendChild(node);
	      signalLater(widget, "redraw");
	    }
	  }

	  function positionLineWidget(widget, node, lineView, dims) {
	    if (widget.noHScroll) {
	      (lineView.alignable || (lineView.alignable = [])).push(node);
	      var width = dims.wrapperWidth;
	      node.style.left = dims.fixedPos + "px";
	      if (!widget.coverGutter) {
	        width -= dims.gutterTotalWidth;
	        node.style.paddingLeft = dims.gutterTotalWidth + "px";
	      }
	      node.style.width = width + "px";
	    }
	    if (widget.coverGutter) {
	      node.style.zIndex = 5;
	      node.style.position = "relative";
	      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
	    }
	  }

	  // POSITION OBJECT

	  // A Pos instance represents a position within the text.
	  var Pos = CodeMirror.Pos = function(line, ch) {
	    if (!(this instanceof Pos)) return new Pos(line, ch);
	    this.line = line; this.ch = ch;
	  };

	  // Compare two positions, return 0 if they are the same, a negative
	  // number when a is less, and a positive number otherwise.
	  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

	  function copyPos(x) {return Pos(x.line, x.ch);}
	  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
	  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

	  // INPUT HANDLING

	  function ensureFocus(cm) {
	    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	  }

	  // This will be set to a {lineWise: bool, text: [string]} object, so
	  // that, when pasting, we know what kind of selections the copied
	  // text was made out of.
	  var lastCopied = null;

	  function applyTextInput(cm, inserted, deleted, sel, origin) {
	    var doc = cm.doc;
	    cm.display.shift = false;
	    if (!sel) sel = doc.sel;

	    var paste = cm.state.pasteIncoming || origin == "paste";
	    var textLines = doc.splitLines(inserted), multiPaste = null
	    // When pasing N lines into N selections, insert one line per selection
	    if (paste && sel.ranges.length > 1) {
	      if (lastCopied && lastCopied.text.join("\n") == inserted) {
	        if (sel.ranges.length % lastCopied.text.length == 0) {
	          multiPaste = [];
	          for (var i = 0; i < lastCopied.text.length; i++)
	            multiPaste.push(doc.splitLines(lastCopied.text[i]));
	        }
	      } else if (textLines.length == sel.ranges.length) {
	        multiPaste = map(textLines, function(l) { return [l]; });
	      }
	    }

	    // Normal behavior is to insert the new text into every selection
	    for (var i = sel.ranges.length - 1; i >= 0; i--) {
	      var range = sel.ranges[i];
	      var from = range.from(), to = range.to();
	      if (range.empty()) {
	        if (deleted && deleted > 0) // Handle deletion
	          from = Pos(from.line, from.ch - deleted);
	        else if (cm.state.overwrite && !paste) // Handle overwrite
	          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
	        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	          from = to = Pos(from.line, 0)
	      }
	      var updateInput = cm.curOp.updateInput;
	      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
	                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
	      makeChange(cm.doc, changeEvent);
	      signalLater(cm, "inputRead", cm, changeEvent);
	    }
	    if (inserted && !paste)
	      triggerElectric(cm, inserted);

	    ensureCursorVisible(cm);
	    cm.curOp.updateInput = updateInput;
	    cm.curOp.typing = true;
	    cm.state.pasteIncoming = cm.state.cutIncoming = false;
	  }

	  function handlePaste(e, cm) {
	    var pasted = e.clipboardData && e.clipboardData.getData("Text");
	    if (pasted) {
	      e.preventDefault();
	      if (!cm.isReadOnly() && !cm.options.disableInput)
	        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
	      return true;
	    }
	  }

	  function triggerElectric(cm, inserted) {
	    // When an 'electric' character is inserted, immediately trigger a reindent
	    if (!cm.options.electricChars || !cm.options.smartIndent) return;
	    var sel = cm.doc.sel;

	    for (var i = sel.ranges.length - 1; i >= 0; i--) {
	      var range = sel.ranges[i];
	      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
	      var mode = cm.getModeAt(range.head);
	      var indented = false;
	      if (mode.electricChars) {
	        for (var j = 0; j < mode.electricChars.length; j++)
	          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	            indented = indentLine(cm, range.head.line, "smart");
	            break;
	          }
	      } else if (mode.electricInput) {
	        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
	          indented = indentLine(cm, range.head.line, "smart");
	      }
	      if (indented) signalLater(cm, "electricInput", cm, range.head.line);
	    }
	  }

	  function copyableRanges(cm) {
	    var text = [], ranges = [];
	    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	      var line = cm.doc.sel.ranges[i].head.line;
	      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	      ranges.push(lineRange);
	      text.push(cm.getRange(lineRange.anchor, lineRange.head));
	    }
	    return {text: text, ranges: ranges};
	  }

	  function disableBrowserMagic(field, spellcheck) {
	    field.setAttribute("autocorrect", "off");
	    field.setAttribute("autocapitalize", "off");
	    field.setAttribute("spellcheck", !!spellcheck);
	  }

	  // TEXTAREA INPUT STYLE

	  function TextareaInput(cm) {
	    this.cm = cm;
	    // See input.poll and input.reset
	    this.prevInput = "";

	    // Flag that indicates whether we expect input to appear real soon
	    // now (after some event like 'keypress' or 'input') and are
	    // polling intensively.
	    this.pollingFast = false;
	    // Self-resetting timeout for the poller
	    this.polling = new Delayed();
	    // Tracks when input.reset has punted to just putting a short
	    // string into the textarea instead of the full selection.
	    this.inaccurateSelection = false;
	    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	    this.hasSelection = false;
	    this.composing = null;
	  };

	  function hiddenTextarea() {
	    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	    // The textarea is kept positioned near the cursor to prevent the
	    // fact that it'll be scrolled into view on input from scrolling
	    // our fake cursor out of view. On webkit, when wrap=off, paste is
	    // very slow. So make the area wide instead.
	    if (webkit) te.style.width = "1000px";
	    else te.setAttribute("wrap", "off");
	    // If border: 0; -- iOS fails to open keyboard (issue #1287)
	    if (ios) te.style.border = "1px solid black";
	    disableBrowserMagic(te);
	    return div;
	  }

	  TextareaInput.prototype = copyObj({
	    init: function(display) {
	      var input = this, cm = this.cm;

	      // Wraps and hides input textarea
	      var div = this.wrapper = hiddenTextarea();
	      // The semihidden textarea that is focused when the editor is
	      // focused, and receives input.
	      var te = this.textarea = div.firstChild;
	      display.wrapper.insertBefore(div, display.wrapper.firstChild);

	      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	      if (ios) te.style.width = "0px";

	      on(te, "input", function() {
	        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
	        input.poll();
	      });

	      on(te, "paste", function(e) {
	        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return

	        cm.state.pasteIncoming = true;
	        input.fastPoll();
	      });

	      function prepareCopyCut(e) {
	        if (signalDOMEvent(cm, e)) return
	        if (cm.somethingSelected()) {
	          lastCopied = {lineWise: false, text: cm.getSelections()};
	          if (input.inaccurateSelection) {
	            input.prevInput = "";
	            input.inaccurateSelection = false;
	            te.value = lastCopied.text.join("\n");
	            selectInput(te);
	          }
	        } else if (!cm.options.lineWiseCopyCut) {
	          return;
	        } else {
	          var ranges = copyableRanges(cm);
	          lastCopied = {lineWise: true, text: ranges.text};
	          if (e.type == "cut") {
	            cm.setSelections(ranges.ranges, null, sel_dontScroll);
	          } else {
	            input.prevInput = "";
	            te.value = ranges.text.join("\n");
	            selectInput(te);
	          }
	        }
	        if (e.type == "cut") cm.state.cutIncoming = true;
	      }
	      on(te, "cut", prepareCopyCut);
	      on(te, "copy", prepareCopyCut);

	      on(display.scroller, "paste", function(e) {
	        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
	        cm.state.pasteIncoming = true;
	        input.focus();
	      });

	      // Prevent normal selection in the editor (we handle our own)
	      on(display.lineSpace, "selectstart", function(e) {
	        if (!eventInWidget(display, e)) e_preventDefault(e);
	      });

	      on(te, "compositionstart", function() {
	        var start = cm.getCursor("from");
	        if (input.composing) input.composing.range.clear()
	        input.composing = {
	          start: start,
	          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	        };
	      });
	      on(te, "compositionend", function() {
	        if (input.composing) {
	          input.poll();
	          input.composing.range.clear();
	          input.composing = null;
	        }
	      });
	    },

	    prepareSelection: function() {
	      // Redraw the selection and/or cursor
	      var cm = this.cm, display = cm.display, doc = cm.doc;
	      var result = prepareSelection(cm);

	      // Move the hidden textarea near the cursor to prevent scrolling artifacts
	      if (cm.options.moveInputWithCursor) {
	        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                            headPos.top + lineOff.top - wrapOff.top));
	        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                             headPos.left + lineOff.left - wrapOff.left));
	      }

	      return result;
	    },

	    showSelection: function(drawn) {
	      var cm = this.cm, display = cm.display;
	      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	      if (drawn.teTop != null) {
	        this.wrapper.style.top = drawn.teTop + "px";
	        this.wrapper.style.left = drawn.teLeft + "px";
	      }
	    },

	    // Reset the input to correspond to the selection (or to be empty,
	    // when not typing and nothing is selected)
	    reset: function(typing) {
	      if (this.contextMenuPending) return;
	      var minimal, selected, cm = this.cm, doc = cm.doc;
	      if (cm.somethingSelected()) {
	        this.prevInput = "";
	        var range = doc.sel.primary();
	        minimal = hasCopyEvent &&
	          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
	        var content = minimal ? "-" : selected || cm.getSelection();
	        this.textarea.value = content;
	        if (cm.state.focused) selectInput(this.textarea);
	        if (ie && ie_version >= 9) this.hasSelection = content;
	      } else if (!typing) {
	        this.prevInput = this.textarea.value = "";
	        if (ie && ie_version >= 9) this.hasSelection = null;
	      }
	      this.inaccurateSelection = minimal;
	    },

	    getField: function() { return this.textarea; },

	    supportsTouch: function() { return false; },

	    focus: function() {
	      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	        try { this.textarea.focus(); }
	        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	      }
	    },

	    blur: function() { this.textarea.blur(); },

	    resetPosition: function() {
	      this.wrapper.style.top = this.wrapper.style.left = 0;
	    },

	    receivedFocus: function() { this.slowPoll(); },

	    // Poll for input changes, using the normal rate of polling. This
	    // runs as long as the editor is focused.
	    slowPoll: function() {
	      var input = this;
	      if (input.pollingFast) return;
	      input.polling.set(this.cm.options.pollInterval, function() {
	        input.poll();
	        if (input.cm.state.focused) input.slowPoll();
	      });
	    },

	    // When an event has just come in that is likely to add or change
	    // something in the input textarea, we poll faster, to ensure that
	    // the change appears on the screen quickly.
	    fastPoll: function() {
	      var missed = false, input = this;
	      input.pollingFast = true;
	      function p() {
	        var changed = input.poll();
	        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	        else {input.pollingFast = false; input.slowPoll();}
	      }
	      input.polling.set(20, p);
	    },

	    // Read input from the textarea, and update the document to match.
	    // When something is selected, it is present in the textarea, and
	    // selected (unless it is huge, in which case a placeholder is
	    // used). When nothing is selected, the cursor sits after previously
	    // seen text (can be empty), which is stored in prevInput (we must
	    // not reset the textarea when typing, because that breaks IME).
	    poll: function() {
	      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	      // Since this is called a *lot*, try to bail out as cheaply as
	      // possible when it is clear that nothing happened. hasSelection
	      // will be the case when there is a lot of text in the textarea,
	      // in which case reading its value would be expensive.
	      if (this.contextMenuPending || !cm.state.focused ||
	          (hasSelection(input) && !prevInput && !this.composing) ||
	          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	        return false;

	      var text = input.value;
	      // If nothing changed, bail.
	      if (text == prevInput && !cm.somethingSelected()) return false;
	      // Work around nonsensical selection resetting in IE9/10, and
	      // inexplicable appearance of private area unicode characters on
	      // some key combos in Mac (#2689).
	      if (ie && ie_version >= 9 && this.hasSelection === text ||
	          mac && /[\uf700-\uf7ff]/.test(text)) {
	        cm.display.input.reset();
	        return false;
	      }

	      if (cm.doc.sel == cm.display.selForContextMenu) {
	        var first = text.charCodeAt(0);
	        if (first == 0x200b && !prevInput) prevInput = "\u200b";
	        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
	      }
	      // Find the part of the input that is actually new
	      var same = 0, l = Math.min(prevInput.length, text.length);
	      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

	      var self = this;
	      runInOp(cm, function() {
	        applyTextInput(cm, text.slice(same), prevInput.length - same,
	                       null, self.composing ? "*compose" : null);

	        // Don't leave long text in the textarea, since it makes further polling slow
	        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
	        else self.prevInput = text;

	        if (self.composing) {
	          self.composing.range.clear();
	          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
	                                             {className: "CodeMirror-composing"});
	        }
	      });
	      return true;
	    },

	    ensurePolled: function() {
	      if (this.pollingFast && this.poll()) this.pollingFast = false;
	    },

	    onKeyPress: function() {
	      if (ie && ie_version >= 9) this.hasSelection = null;
	      this.fastPoll();
	    },

	    onContextMenu: function(e) {
	      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	      if (!pos || presto) return; // Opera is difficult.

	      // Reset the current text selection only if the click is done outside of the selection
	      // and 'resetSelectionOnContextMenu' option is true.
	      var reset = cm.options.resetSelectionOnContextMenu;
	      if (reset && cm.doc.sel.contains(pos) == -1)
	        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

	      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	      input.wrapper.style.cssText = "position: absolute"
	      var wrapperBox = input.wrapper.getBoundingClientRect()
	      te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) +
	        "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " +
	        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
	        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
	      display.input.focus();
	      if (webkit) window.scrollTo(null, oldScrollY);
	      display.input.reset();
	      // Adds "Select all" to context menu in FF
	      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
	      input.contextMenuPending = true;
	      display.selForContextMenu = cm.doc.sel;
	      clearTimeout(display.detectingSelectAll);

	      // Select-all will be greyed out if there's nothing to select, so
	      // this adds a zero-width space so that we can later check whether
	      // it got selected.
	      function prepareSelectAllHack() {
	        if (te.selectionStart != null) {
	          var selected = cm.somethingSelected();
	          var extval = "\u200b" + (selected ? te.value : "");
	          te.value = "\u21da"; // Used to catch context-menu undo
	          te.value = extval;
	          input.prevInput = selected ? "" : "\u200b";
	          te.selectionStart = 1; te.selectionEnd = extval.length;
	          // Re-set this, in case some other handler touched the
	          // selection in the meantime.
	          display.selForContextMenu = cm.doc.sel;
	        }
	      }
	      function rehide() {
	        input.contextMenuPending = false;
	        input.wrapper.style.cssText = oldWrapperCSS
	        te.style.cssText = oldCSS;
	        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

	        // Try to detect the user choosing select-all
	        if (te.selectionStart != null) {
	          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
	          var i = 0, poll = function() {
	            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	                te.selectionEnd > 0 && input.prevInput == "\u200b")
	              operation(cm, commands.selectAll)(cm);
	            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
	            else display.input.reset();
	          };
	          display.detectingSelectAll = setTimeout(poll, 200);
	        }
	      }

	      if (ie && ie_version >= 9) prepareSelectAllHack();
	      if (captureRightClick) {
	        e_stop(e);
	        var mouseup = function() {
	          off(window, "mouseup", mouseup);
	          setTimeout(rehide, 20);
	        };
	        on(window, "mouseup", mouseup);
	      } else {
	        setTimeout(rehide, 50);
	      }
	    },

	    readOnlyChanged: function(val) {
	      if (!val) this.reset();
	    },

	    setUneditable: nothing,

	    needsContentAttribute: false
	  }, TextareaInput.prototype);

	  // CONTENTEDITABLE INPUT STYLE

	  function ContentEditableInput(cm) {
	    this.cm = cm;
	    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	    this.polling = new Delayed();
	    this.gracePeriod = false;
	  }

	  ContentEditableInput.prototype = copyObj({
	    init: function(display) {
	      var input = this, cm = input.cm;
	      var div = input.div = display.lineDiv;
	      disableBrowserMagic(div, cm.options.spellcheck);

	      on(div, "paste", function(e) {
	        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return
	        // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	        if (ie_version <= 11) setTimeout(operation(cm, function() {
	          if (!input.pollContent()) regChange(cm);
	        }), 20)
	      })

	      on(div, "compositionstart", function(e) {
	        var data = e.data;
	        input.composing = {sel: cm.doc.sel, data: data, startData: data};
	        if (!data) return;
	        var prim = cm.doc.sel.primary();
	        var line = cm.getLine(prim.head.line);
	        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
	        if (found > -1 && found <= prim.head.ch)
	          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
	                                                Pos(prim.head.line, found + data.length));
	      });
	      on(div, "compositionupdate", function(e) {
	        input.composing.data = e.data;
	      });
	      on(div, "compositionend", function(e) {
	        var ours = input.composing;
	        if (!ours) return;
	        if (e.data != ours.startData && !/\u200b/.test(e.data))
	          ours.data = e.data;
	        // Need a small delay to prevent other code (input event,
	        // selection polling) from doing damage when fired right after
	        // compositionend.
	        setTimeout(function() {
	          if (!ours.handled)
	            input.applyComposition(ours);
	          if (input.composing == ours)
	            input.composing = null;
	        }, 50);
	      });

	      on(div, "touchstart", function() {
	        input.forceCompositionEnd();
	      });

	      on(div, "input", function() {
	        if (input.composing) return;
	        if (cm.isReadOnly() || !input.pollContent())
	          runInOp(input.cm, function() {regChange(cm);});
	      });

	      function onCopyCut(e) {
	        if (signalDOMEvent(cm, e)) return
	        if (cm.somethingSelected()) {
	          lastCopied = {lineWise: false, text: cm.getSelections()};
	          if (e.type == "cut") cm.replaceSelection("", null, "cut");
	        } else if (!cm.options.lineWiseCopyCut) {
	          return;
	        } else {
	          var ranges = copyableRanges(cm);
	          lastCopied = {lineWise: true, text: ranges.text};
	          if (e.type == "cut") {
	            cm.operation(function() {
	              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	              cm.replaceSelection("", null, "cut");
	            });
	          }
	        }
	        if (e.clipboardData) {
	          e.clipboardData.clearData();
	          var content = lastCopied.text.join("\n")
	          // iOS exposes the clipboard API, but seems to discard content inserted into it
	          e.clipboardData.setData("Text", content);
	          if (e.clipboardData.getData("Text") == content) {
	            e.preventDefault();
	            return
	          }
	        }
	        // Old-fashioned briefly-focus-a-textarea hack
	        var kludge = hiddenTextarea(), te = kludge.firstChild;
	        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	        te.value = lastCopied.text.join("\n");
	        var hadFocus = document.activeElement;
	        selectInput(te);
	        setTimeout(function() {
	          cm.display.lineSpace.removeChild(kludge);
	          hadFocus.focus();
	          if (hadFocus == div) input.showPrimarySelection()
	        }, 50);
	      }
	      on(div, "copy", onCopyCut);
	      on(div, "cut", onCopyCut);
	    },

	    prepareSelection: function() {
	      var result = prepareSelection(this.cm, false);
	      result.focus = this.cm.state.focused;
	      return result;
	    },

	    showSelection: function(info, takeFocus) {
	      if (!info || !this.cm.display.view.length) return;
	      if (info.focus || takeFocus) this.showPrimarySelection();
	      this.showMultipleSelections(info);
	    },

	    showPrimarySelection: function() {
	      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
	      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
	      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
	      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
	          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
	        return;

	      var start = posToDOM(this.cm, prim.from());
	      var end = posToDOM(this.cm, prim.to());
	      if (!start && !end) return;

	      var view = this.cm.display.view;
	      var old = sel.rangeCount && sel.getRangeAt(0);
	      if (!start) {
	        start = {node: view[0].measure.map[2], offset: 0};
	      } else if (!end) { // FIXME dangerously hacky
	        var measure = view[view.length - 1].measure;
	        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
	      }

	      try { var rng = range(start.node, start.offset, end.offset, end.node); }
	      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	      if (rng) {
	        if (!gecko && this.cm.state.focused) {
	          sel.collapse(start.node, start.offset);
	          if (!rng.collapsed) sel.addRange(rng);
	        } else {
	          sel.removeAllRanges();
	          sel.addRange(rng);
	        }
	        if (old && sel.anchorNode == null) sel.addRange(old);
	        else if (gecko) this.startGracePeriod();
	      }
	      this.rememberSelection();
	    },

	    startGracePeriod: function() {
	      var input = this;
	      clearTimeout(this.gracePeriod);
	      this.gracePeriod = setTimeout(function() {
	        input.gracePeriod = false;
	        if (input.selectionChanged())
	          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
	      }, 20);
	    },

	    showMultipleSelections: function(info) {
	      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	    },

	    rememberSelection: function() {
	      var sel = window.getSelection();
	      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	    },

	    selectionInEditor: function() {
	      var sel = window.getSelection();
	      if (!sel.rangeCount) return false;
	      var node = sel.getRangeAt(0).commonAncestorContainer;
	      return contains(this.div, node);
	    },

	    focus: function() {
	      if (this.cm.options.readOnly != "nocursor") this.div.focus();
	    },
	    blur: function() { this.div.blur(); },
	    getField: function() { return this.div; },

	    supportsTouch: function() { return true; },

	    receivedFocus: function() {
	      var input = this;
	      if (this.selectionInEditor())
	        this.pollSelection();
	      else
	        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

	      function poll() {
	        if (input.cm.state.focused) {
	          input.pollSelection();
	          input.polling.set(input.cm.options.pollInterval, poll);
	        }
	      }
	      this.polling.set(this.cm.options.pollInterval, poll);
	    },

	    selectionChanged: function() {
	      var sel = window.getSelection();
	      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
	    },

	    pollSelection: function() {
	      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
	        var sel = window.getSelection(), cm = this.cm;
	        this.rememberSelection();
	        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	        if (anchor && head) runInOp(cm, function() {
	          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
	        });
	      }
	    },

	    pollContent: function() {
	      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	      var from = sel.from(), to = sel.to();
	      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

	      var fromIndex;
	      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	        var fromLine = lineNo(display.view[0].line);
	        var fromNode = display.view[0].node;
	      } else {
	        var fromLine = lineNo(display.view[fromIndex].line);
	        var fromNode = display.view[fromIndex - 1].node.nextSibling;
	      }
	      var toIndex = findViewIndex(cm, to.line);
	      if (toIndex == display.view.length - 1) {
	        var toLine = display.viewTo - 1;
	        var toNode = display.lineDiv.lastChild;
	      } else {
	        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
	        var toNode = display.view[toIndex + 1].node.previousSibling;
	      }

	      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	      while (newText.length > 1 && oldText.length > 1) {
	        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	        else break;
	      }

	      var cutFront = 0, cutEnd = 0;
	      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	        ++cutFront;
	      var newBot = lst(newText), oldBot = lst(oldText);
	      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
	      while (cutEnd < maxCutEnd &&
	             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	        ++cutEnd;

	      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
	      newText[0] = newText[0].slice(cutFront);

	      var chFrom = Pos(fromLine, cutFront);
	      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	        return true;
	      }
	    },

	    ensurePolled: function() {
	      this.forceCompositionEnd();
	    },
	    reset: function() {
	      this.forceCompositionEnd();
	    },
	    forceCompositionEnd: function() {
	      if (!this.composing || this.composing.handled) return;
	      this.applyComposition(this.composing);
	      this.composing.handled = true;
	      this.div.blur();
	      this.div.focus();
	    },
	    applyComposition: function(composing) {
	      if (this.cm.isReadOnly())
	        operation(this.cm, regChange)(this.cm)
	      else if (composing.data && composing.data != composing.startData)
	        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
	    },

	    setUneditable: function(node) {
	      node.contentEditable = "false"
	    },

	    onKeyPress: function(e) {
	      e.preventDefault();
	      if (!this.cm.isReadOnly())
	        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
	    },

	    readOnlyChanged: function(val) {
	      this.div.contentEditable = String(val != "nocursor")
	    },

	    onContextMenu: nothing,
	    resetPosition: nothing,

	    needsContentAttribute: true
	  }, ContentEditableInput.prototype);

	  function posToDOM(cm, pos) {
	    var view = findViewForLine(cm, pos.line);
	    if (!view || view.hidden) return null;
	    var line = getLine(cm.doc, pos.line);
	    var info = mapFromLineView(view, line, pos.line);

	    var order = getOrder(line), side = "left";
	    if (order) {
	      var partPos = getBidiPartAt(order, pos.ch);
	      side = partPos % 2 ? "right" : "left";
	    }
	    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	    result.offset = result.collapse == "right" ? result.end : result.start;
	    return result;
	  }

	  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

	  function domToPos(cm, node, offset) {
	    var lineNode;
	    if (node == cm.display.lineDiv) {
	      lineNode = cm.display.lineDiv.childNodes[offset];
	      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
	      node = null; offset = 0;
	    } else {
	      for (lineNode = node;; lineNode = lineNode.parentNode) {
	        if (!lineNode || lineNode == cm.display.lineDiv) return null;
	        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
	      }
	    }
	    for (var i = 0; i < cm.display.view.length; i++) {
	      var lineView = cm.display.view[i];
	      if (lineView.node == lineNode)
	        return locateNodeInLineView(lineView, node, offset);
	    }
	  }

	  function locateNodeInLineView(lineView, node, offset) {
	    var wrapper = lineView.text.firstChild, bad = false;
	    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
	    if (node == wrapper) {
	      bad = true;
	      node = wrapper.childNodes[offset];
	      offset = 0;
	      if (!node) {
	        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	        return badPos(Pos(lineNo(line), line.text.length), bad);
	      }
	    }

	    var textNode = node.nodeType == 3 ? node : null, topNode = node;
	    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	      textNode = node.firstChild;
	      if (offset) offset = textNode.nodeValue.length;
	    }
	    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
	    var measure = lineView.measure, maps = measure.maps;

	    function find(textNode, topNode, offset) {
	      for (var i = -1; i < (maps ? maps.length : 0); i++) {
	        var map = i < 0 ? measure.map : maps[i];
	        for (var j = 0; j < map.length; j += 3) {
	          var curNode = map[j + 2];
	          if (curNode == textNode || curNode == topNode) {
	            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	            var ch = map[j] + offset;
	            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
	            return Pos(line, ch);
	          }
	        }
	      }
	    }
	    var found = find(textNode, topNode, offset);
	    if (found) return badPos(found, bad);

	    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	      found = find(after, after.firstChild, 0);
	      if (found)
	        return badPos(Pos(found.line, found.ch - dist), bad);
	      else
	        dist += after.textContent.length;
	    }
	    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
	      found = find(before, before.firstChild, -1);
	      if (found)
	        return badPos(Pos(found.line, found.ch + dist), bad);
	      else
	        dist += before.textContent.length;
	    }
	  }

	  function domTextBetween(cm, from, to, fromLine, toLine) {
	    var text = "", closing = false, lineSep = cm.doc.lineSeparator();
	    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
	    function walk(node) {
	      if (node.nodeType == 1) {
	        var cmText = node.getAttribute("cm-text");
	        if (cmText != null) {
	          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
	          text += cmText;
	          return;
	        }
	        var markerID = node.getAttribute("cm-marker"), range;
	        if (markerID) {
	          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	          if (found.length && (range = found[0].find()))
	            text += getBetween(cm.doc, range.from, range.to).join(lineSep);
	          return;
	        }
	        if (node.getAttribute("contenteditable") == "false") return;
	        for (var i = 0; i < node.childNodes.length; i++)
	          walk(node.childNodes[i]);
	        if (/^(pre|div|p)$/i.test(node.nodeName))
	          closing = true;
	      } else if (node.nodeType == 3) {
	        var val = node.nodeValue;
	        if (!val) return;
	        if (closing) {
	          text += lineSep;
	          closing = false;
	        }
	        text += val;
	      }
	    }
	    for (;;) {
	      walk(from);
	      if (from == to) break;
	      from = from.nextSibling;
	    }
	    return text;
	  }

	  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

	  // SELECTION / CURSOR

	  // Selection objects are immutable. A new one is created every time
	  // the selection changes. A selection is one or more non-overlapping
	  // (and non-touching) ranges, sorted, and an integer that indicates
	  // which one is the primary selection (the one that's scrolled into
	  // view, that getCursor returns, etc).
	  function Selection(ranges, primIndex) {
	    this.ranges = ranges;
	    this.primIndex = primIndex;
	  }

	  Selection.prototype = {
	    primary: function() { return this.ranges[this.primIndex]; },
	    equals: function(other) {
	      if (other == this) return true;
	      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
	      for (var i = 0; i < this.ranges.length; i++) {
	        var here = this.ranges[i], there = other.ranges[i];
	        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
	      }
	      return true;
	    },
	    deepCopy: function() {
	      for (var out = [], i = 0; i < this.ranges.length; i++)
	        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
	      return new Selection(out, this.primIndex);
	    },
	    somethingSelected: function() {
	      for (var i = 0; i < this.ranges.length; i++)
	        if (!this.ranges[i].empty()) return true;
	      return false;
	    },
	    contains: function(pos, end) {
	      if (!end) end = pos;
	      for (var i = 0; i < this.ranges.length; i++) {
	        var range = this.ranges[i];
	        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	          return i;
	      }
	      return -1;
	    }
	  };

	  function Range(anchor, head) {
	    this.anchor = anchor; this.head = head;
	  }

	  Range.prototype = {
	    from: function() { return minPos(this.anchor, this.head); },
	    to: function() { return maxPos(this.anchor, this.head); },
	    empty: function() {
	      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
	    }
	  };

	  // Take an unsorted, potentially overlapping set of ranges, and
	  // build a selection out of it. 'Consumes' ranges array (modifying
	  // it).
	  function normalizeSelection(ranges, primIndex) {
	    var prim = ranges[primIndex];
	    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
	    primIndex = indexOf(ranges, prim);
	    for (var i = 1; i < ranges.length; i++) {
	      var cur = ranges[i], prev = ranges[i - 1];
	      if (cmp(prev.to(), cur.from()) >= 0) {
	        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	        if (i <= primIndex) --primIndex;
	        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	      }
	    }
	    return new Selection(ranges, primIndex);
	  }

	  function simpleSelection(anchor, head) {
	    return new Selection([new Range(anchor, head || anchor)], 0);
	  }

	  // Most of the external API clips given positions to make sure they
	  // actually exist within the document.
	  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
	  function clipPos(doc, pos) {
	    if (pos.line < doc.first) return Pos(doc.first, 0);
	    var last = doc.first + doc.size - 1;
	    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
	    return clipToLen(pos, getLine(doc, pos.line).text.length);
	  }
	  function clipToLen(pos, linelen) {
	    var ch = pos.ch;
	    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
	    else if (ch < 0) return Pos(pos.line, 0);
	    else return pos;
	  }
	  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
	  function clipPosArray(doc, array) {
	    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
	    return out;
	  }

	  // SELECTION UPDATES

	  // The 'scroll' parameter given to many of these indicated whether
	  // the new cursor position should be scrolled into view after
	  // modifying the selection.

	  // If shift is held or the extend flag is set, extends a range to
	  // include a given position (and optionally a second position).
	  // Otherwise, simply returns the range between the given positions.
	  // Used for cursor motion and such.
	  function extendRange(doc, range, head, other) {
	    if (doc.cm && doc.cm.display.shift || doc.extend) {
	      var anchor = range.anchor;
	      if (other) {
	        var posBefore = cmp(head, anchor) < 0;
	        if (posBefore != (cmp(other, anchor) < 0)) {
	          anchor = head;
	          head = other;
	        } else if (posBefore != (cmp(head, other) < 0)) {
	          head = other;
	        }
	      }
	      return new Range(anchor, head);
	    } else {
	      return new Range(other || head, head);
	    }
	  }

	  // Extend the primary selection range, discard the rest.
	  function extendSelection(doc, head, other, options) {
	    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
	  }

	  // Extend all selections (pos is an array of selections with length
	  // equal the number of selections)
	  function extendSelections(doc, heads, options) {
	    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
	      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
	    var newSel = normalizeSelection(out, doc.sel.primIndex);
	    setSelection(doc, newSel, options);
	  }

	  // Updates a single range in the selection.
	  function replaceOneSelection(doc, i, range, options) {
	    var ranges = doc.sel.ranges.slice(0);
	    ranges[i] = range;
	    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
	  }

	  // Reset the selection to a single range.
	  function setSimpleSelection(doc, anchor, head, options) {
	    setSelection(doc, simpleSelection(anchor, head), options);
	  }

	  // Give beforeSelectionChange handlers a change to influence a
	  // selection update.
	  function filterSelectionChange(doc, sel, options) {
	    var obj = {
	      ranges: sel.ranges,
	      update: function(ranges) {
	        this.ranges = [];
	        for (var i = 0; i < ranges.length; i++)
	          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                     clipPos(doc, ranges[i].head));
	      },
	      origin: options && options.origin
	    };
	    signal(doc, "beforeSelectionChange", doc, obj);
	    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
	    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
	    else return sel;
	  }

	  function setSelectionReplaceHistory(doc, sel, options) {
	    var done = doc.history.done, last = lst(done);
	    if (last && last.ranges) {
	      done[done.length - 1] = sel;
	      setSelectionNoUndo(doc, sel, options);
	    } else {
	      setSelection(doc, sel, options);
	    }
	  }

	  // Set a new selection.
	  function setSelection(doc, sel, options) {
	    setSelectionNoUndo(doc, sel, options);
	    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	  }

	  function setSelectionNoUndo(doc, sel, options) {
	    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	      sel = filterSelectionChange(doc, sel, options);

	    var bias = options && options.bias ||
	      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

	    if (!(options && options.scroll === false) && doc.cm)
	      ensureCursorVisible(doc.cm);
	  }

	  function setSelectionInner(doc, sel) {
	    if (sel.equals(doc.sel)) return;

	    doc.sel = sel;

	    if (doc.cm) {
	      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
	      signalCursorActivity(doc.cm);
	    }
	    signalLater(doc, "cursorActivity", doc);
	  }

	  // Verify that the selection does not partially select any atomic
	  // marked ranges.
	  function reCheckSelection(doc) {
	    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
	  }

	  // Return a selection that does not partially select any atomic
	  // ranges.
	  function skipAtomicInSelection(doc, sel, bias, mayClear) {
	    var out;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range = sel.ranges[i];
	      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	      if (out || newAnchor != range.anchor || newHead != range.head) {
	        if (!out) out = sel.ranges.slice(0, i);
	        out[i] = new Range(newAnchor, newHead);
	      }
	    }
	    return out ? normalizeSelection(out, sel.primIndex) : sel;
	  }

	  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	    var line = getLine(doc, pos.line);
	    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
	      var sp = line.markedSpans[i], m = sp.marker;
	      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	        if (mayClear) {
	          signal(m, "beforeCursorEnter");
	          if (m.explicitlyCleared) {
	            if (!line.markedSpans) break;
	            else {--i; continue;}
	          }
	        }
	        if (!m.atomic) continue;

	        if (oldPos) {
	          var near = m.find(dir < 0 ? 1 : -1), diff;
	          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
	            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
	          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	            return skipAtomicInner(doc, near, pos, dir, mayClear);
	        }

	        var far = m.find(dir < 0 ? -1 : 1);
	        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
	          far = movePos(doc, far, dir, far.line == pos.line ? line : null);
	        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
	      }
	    }
	    return pos;
	  }

	  // Ensure a given position is not inside an atomic range.
	  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	    var dir = bias || 1;
	    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	    if (!found) {
	      doc.cantEdit = true;
	      return Pos(doc.first, 0);
	    }
	    return found;
	  }

	  function movePos(doc, pos, dir, line) {
	    if (dir < 0 && pos.ch == 0) {
	      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));
	      else return null;
	    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);
	      else return null;
	    } else {
	      return new Pos(pos.line, pos.ch + dir);
	    }
	  }

	  // SELECTION DRAWING

	  function updateSelection(cm) {
	    cm.display.input.showSelection(cm.display.input.prepareSelection());
	  }

	  function prepareSelection(cm, primary) {
	    var doc = cm.doc, result = {};
	    var curFragment = result.cursors = document.createDocumentFragment();
	    var selFragment = result.selection = document.createDocumentFragment();

	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      if (primary === false && i == doc.sel.primIndex) continue;
	      var range = doc.sel.ranges[i];
	      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;
	      var collapsed = range.empty();
	      if (collapsed || cm.options.showCursorWhenSelecting)
	        drawSelectionCursor(cm, range.head, curFragment);
	      if (!collapsed)
	        drawSelectionRange(cm, range, selFragment);
	    }
	    return result;
	  }

	  // Draws a cursor for the given range
	  function drawSelectionCursor(cm, head, output) {
	    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

	    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	    cursor.style.left = pos.left + "px";
	    cursor.style.top = pos.top + "px";
	    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

	    if (pos.other) {
	      // Secondary cursor, shown when on a 'jump' in bi-directional text
	      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	      otherCursor.style.display = "";
	      otherCursor.style.left = pos.other.left + "px";
	      otherCursor.style.top = pos.other.top + "px";
	      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	    }
	  }

	  // Draws the given range as a highlighted selection
	  function drawSelectionRange(cm, range, output) {
	    var display = cm.display, doc = cm.doc;
	    var fragment = document.createDocumentFragment();
	    var padding = paddingH(cm.display), leftSide = padding.left;
	    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

	    function add(left, top, width, bottom) {
	      if (top < 0) top = 0;
	      top = Math.round(top);
	      bottom = Math.round(bottom);
	      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
	                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
	                               "px; height: " + (bottom - top) + "px"));
	    }

	    function drawForLine(line, fromArg, toArg) {
	      var lineObj = getLine(doc, line);
	      var lineLen = lineObj.text.length;
	      var start, end;
	      function coords(ch, bias) {
	        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
	      }

	      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
	        var leftPos = coords(from, "left"), rightPos, left, right;
	        if (from == to) {
	          rightPos = leftPos;
	          left = right = leftPos.left;
	        } else {
	          rightPos = coords(to - 1, "right");
	          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
	          left = leftPos.left;
	          right = rightPos.right;
	        }
	        if (fromArg == null && from == 0) left = leftSide;
	        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
	          add(left, leftPos.top, null, leftPos.bottom);
	          left = leftSide;
	          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
	        }
	        if (toArg == null && to == lineLen) right = rightSide;
	        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
	          start = leftPos;
	        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
	          end = rightPos;
	        if (left < leftSide + 1) left = leftSide;
	        add(left, rightPos.top, right - left, rightPos.bottom);
	      });
	      return {start: start, end: end};
	    }

	    var sFrom = range.from(), sTo = range.to();
	    if (sFrom.line == sTo.line) {
	      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	    } else {
	      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	      var singleVLine = visualLine(fromLine) == visualLine(toLine);
	      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	      if (singleVLine) {
	        if (leftEnd.top < rightStart.top - 2) {
	          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	        } else {
	          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	        }
	      }
	      if (leftEnd.bottom < rightStart.top)
	        add(leftSide, leftEnd.bottom, null, rightStart.top);
	    }

	    output.appendChild(fragment);
	  }

	  // Cursor-blinking
	  function restartBlink(cm) {
	    if (!cm.state.focused) return;
	    var display = cm.display;
	    clearInterval(display.blinker);
	    var on = true;
	    display.cursorDiv.style.visibility = "";
	    if (cm.options.cursorBlinkRate > 0)
	      display.blinker = setInterval(function() {
	        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
	      }, cm.options.cursorBlinkRate);
	    else if (cm.options.cursorBlinkRate < 0)
	      display.cursorDiv.style.visibility = "hidden";
	  }

	  // HIGHLIGHT WORKER

	  function startWorker(cm, time) {
	    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
	      cm.state.highlight.set(time, bind(highlightWorker, cm));
	  }

	  function highlightWorker(cm) {
	    var doc = cm.doc;
	    if (doc.frontier < doc.first) doc.frontier = doc.first;
	    if (doc.frontier >= cm.display.viewTo) return;
	    var end = +new Date + cm.options.workTime;
	    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
	    var changedLines = [];

	    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
	      if (doc.frontier >= cm.display.viewFrom) { // Visible
	        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
	        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
	        line.styles = highlighted.styles;
	        var oldCls = line.styleClasses, newCls = highlighted.classes;
	        if (newCls) line.styleClasses = newCls;
	        else if (oldCls) line.styleClasses = null;
	        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
	        if (ischange) changedLines.push(doc.frontier);
	        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
	      } else {
	        if (line.text.length <= cm.options.maxHighlightLength)
	          processLine(cm, line.text, state);
	        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
	      }
	      ++doc.frontier;
	      if (+new Date > end) {
	        startWorker(cm, cm.options.workDelay);
	        return true;
	      }
	    });
	    if (changedLines.length) runInOp(cm, function() {
	      for (var i = 0; i < changedLines.length; i++)
	        regLineChange(cm, changedLines[i], "text");
	    });
	  }

	  // Finds the line to start with when starting a parse. Tries to
	  // find a line with a stateAfter, so that it can start with a
	  // valid state. If that fails, it returns the line with the
	  // smallest indentation, which tends to need the least context to
	  // parse correctly.
	  function findStartLine(cm, n, precise) {
	    var minindent, minline, doc = cm.doc;
	    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	    for (var search = n; search > lim; --search) {
	      if (search <= doc.first) return doc.first;
	      var line = getLine(doc, search - 1);
	      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
	      var indented = countColumn(line.text, null, cm.options.tabSize);
	      if (minline == null || minindent > indented) {
	        minline = search - 1;
	        minindent = indented;
	      }
	    }
	    return minline;
	  }

	  function getStateBefore(cm, n, precise) {
	    var doc = cm.doc, display = cm.display;
	    if (!doc.mode.startState) return true;
	    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
	    if (!state) state = startState(doc.mode);
	    else state = copyState(doc.mode, state);
	    doc.iter(pos, n, function(line) {
	      processLine(cm, line.text, state);
	      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
	      line.stateAfter = save ? copyState(doc.mode, state) : null;
	      ++pos;
	    });
	    if (precise) doc.frontier = pos;
	    return state;
	  }

	  // POSITION MEASUREMENT

	  function paddingTop(display) {return display.lineSpace.offsetTop;}
	  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
	  function paddingH(display) {
	    if (display.cachedPaddingH) return display.cachedPaddingH;
	    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
	    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
	    return data;
	  }

	  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
	  function displayWidth(cm) {
	    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
	  }
	  function displayHeight(cm) {
	    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
	  }

	  // Ensure the lineView.wrapping.heights array is populated. This is
	  // an array of bottom offsets for the lines that make up a drawn
	  // line. When lineWrapping is on, there might be more than one
	  // height.
	  function ensureLineHeights(cm, lineView, rect) {
	    var wrapping = cm.options.lineWrapping;
	    var curWidth = wrapping && displayWidth(cm);
	    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	      var heights = lineView.measure.heights = [];
	      if (wrapping) {
	        lineView.measure.width = curWidth;
	        var rects = lineView.text.firstChild.getClientRects();
	        for (var i = 0; i < rects.length - 1; i++) {
	          var cur = rects[i], next = rects[i + 1];
	          if (Math.abs(cur.bottom - next.bottom) > 2)
	            heights.push((cur.bottom + next.top) / 2 - rect.top);
	        }
	      }
	      heights.push(rect.bottom - rect.top);
	    }
	  }

	  // Find a line map (mapping character offsets to text nodes) and a
	  // measurement cache for the given line number. (A line view might
	  // contain multiple lines when collapsed ranges are present.)
	  function mapFromLineView(lineView, line, lineN) {
	    if (lineView.line == line)
	      return {map: lineView.measure.map, cache: lineView.measure.cache};
	    for (var i = 0; i < lineView.rest.length; i++)
	      if (lineView.rest[i] == line)
	        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
	    for (var i = 0; i < lineView.rest.length; i++)
	      if (lineNo(lineView.rest[i]) > lineN)
	        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
	  }

	  // Render a line into the hidden node display.externalMeasured. Used
	  // when measurement is needed for a line that's not in the viewport.
	  function updateExternalMeasurement(cm, line) {
	    line = visualLine(line);
	    var lineN = lineNo(line);
	    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	    view.lineN = lineN;
	    var built = view.built = buildLineContent(cm, view);
	    view.text = built.pre;
	    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	    return view;
	  }

	  // Get a {top, bottom, left, right} box (in line-local coordinates)
	  // for a given character.
	  function measureChar(cm, line, ch, bias) {
	    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
	  }

	  // Find a line view that corresponds to the given line number.
	  function findViewForLine(cm, lineN) {
	    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	      return cm.display.view[findViewIndex(cm, lineN)];
	    var ext = cm.display.externalMeasured;
	    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	      return ext;
	  }

	  // Measurement can be split in two steps, the set-up work that
	  // applies to the whole line, and the measurement of the actual
	  // character. Functions like coordsChar, that need to do a lot of
	  // measurements in a row, can thus ensure that the set-up work is
	  // only done once.
	  function prepareMeasureForLine(cm, line) {
	    var lineN = lineNo(line);
	    var view = findViewForLine(cm, lineN);
	    if (view && !view.text) {
	      view = null;
	    } else if (view && view.changes) {
	      updateLineForChanges(cm, view, lineN, getDimensions(cm));
	      cm.curOp.forceUpdate = true;
	    }
	    if (!view)
	      view = updateExternalMeasurement(cm, line);

	    var info = mapFromLineView(view, line, lineN);
	    return {
	      line: line, view: view, rect: null,
	      map: info.map, cache: info.cache, before: info.before,
	      hasHeights: false
	    };
	  }

	  // Given a prepared measurement object, measures the position of an
	  // actual character (or fetches it from the cache).
	  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	    if (prepared.before) ch = -1;
	    var key = ch + (bias || ""), found;
	    if (prepared.cache.hasOwnProperty(key)) {
	      found = prepared.cache[key];
	    } else {
	      if (!prepared.rect)
	        prepared.rect = prepared.view.text.getBoundingClientRect();
	      if (!prepared.hasHeights) {
	        ensureLineHeights(cm, prepared.view, prepared.rect);
	        prepared.hasHeights = true;
	      }
	      found = measureCharInner(cm, prepared, ch, bias);
	      if (!found.bogus) prepared.cache[key] = found;
	    }
	    return {left: found.left, right: found.right,
	            top: varHeight ? found.rtop : found.top,
	            bottom: varHeight ? found.rbottom : found.bottom};
	  }

	  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

	  function nodeAndOffsetInLineMap(map, ch, bias) {
	    var node, start, end, collapse;
	    // First, search the line map for the text node corresponding to,
	    // or closest to, the target character.
	    for (var i = 0; i < map.length; i += 3) {
	      var mStart = map[i], mEnd = map[i + 1];
	      if (ch < mStart) {
	        start = 0; end = 1;
	        collapse = "left";
	      } else if (ch < mEnd) {
	        start = ch - mStart;
	        end = start + 1;
	      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
	        end = mEnd - mStart;
	        start = end - 1;
	        if (ch >= mEnd) collapse = "right";
	      }
	      if (start != null) {
	        node = map[i + 2];
	        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	          collapse = bias;
	        if (bias == "left" && start == 0)
	          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
	            node = map[(i -= 3) + 2];
	            collapse = "left";
	          }
	        if (bias == "right" && start == mEnd - mStart)
	          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
	            node = map[(i += 3) + 2];
	            collapse = "right";
	          }
	        break;
	      }
	    }
	    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
	  }

	  function getUsefulRect(rects, bias) {
	    var rect = nullRect
	    if (bias == "left") for (var i = 0; i < rects.length; i++) {
	      if ((rect = rects[i]).left != rect.right) break
	    } else for (var i = rects.length - 1; i >= 0; i--) {
	      if ((rect = rects[i]).left != rect.right) break
	    }
	    return rect
	  }

	  function measureCharInner(cm, prepared, ch, bias) {
	    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

	    var rect;
	    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
	        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
	        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	          rect = node.parentNode.getBoundingClientRect();
	        else
	          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)
	        if (rect.left || rect.right || start == 0) break;
	        end = start;
	        start = start - 1;
	        collapse = "right";
	      }
	      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
	    } else { // If it is a widget, simply get the box for the whole widget.
	      if (start > 0) collapse = bias = "right";
	      var rects;
	      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	        rect = rects[bias == "right" ? rects.length - 1 : 0];
	      else
	        rect = node.getBoundingClientRect();
	    }
	    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	      var rSpan = node.parentNode.getClientRects()[0];
	      if (rSpan)
	        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
	      else
	        rect = nullRect;
	    }

	    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	    var mid = (rtop + rbot) / 2;
	    var heights = prepared.view.measure.heights;
	    for (var i = 0; i < heights.length - 1; i++)
	      if (mid < heights[i]) break;
	    var top = i ? heights[i - 1] : 0, bot = heights[i];
	    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                  top: top, bottom: bot};
	    if (!rect.left && !rect.right) result.bogus = true;
	    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

	    return result;
	  }

	  // Work around problem with bounding client rects on ranges being
	  // returned incorrectly when zoomed on IE10 and below.
	  function maybeUpdateRectForZooming(measure, rect) {
	    if (!window.screen || screen.logicalXDPI == null ||
	        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	      return rect;
	    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	    return {left: rect.left * scaleX, right: rect.right * scaleX,
	            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
	  }

	  function clearLineMeasurementCacheFor(lineView) {
	    if (lineView.measure) {
	      lineView.measure.cache = {};
	      lineView.measure.heights = null;
	      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
	        lineView.measure.caches[i] = {};
	    }
	  }

	  function clearLineMeasurementCache(cm) {
	    cm.display.externalMeasure = null;
	    removeChildren(cm.display.lineMeasure);
	    for (var i = 0; i < cm.display.view.length; i++)
	      clearLineMeasurementCacheFor(cm.display.view[i]);
	  }

	  function clearCaches(cm) {
	    clearLineMeasurementCache(cm);
	    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
	    cm.display.lineNumChars = null;
	  }

	  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
	  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

	  // Converts a {top, bottom, left, right} box from line-local
	  // coordinates into another coordinate system. Context may be one of
	  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
	  // or "page".
	  function intoCoordSystem(cm, lineObj, rect, context) {
	    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
	      var size = widgetHeight(lineObj.widgets[i]);
	      rect.top += size; rect.bottom += size;
	    }
	    if (context == "line") return rect;
	    if (!context) context = "local";
	    var yOff = heightAtLine(lineObj);
	    if (context == "local") yOff += paddingTop(cm.display);
	    else yOff -= cm.display.viewOffset;
	    if (context == "page" || context == "window") {
	      var lOff = cm.display.lineSpace.getBoundingClientRect();
	      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	      rect.left += xOff; rect.right += xOff;
	    }
	    rect.top += yOff; rect.bottom += yOff;
	    return rect;
	  }

	  // Coverts a box from "div" coords to another coordinate system.
	  // Context may be "window", "page", "div", or "local"/null.
	  function fromCoordSystem(cm, coords, context) {
	    if (context == "div") return coords;
	    var left = coords.left, top = coords.top;
	    // First move into "page" coordinate system
	    if (context == "page") {
	      left -= pageScrollX();
	      top -= pageScrollY();
	    } else if (context == "local" || !context) {
	      var localBox = cm.display.sizer.getBoundingClientRect();
	      left += localBox.left;
	      top += localBox.top;
	    }

	    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
	  }

	  function charCoords(cm, pos, context, lineObj, bias) {
	    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
	    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
	  }

	  // Returns a box for a given cursor position, which may have an
	  // 'other' property containing the position of the secondary cursor
	  // on a bidi boundary.
	  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	    lineObj = lineObj || getLine(cm.doc, pos.line);
	    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
	    function get(ch, right) {
	      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	      if (right) m.left = m.right; else m.right = m.left;
	      return intoCoordSystem(cm, lineObj, m, context);
	    }
	    function getBidi(ch, partPos) {
	      var part = order[partPos], right = part.level % 2;
	      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
	        part = order[--partPos];
	        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
	        right = true;
	      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
	        part = order[++partPos];
	        ch = bidiLeft(part) - part.level % 2;
	        right = false;
	      }
	      if (right && ch == part.to && ch > part.from) return get(ch - 1);
	      return get(ch, right);
	    }
	    var order = getOrder(lineObj), ch = pos.ch;
	    if (!order) return get(ch);
	    var partPos = getBidiPartAt(order, ch);
	    var val = getBidi(ch, partPos);
	    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
	    return val;
	  }

	  // Used to cheaply estimate the coordinates for a position. Used for
	  // intermediate scroll updates.
	  function estimateCoords(cm, pos) {
	    var left = 0, pos = clipPos(cm.doc, pos);
	    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
	    var lineObj = getLine(cm.doc, pos.line);
	    var top = heightAtLine(lineObj) + paddingTop(cm.display);
	    return {left: left, right: left, top: top, bottom: top + lineObj.height};
	  }

	  // Positions returned by coordsChar contain some extra information.
	  // xRel is the relative x position of the input coordinates compared
	  // to the found position (so xRel > 0 means the coordinates are to
	  // the right of the character position, for example). When outside
	  // is true, that means the coordinates lie outside the line's
	  // vertical range.
	  function PosWithInfo(line, ch, outside, xRel) {
	    var pos = Pos(line, ch);
	    pos.xRel = xRel;
	    if (outside) pos.outside = true;
	    return pos;
	  }

	  // Compute the character position closest to the given coordinates.
	  // Input must be lineSpace-local ("div" coordinate system).
	  function coordsChar(cm, x, y) {
	    var doc = cm.doc;
	    y += cm.display.viewOffset;
	    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
	    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	    if (lineN > last)
	      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
	    if (x < 0) x = 0;

	    var lineObj = getLine(doc, lineN);
	    for (;;) {
	      var found = coordsCharInner(cm, lineObj, lineN, x, y);
	      var merged = collapsedSpanAtEnd(lineObj);
	      var mergedPos = merged && merged.find(0, true);
	      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	        lineN = lineNo(lineObj = mergedPos.to.line);
	      else
	        return found;
	    }
	  }

	  function coordsCharInner(cm, lineObj, lineNo, x, y) {
	    var innerOff = y - heightAtLine(lineObj);
	    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
	    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

	    function getX(ch) {
	      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
	      wrongLine = true;
	      if (innerOff > sp.bottom) return sp.left - adjust;
	      else if (innerOff < sp.top) return sp.left + adjust;
	      else wrongLine = false;
	      return sp.left;
	    }

	    var bidi = getOrder(lineObj), dist = lineObj.text.length;
	    var from = lineLeft(lineObj), to = lineRight(lineObj);
	    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

	    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
	    // Do a binary search between these bounds.
	    for (;;) {
	      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
	        var ch = x < fromX || x - fromX <= toX - x ? from : to;
	        var outside = ch == from ? fromOutside : toOutside
	        var xDiff = x - (ch == from ? fromX : toX);
	        // This is a kludge to handle the case where the coordinates
	        // are after a line-wrapped line. We should replace it with a
	        // more general handling of cursor positions around line
	        // breaks. (Issue #4078)
	        if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&
	            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
	          var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right");
	          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
	            outside = false
	            ch++
	            xDiff = x - charSize.right
	          }
	        }
	        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
	        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
	        return pos;
	      }
	      var step = Math.ceil(dist / 2), middle = from + step;
	      if (bidi) {
	        middle = from;
	        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
	      }
	      var middleX = getX(middle);
	      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
	      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
	    }
	  }

	  var measureText;
	  // Compute the default text height.
	  function textHeight(display) {
	    if (display.cachedTextHeight != null) return display.cachedTextHeight;
	    if (measureText == null) {
	      measureText = elt("pre");
	      // Measure a bunch of lines, for browsers that compute
	      // fractional heights.
	      for (var i = 0; i < 49; ++i) {
	        measureText.appendChild(document.createTextNode("x"));
	        measureText.appendChild(elt("br"));
	      }
	      measureText.appendChild(document.createTextNode("x"));
	    }
	    removeChildrenAndAdd(display.measure, measureText);
	    var height = measureText.offsetHeight / 50;
	    if (height > 3) display.cachedTextHeight = height;
	    removeChildren(display.measure);
	    return height || 1;
	  }

	  // Compute the default character width.
	  function charWidth(display) {
	    if (display.cachedCharWidth != null) return display.cachedCharWidth;
	    var anchor = elt("span", "xxxxxxxxxx");
	    var pre = elt("pre", [anchor]);
	    removeChildrenAndAdd(display.measure, pre);
	    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	    if (width > 2) display.cachedCharWidth = width;
	    return width || 10;
	  }

	  // OPERATIONS

	  // Operations are used to wrap a series of changes to the editor
	  // state in such a way that each change won't have to update the
	  // cursor and display (which would be awkward, slow, and
	  // error-prone). Instead, display updates are batched and then all
	  // combined and executed at once.

	  var operationGroup = null;

	  var nextOpId = 0;
	  // Start a new operation.
	  function startOperation(cm) {
	    cm.curOp = {
	      cm: cm,
	      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	      startHeight: cm.doc.height, // Used to detect need to update scrollbar
	      forceUpdate: false,      // Used to force a redraw
	      updateInput: null,       // Whether to reset the input textarea
	      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	      changeObjs: null,        // Accumulated changes, for firing change events
	      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	      selectionChanged: false, // Whether the selection needs to be redrawn
	      updateMaxLine: false,    // Set when the widest line needs to be determined anew
	      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	      scrollToPos: null,       // Used to scroll to a specific position
	      focus: false,
	      id: ++nextOpId           // Unique ID
	    };
	    if (operationGroup) {
	      operationGroup.ops.push(cm.curOp);
	    } else {
	      cm.curOp.ownsGroup = operationGroup = {
	        ops: [cm.curOp],
	        delayedCallbacks: []
	      };
	    }
	  }

	  function fireCallbacksForOps(group) {
	    // Calls delayed callbacks and cursorActivity handlers until no
	    // new ones appear
	    var callbacks = group.delayedCallbacks, i = 0;
	    do {
	      for (; i < callbacks.length; i++)
	        callbacks[i].call(null);
	      for (var j = 0; j < group.ops.length; j++) {
	        var op = group.ops[j];
	        if (op.cursorActivityHandlers)
	          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
	      }
	    } while (i < callbacks.length);
	  }

	  // Finish an operation, updating the display and signalling delayed events
	  function endOperation(cm) {
	    var op = cm.curOp, group = op.ownsGroup;
	    if (!group) return;

	    try { fireCallbacksForOps(group); }
	    finally {
	      operationGroup = null;
	      for (var i = 0; i < group.ops.length; i++)
	        group.ops[i].cm.curOp = null;
	      endOperations(group);
	    }
	  }

	  // The DOM updates done when an operation finishes are batched so
	  // that the minimum number of relayouts are required.
	  function endOperations(group) {
	    var ops = group.ops;
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_R1(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
	      endOperation_W1(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_R2(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
	      endOperation_W2(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_finish(ops[i]);
	  }

	  function endOperation_R1(op) {
	    var cm = op.cm, display = cm.display;
	    maybeClipScrollbars(cm);
	    if (op.updateMaxLine) findMaxLine(cm);

	    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                         op.scrollToPos.to.line >= display.viewTo) ||
	      display.maxLineChanged && cm.options.lineWrapping;
	    op.update = op.mustUpdate &&
	      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	  }

	  function endOperation_W1(op) {
	    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	  }

	  function endOperation_R2(op) {
	    var cm = op.cm, display = cm.display;
	    if (op.updatedDisplay) updateHeightsInViewport(cm);

	    op.barMeasure = measureForScrollbars(cm);

	    // If the max line changed since it was last measured, measure it,
	    // and ensure the document's width matches it.
	    // updateDisplay_W2 will use these properties to do the actual resizing
	    if (display.maxLineChanged && !cm.options.lineWrapping) {
	      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	      cm.display.sizerWidth = op.adjustWidthTo;
	      op.barMeasure.scrollWidth =
	        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	    }

	    if (op.updatedDisplay || op.selectionChanged)
	      op.preparedSelection = display.input.prepareSelection(op.focus);
	  }

	  function endOperation_W2(op) {
	    var cm = op.cm;

	    if (op.adjustWidthTo != null) {
	      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	      if (op.maxScrollLeft < cm.doc.scrollLeft)
	        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
	      cm.display.maxLineChanged = false;
	    }

	    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())
	    if (op.preparedSelection)
	      cm.display.input.showSelection(op.preparedSelection, takeFocus);
	    if (op.updatedDisplay || op.startHeight != cm.doc.height)
	      updateScrollbars(cm, op.barMeasure);
	    if (op.updatedDisplay)
	      setDocumentHeight(cm, op.barMeasure);

	    if (op.selectionChanged) restartBlink(cm);

	    if (cm.state.focused && op.updateInput)
	      cm.display.input.reset(op.typing);
	    if (takeFocus) ensureFocus(op.cm);
	  }

	  function endOperation_finish(op) {
	    var cm = op.cm, display = cm.display, doc = cm.doc;

	    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

	    // Abort mouse wheel delta measurement, when scrolling explicitly
	    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	      display.wheelStartX = display.wheelStartY = null;

	    // Propagate the scroll position to the actual DOM scroller
	    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
	      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
	      display.scrollbars.setScrollTop(doc.scrollTop);
	      display.scroller.scrollTop = doc.scrollTop;
	    }
	    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
	      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
	      display.scrollbars.setScrollLeft(doc.scrollLeft);
	      display.scroller.scrollLeft = doc.scrollLeft;
	      alignHorizontally(cm);
	    }
	    // If we need to scroll a specific position into view, do so.
	    if (op.scrollToPos) {
	      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
	    }

	    // Fire events for markers that are hidden/unidden by editing or
	    // undoing
	    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	    if (hidden) for (var i = 0; i < hidden.length; ++i)
	      if (!hidden[i].lines.length) signal(hidden[i], "hide");
	    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
	      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

	    if (display.wrapper.offsetHeight)
	      doc.scrollTop = cm.display.scroller.scrollTop;

	    // Fire change events, and delayed event handlers
	    if (op.changeObjs)
	      signal(cm, "changes", cm, op.changeObjs);
	    if (op.update)
	      op.update.finish();
	  }

	  // Run the given function in an operation
	  function runInOp(cm, f) {
	    if (cm.curOp) return f();
	    startOperation(cm);
	    try { return f(); }
	    finally { endOperation(cm); }
	  }
	  // Wraps a function in an operation. Returns the wrapped function.
	  function operation(cm, f) {
	    return function() {
	      if (cm.curOp) return f.apply(cm, arguments);
	      startOperation(cm);
	      try { return f.apply(cm, arguments); }
	      finally { endOperation(cm); }
	    };
	  }
	  // Used to add methods to editor and doc instances, wrapping them in
	  // operations.
	  function methodOp(f) {
	    return function() {
	      if (this.curOp) return f.apply(this, arguments);
	      startOperation(this);
	      try { return f.apply(this, arguments); }
	      finally { endOperation(this); }
	    };
	  }
	  function docMethodOp(f) {
	    return function() {
	      var cm = this.cm;
	      if (!cm || cm.curOp) return f.apply(this, arguments);
	      startOperation(cm);
	      try { return f.apply(this, arguments); }
	      finally { endOperation(cm); }
	    };
	  }

	  // VIEW TRACKING

	  // These objects are used to represent the visible (currently drawn)
	  // part of the document. A LineView may correspond to multiple
	  // logical lines, if those are connected by collapsed ranges.
	  function LineView(doc, line, lineN) {
	    // The starting line
	    this.line = line;
	    // Continuing lines, if any
	    this.rest = visualLineContinued(line);
	    // Number of logical lines in this visual line
	    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	    this.node = this.text = null;
	    this.hidden = lineIsHidden(doc, line);
	  }

	  // Create a range of LineView objects for the given lines.
	  function buildViewArray(cm, from, to) {
	    var array = [], nextPos;
	    for (var pos = from; pos < to; pos = nextPos) {
	      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	      nextPos = pos + view.size;
	      array.push(view);
	    }
	    return array;
	  }

	  // Updates the display.view data structure for a given change to the
	  // document. From and to are in pre-change coordinates. Lendiff is
	  // the amount of lines added or subtracted by the change. This is
	  // used for changes that span multiple lines, or change the way
	  // lines are divided into visual lines. regLineChange (below)
	  // registers single-line changes.
	  function regChange(cm, from, to, lendiff) {
	    if (from == null) from = cm.doc.first;
	    if (to == null) to = cm.doc.first + cm.doc.size;
	    if (!lendiff) lendiff = 0;

	    var display = cm.display;
	    if (lendiff && to < display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers > from))
	      display.updateLineNumbers = from;

	    cm.curOp.viewChanged = true;

	    if (from >= display.viewTo) { // Change after
	      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	        resetView(cm);
	    } else if (to <= display.viewFrom) { // Change before
	      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	        resetView(cm);
	      } else {
	        display.viewFrom += lendiff;
	        display.viewTo += lendiff;
	      }
	    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	      resetView(cm);
	    } else if (from <= display.viewFrom) { // Top overlap
	      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cut) {
	        display.view = display.view.slice(cut.index);
	        display.viewFrom = cut.lineN;
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    } else if (to >= display.viewTo) { // Bottom overlap
	      var cut = viewCuttingPoint(cm, from, from, -1);
	      if (cut) {
	        display.view = display.view.slice(0, cut.index);
	        display.viewTo = cut.lineN;
	      } else {
	        resetView(cm);
	      }
	    } else { // Gap in the middle
	      var cutTop = viewCuttingPoint(cm, from, from, -1);
	      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cutTop && cutBot) {
	        display.view = display.view.slice(0, cutTop.index)
	          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	          .concat(display.view.slice(cutBot.index));
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    }

	    var ext = display.externalMeasured;
	    if (ext) {
	      if (to < ext.lineN)
	        ext.lineN += lendiff;
	      else if (from < ext.lineN + ext.size)
	        display.externalMeasured = null;
	    }
	  }

	  // Register a change to a single line. Type must be one of "text",
	  // "gutter", "class", "widget"
	  function regLineChange(cm, line, type) {
	    cm.curOp.viewChanged = true;
	    var display = cm.display, ext = cm.display.externalMeasured;
	    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	      display.externalMeasured = null;

	    if (line < display.viewFrom || line >= display.viewTo) return;
	    var lineView = display.view[findViewIndex(cm, line)];
	    if (lineView.node == null) return;
	    var arr = lineView.changes || (lineView.changes = []);
	    if (indexOf(arr, type) == -1) arr.push(type);
	  }

	  // Clear the view.
	  function resetView(cm) {
	    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	    cm.display.view = [];
	    cm.display.viewOffset = 0;
	  }

	  // Find the view element corresponding to a given line. Return null
	  // when the line isn't visible.
	  function findViewIndex(cm, n) {
	    if (n >= cm.display.viewTo) return null;
	    n -= cm.display.viewFrom;
	    if (n < 0) return null;
	    var view = cm.display.view;
	    for (var i = 0; i < view.length; i++) {
	      n -= view[i].size;
	      if (n < 0) return i;
	    }
	  }

	  function viewCuttingPoint(cm, oldN, newN, dir) {
	    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	      return {index: index, lineN: newN};
	    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
	      n += view[i].size;
	    if (n != oldN) {
	      if (dir > 0) {
	        if (index == view.length - 1) return null;
	        diff = (n + view[index].size) - oldN;
	        index++;
	      } else {
	        diff = n - oldN;
	      }
	      oldN += diff; newN += diff;
	    }
	    while (visualLineNo(cm.doc, newN) != newN) {
	      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
	      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	      index += dir;
	    }
	    return {index: index, lineN: newN};
	  }

	  // Force the view to cover a given range, adding empty view element
	  // or clipping off existing ones as needed.
	  function adjustView(cm, from, to) {
	    var display = cm.display, view = display.view;
	    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	      display.view = buildViewArray(cm, from, to);
	      display.viewFrom = from;
	    } else {
	      if (display.viewFrom > from)
	        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
	      else if (display.viewFrom < from)
	        display.view = display.view.slice(findViewIndex(cm, from));
	      display.viewFrom = from;
	      if (display.viewTo < to)
	        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
	      else if (display.viewTo > to)
	        display.view = display.view.slice(0, findViewIndex(cm, to));
	    }
	    display.viewTo = to;
	  }

	  // Count the number of lines in the view whose DOM representation is
	  // out of date (or nonexistent).
	  function countDirtyView(cm) {
	    var view = cm.display.view, dirty = 0;
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
	    }
	    return dirty;
	  }

	  // EVENT HANDLERS

	  // Attach the necessary event handlers when initializing the editor
	  function registerEventHandlers(cm) {
	    var d = cm.display;
	    on(d.scroller, "mousedown", operation(cm, onMouseDown));
	    // Older IE's will not fire a second mousedown for a double click
	    if (ie && ie_version < 11)
	      on(d.scroller, "dblclick", operation(cm, function(e) {
	        if (signalDOMEvent(cm, e)) return;
	        var pos = posFromMouse(cm, e);
	        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
	        e_preventDefault(e);
	        var word = cm.findWordAt(pos);
	        extendSelection(cm.doc, word.anchor, word.head);
	      }));
	    else
	      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
	    // Some browsers fire contextmenu *after* opening the menu, at
	    // which point we can't mess with it anymore. Context menu is
	    // handled in onMouseDown for these browsers.
	    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

	    // Used to suppress mouse event handling when a touch happens
	    var touchFinished, prevTouch = {end: 0};
	    function finishTouch() {
	      if (d.activeTouch) {
	        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
	        prevTouch = d.activeTouch;
	        prevTouch.end = +new Date;
	      }
	    };
	    function isMouseLikeTouchEvent(e) {
	      if (e.touches.length != 1) return false;
	      var touch = e.touches[0];
	      return touch.radiusX <= 1 && touch.radiusY <= 1;
	    }
	    function farAway(touch, other) {
	      if (other.left == null) return true;
	      var dx = other.left - touch.left, dy = other.top - touch.top;
	      return dx * dx + dy * dy > 20 * 20;
	    }
	    on(d.scroller, "touchstart", function(e) {
	      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
	        clearTimeout(touchFinished);
	        var now = +new Date;
	        d.activeTouch = {start: now, moved: false,
	                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
	        if (e.touches.length == 1) {
	          d.activeTouch.left = e.touches[0].pageX;
	          d.activeTouch.top = e.touches[0].pageY;
	        }
	      }
	    });
	    on(d.scroller, "touchmove", function() {
	      if (d.activeTouch) d.activeTouch.moved = true;
	    });
	    on(d.scroller, "touchend", function(e) {
	      var touch = d.activeTouch;
	      if (touch && !eventInWidget(d, e) && touch.left != null &&
	          !touch.moved && new Date - touch.start < 300) {
	        var pos = cm.coordsChar(d.activeTouch, "page"), range;
	        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	          range = new Range(pos, pos);
	        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	          range = cm.findWordAt(pos);
	        else // Triple tap
	          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
	        cm.setSelection(range.anchor, range.head);
	        cm.focus();
	        e_preventDefault(e);
	      }
	      finishTouch();
	    });
	    on(d.scroller, "touchcancel", finishTouch);

	    // Sync scrolling between fake scrollbars and real scrollable
	    // area, ensure viewport is updated when scrolling.
	    on(d.scroller, "scroll", function() {
	      if (d.scroller.clientHeight) {
	        setScrollTop(cm, d.scroller.scrollTop);
	        setScrollLeft(cm, d.scroller.scrollLeft, true);
	        signal(cm, "scroll", cm);
	      }
	    });

	    // Listen to wheel events in order to try and update the viewport on time.
	    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
	    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

	    // Prevent wrapper from ever scrolling
	    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

	    d.dragFunctions = {
	      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
	      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	      start: function(e){onDragStart(cm, e);},
	      drop: operation(cm, onDrop),
	      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	    };

	    var inp = d.input.getField();
	    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
	    on(inp, "keydown", operation(cm, onKeyDown));
	    on(inp, "keypress", operation(cm, onKeyPress));
	    on(inp, "focus", function (e) { onFocus(cm, e); });
	    on(inp, "blur", function (e) { onBlur(cm, e); });
	  }

	  function dragDropChanged(cm, value, old) {
	    var wasOn = old && old != CodeMirror.Init;
	    if (!value != !wasOn) {
	      var funcs = cm.display.dragFunctions;
	      var toggle = value ? on : off;
	      toggle(cm.display.scroller, "dragstart", funcs.start);
	      toggle(cm.display.scroller, "dragenter", funcs.enter);
	      toggle(cm.display.scroller, "dragover", funcs.over);
	      toggle(cm.display.scroller, "dragleave", funcs.leave);
	      toggle(cm.display.scroller, "drop", funcs.drop);
	    }
	  }

	  // Called when the window resizes
	  function onResize(cm) {
	    var d = cm.display;
	    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	      return;
	    // Might be a text scaling operation, clear size caches.
	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	    d.scrollbarsClipped = false;
	    cm.setSize();
	  }

	  // MOUSE EVENTS

	  // Return true when the given mouse event happened in a widget
	  function eventInWidget(display, e) {
	    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	          (n.parentNode == display.sizer && n != display.mover))
	        return true;
	    }
	  }

	  // Given a mouse event, find the corresponding position. If liberal
	  // is false, it checks whether a gutter or scrollbar was clicked,
	  // and returns null if it was. forRect is used by rectangular
	  // selections, and tries to estimate a character position even for
	  // coordinates beyond the right of the text.
	  function posFromMouse(cm, e, liberal, forRect) {
	    var display = cm.display;
	    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

	    var x, y, space = display.lineSpace.getBoundingClientRect();
	    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	    try { x = e.clientX - space.left; y = e.clientY - space.top; }
	    catch (e) { return null; }
	    var coords = coordsChar(cm, x, y), line;
	    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	    }
	    return coords;
	  }

	  // A mouse down can be a single click, double click, triple click,
	  // start of selection drag, start of text drag, new cursor
	  // (ctrl-click), rectangle drag (alt-drag), or xwin
	  // middle-click-paste. Or it might be a click on something we should
	  // not interfere with, such as a scrollbar or widget.
	  function onMouseDown(e) {
	    var cm = this, display = cm.display;
	    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
	    display.shift = e.shiftKey;

	    if (eventInWidget(display, e)) {
	      if (!webkit) {
	        // Briefly turn off draggability, to allow widgets to do
	        // normal dragging things.
	        display.scroller.draggable = false;
	        setTimeout(function(){display.scroller.draggable = true;}, 100);
	      }
	      return;
	    }
	    if (clickInGutter(cm, e)) return;
	    var start = posFromMouse(cm, e);
	    window.focus();

	    switch (e_button(e)) {
	    case 1:
	      // #3261: make sure, that we're not starting a second selection
	      if (cm.state.selectingText)
	        cm.state.selectingText(e);
	      else if (start)
	        leftButtonDown(cm, e, start);
	      else if (e_target(e) == display.scroller)
	        e_preventDefault(e);
	      break;
	    case 2:
	      if (webkit) cm.state.lastMiddleDown = +new Date;
	      if (start) extendSelection(cm.doc, start);
	      setTimeout(function() {display.input.focus();}, 20);
	      e_preventDefault(e);
	      break;
	    case 3:
	      if (captureRightClick) onContextMenu(cm, e);
	      else delayBlurEvent(cm);
	      break;
	    }
	  }

	  var lastClick, lastDoubleClick;
	  function leftButtonDown(cm, e, start) {
	    if (ie) setTimeout(bind(ensureFocus, cm), 0);
	    else cm.curOp.focus = activeElt();

	    var now = +new Date, type;
	    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
	      type = "triple";
	    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
	      type = "double";
	      lastDoubleClick = {time: now, pos: start};
	    } else {
	      type = "single";
	      lastClick = {time: now, pos: start};
	    }

	    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
	    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	        type == "single" && (contained = sel.contains(start)) > -1 &&
	        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
	        (cmp(contained.to(), start) > 0 || start.xRel < 0))
	      leftButtonStartDrag(cm, e, start, modifier);
	    else
	      leftButtonSelect(cm, e, start, type, modifier);
	  }

	  // Start a text drag. When it ends, see if any dragging actually
	  // happen, and treat as a click if it didn't.
	  function leftButtonStartDrag(cm, e, start, modifier) {
	    var display = cm.display, startTime = +new Date;
	    var dragEnd = operation(cm, function(e2) {
	      if (webkit) display.scroller.draggable = false;
	      cm.state.draggingText = false;
	      off(document, "mouseup", dragEnd);
	      off(display.scroller, "drop", dragEnd);
	      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
	        e_preventDefault(e2);
	        if (!modifier && +new Date - 200 < startTime)
	          extendSelection(cm.doc, start);
	        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	        if (webkit || ie && ie_version == 9)
	          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
	        else
	          display.input.focus();
	      }
	    });
	    // Let the drag handler handle this.
	    if (webkit) display.scroller.draggable = true;
	    cm.state.draggingText = dragEnd;
	    dragEnd.copy = mac ? e.altKey : e.ctrlKey
	    // IE's approach to draggable
	    if (display.scroller.dragDrop) display.scroller.dragDrop();
	    on(document, "mouseup", dragEnd);
	    on(display.scroller, "drop", dragEnd);
	  }

	  // Normal selection, as opposed to text dragging.
	  function leftButtonSelect(cm, e, start, type, addNew) {
	    var display = cm.display, doc = cm.doc;
	    e_preventDefault(e);

	    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	    if (addNew && !e.shiftKey) {
	      ourIndex = doc.sel.contains(start);
	      if (ourIndex > -1)
	        ourRange = ranges[ourIndex];
	      else
	        ourRange = new Range(start, start);
	    } else {
	      ourRange = doc.sel.primary();
	      ourIndex = doc.sel.primIndex;
	    }

	    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
	      type = "rect";
	      if (!addNew) ourRange = new Range(start, start);
	      start = posFromMouse(cm, e, true, true);
	      ourIndex = -1;
	    } else if (type == "double") {
	      var word = cm.findWordAt(start);
	      if (cm.display.shift || doc.extend)
	        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
	      else
	        ourRange = word;
	    } else if (type == "triple") {
	      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
	      if (cm.display.shift || doc.extend)
	        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
	      else
	        ourRange = line;
	    } else {
	      ourRange = extendRange(doc, ourRange, start);
	    }

	    if (!addNew) {
	      ourIndex = 0;
	      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	      startSel = doc.sel;
	    } else if (ourIndex == -1) {
	      ourIndex = ranges.length;
	      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                   {scroll: false, origin: "*mouse"});
	    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
	      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                   {scroll: false, origin: "*mouse"});
	      startSel = doc.sel;
	    } else {
	      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	    }

	    var lastPos = start;
	    function extendTo(pos) {
	      if (cmp(lastPos, pos) == 0) return;
	      lastPos = pos;

	      if (type == "rect") {
	        var ranges = [], tabSize = cm.options.tabSize;
	        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	             line <= end; line++) {
	          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	          if (left == right)
	            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
	          else if (text.length > leftPos)
	            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
	        }
	        if (!ranges.length) ranges.push(new Range(start, start));
	        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                     {origin: "*mouse", scroll: false});
	        cm.scrollIntoView(pos);
	      } else {
	        var oldRange = ourRange;
	        var anchor = oldRange.anchor, head = pos;
	        if (type != "single") {
	          if (type == "double")
	            var range = cm.findWordAt(pos);
	          else
	            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
	          if (cmp(range.anchor, anchor) > 0) {
	            head = range.head;
	            anchor = minPos(oldRange.from(), range.anchor);
	          } else {
	            head = range.anchor;
	            anchor = maxPos(oldRange.to(), range.head);
	          }
	        }
	        var ranges = startSel.ranges.slice(0);
	        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
	        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
	      }
	    }

	    var editorSize = display.wrapper.getBoundingClientRect();
	    // Used to ensure timeout re-tries don't fire when another extend
	    // happened in the meantime (clearTimeout isn't reliable -- at
	    // least on Chrome, the timeouts still happen even when cleared,
	    // if the clear happens after their scheduled firing time).
	    var counter = 0;

	    function extend(e) {
	      var curCount = ++counter;
	      var cur = posFromMouse(cm, e, true, type == "rect");
	      if (!cur) return;
	      if (cmp(cur, lastPos) != 0) {
	        cm.curOp.focus = activeElt();
	        extendTo(cur);
	        var visible = visibleLines(display, doc);
	        if (cur.line >= visible.to || cur.line < visible.from)
	          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
	      } else {
	        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	        if (outside) setTimeout(operation(cm, function() {
	          if (counter != curCount) return;
	          display.scroller.scrollTop += outside;
	          extend(e);
	        }), 50);
	      }
	    }

	    function done(e) {
	      cm.state.selectingText = false;
	      counter = Infinity;
	      e_preventDefault(e);
	      display.input.focus();
	      off(document, "mousemove", move);
	      off(document, "mouseup", up);
	      doc.history.lastSelOrigin = null;
	    }

	    var move = operation(cm, function(e) {
	      if (!e_button(e)) done(e);
	      else extend(e);
	    });
	    var up = operation(cm, done);
	    cm.state.selectingText = up;
	    on(document, "mousemove", move);
	    on(document, "mouseup", up);
	  }

	  // Determines whether an event happened in the gutter, and fires the
	  // handlers for the corresponding event.
	  function gutterEvent(cm, e, type, prevent) {
	    try { var mX = e.clientX, mY = e.clientY; }
	    catch(e) { return false; }
	    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
	    if (prevent) e_preventDefault(e);

	    var display = cm.display;
	    var lineBox = display.lineDiv.getBoundingClientRect();

	    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
	    mY -= lineBox.top - display.viewOffset;

	    for (var i = 0; i < cm.options.gutters.length; ++i) {
	      var g = display.gutters.childNodes[i];
	      if (g && g.getBoundingClientRect().right >= mX) {
	        var line = lineAtHeight(cm.doc, mY);
	        var gutter = cm.options.gutters[i];
	        signal(cm, type, cm, line, gutter, e);
	        return e_defaultPrevented(e);
	      }
	    }
	  }

	  function clickInGutter(cm, e) {
	    return gutterEvent(cm, e, "gutterClick", true);
	  }

	  // Kludge to work around strange IE behavior where it'll sometimes
	  // re-fire a series of drag-related events right after the drop (#1551)
	  var lastDrop = 0;

	  function onDrop(e) {
	    var cm = this;
	    clearDragCursor(cm);
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	      return;
	    e_preventDefault(e);
	    if (ie) lastDrop = +new Date;
	    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	    if (!pos || cm.isReadOnly()) return;
	    // Might be a file drop, in which case we simply extract the text
	    // and insert it.
	    if (files && files.length && window.FileReader && window.File) {
	      var n = files.length, text = Array(n), read = 0;
	      var loadFile = function(file, i) {
	        if (cm.options.allowDropFileTypes &&
	            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
	          return;

	        var reader = new FileReader;
	        reader.onload = operation(cm, function() {
	          var content = reader.result;
	          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";
	          text[i] = content;
	          if (++read == n) {
	            pos = clipPos(cm.doc, pos);
	            var change = {from: pos, to: pos,
	                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
	                          origin: "paste"};
	            makeChange(cm.doc, change);
	            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
	          }
	        });
	        reader.readAsText(file);
	      };
	      for (var i = 0; i < n; ++i) loadFile(files[i], i);
	    } else { // Normal drop
	      // Don't do a replace if the drop happened inside of the selected text.
	      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	        cm.state.draggingText(e);
	        // Ensure the editor is re-focused
	        setTimeout(function() {cm.display.input.focus();}, 20);
	        return;
	      }
	      try {
	        var text = e.dataTransfer.getData("Text");
	        if (text) {
	          if (cm.state.draggingText && !cm.state.draggingText.copy)
	            var selected = cm.listSelections();
	          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	          if (selected) for (var i = 0; i < selected.length; ++i)
	            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
	          cm.replaceSelection(text, "around", "paste");
	          cm.display.input.focus();
	        }
	      }
	      catch(e){}
	    }
	  }

	  function onDragStart(cm, e) {
	    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

	    e.dataTransfer.setData("Text", cm.getSelection());
	    e.dataTransfer.effectAllowed = "copyMove"

	    // Use dummy image instead of default browsers image.
	    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	    if (e.dataTransfer.setDragImage && !safari) {
	      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	      if (presto) {
	        img.width = img.height = 1;
	        cm.display.wrapper.appendChild(img);
	        // Force a relayout, or Opera won't use our image for some obscure reason
	        img._top = img.offsetTop;
	      }
	      e.dataTransfer.setDragImage(img, 0, 0);
	      if (presto) img.parentNode.removeChild(img);
	    }
	  }

	  function onDragOver(cm, e) {
	    var pos = posFromMouse(cm, e);
	    if (!pos) return;
	    var frag = document.createDocumentFragment();
	    drawSelectionCursor(cm, pos, frag);
	    if (!cm.display.dragCursor) {
	      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	    }
	    removeChildrenAndAdd(cm.display.dragCursor, frag);
	  }

	  function clearDragCursor(cm) {
	    if (cm.display.dragCursor) {
	      cm.display.lineSpace.removeChild(cm.display.dragCursor);
	      cm.display.dragCursor = null;
	    }
	  }

	  // SCROLL EVENTS

	  // Sync the scrollable area and scrollbars, ensure the viewport
	  // covers the visible area.
	  function setScrollTop(cm, val) {
	    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
	    cm.doc.scrollTop = val;
	    if (!gecko) updateDisplaySimple(cm, {top: val});
	    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
	    cm.display.scrollbars.setScrollTop(val);
	    if (gecko) updateDisplaySimple(cm);
	    startWorker(cm, 100);
	  }
	  // Sync scroller and scrollbar, ensure the gutter elements are
	  // aligned.
	  function setScrollLeft(cm, val, isScroller) {
	    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
	    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
	    cm.doc.scrollLeft = val;
	    alignHorizontally(cm);
	    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
	    cm.display.scrollbars.setScrollLeft(val);
	  }

	  // Since the delta values reported on mouse wheel events are
	  // unstandardized between browsers and even browser versions, and
	  // generally horribly unpredictable, this code starts by measuring
	  // the scroll effect that the first few mouse wheel events have,
	  // and, from that, detects the way it can convert deltas to pixel
	  // offsets afterwards.
	  //
	  // The reason we want to know the amount a wheel event will scroll
	  // is that it gives us a chance to update the display before the
	  // actual scrolling happens, reducing flickering.

	  var wheelSamples = 0, wheelPixelsPerUnit = null;
	  // Fill in a browser-detected starting value on browsers where we
	  // know one. These don't have to be accurate -- the result of them
	  // being wrong would just be a slight flicker on the first wheel
	  // scroll (if it is large enough).
	  if (ie) wheelPixelsPerUnit = -.53;
	  else if (gecko) wheelPixelsPerUnit = 15;
	  else if (chrome) wheelPixelsPerUnit = -.7;
	  else if (safari) wheelPixelsPerUnit = -1/3;

	  var wheelEventDelta = function(e) {
	    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
	    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
	    else if (dy == null) dy = e.wheelDelta;
	    return {x: dx, y: dy};
	  };
	  CodeMirror.wheelEventPixels = function(e) {
	    var delta = wheelEventDelta(e);
	    delta.x *= wheelPixelsPerUnit;
	    delta.y *= wheelPixelsPerUnit;
	    return delta;
	  };

	  function onScrollWheel(cm, e) {
	    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

	    var display = cm.display, scroll = display.scroller;
	    // Quit if there's nothing to scroll here
	    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	    if (!(dx && canScrollX || dy && canScrollY)) return;

	    // Webkit browsers on OS X abort momentum scrolls when the target
	    // of the scroll event is removed from the scrollable element.
	    // This hack (see related code in patchDisplay) makes sure the
	    // element is kept around.
	    if (dy && mac && webkit) {
	      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	        for (var i = 0; i < view.length; i++) {
	          if (view[i].node == cur) {
	            cm.display.currentWheelTarget = cur;
	            break outer;
	          }
	        }
	      }
	    }

	    // On some browsers, horizontal scrolling will cause redraws to
	    // happen before the gutter has been realigned, causing it to
	    // wriggle around in a most unseemly way. When we have an
	    // estimated pixels/delta value, we just handle horizontal
	    // scrolling entirely here. It'll be slightly off from native, but
	    // better than glitching out.
	    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	      if (dy && canScrollY)
	        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
	      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
	      // Only prevent default scrolling if vertical scrolling is
	      // actually possible. Otherwise, it causes vertical scroll
	      // jitter on OSX trackpads when deltaX is small and deltaY
	      // is large (issue #3579)
	      if (!dy || (dy && canScrollY))
	        e_preventDefault(e);
	      display.wheelStartX = null; // Abort measurement, if in progress
	      return;
	    }

	    // 'Project' the visible viewport to cover the area that is being
	    // scrolled into view (if we know enough to estimate it).
	    if (dy && wheelPixelsPerUnit != null) {
	      var pixels = dy * wheelPixelsPerUnit;
	      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	      if (pixels < 0) top = Math.max(0, top + pixels - 50);
	      else bot = Math.min(cm.doc.height, bot + pixels + 50);
	      updateDisplaySimple(cm, {top: top, bottom: bot});
	    }

	    if (wheelSamples < 20) {
	      if (display.wheelStartX == null) {
	        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	        display.wheelDX = dx; display.wheelDY = dy;
	        setTimeout(function() {
	          if (display.wheelStartX == null) return;
	          var movedX = scroll.scrollLeft - display.wheelStartX;
	          var movedY = scroll.scrollTop - display.wheelStartY;
	          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	            (movedX && display.wheelDX && movedX / display.wheelDX);
	          display.wheelStartX = display.wheelStartY = null;
	          if (!sample) return;
	          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	          ++wheelSamples;
	        }, 200);
	      } else {
	        display.wheelDX += dx; display.wheelDY += dy;
	      }
	    }
	  }

	  // KEY EVENTS

	  // Run a handler that was bound to a key.
	  function doHandleBinding(cm, bound, dropShift) {
	    if (typeof bound == "string") {
	      bound = commands[bound];
	      if (!bound) return false;
	    }
	    // Ensure previous input has been read, so that the handler sees a
	    // consistent view of the document
	    cm.display.input.ensurePolled();
	    var prevShift = cm.display.shift, done = false;
	    try {
	      if (cm.isReadOnly()) cm.state.suppressEdits = true;
	      if (dropShift) cm.display.shift = false;
	      done = bound(cm) != Pass;
	    } finally {
	      cm.display.shift = prevShift;
	      cm.state.suppressEdits = false;
	    }
	    return done;
	  }

	  function lookupKeyForEditor(cm, name, handle) {
	    for (var i = 0; i < cm.state.keyMaps.length; i++) {
	      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	      if (result) return result;
	    }
	    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	      || lookupKey(name, cm.options.keyMap, handle, cm);
	  }

	  var stopSeq = new Delayed;
	  function dispatchKey(cm, name, e, handle) {
	    var seq = cm.state.keySeq;
	    if (seq) {
	      if (isModifierKey(name)) return "handled";
	      stopSeq.set(50, function() {
	        if (cm.state.keySeq == seq) {
	          cm.state.keySeq = null;
	          cm.display.input.reset();
	        }
	      });
	      name = seq + " " + name;
	    }
	    var result = lookupKeyForEditor(cm, name, handle);

	    if (result == "multi")
	      cm.state.keySeq = name;
	    if (result == "handled")
	      signalLater(cm, "keyHandled", cm, name, e);

	    if (result == "handled" || result == "multi") {
	      e_preventDefault(e);
	      restartBlink(cm);
	    }

	    if (seq && !result && /\'$/.test(name)) {
	      e_preventDefault(e);
	      return true;
	    }
	    return !!result;
	  }

	  // Handle a key from the keydown event.
	  function handleKeyBinding(cm, e) {
	    var name = keyName(e, true);
	    if (!name) return false;

	    if (e.shiftKey && !cm.state.keySeq) {
	      // First try to resolve full name (including 'Shift-'). Failing
	      // that, see if there is a cursor-motion command (starting with
	      // 'go') bound to the keyname without 'Shift-'.
	      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
	          || dispatchKey(cm, name, e, function(b) {
	               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	                 return doHandleBinding(cm, b);
	             });
	    } else {
	      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
	    }
	  }

	  // Handle a key from the keypress event
	  function handleCharBinding(cm, e, ch) {
	    return dispatchKey(cm, "'" + ch + "'", e,
	                       function(b) { return doHandleBinding(cm, b, true); });
	  }

	  var lastStoppedKey = null;
	  function onKeyDown(e) {
	    var cm = this;
	    cm.curOp.focus = activeElt();
	    if (signalDOMEvent(cm, e)) return;
	    // IE does strange things with escape.
	    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
	    var code = e.keyCode;
	    cm.display.shift = code == 16 || e.shiftKey;
	    var handled = handleKeyBinding(cm, e);
	    if (presto) {
	      lastStoppedKey = handled ? code : null;
	      // Opera has no cut event... we try to at least catch the key combo
	      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	        cm.replaceSelection("", null, "cut");
	    }

	    // Turn mouse into crosshair when Alt is held on Mac.
	    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	      showCrossHair(cm);
	  }

	  function showCrossHair(cm) {
	    var lineDiv = cm.display.lineDiv;
	    addClass(lineDiv, "CodeMirror-crosshair");

	    function up(e) {
	      if (e.keyCode == 18 || !e.altKey) {
	        rmClass(lineDiv, "CodeMirror-crosshair");
	        off(document, "keyup", up);
	        off(document, "mouseover", up);
	      }
	    }
	    on(document, "keyup", up);
	    on(document, "mouseover", up);
	  }

	  function onKeyUp(e) {
	    if (e.keyCode == 16) this.doc.sel.shift = false;
	    signalDOMEvent(this, e);
	  }

	  function onKeyPress(e) {
	    var cm = this;
	    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
	    var keyCode = e.keyCode, charCode = e.charCode;
	    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
	    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
	    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	    if (handleCharBinding(cm, e, ch)) return;
	    cm.display.input.onKeyPress(e);
	  }

	  // FOCUS/BLUR EVENTS

	  function delayBlurEvent(cm) {
	    cm.state.delayingBlurEvent = true;
	    setTimeout(function() {
	      if (cm.state.delayingBlurEvent) {
	        cm.state.delayingBlurEvent = false;
	        onBlur(cm);
	      }
	    }, 100);
	  }

	  function onFocus(cm, e) {
	    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

	    if (cm.options.readOnly == "nocursor") return;
	    if (!cm.state.focused) {
	      signal(cm, "focus", cm, e);
	      cm.state.focused = true;
	      addClass(cm.display.wrapper, "CodeMirror-focused");
	      // This test prevents this from firing when a context
	      // menu is closed (since the input reset would kill the
	      // select-all detection hack)
	      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	        cm.display.input.reset();
	        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
	      }
	      cm.display.input.receivedFocus();
	    }
	    restartBlink(cm);
	  }
	  function onBlur(cm, e) {
	    if (cm.state.delayingBlurEvent) return;

	    if (cm.state.focused) {
	      signal(cm, "blur", cm, e);
	      cm.state.focused = false;
	      rmClass(cm.display.wrapper, "CodeMirror-focused");
	    }
	    clearInterval(cm.display.blinker);
	    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
	  }

	  // CONTEXT MENU HANDLING

	  // To make the context menu work, we need to briefly unhide the
	  // textarea (making it as unobtrusive as possible) to let the
	  // right-click take effect on it.
	  function onContextMenu(cm, e) {
	    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
	    if (signalDOMEvent(cm, e, "contextmenu")) return;
	    cm.display.input.onContextMenu(e);
	  }

	  function contextMenuInGutter(cm, e) {
	    if (!hasHandler(cm, "gutterContextMenu")) return false;
	    return gutterEvent(cm, e, "gutterContextMenu", false);
	  }

	  // UPDATING

	  // Compute the position of the end of a change (its 'to' property
	  // refers to the pre-change end).
	  var changeEnd = CodeMirror.changeEnd = function(change) {
	    if (!change.text) return change.to;
	    return Pos(change.from.line + change.text.length - 1,
	               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
	  };

	  // Adjust a position to refer to the post-change position of the
	  // same text, or the end of the change if the change covers it.
	  function adjustForChange(pos, change) {
	    if (cmp(pos, change.from) < 0) return pos;
	    if (cmp(pos, change.to) <= 0) return changeEnd(change);

	    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
	    return Pos(line, ch);
	  }

	  function computeSelAfterChange(doc, change) {
	    var out = [];
	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      var range = doc.sel.ranges[i];
	      out.push(new Range(adjustForChange(range.anchor, change),
	                         adjustForChange(range.head, change)));
	    }
	    return normalizeSelection(out, doc.sel.primIndex);
	  }

	  function offsetPos(pos, old, nw) {
	    if (pos.line == old.line)
	      return Pos(nw.line, pos.ch - old.ch + nw.ch);
	    else
	      return Pos(nw.line + (pos.line - old.line), pos.ch);
	  }

	  // Used by replaceSelections to allow moving the selection to the
	  // start or around the replaced test. Hint may be "start" or "around".
	  function computeReplacedSel(doc, changes, hint) {
	    var out = [];
	    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	    for (var i = 0; i < changes.length; i++) {
	      var change = changes[i];
	      var from = offsetPos(change.from, oldPrev, newPrev);
	      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	      oldPrev = change.to;
	      newPrev = to;
	      if (hint == "around") {
	        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	        out[i] = new Range(inv ? to : from, inv ? from : to);
	      } else {
	        out[i] = new Range(from, from);
	      }
	    }
	    return new Selection(out, doc.sel.primIndex);
	  }

	  // Allow "beforeChange" event handlers to influence a change
	  function filterChange(doc, change, update) {
	    var obj = {
	      canceled: false,
	      from: change.from,
	      to: change.to,
	      text: change.text,
	      origin: change.origin,
	      cancel: function() { this.canceled = true; }
	    };
	    if (update) obj.update = function(from, to, text, origin) {
	      if (from) this.from = clipPos(doc, from);
	      if (to) this.to = clipPos(doc, to);
	      if (text) this.text = text;
	      if (origin !== undefined) this.origin = origin;
	    };
	    signal(doc, "beforeChange", doc, obj);
	    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

	    if (obj.canceled) return null;
	    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
	  }

	  // Apply a change to a document, and add it to the document's
	  // history, and propagating it to all linked documents.
	  function makeChange(doc, change, ignoreReadOnly) {
	    if (doc.cm) {
	      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
	      if (doc.cm.state.suppressEdits) return;
	    }

	    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	      change = filterChange(doc, change, true);
	      if (!change) return;
	    }

	    // Possibly split or suppress the update based on the presence
	    // of read-only spans in its range.
	    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	    if (split) {
	      for (var i = split.length - 1; i >= 0; --i)
	        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
	    } else {
	      makeChangeInner(doc, change);
	    }
	  }

	  function makeChangeInner(doc, change) {
	    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
	    var selAfter = computeSelAfterChange(doc, change);
	    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

	    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	    var rebased = [];

	    linkedDocs(doc, function(doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	    });
	  }

	  // Revert a change stored in a document's history.
	  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;

	    var hist = doc.history, event, selAfter = doc.sel;
	    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

	    // Verify that there is a useable event (so that ctrl-z won't
	    // needlessly clear selection events)
	    for (var i = 0; i < source.length; i++) {
	      event = source[i];
	      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	        break;
	    }
	    if (i == source.length) return;
	    hist.lastOrigin = hist.lastSelOrigin = null;

	    for (;;) {
	      event = source.pop();
	      if (event.ranges) {
	        pushSelectionToHistory(event, dest);
	        if (allowSelectionOnly && !event.equals(doc.sel)) {
	          setSelection(doc, event, {clearRedo: false});
	          return;
	        }
	        selAfter = event;
	      }
	      else break;
	    }

	    // Build up a reverse change object to add to the opposite history
	    // stack (redo when undoing, and vice versa).
	    var antiChanges = [];
	    pushSelectionToHistory(selAfter, dest);
	    dest.push({changes: antiChanges, generation: hist.generation});
	    hist.generation = event.generation || ++hist.maxGeneration;

	    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

	    for (var i = event.changes.length - 1; i >= 0; --i) {
	      var change = event.changes[i];
	      change.origin = type;
	      if (filter && !filterChange(doc, change, false)) {
	        source.length = 0;
	        return;
	      }

	      antiChanges.push(historyChangeFromChange(doc, change));

	      var after = i ? computeSelAfterChange(doc, change) : lst(source);
	      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
	      var rebased = [];

	      // Propagate to the linked documents
	      linkedDocs(doc, function(doc, sharedHist) {
	        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	          rebaseHist(doc.history, change);
	          rebased.push(doc.history);
	        }
	        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	      });
	    }
	  }

	  // Sub-views need their line numbers shifted when text is added
	  // above or below them in the parent document.
	  function shiftDoc(doc, distance) {
	    if (distance == 0) return;
	    doc.first += distance;
	    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
	      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
	                       Pos(range.head.line + distance, range.head.ch));
	    }), doc.sel.primIndex);
	    if (doc.cm) {
	      regChange(doc.cm, doc.first, doc.first - distance, distance);
	      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	        regLineChange(doc.cm, l, "gutter");
	    }
	  }

	  // More lower-level change function, handling only a single document
	  // (not linked ones).
	  function makeChangeSingleDoc(doc, change, selAfter, spans) {
	    if (doc.cm && !doc.cm.curOp)
	      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

	    if (change.to.line < doc.first) {
	      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	      return;
	    }
	    if (change.from.line > doc.lastLine()) return;

	    // Clip the change to the size of this doc
	    if (change.from.line < doc.first) {
	      var shift = change.text.length - 1 - (doc.first - change.from.line);
	      shiftDoc(doc, shift);
	      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	                text: [lst(change.text)], origin: change.origin};
	    }
	    var last = doc.lastLine();
	    if (change.to.line > last) {
	      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	                text: [change.text[0]], origin: change.origin};
	    }

	    change.removed = getBetween(doc, change.from, change.to);

	    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
	    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
	    else updateDoc(doc, change, spans);
	    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	  }

	  // Handle the interaction of a change to a document with the editor
	  // that this document is part of.
	  function makeChangeSingleDocInEditor(cm, change, spans) {
	    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

	    var recomputeMaxLength = false, checkWidthStart = from.line;
	    if (!cm.options.lineWrapping) {
	      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	      doc.iter(checkWidthStart, to.line + 1, function(line) {
	        if (line == display.maxLine) {
	          recomputeMaxLength = true;
	          return true;
	        }
	      });
	    }

	    if (doc.sel.contains(change.from, change.to) > -1)
	      signalCursorActivity(cm);

	    updateDoc(doc, change, spans, estimateHeight(cm));

	    if (!cm.options.lineWrapping) {
	      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
	        var len = lineLength(line);
	        if (len > display.maxLineLength) {
	          display.maxLine = line;
	          display.maxLineLength = len;
	          display.maxLineChanged = true;
	          recomputeMaxLength = false;
	        }
	      });
	      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
	    }

	    // Adjust frontier, schedule worker
	    doc.frontier = Math.min(doc.frontier, from.line);
	    startWorker(cm, 400);

	    var lendiff = change.text.length - (to.line - from.line) - 1;
	    // Remember that these lines changed, for updating the display
	    if (change.full)
	      regChange(cm);
	    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	      regLineChange(cm, from.line, "text");
	    else
	      regChange(cm, from.line, to.line + 1, lendiff);

	    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	    if (changeHandler || changesHandler) {
	      var obj = {
	        from: from, to: to,
	        text: change.text,
	        removed: change.removed,
	        origin: change.origin
	      };
	      if (changeHandler) signalLater(cm, "change", cm, obj);
	      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
	    }
	    cm.display.selForContextMenu = null;
	  }

	  function replaceRange(doc, code, from, to, origin) {
	    if (!to) to = from;
	    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
	    if (typeof code == "string") code = doc.splitLines(code);
	    makeChange(doc, {from: from, to: to, text: code, origin: origin});
	  }

	  // SCROLLING THINGS INTO VIEW

	  // If an editor sits on the top or bottom of the window, partially
	  // scrolled out of view, this ensures that the cursor is visible.
	  function maybeScrollWindow(cm, coords) {
	    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

	    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	    if (coords.top + box.top < 0) doScroll = true;
	    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
	    if (doScroll != null && !phantom) {
	      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
	                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
	                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
	                           coords.left + "px; width: 2px;");
	      cm.display.lineSpace.appendChild(scrollNode);
	      scrollNode.scrollIntoView(doScroll);
	      cm.display.lineSpace.removeChild(scrollNode);
	    }
	  }

	  // Scroll a given position into view (immediately), verifying that
	  // it actually became visible (as line heights are accurately
	  // measured, the position of something may 'drift' during drawing).
	  function scrollPosIntoView(cm, pos, end, margin) {
	    if (margin == null) margin = 0;
	    for (var limit = 0; limit < 5; limit++) {
	      var changed = false, coords = cursorCoords(cm, pos);
	      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
	                                         Math.min(coords.top, endCoords.top) - margin,
	                                         Math.max(coords.left, endCoords.left),
	                                         Math.max(coords.bottom, endCoords.bottom) + margin);
	      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	      if (scrollPos.scrollTop != null) {
	        setScrollTop(cm, scrollPos.scrollTop);
	        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
	      }
	      if (scrollPos.scrollLeft != null) {
	        setScrollLeft(cm, scrollPos.scrollLeft);
	        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
	      }
	      if (!changed) break;
	    }
	    return coords;
	  }

	  // Scroll a given set of coordinates into view (immediately).
	  function scrollIntoView(cm, x1, y1, x2, y2) {
	    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
	    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
	    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
	  }

	  // Calculate a new scroll position needed to scroll the given
	  // rectangle into view. Returns an object with scrollTop and
	  // scrollLeft properties. When these are undefined, the
	  // vertical/horizontal position does not need to be adjusted.
	  function calculateScrollPos(cm, x1, y1, x2, y2) {
	    var display = cm.display, snapMargin = textHeight(cm.display);
	    if (y1 < 0) y1 = 0;
	    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	    var screen = displayHeight(cm), result = {};
	    if (y2 - y1 > screen) y2 = y1 + screen;
	    var docBottom = cm.doc.height + paddingVert(display);
	    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
	    if (y1 < screentop) {
	      result.scrollTop = atTop ? 0 : y1;
	    } else if (y2 > screentop + screen) {
	      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
	      if (newTop != screentop) result.scrollTop = newTop;
	    }

	    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	    var tooWide = x2 - x1 > screenw;
	    if (tooWide) x2 = x1 + screenw;
	    if (x1 < 10)
	      result.scrollLeft = 0;
	    else if (x1 < screenleft)
	      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
	    else if (x2 > screenw + screenleft - 3)
	      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
	    return result;
	  }

	  // Store a relative adjustment to the scroll position in the current
	  // operation (to be applied when the operation finishes).
	  function addToScrollPos(cm, left, top) {
	    if (left != null || top != null) resolveScrollToPos(cm);
	    if (left != null)
	      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
	    if (top != null)
	      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	  }

	  // Make sure that at the end of the operation the current cursor is
	  // shown.
	  function ensureCursorVisible(cm) {
	    resolveScrollToPos(cm);
	    var cur = cm.getCursor(), from = cur, to = cur;
	    if (!cm.options.lineWrapping) {
	      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
	      to = Pos(cur.line, cur.ch + 1);
	    }
	    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
	  }

	  // When an operation has its scrollToPos property set, and another
	  // scroll action is applied before the end of the operation, this
	  // 'simulates' scrolling that position into view in a cheap way, so
	  // that the effect of intermediate scroll commands is not ignored.
	  function resolveScrollToPos(cm) {
	    var range = cm.curOp.scrollToPos;
	    if (range) {
	      cm.curOp.scrollToPos = null;
	      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
	      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
	                                    Math.min(from.top, to.top) - range.margin,
	                                    Math.max(from.right, to.right),
	                                    Math.max(from.bottom, to.bottom) + range.margin);
	      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	    }
	  }

	  // API UTILITIES

	  // Indent the given line. The how parameter can be "smart",
	  // "add"/null, "subtract", or "prev". When aggressive is false
	  // (typically set to true for forced single-line indents), empty
	  // lines are not indented, and places where the mode returns Pass
	  // are left alone.
	  function indentLine(cm, n, how, aggressive) {
	    var doc = cm.doc, state;
	    if (how == null) how = "add";
	    if (how == "smart") {
	      // Fall back to "prev" when the mode doesn't have an indentation
	      // method.
	      if (!doc.mode.indent) how = "prev";
	      else state = getStateBefore(cm, n);
	    }

	    var tabSize = cm.options.tabSize;
	    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	    if (line.stateAfter) line.stateAfter = null;
	    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	    if (!aggressive && !/\S/.test(line.text)) {
	      indentation = 0;
	      how = "not";
	    } else if (how == "smart") {
	      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	      if (indentation == Pass || indentation > 150) {
	        if (!aggressive) return;
	        how = "prev";
	      }
	    }
	    if (how == "prev") {
	      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
	      else indentation = 0;
	    } else if (how == "add") {
	      indentation = curSpace + cm.options.indentUnit;
	    } else if (how == "subtract") {
	      indentation = curSpace - cm.options.indentUnit;
	    } else if (typeof how == "number") {
	      indentation = curSpace + how;
	    }
	    indentation = Math.max(0, indentation);

	    var indentString = "", pos = 0;
	    if (cm.options.indentWithTabs)
	      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
	    if (pos < indentation) indentString += spaceStr(indentation - pos);

	    if (indentString != curSpaceString) {
	      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	      line.stateAfter = null;
	      return true;
	    } else {
	      // Ensure that, if the cursor was in the whitespace at the start
	      // of the line, it is moved to the end of that space.
	      for (var i = 0; i < doc.sel.ranges.length; i++) {
	        var range = doc.sel.ranges[i];
	        if (range.head.line == n && range.head.ch < curSpaceString.length) {
	          var pos = Pos(n, curSpaceString.length);
	          replaceOneSelection(doc, i, new Range(pos, pos));
	          break;
	        }
	      }
	    }
	  }

	  // Utility for applying a change to a line by handle or number,
	  // returning the number and optionally registering the line as
	  // changed.
	  function changeLine(doc, handle, changeType, op) {
	    var no = handle, line = handle;
	    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
	    else no = lineNo(handle);
	    if (no == null) return null;
	    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
	    return line;
	  }

	  // Helper for deleting text near the selection(s), used to implement
	  // backspace, delete, and similar functionality.
	  function deleteNearSelection(cm, compute) {
	    var ranges = cm.doc.sel.ranges, kill = [];
	    // Build up a set of ranges to kill first, merging overlapping
	    // ranges.
	    for (var i = 0; i < ranges.length; i++) {
	      var toKill = compute(ranges[i]);
	      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	        var replaced = kill.pop();
	        if (cmp(replaced.from, toKill.from) < 0) {
	          toKill.from = replaced.from;
	          break;
	        }
	      }
	      kill.push(toKill);
	    }
	    // Next, remove those actual ranges.
	    runInOp(cm, function() {
	      for (var i = kill.length - 1; i >= 0; i--)
	        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
	      ensureCursorVisible(cm);
	    });
	  }

	  // Used for horizontal relative motion. Dir is -1 or 1 (left or
	  // right), unit can be "char", "column" (like char, but doesn't
	  // cross line boundaries), "word" (across next word), or "group" (to
	  // the start of next group of word or non-word-non-whitespace
	  // chars). The visually param controls whether, in right-to-left
	  // text, direction 1 means to move towards the next index in the
	  // string, or towards the character to the right of the current
	  // position. The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosH(doc, pos, dir, unit, visually) {
	    var line = pos.line, ch = pos.ch, origDir = dir;
	    var lineObj = getLine(doc, line);
	    function findNextLine() {
	      var l = line + dir;
	      if (l < doc.first || l >= doc.first + doc.size) return false
	      line = l;
	      return lineObj = getLine(doc, l);
	    }
	    function moveOnce(boundToLine) {
	      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
	      if (next == null) {
	        if (!boundToLine && findNextLine()) {
	          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
	          else ch = dir < 0 ? lineObj.text.length : 0;
	        } else return false
	      } else ch = next;
	      return true;
	    }

	    if (unit == "char") {
	      moveOnce()
	    } else if (unit == "column") {
	      moveOnce(true)
	    } else if (unit == "word" || unit == "group") {
	      var sawType = null, group = unit == "group";
	      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	      for (var first = true;; first = false) {
	        if (dir < 0 && !moveOnce(!first)) break;
	        var cur = lineObj.text.charAt(ch) || "\n";
	        var type = isWordChar(cur, helper) ? "w"
	          : group && cur == "\n" ? "n"
	          : !group || /\s/.test(cur) ? null
	          : "p";
	        if (group && !first && !type) type = "s";
	        if (sawType && sawType != type) {
	          if (dir < 0) {dir = 1; moveOnce();}
	          break;
	        }

	        if (type) sawType = type;
	        if (dir > 0 && !moveOnce(!first)) break;
	      }
	    }
	    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
	    if (!cmp(pos, result)) result.hitSide = true;
	    return result;
	  }

	  // For relative vertical movement. Dir may be -1 or 1. Unit can be
	  // "page" or "line". The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosV(cm, pos, dir, unit) {
	    var doc = cm.doc, x = pos.left, y;
	    if (unit == "page") {
	      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
	    } else if (unit == "line") {
	      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	    }
	    for (;;) {
	      var target = coordsChar(cm, x, y);
	      if (!target.outside) break;
	      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
	      y += dir * 5;
	    }
	    return target;
	  }

	  // EDITOR METHODS

	  // The publicly visible API. Note that methodOp(f) means
	  // 'wrap f in an operation, performed on its `this` parameter'.

	  // This is not the complete set of editor methods. Most of the
	  // methods defined on the Doc type are also injected into
	  // CodeMirror.prototype, for backwards compatibility and
	  // convenience.

	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); this.display.input.focus();},

	    setOption: function(option, value) {
	      var options = this.options, old = options[option];
	      if (options[option] == value && option != "mode") return;
	      options[option] = value;
	      if (optionHandlers.hasOwnProperty(option))
	        operation(this, optionHandlers[option])(this, value, old);
	    },

	    getOption: function(option) {return this.options[option];},
	    getDoc: function() {return this.doc;},

	    addKeyMap: function(map, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
	    },
	    removeKeyMap: function(map) {
	      var maps = this.state.keyMaps;
	      for (var i = 0; i < maps.length; ++i)
	        if (maps[i] == map || maps[i].name == map) {
	          maps.splice(i, 1);
	          return true;
	        }
	    },

	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	      if (mode.startState) throw new Error("Overlays may not be stateful.");
	      insertSorted(this.state.overlays,
	                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                    priority: (options && options.priority) || 0},
	                   function(overlay) { return overlay.priority })
	      this.state.modeGen++;
	      regChange(this);
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var overlays = this.state.overlays;
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec;
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1);
	          this.state.modeGen++;
	          regChange(this);
	          return;
	        }
	      }
	    }),

	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
	        else dir = dir ? "add" : "subtract";
	      }
	      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
	    }),
	    indentSelection: methodOp(function(how) {
	      var ranges = this.doc.sel.ranges, end = -1;
	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i];
	        if (!range.empty()) {
	          var from = range.from(), to = range.to();
	          var start = Math.max(end, from.line);
	          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	          for (var j = start; j < end; ++j)
	            indentLine(this, j, how);
	          var newRanges = this.doc.sel.ranges;
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
	        } else if (range.head.line > end) {
	          indentLine(this, range.head.line, how, true);
	          end = range.head.line;
	          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
	        }
	      }
	    }),

	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise);
	    },

	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true);
	    },

	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos);
	      var styles = getLineStyles(this, getLine(this.doc, pos.line));
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	      var type;
	      if (ch == 0) type = styles[2];
	      else for (;;) {
	        var mid = (before + after) >> 1;
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
	        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
	        else { type = styles[mid * 2 + 2]; break; }
	      }
	      var cut = type ? type.indexOf("cm-overlay ") : -1;
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
	    },

	    getModeAt: function(pos) {
	      var mode = this.doc.mode;
	      if (!mode.innerMode) return mode;
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
	    },

	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0];
	    },

	    getHelpers: function(pos, type) {
	      var found = [];
	      if (!helpers.hasOwnProperty(type)) return found;
	      var help = helpers[type], mode = this.getModeAt(pos);
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) found.push(help[mode[type]]);
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]];
	          if (val) found.push(val);
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType]);
	      } else if (help[mode.name]) {
	        found.push(help[mode.name]);
	      }
	      for (var i = 0; i < help._global.length; i++) {
	        var cur = help._global[i];
	        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
	          found.push(cur.val);
	      }
	      return found;
	    },

	    getStateAfter: function(line, precise) {
	      var doc = this.doc;
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	      return getStateBefore(this, line + 1, precise);
	    },

	    cursorCoords: function(start, mode) {
	      var pos, range = this.doc.sel.primary();
	      if (start == null) pos = range.head;
	      else if (typeof start == "object") pos = clipPos(this.doc, start);
	      else pos = start ? range.from() : range.to();
	      return cursorCoords(this, pos, mode || "page");
	    },

	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page");
	    },

	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page");
	      return coordsChar(this, coords.left, coords.top);
	    },

	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	      return lineAtHeight(this.doc, height + this.display.viewOffset);
	    },
	    heightAtLine: function(line, mode) {
	      var end = false, lineObj;
	      if (typeof line == "number") {
	        var last = this.doc.first + this.doc.size - 1;
	        if (line < this.doc.first) line = this.doc.first;
	        else if (line > last) { line = last; end = true; }
	        lineObj = getLine(this.doc, line);
	      } else {
	        lineObj = line;
	      }
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0);
	    },

	    defaultTextHeight: function() { return textHeight(this.display); },
	    defaultCharWidth: function() { return charWidth(this.display); },

	    setGutterMarker: methodOp(function(line, gutterID, value) {
	      return changeLine(this.doc, line, "gutter", function(line) {
	        var markers = line.gutterMarkers || (line.gutterMarkers = {});
	        markers[gutterID] = value;
	        if (!value && isEmpty(markers)) line.gutterMarkers = null;
	        return true;
	      });
	    }),

	    clearGutter: methodOp(function(gutterID) {
	      var cm = this, doc = cm.doc, i = doc.first;
	      doc.iter(function(line) {
	        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	          line.gutterMarkers[gutterID] = null;
	          regLineChange(cm, i, "gutter");
	          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
	        }
	        ++i;
	      });
	    }),

	    lineInfo: function(line) {
	      if (typeof line == "number") {
	        if (!isLine(this.doc, line)) return null;
	        var n = line;
	        line = getLine(this.doc, line);
	        if (!line) return null;
	      } else {
	        var n = lineNo(line);
	        if (n == null) return null;
	      }
	      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	              widgets: line.widgets};
	    },

	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display;
	      pos = cursorCoords(this, clipPos(this.doc, pos));
	      var top = pos.bottom, left = pos.left;
	      node.style.position = "absolute";
	      node.setAttribute("cm-ignore-events", "true");
	      this.display.input.setUneditable(node);
	      display.sizer.appendChild(node);
	      if (vert == "over") {
	        top = pos.top;
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          top = pos.top - node.offsetHeight;
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          top = pos.bottom;
	        if (left + node.offsetWidth > hspace)
	          left = hspace - node.offsetWidth;
	      }
	      node.style.top = top + "px";
	      node.style.left = node.style.right = "";
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth;
	        node.style.right = "0px";
	      } else {
	        if (horiz == "left") left = 0;
	        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
	        node.style.left = left + "px";
	      }
	      if (scroll)
	        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
	    },

	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,

	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        return commands[cmd].call(null, this);
	    },

	    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

	    findPosH: function(from, amount, unit, visually) {
	      var dir = 1;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
	        cur = findPosH(this.doc, cur, dir, unit, visually);
	        if (cur.hitSide) break;
	      }
	      return cur;
	    },

	    moveH: methodOp(function(dir, unit) {
	      var cm = this;
	      cm.extendSelectionsBy(function(range) {
	        if (cm.display.shift || cm.doc.extend || range.empty())
	          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
	        else
	          return dir < 0 ? range.from() : range.to();
	      }, sel_move);
	    }),

	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc;
	      if (sel.somethingSelected())
	        doc.replaceSelection("", null, "+delete");
	      else
	        deleteNearSelection(this, function(range) {
	          var other = findPosH(doc, range.head, dir, unit, false);
	          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
	        });
	    }),

	    findPosV: function(from, amount, unit, goalColumn) {
	      var dir = 1, x = goalColumn;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
	        var coords = cursorCoords(this, cur, "div");
	        if (x == null) x = coords.left;
	        else coords.left = x;
	        cur = findPosV(this, coords, dir, unit);
	        if (cur.hitSide) break;
	      }
	      return cur;
	    },

	    moveV: methodOp(function(dir, unit) {
	      var cm = this, doc = this.doc, goals = [];
	      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
	      doc.extendSelectionsBy(function(range) {
	        if (collapse)
	          return dir < 0 ? range.from() : range.to();
	        var headPos = cursorCoords(cm, range.head, "div");
	        if (range.goalColumn != null) headPos.left = range.goalColumn;
	        goals.push(headPos.left);
	        var pos = findPosV(cm, headPos, dir, unit);
	        if (unit == "page" && range == doc.sel.primary())
	          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
	        return pos;
	      }, sel_move);
	      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
	        doc.sel.ranges[i].goalColumn = goals[i];
	    }),

	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text;
	      var start = pos.ch, end = pos.ch;
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars");
	        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
	        var startChar = line.charAt(start);
	        var check = isWordChar(startChar, helper)
	          ? function(ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
	          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
	        while (start > 0 && check(line.charAt(start - 1))) --start;
	        while (end < line.length && check(line.charAt(end))) ++end;
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end));
	    },

	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) return;
	      if (this.state.overwrite = !this.state.overwrite)
	        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
	      else
	        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

	      signal(this, "overwriteToggle", this, this.state.overwrite);
	    },
	    hasFocus: function() { return this.display.input.getField() == activeElt(); },
	    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },

	    scrollTo: methodOp(function(x, y) {
	      if (x != null || y != null) resolveScrollToPos(this);
	      if (x != null) this.curOp.scrollLeft = x;
	      if (y != null) this.curOp.scrollTop = y;
	    }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller;
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
	    },

	    scrollIntoView: methodOp(function(range, margin) {
	      if (range == null) {
	        range = {from: this.doc.sel.primary().head, to: null};
	        if (margin == null) margin = this.options.cursorScrollMargin;
	      } else if (typeof range == "number") {
	        range = {from: Pos(range, 0), to: null};
	      } else if (range.from == null) {
	        range = {from: range, to: null};
	      }
	      if (!range.to) range.to = range.from;
	      range.margin = margin || 0;

	      if (range.from.line != null) {
	        resolveScrollToPos(this);
	        this.curOp.scrollToPos = range;
	      } else {
	        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
	                                      Math.min(range.from.top, range.to.top) - range.margin,
	                                      Math.max(range.from.right, range.to.right),
	                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
	        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	      }
	    }),

	    setSize: methodOp(function(width, height) {
	      var cm = this;
	      function interpret(val) {
	        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
	      }
	      if (width != null) cm.display.wrapper.style.width = interpret(width);
	      if (height != null) cm.display.wrapper.style.height = interpret(height);
	      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
	      var lineNo = cm.display.viewFrom;
	      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
	        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
	          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
	        ++lineNo;
	      });
	      cm.curOp.forceUpdate = true;
	      signal(cm, "refresh", this);
	    }),

	    operation: function(f){return runInOp(this, f);},

	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight;
	      regChange(this);
	      this.curOp.forceUpdate = true;
	      clearCaches(this);
	      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
	      updateGutterSpace(this);
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        estimateLineHeights(this);
	      signal(this, "refresh", this);
	    }),

	    swapDoc: methodOp(function(doc) {
	      var old = this.doc;
	      old.cm = null;
	      attachDoc(this, doc);
	      clearCaches(this);
	      this.display.input.reset();
	      this.scrollTo(doc.scrollLeft, doc.scrollTop);
	      this.curOp.forceScroll = true;
	      signalLater(this, "swapDoc", this, old);
	      return old;
	    }),

	    getInputField: function(){return this.display.input.getField();},
	    getWrapperElement: function(){return this.display.wrapper;},
	    getScrollerElement: function(){return this.display.scroller;},
	    getGutterElement: function(){return this.display.gutters;}
	  };
	  eventMixin(CodeMirror);

	  // OPTION DEFAULTS

	  // The default configuration options.
	  var defaults = CodeMirror.defaults = {};
	  // Functions to run when options are changed.
	  var optionHandlers = CodeMirror.optionHandlers = {};

	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt;
	    if (handle) optionHandlers[name] =
	      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
	  }

	  // Passed to option handlers when there is no old value.
	  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function(cm, val) {
	    cm.setValue(val);
	  }, true);
	  option("mode", null, function(cm, val) {
	    cm.doc.modeOption = val;
	    loadMode(cm);
	  }, true);

	  option("indentUnit", 2, loadMode, true);
	  option("indentWithTabs", false);
	  option("smartIndent", true);
	  option("tabSize", 4, function(cm) {
	    resetModeState(cm);
	    clearCaches(cm);
	    regChange(cm);
	  }, true);
	  option("lineSeparator", null, function(cm, val) {
	    cm.doc.lineSep = val;
	    if (!val) return;
	    var newBreaks = [], lineNo = cm.doc.first;
	    cm.doc.iter(function(line) {
	      for (var pos = 0;;) {
	        var found = line.text.indexOf(val, pos);
	        if (found == -1) break;
	        pos = found + val.length;
	        newBreaks.push(Pos(lineNo, found));
	      }
	      lineNo++;
	    });
	    for (var i = newBreaks.length - 1; i >= 0; i--)
	      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
	  });
	  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
	    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	    if (old != CodeMirror.Init) cm.refresh();
	  });
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
	  option("electricChars", true);
	  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
	    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
	  }, true);
	  option("spellcheck", false, function(cm, val) {
	    cm.getInputField().spellcheck = val
	  }, true);
	  option("rtlMoveVisually", !windows);
	  option("wholeLineUpdateBefore", true);

	  option("theme", "default", function(cm) {
	    themeChanged(cm);
	    guttersChanged(cm);
	  }, true);
	  option("keyMap", "default", function(cm, val, old) {
	    var next = getKeyMap(val);
	    var prev = old != CodeMirror.Init && getKeyMap(old);
	    if (prev && prev.detach) prev.detach(cm, next);
	    if (next.attach) next.attach(cm, prev || null);
	  });
	  option("extraKeys", null);

	  option("lineWrapping", false, wrappingChanged, true);
	  option("gutters", [], function(cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("fixedGutter", true, function(cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	    cm.refresh();
	  }, true);
	  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
	  option("scrollbarStyle", "native", function(cm) {
	    initScrollbars(cm);
	    updateScrollbars(cm);
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	  }, true);
	  option("lineNumbers", false, function(cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("firstLineNumber", 1, guttersChanged, true);
	  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
	  option("showCursorWhenSelecting", false, updateSelection, true);

	  option("resetSelectionOnContextMenu", true);
	  option("lineWiseCopyCut", true);

	  option("readOnly", false, function(cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm);
	      cm.display.input.blur();
	      cm.display.disabled = true;
	    } else {
	      cm.display.disabled = false;
	    }
	    cm.display.input.readOnlyChanged(val)
	  });
	  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
	  option("dragDrop", true, dragDropChanged);
	  option("allowDropFileTypes", null);

	  option("cursorBlinkRate", 530);
	  option("cursorScrollMargin", 0);
	  option("cursorHeight", 1, updateSelection, true);
	  option("singleCursorHeightPerLine", true, updateSelection, true);
	  option("workTime", 100);
	  option("workDelay", 100);
	  option("flattenSpans", true, resetModeState, true);
	  option("addModeClass", false, resetModeState, true);
	  option("pollInterval", 100);
	  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
	  option("historyEventDelay", 1250);
	  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
	  option("maxHighlightLength", 10000, resetModeState, true);
	  option("moveInputWithCursor", true, function(cm, val) {
	    if (!val) cm.display.input.resetPosition();
	  });

	  option("tabindex", null, function(cm, val) {
	    cm.display.input.getField().tabIndex = val || "";
	  });
	  option("autofocus", null);

	  // MODE DEFINITION AND QUERYING

	  // Known modes, by name and by MIME
	  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

	  // Extra arguments are stored as the mode's dependencies, which is
	  // used by (legacy) mechanisms like loadmode.js to automatically
	  // load a mode. (Preferred mechanism is the require/define calls.)
	  CodeMirror.defineMode = function(name, mode) {
	    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
	    if (arguments.length > 2)
	      mode.dependencies = Array.prototype.slice.call(arguments, 2);
	    modes[name] = mode;
	  };

	  CodeMirror.defineMIME = function(mime, spec) {
	    mimeModes[mime] = spec;
	  };

	  // Given a MIME type, a {name, ...options} config object, or a name
	  // string, return a mode config object.
	  CodeMirror.resolveMode = function(spec) {
	    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	      spec = mimeModes[spec];
	    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	      var found = mimeModes[spec.name];
	      if (typeof found == "string") found = {name: found};
	      spec = createObj(found, spec);
	      spec.name = found.name;
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	      return CodeMirror.resolveMode("application/xml");
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	      return CodeMirror.resolveMode("application/json");
	    }
	    if (typeof spec == "string") return {name: spec};
	    else return spec || {name: "null"};
	  };

	  // Given a mode spec (anything that resolveMode accepts), find and
	  // initialize an actual mode object.
	  CodeMirror.getMode = function(options, spec) {
	    var spec = CodeMirror.resolveMode(spec);
	    var mfactory = modes[spec.name];
	    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
	    var modeObj = mfactory(options, spec);
	    if (modeExtensions.hasOwnProperty(spec.name)) {
	      var exts = modeExtensions[spec.name];
	      for (var prop in exts) {
	        if (!exts.hasOwnProperty(prop)) continue;
	        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
	        modeObj[prop] = exts[prop];
	      }
	    }
	    modeObj.name = spec.name;
	    if (spec.helperType) modeObj.helperType = spec.helperType;
	    if (spec.modeProps) for (var prop in spec.modeProps)
	      modeObj[prop] = spec.modeProps[prop];

	    return modeObj;
	  };

	  // Minimal default mode.
	  CodeMirror.defineMode("null", function() {
	    return {token: function(stream) {stream.skipToEnd();}};
	  });
	  CodeMirror.defineMIME("text/plain", "null");

	  // This can be used to attach properties to mode objects from
	  // outside the actual mode definition.
	  var modeExtensions = CodeMirror.modeExtensions = {};
	  CodeMirror.extendMode = function(mode, properties) {
	    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	    copyObj(properties, exts);
	  };

	  // EXTENSIONS

	  CodeMirror.defineExtension = function(name, func) {
	    CodeMirror.prototype[name] = func;
	  };
	  CodeMirror.defineDocExtension = function(name, func) {
	    Doc.prototype[name] = func;
	  };
	  CodeMirror.defineOption = option;

	  var initHooks = [];
	  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

	  var helpers = CodeMirror.helpers = {};
	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
	    helpers[type][name] = value;
	  };
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value);
	    helpers[type]._global.push({pred: predicate, val: value});
	  };

	  // MODE STATE HANDLING

	  // Utility functions for working with state. Exported because nested
	  // modes need to do this for their inner modes.

	  var copyState = CodeMirror.copyState = function(mode, state) {
	    if (state === true) return state;
	    if (mode.copyState) return mode.copyState(state);
	    var nstate = {};
	    for (var n in state) {
	      var val = state[n];
	      if (val instanceof Array) val = val.concat([]);
	      nstate[n] = val;
	    }
	    return nstate;
	  };

	  var startState = CodeMirror.startState = function(mode, a1, a2) {
	    return mode.startState ? mode.startState(a1, a2) : true;
	  };

	  // Given a mode and a state (for that mode), find the inner mode and
	  // state at the position that the state refers to.
	  CodeMirror.innerMode = function(mode, state) {
	    while (mode.innerMode) {
	      var info = mode.innerMode(state);
	      if (!info || info.mode == mode) break;
	      state = info.state;
	      mode = info.mode;
	    }
	    return info || {mode: mode, state: state};
	  };

	  // STANDARD COMMANDS

	  // Commands are parameter-less actions that can be performed on an
	  // editor, mostly used for keybindings.
	  var commands = CodeMirror.commands = {
	    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
	    singleSelection: function(cm) {
	      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
	    },
	    killLine: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        if (range.empty()) {
	          var len = getLine(cm.doc, range.head.line).text.length;
	          if (range.head.ch == len && range.head.line < cm.lastLine())
	            return {from: range.head, to: Pos(range.head.line + 1, 0)};
	          else
	            return {from: range.head, to: Pos(range.head.line, len)};
	        } else {
	          return {from: range.from(), to: range.to()};
	        }
	      });
	    },
	    deleteLine: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        return {from: Pos(range.from().line, 0),
	                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
	      });
	    },
	    delLineLeft: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        return {from: Pos(range.from().line, 0), to: range.from()};
	      });
	    },
	    delWrappedLineLeft: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	        return {from: leftPos, to: range.from()};
	      });
	    },
	    delWrappedLineRight: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	        return {from: range.from(), to: rightPos };
	      });
	    },
	    undo: function(cm) {cm.undo();},
	    redo: function(cm) {cm.redo();},
	    undoSelection: function(cm) {cm.undoSelection();},
	    redoSelection: function(cm) {cm.redoSelection();},
	    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
	    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
	    goLineStart: function(cm) {
	      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
	                            {origin: "+move", bias: 1});
	    },
	    goLineStartSmart: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        return lineStartSmart(cm, range.head);
	      }, {origin: "+move", bias: 1});
	    },
	    goLineEnd: function(cm) {
	      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
	                            {origin: "+move", bias: -1});
	    },
	    goLineRight: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	      }, sel_move);
	    },
	    goLineLeft: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        return cm.coordsChar({left: 0, top: top}, "div");
	      }, sel_move);
	    },
	    goLineLeftSmart: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var pos = cm.coordsChar({left: 0, top: top}, "div");
	        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
	        return pos;
	      }, sel_move);
	    },
	    goLineUp: function(cm) {cm.moveV(-1, "line");},
	    goLineDown: function(cm) {cm.moveV(1, "line");},
	    goPageUp: function(cm) {cm.moveV(-1, "page");},
	    goPageDown: function(cm) {cm.moveV(1, "page");},
	    goCharLeft: function(cm) {cm.moveH(-1, "char");},
	    goCharRight: function(cm) {cm.moveH(1, "char");},
	    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
	    goColumnRight: function(cm) {cm.moveH(1, "column");},
	    goWordLeft: function(cm) {cm.moveH(-1, "word");},
	    goGroupRight: function(cm) {cm.moveH(1, "group");},
	    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
	    goWordRight: function(cm) {cm.moveH(1, "word");},
	    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
	    delCharAfter: function(cm) {cm.deleteH(1, "char");},
	    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
	    delWordAfter: function(cm) {cm.deleteH(1, "word");},
	    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
	    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
	    indentAuto: function(cm) {cm.indentSelection("smart");},
	    indentMore: function(cm) {cm.indentSelection("add");},
	    indentLess: function(cm) {cm.indentSelection("subtract");},
	    insertTab: function(cm) {cm.replaceSelection("\t");},
	    insertSoftTab: function(cm) {
	      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	      for (var i = 0; i < ranges.length; i++) {
	        var pos = ranges[i].from();
	        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	        spaces.push(spaceStr(tabSize - col % tabSize));
	      }
	      cm.replaceSelections(spaces);
	    },
	    defaultTab: function(cm) {
	      if (cm.somethingSelected()) cm.indentSelection("add");
	      else cm.execCommand("insertTab");
	    },
	    transposeChars: function(cm) {
	      runInOp(cm, function() {
	        var ranges = cm.listSelections(), newSel = [];
	        for (var i = 0; i < ranges.length; i++) {
	          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	          if (line) {
	            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
	            if (cur.ch > 0) {
	              cur = new Pos(cur.line, cur.ch + 1);
	              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
	            } else if (cur.line > cm.doc.first) {
	              var prev = getLine(cm.doc, cur.line - 1).text;
	              if (prev)
	                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                                prev.charAt(prev.length - 1),
	                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
	            }
	          }
	          newSel.push(new Range(cur, cur));
	        }
	        cm.setSelections(newSel);
	      });
	    },
	    newlineAndIndent: function(cm) {
	      runInOp(cm, function() {
	        var len = cm.listSelections().length;
	        for (var i = 0; i < len; i++) {
	          var range = cm.listSelections()[i];
	          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
	          cm.indentLine(range.from().line + 1, null, true);
	        }
	        ensureCursorVisible(cm);
	      });
	    },
	    openLine: function(cm) {cm.replaceSelection("\n", "start")},
	    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
	  };


	  // STANDARD KEYMAPS

	  var keyMap = CodeMirror.keyMap = {};

	  keyMap.basic = {
	    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	    "Esc": "singleSelection"
	  };
	  // Note that the save and find-related commands aren't defined by
	  // default. User code or addons can define them. Unknown commands
	  // are simply ignored.
	  keyMap.pcDefault = {
	    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	    fallthrough: "basic"
	  };
	  // Very basic readline/emacs-style bindings, which are standard on Mac.
	  keyMap.emacsy = {
	    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	    "Ctrl-O": "openLine"
	  };
	  keyMap.macDefault = {
	    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	    fallthrough: ["basic", "emacsy"]
	  };
	  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

	  // KEYMAP DISPATCH

	  function normalizeKeyName(name) {
	    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
	    var alt, ctrl, shift, cmd;
	    for (var i = 0; i < parts.length - 1; i++) {
	      var mod = parts[i];
	      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
	      else if (/^a(lt)?$/i.test(mod)) alt = true;
	      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
	      else if (/^s(hift)$/i.test(mod)) shift = true;
	      else throw new Error("Unrecognized modifier name: " + mod);
	    }
	    if (alt) name = "Alt-" + name;
	    if (ctrl) name = "Ctrl-" + name;
	    if (cmd) name = "Cmd-" + name;
	    if (shift) name = "Shift-" + name;
	    return name;
	  }

	  // This is a kludge to keep keymaps mostly working as raw objects
	  // (backwards compatibility) while at the same time support features
	  // like normalization and multi-stroke key bindings. It compiles a
	  // new normalized keymap, and then updates the old object to reflect
	  // this.
	  CodeMirror.normalizeKeyMap = function(keymap) {
	    var copy = {};
	    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
	      var value = keymap[keyname];
	      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
	      if (value == "...") { delete keymap[keyname]; continue; }

	      var keys = map(keyname.split(" "), normalizeKeyName);
	      for (var i = 0; i < keys.length; i++) {
	        var val, name;
	        if (i == keys.length - 1) {
	          name = keys.join(" ");
	          val = value;
	        } else {
	          name = keys.slice(0, i + 1).join(" ");
	          val = "...";
	        }
	        var prev = copy[name];
	        if (!prev) copy[name] = val;
	        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
	      }
	      delete keymap[keyname];
	    }
	    for (var prop in copy) keymap[prop] = copy[prop];
	    return keymap;
	  };

	  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
	    map = getKeyMap(map);
	    var found = map.call ? map.call(key, context) : map[key];
	    if (found === false) return "nothing";
	    if (found === "...") return "multi";
	    if (found != null && handle(found)) return "handled";

	    if (map.fallthrough) {
	      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
	        return lookupKey(key, map.fallthrough, handle, context);
	      for (var i = 0; i < map.fallthrough.length; i++) {
	        var result = lookupKey(key, map.fallthrough[i], handle, context);
	        if (result) return result;
	      }
	    }
	  };

	  // Modifier key presses don't count as 'real' key presses for the
	  // purpose of keymap fallthrough.
	  var isModifierKey = CodeMirror.isModifierKey = function(value) {
	    var name = typeof value == "string" ? value : keyNames[value.keyCode];
	    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
	  };

	  // Look up the name of a key as indicated by an event object.
	  var keyName = CodeMirror.keyName = function(event, noShift) {
	    if (presto && event.keyCode == 34 && event["char"]) return false;
	    var base = keyNames[event.keyCode], name = base;
	    if (name == null || event.altGraphKey) return false;
	    if (event.altKey && base != "Alt") name = "Alt-" + name;
	    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
	    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
	    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
	    return name;
	  };

	  function getKeyMap(val) {
	    return typeof val == "string" ? keyMap[val] : val;
	  }

	  // FROMTEXTAREA

	  CodeMirror.fromTextArea = function(textarea, options) {
	    options = options ? copyObj(options) : {};
	    options.value = textarea.value;
	    if (!options.tabindex && textarea.tabIndex)
	      options.tabindex = textarea.tabIndex;
	    if (!options.placeholder && textarea.placeholder)
	      options.placeholder = textarea.placeholder;
	    // Set autofocus to true if this textarea is focused, or if it has
	    // autofocus and no other element is focused.
	    if (options.autofocus == null) {
	      var hasFocus = activeElt();
	      options.autofocus = hasFocus == textarea ||
	        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	    }

	    function save() {textarea.value = cm.getValue();}
	    if (textarea.form) {
	      on(textarea.form, "submit", save);
	      // Deplorable hack to make the submit method do the right thing.
	      if (!options.leaveSubmitMethodAlone) {
	        var form = textarea.form, realSubmit = form.submit;
	        try {
	          var wrappedSubmit = form.submit = function() {
	            save();
	            form.submit = realSubmit;
	            form.submit();
	            form.submit = wrappedSubmit;
	          };
	        } catch(e) {}
	      }
	    }

	    options.finishInit = function(cm) {
	      cm.save = save;
	      cm.getTextArea = function() { return textarea; };
	      cm.toTextArea = function() {
	        cm.toTextArea = isNaN; // Prevent this from being ran twice
	        save();
	        textarea.parentNode.removeChild(cm.getWrapperElement());
	        textarea.style.display = "";
	        if (textarea.form) {
	          off(textarea.form, "submit", save);
	          if (typeof textarea.form.submit == "function")
	            textarea.form.submit = realSubmit;
	        }
	      };
	    };

	    textarea.style.display = "none";
	    var cm = CodeMirror(function(node) {
	      textarea.parentNode.insertBefore(node, textarea.nextSibling);
	    }, options);
	    return cm;
	  };

	  // STRING STREAM

	  // Fed to the mode parsers, provides helper functions to make
	  // parsers more succinct.

	  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
	    this.pos = this.start = 0;
	    this.string = string;
	    this.tabSize = tabSize || 8;
	    this.lastColumnPos = this.lastColumnValue = 0;
	    this.lineStart = 0;
	  };

	  StringStream.prototype = {
	    eol: function() {return this.pos >= this.string.length;},
	    sol: function() {return this.pos == this.lineStart;},
	    peek: function() {return this.string.charAt(this.pos) || undefined;},
	    next: function() {
	      if (this.pos < this.string.length)
	        return this.string.charAt(this.pos++);
	    },
	    eat: function(match) {
	      var ch = this.string.charAt(this.pos);
	      if (typeof match == "string") var ok = ch == match;
	      else var ok = ch && (match.test ? match.test(ch) : match(ch));
	      if (ok) {++this.pos; return ch;}
	    },
	    eatWhile: function(match) {
	      var start = this.pos;
	      while (this.eat(match)){}
	      return this.pos > start;
	    },
	    eatSpace: function() {
	      var start = this.pos;
	      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
	      return this.pos > start;
	    },
	    skipToEnd: function() {this.pos = this.string.length;},
	    skipTo: function(ch) {
	      var found = this.string.indexOf(ch, this.pos);
	      if (found > -1) {this.pos = found; return true;}
	    },
	    backUp: function(n) {this.pos -= n;},
	    column: function() {
	      if (this.lastColumnPos < this.start) {
	        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	        this.lastColumnPos = this.start;
	      }
	      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    },
	    indentation: function() {
	      return countColumn(this.string, null, this.tabSize) -
	        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    },
	    match: function(pattern, consume, caseInsensitive) {
	      if (typeof pattern == "string") {
	        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
	        var substr = this.string.substr(this.pos, pattern.length);
	        if (cased(substr) == cased(pattern)) {
	          if (consume !== false) this.pos += pattern.length;
	          return true;
	        }
	      } else {
	        var match = this.string.slice(this.pos).match(pattern);
	        if (match && match.index > 0) return null;
	        if (match && consume !== false) this.pos += match[0].length;
	        return match;
	      }
	    },
	    current: function(){return this.string.slice(this.start, this.pos);},
	    hideFirstChars: function(n, inner) {
	      this.lineStart += n;
	      try { return inner(); }
	      finally { this.lineStart -= n; }
	    }
	  };

	  // TEXTMARKERS

	  // Created with markText and setBookmark methods. A TextMarker is a
	  // handle that can be used to clear or find a marked position in the
	  // document. Line objects hold arrays (markedSpans) containing
	  // {from, to, marker} object pointing to such marker objects, and
	  // indicating that such a marker is present on that line. Multiple
	  // lines may point to the same marker when it spans across lines.
	  // The spans will have null for their from/to properties when the
	  // marker continues beyond the start/end of the line. Markers have
	  // links back to the lines they currently touch.

	  var nextMarkerId = 0;

	  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
	    this.lines = [];
	    this.type = type;
	    this.doc = doc;
	    this.id = ++nextMarkerId;
	  };
	  eventMixin(TextMarker);

	  // Clear the marker.
	  TextMarker.prototype.clear = function() {
	    if (this.explicitlyCleared) return;
	    var cm = this.doc.cm, withOp = cm && !cm.curOp;
	    if (withOp) startOperation(cm);
	    if (hasHandler(this, "clear")) {
	      var found = this.find();
	      if (found) signalLater(this, "clear", found.from, found.to);
	    }
	    var min = null, max = null;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
	      else if (cm) {
	        if (span.to != null) max = lineNo(line);
	        if (span.from != null) min = lineNo(line);
	      }
	      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
	        updateLineHeight(line, textHeight(cm.display));
	    }
	    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
	      var visual = visualLine(this.lines[i]), len = lineLength(visual);
	      if (len > cm.display.maxLineLength) {
	        cm.display.maxLine = visual;
	        cm.display.maxLineLength = len;
	        cm.display.maxLineChanged = true;
	      }
	    }

	    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
	    this.lines.length = 0;
	    this.explicitlyCleared = true;
	    if (this.atomic && this.doc.cantEdit) {
	      this.doc.cantEdit = false;
	      if (cm) reCheckSelection(cm.doc);
	    }
	    if (cm) signalLater(cm, "markerCleared", cm, this);
	    if (withOp) endOperation(cm);
	    if (this.parent) this.parent.clear();
	  };

	  // Find the position of the marker in the document. Returns a {from,
	  // to} object by default. Side can be passed to get a specific side
	  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	  // Pos objects returned contain a line object, rather than a line
	  // number (used to prevent looking up the same line twice).
	  TextMarker.prototype.find = function(side, lineObj) {
	    if (side == null && this.type == "bookmark") side = 1;
	    var from, to;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (span.from != null) {
	        from = Pos(lineObj ? line : lineNo(line), span.from);
	        if (side == -1) return from;
	      }
	      if (span.to != null) {
	        to = Pos(lineObj ? line : lineNo(line), span.to);
	        if (side == 1) return to;
	      }
	    }
	    return from && {from: from, to: to};
	  };

	  // Signals that the marker's widget changed, and surrounding layout
	  // should be recomputed.
	  TextMarker.prototype.changed = function() {
	    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	    if (!pos || !cm) return;
	    runInOp(cm, function() {
	      var line = pos.line, lineN = lineNo(pos.line);
	      var view = findViewForLine(cm, lineN);
	      if (view) {
	        clearLineMeasurementCacheFor(view);
	        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	      }
	      cm.curOp.updateMaxLine = true;
	      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	        var oldHeight = widget.height;
	        widget.height = null;
	        var dHeight = widgetHeight(widget) - oldHeight;
	        if (dHeight)
	          updateLineHeight(line, line.height + dHeight);
	      }
	    });
	  };

	  TextMarker.prototype.attachLine = function(line) {
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
	    }
	    this.lines.push(line);
	  };
	  TextMarker.prototype.detachLine = function(line) {
	    this.lines.splice(indexOf(this.lines, line), 1);
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	    }
	  };

	  // Collapsed markers have unique ids, in order to be able to order
	  // them, which is needed for uniquely determining an outer marker
	  // when they overlap (they may nest, but not partially overlap).
	  var nextMarkerId = 0;

	  // Create a marker, wire it up to the right lines, and
	  function markText(doc, from, to, options, type) {
	    // Shared markers (across linked documents) are handled separately
	    // (markTextShared will call out to this again, once per
	    // document).
	    if (options && options.shared) return markTextShared(doc, from, to, options, type);
	    // Ensure we are in an operation.
	    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

	    var marker = new TextMarker(doc, type), diff = cmp(from, to);
	    if (options) copyObj(options, marker, false);
	    // Don't connect empty markers unless clearWhenEmpty is false
	    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	      return marker;
	    if (marker.replacedWith) {
	      // Showing up as a widget implies collapsed (widget replaces text)
	      marker.collapsed = true;
	      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
	      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
	      if (options.insertLeft) marker.widgetNode.insertLeft = true;
	    }
	    if (marker.collapsed) {
	      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	        throw new Error("Inserting collapsed marker partially overlapping an existing one");
	      sawCollapsedSpans = true;
	    }

	    if (marker.addToHistory)
	      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

	    var curLine = from.line, cm = doc.cm, updateMaxLine;
	    doc.iter(curLine, to.line + 1, function(line) {
	      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	        updateMaxLine = true;
	      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
	      addMarkedSpan(line, new MarkedSpan(marker,
	                                         curLine == from.line ? from.ch : null,
	                                         curLine == to.line ? to.ch : null));
	      ++curLine;
	    });
	    // lineIsHidden depends on the presence of the spans, so needs a second pass
	    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
	      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
	    });

	    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

	    if (marker.readOnly) {
	      sawReadOnlySpans = true;
	      if (doc.history.done.length || doc.history.undone.length)
	        doc.clearHistory();
	    }
	    if (marker.collapsed) {
	      marker.id = ++nextMarkerId;
	      marker.atomic = true;
	    }
	    if (cm) {
	      // Sync editor state
	      if (updateMaxLine) cm.curOp.updateMaxLine = true;
	      if (marker.collapsed)
	        regChange(cm, from.line, to.line + 1);
	      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
	      if (marker.atomic) reCheckSelection(cm.doc);
	      signalLater(cm, "markerAdded", cm, marker);
	    }
	    return marker;
	  }

	  // SHARED TEXTMARKERS

	  // A shared marker spans multiple linked documents. It is
	  // implemented as a meta-marker-object controlling multiple normal
	  // markers.
	  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
	    this.markers = markers;
	    this.primary = primary;
	    for (var i = 0; i < markers.length; ++i)
	      markers[i].parent = this;
	  };
	  eventMixin(SharedTextMarker);

	  SharedTextMarker.prototype.clear = function() {
	    if (this.explicitlyCleared) return;
	    this.explicitlyCleared = true;
	    for (var i = 0; i < this.markers.length; ++i)
	      this.markers[i].clear();
	    signalLater(this, "clear");
	  };
	  SharedTextMarker.prototype.find = function(side, lineObj) {
	    return this.primary.find(side, lineObj);
	  };

	  function markTextShared(doc, from, to, options, type) {
	    options = copyObj(options);
	    options.shared = false;
	    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	    var widget = options.widgetNode;
	    linkedDocs(doc, function(doc) {
	      if (widget) options.widgetNode = widget.cloneNode(true);
	      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	      for (var i = 0; i < doc.linked.length; ++i)
	        if (doc.linked[i].isParent) return;
	      primary = lst(markers);
	    });
	    return new SharedTextMarker(markers, primary);
	  }

	  function findSharedMarkers(doc) {
	    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
	                         function(m) { return m.parent; });
	  }

	  function copySharedMarkers(doc, markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], pos = marker.find();
	      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	      if (cmp(mFrom, mTo)) {
	        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	        marker.markers.push(subMark);
	        subMark.parent = marker;
	      }
	    }
	  }

	  function detachSharedMarkers(markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], linked = [marker.primary.doc];;
	      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
	      for (var j = 0; j < marker.markers.length; j++) {
	        var subMarker = marker.markers[j];
	        if (indexOf(linked, subMarker.doc) == -1) {
	          subMarker.parent = null;
	          marker.markers.splice(j--, 1);
	        }
	      }
	    }
	  }

	  // TEXTMARKER SPANS

	  function MarkedSpan(marker, from, to) {
	    this.marker = marker;
	    this.from = from; this.to = to;
	  }

	  // Search an array of spans for a span matching the given marker.
	  function getMarkedSpanFor(spans, marker) {
	    if (spans) for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.marker == marker) return span;
	    }
	  }
	  // Remove a span from an array, returning undefined if no spans are
	  // left (we don't store arrays for lines without spans).
	  function removeMarkedSpan(spans, span) {
	    for (var r, i = 0; i < spans.length; ++i)
	      if (spans[i] != span) (r || (r = [])).push(spans[i]);
	    return r;
	  }
	  // Add a span to a line.
	  function addMarkedSpan(line, span) {
	    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	    span.marker.attachLine(line);
	  }

	  // Used for the algorithm that adjusts markers for a change in the
	  // document. These functions cut an array of spans at a given
	  // character position, returning an array of remaining chunks (or
	  // undefined if nothing remains).
	  function markedSpansBefore(old, startCh, isInsert) {
	    if (old) for (var i = 0, nw; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
	        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	      }
	    }
	    return nw;
	  }
	  function markedSpansAfter(old, endCh, isInsert) {
	    if (old) for (var i = 0, nw; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
	        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                              span.to == null ? null : span.to - endCh));
	      }
	    }
	    return nw;
	  }

	  // Given a change object, compute the new set of marker spans that
	  // cover the line in which the change took place. Removes spans
	  // entirely within the change, reconnects spans belonging to the
	  // same marker that appear on both sides of the change, and cuts off
	  // spans partially within the change. Returns an array of span
	  // arrays with one element for each line in (after) the change.
	  function stretchSpansOverChange(doc, change) {
	    if (change.full) return null;
	    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	    if (!oldFirst && !oldLast) return null;

	    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	    // Get the spans that 'stick out' on both sides
	    var first = markedSpansBefore(oldFirst, startCh, isInsert);
	    var last = markedSpansAfter(oldLast, endCh, isInsert);

	    // Next, merge those two ends
	    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	    if (first) {
	      // Fix up .to properties of first
	      for (var i = 0; i < first.length; ++i) {
	        var span = first[i];
	        if (span.to == null) {
	          var found = getMarkedSpanFor(last, span.marker);
	          if (!found) span.to = startCh;
	          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
	        }
	      }
	    }
	    if (last) {
	      // Fix up .from in last (or move them into first in case of sameLine)
	      for (var i = 0; i < last.length; ++i) {
	        var span = last[i];
	        if (span.to != null) span.to += offset;
	        if (span.from == null) {
	          var found = getMarkedSpanFor(first, span.marker);
	          if (!found) {
	            span.from = offset;
	            if (sameLine) (first || (first = [])).push(span);
	          }
	        } else {
	          span.from += offset;
	          if (sameLine) (first || (first = [])).push(span);
	        }
	      }
	    }
	    // Make sure we didn't create any zero-length spans
	    if (first) first = clearEmptySpans(first);
	    if (last && last != first) last = clearEmptySpans(last);

	    var newMarkers = [first];
	    if (!sameLine) {
	      // Fill gap with whole-line-spans
	      var gap = change.text.length - 2, gapMarkers;
	      if (gap > 0 && first)
	        for (var i = 0; i < first.length; ++i)
	          if (first[i].to == null)
	            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
	      for (var i = 0; i < gap; ++i)
	        newMarkers.push(gapMarkers);
	      newMarkers.push(last);
	    }
	    return newMarkers;
	  }

	  // Remove spans that are empty and don't have a clearWhenEmpty
	  // option of false.
	  function clearEmptySpans(spans) {
	    for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	        spans.splice(i--, 1);
	    }
	    if (!spans.length) return null;
	    return spans;
	  }

	  // Used for un/re-doing changes from the history. Combines the
	  // result of computing the existing spans with the set of spans that
	  // existed in the history (so that deleting around a span and then
	  // undoing brings back the span).
	  function mergeOldSpans(doc, change) {
	    var old = getOldSpans(doc, change);
	    var stretched = stretchSpansOverChange(doc, change);
	    if (!old) return stretched;
	    if (!stretched) return old;

	    for (var i = 0; i < old.length; ++i) {
	      var oldCur = old[i], stretchCur = stretched[i];
	      if (oldCur && stretchCur) {
	        spans: for (var j = 0; j < stretchCur.length; ++j) {
	          var span = stretchCur[j];
	          for (var k = 0; k < oldCur.length; ++k)
	            if (oldCur[k].marker == span.marker) continue spans;
	          oldCur.push(span);
	        }
	      } else if (stretchCur) {
	        old[i] = stretchCur;
	      }
	    }
	    return old;
	  }

	  // Used to 'clip' out readOnly ranges when making a change.
	  function removeReadOnlyRanges(doc, from, to) {
	    var markers = null;
	    doc.iter(from.line, to.line + 1, function(line) {
	      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
	        var mark = line.markedSpans[i].marker;
	        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	          (markers || (markers = [])).push(mark);
	      }
	    });
	    if (!markers) return null;
	    var parts = [{from: from, to: to}];
	    for (var i = 0; i < markers.length; ++i) {
	      var mk = markers[i], m = mk.find(0);
	      for (var j = 0; j < parts.length; ++j) {
	        var p = parts[j];
	        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
	        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	          newParts.push({from: p.from, to: m.from});
	        if (dto > 0 || !mk.inclusiveRight && !dto)
	          newParts.push({from: m.to, to: p.to});
	        parts.splice.apply(parts, newParts);
	        j += newParts.length - 1;
	      }
	    }
	    return parts;
	  }

	  // Connect or disconnect spans from a line.
	  function detachMarkedSpans(line) {
	    var spans = line.markedSpans;
	    if (!spans) return;
	    for (var i = 0; i < spans.length; ++i)
	      spans[i].marker.detachLine(line);
	    line.markedSpans = null;
	  }
	  function attachMarkedSpans(line, spans) {
	    if (!spans) return;
	    for (var i = 0; i < spans.length; ++i)
	      spans[i].marker.attachLine(line);
	    line.markedSpans = spans;
	  }

	  // Helpers used when computing which overlapping collapsed span
	  // counts as the larger one.
	  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
	  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

	  // Returns a number indicating which of two overlapping collapsed
	  // spans is larger (and thus includes the other). Falls back to
	  // comparing ids when the spans cover exactly the same range.
	  function compareCollapsedMarkers(a, b) {
	    var lenDiff = a.lines.length - b.lines.length;
	    if (lenDiff != 0) return lenDiff;
	    var aPos = a.find(), bPos = b.find();
	    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	    if (fromCmp) return -fromCmp;
	    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	    if (toCmp) return toCmp;
	    return b.id - a.id;
	  }

	  // Find out whether a line ends or starts in a collapsed span. If
	  // so, return the marker for that span.
	  function collapsedSpanAtSide(line, start) {
	    var sps = sawCollapsedSpans && line.markedSpans, found;
	    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	        found = sp.marker;
	    }
	    return found;
	  }
	  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
	  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

	  // Test whether there exists a collapsed span that partially
	  // overlaps (covers the start or end, but not both) of a new span.
	  // Such overlap is not allowed.
	  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
	    var line = getLine(doc, lineNo);
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) for (var i = 0; i < sps.length; ++i) {
	      var sp = sps[i];
	      if (!sp.marker.collapsed) continue;
	      var found = sp.marker.find(0);
	      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
	      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	        return true;
	    }
	  }

	  // A visual line is a line as drawn on the screen. Folding, for
	  // example, can cause multiple logical lines to appear on the same
	  // visual line. This finds the start of the visual line that the
	  // given line is part of (usually that is the line itself).
	  function visualLine(line) {
	    var merged;
	    while (merged = collapsedSpanAtStart(line))
	      line = merged.find(-1, true).line;
	    return line;
	  }

	  // Returns an array of logical lines that continue the visual line
	  // started by the argument, or undefined if there are no such lines.
	  function visualLineContinued(line) {
	    var merged, lines;
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line;
	      (lines || (lines = [])).push(line);
	    }
	    return lines;
	  }

	  // Get the line number of the start of the visual line that the
	  // given line number is part of.
	  function visualLineNo(doc, lineN) {
	    var line = getLine(doc, lineN), vis = visualLine(line);
	    if (line == vis) return lineN;
	    return lineNo(vis);
	  }
	  // Get the line number of the start of the next visual line after
	  // the given line.
	  function visualLineEndNo(doc, lineN) {
	    if (lineN > doc.lastLine()) return lineN;
	    var line = getLine(doc, lineN), merged;
	    if (!lineIsHidden(doc, line)) return lineN;
	    while (merged = collapsedSpanAtEnd(line))
	      line = merged.find(1, true).line;
	    return lineNo(line) + 1;
	  }

	  // Compute whether a line is hidden. Lines count as hidden when they
	  // are part of a visual line that starts with another line, or when
	  // they are entirely covered by collapsed, non-widget span.
	  function lineIsHidden(doc, line) {
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (!sp.marker.collapsed) continue;
	      if (sp.from == null) return true;
	      if (sp.marker.widgetNode) continue;
	      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	        return true;
	    }
	  }
	  function lineIsHiddenInner(doc, line, span) {
	    if (span.to == null) {
	      var end = span.marker.find(1, true);
	      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
	    }
	    if (span.marker.inclusiveRight && span.to == line.text.length)
	      return true;
	    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
	      sp = line.markedSpans[i];
	      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	          (sp.to == null || sp.to != span.from) &&
	          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	          lineIsHiddenInner(doc, line, sp)) return true;
	    }
	  }

	  // LINE WIDGETS

	  // Line widgets are block elements displayed above or below a line.

	  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
	    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
	      this[opt] = options[opt];
	    this.doc = doc;
	    this.node = node;
	  };
	  eventMixin(LineWidget);

	  function adjustScrollWhenAboveVisible(cm, line, diff) {
	    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	      addToScrollPos(cm, null, diff);
	  }

	  LineWidget.prototype.clear = function() {
	    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	    if (no == null || !ws) return;
	    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
	    if (!ws.length) line.widgets = null;
	    var height = widgetHeight(this);
	    updateLineHeight(line, Math.max(0, line.height - height));
	    if (cm) runInOp(cm, function() {
	      adjustScrollWhenAboveVisible(cm, line, -height);
	      regLineChange(cm, no, "widget");
	    });
	  };
	  LineWidget.prototype.changed = function() {
	    var oldH = this.height, cm = this.doc.cm, line = this.line;
	    this.height = null;
	    var diff = widgetHeight(this) - oldH;
	    if (!diff) return;
	    updateLineHeight(line, line.height + diff);
	    if (cm) runInOp(cm, function() {
	      cm.curOp.forceUpdate = true;
	      adjustScrollWhenAboveVisible(cm, line, diff);
	    });
	  };

	  function widgetHeight(widget) {
	    if (widget.height != null) return widget.height;
	    var cm = widget.doc.cm;
	    if (!cm) return 0;
	    if (!contains(document.body, widget.node)) {
	      var parentStyle = "position: relative;";
	      if (widget.coverGutter)
	        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
	      if (widget.noHScroll)
	        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
	      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	    }
	    return widget.height = widget.node.parentNode.offsetHeight;
	  }

	  function addLineWidget(doc, handle, node, options) {
	    var widget = new LineWidget(doc, node, options);
	    var cm = doc.cm;
	    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
	    changeLine(doc, handle, "widget", function(line) {
	      var widgets = line.widgets || (line.widgets = []);
	      if (widget.insertAt == null) widgets.push(widget);
	      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
	      widget.line = line;
	      if (cm && !lineIsHidden(doc, line)) {
	        var aboveVisible = heightAtLine(line) < doc.scrollTop;
	        updateLineHeight(line, line.height + widgetHeight(widget));
	        if (aboveVisible) addToScrollPos(cm, null, widget.height);
	        cm.curOp.forceUpdate = true;
	      }
	      return true;
	    });
	    return widget;
	  }

	  // LINE DATA STRUCTURE

	  // Line objects. These hold state related to a line, including
	  // highlighting info (the styles array).
	  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
	    this.text = text;
	    attachMarkedSpans(this, markedSpans);
	    this.height = estimateHeight ? estimateHeight(this) : 1;
	  };
	  eventMixin(Line);
	  Line.prototype.lineNo = function() { return lineNo(this); };

	  // Change the content (text, markers) of a line. Automatically
	  // invalidates cached information and tries to re-estimate the
	  // line's height.
	  function updateLine(line, text, markedSpans, estimateHeight) {
	    line.text = text;
	    if (line.stateAfter) line.stateAfter = null;
	    if (line.styles) line.styles = null;
	    if (line.order != null) line.order = null;
	    detachMarkedSpans(line);
	    attachMarkedSpans(line, markedSpans);
	    var estHeight = estimateHeight ? estimateHeight(line) : 1;
	    if (estHeight != line.height) updateLineHeight(line, estHeight);
	  }

	  // Detach a line from the document tree and its markers.
	  function cleanUpLine(line) {
	    line.parent = null;
	    detachMarkedSpans(line);
	  }

	  function extractLineClasses(type, output) {
	    if (type) for (;;) {
	      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	      if (!lineClass) break;
	      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	      var prop = lineClass[1] ? "bgClass" : "textClass";
	      if (output[prop] == null)
	        output[prop] = lineClass[2];
	      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	        output[prop] += " " + lineClass[2];
	    }
	    return type;
	  }

	  function callBlankLine(mode, state) {
	    if (mode.blankLine) return mode.blankLine(state);
	    if (!mode.innerMode) return;
	    var inner = CodeMirror.innerMode(mode, state);
	    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
	  }

	  function readToken(mode, stream, state, inner) {
	    for (var i = 0; i < 10; i++) {
	      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
	      var style = mode.token(stream, state);
	      if (stream.pos > stream.start) return style;
	    }
	    throw new Error("Mode " + mode.name + " failed to advance stream.");
	  }

	  // Utility for getTokenAt and getLineTokens
	  function takeToken(cm, pos, precise, asArray) {
	    function getObj(copy) {
	      return {start: stream.start, end: stream.pos,
	              string: stream.current(),
	              type: style || null,
	              state: copy ? copyState(doc.mode, state) : state};
	    }

	    var doc = cm.doc, mode = doc.mode, style;
	    pos = clipPos(doc, pos);
	    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
	    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
	    if (asArray) tokens = [];
	    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	      stream.start = stream.pos;
	      style = readToken(mode, stream, state);
	      if (asArray) tokens.push(getObj(true));
	    }
	    return asArray ? tokens : getObj();
	  }

	  // Run the given mode's parser over a line, calling f for each token.
	  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
	    var flattenSpans = mode.flattenSpans;
	    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
	    var curStart = 0, curStyle = null;
	    var stream = new StringStream(text, cm.options.tabSize), style;
	    var inner = cm.options.addModeClass && [null];
	    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
	    while (!stream.eol()) {
	      if (stream.pos > cm.options.maxHighlightLength) {
	        flattenSpans = false;
	        if (forceToEnd) processLine(cm, text, state, stream.pos);
	        stream.pos = text.length;
	        style = null;
	      } else {
	        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
	      }
	      if (inner) {
	        var mName = inner[0].name;
	        if (mName) style = "m-" + (style ? mName + " " + style : mName);
	      }
	      if (!flattenSpans || curStyle != style) {
	        while (curStart < stream.start) {
	          curStart = Math.min(stream.start, curStart + 5000);
	          f(curStart, curStyle);
	        }
	        curStyle = style;
	      }
	      stream.start = stream.pos;
	    }
	    while (curStart < stream.pos) {
	      // Webkit seems to refuse to render text nodes longer than 57444
	      // characters, and returns inaccurate measurements in nodes
	      // starting around 5000 chars.
	      var pos = Math.min(stream.pos, curStart + 5000);
	      f(pos, curStyle);
	      curStart = pos;
	    }
	  }

	  // Compute a style array (an array starting with a mode generation
	  // -- for invalidation -- followed by pairs of end positions and
	  // style strings), which is used to highlight the tokens on the
	  // line.
	  function highlightLine(cm, line, state, forceToEnd) {
	    // A styles array always starts with a number identifying the
	    // mode/overlays that it is based on (for easy invalidation).
	    var st = [cm.state.modeGen], lineClasses = {};
	    // Compute the base array of styles
	    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
	      st.push(end, style);
	    }, lineClasses, forceToEnd);

	    // Run overlays, adjust style array.
	    for (var o = 0; o < cm.state.overlays.length; ++o) {
	      var overlay = cm.state.overlays[o], i = 1, at = 0;
	      runMode(cm, line.text, overlay.mode, true, function(end, style) {
	        var start = i;
	        // Ensure there's a token end at the current position, and that i points at it
	        while (at < end) {
	          var i_end = st[i];
	          if (i_end > end)
	            st.splice(i, 1, end, st[i+1], i_end);
	          i += 2;
	          at = Math.min(end, i_end);
	        }
	        if (!style) return;
	        if (overlay.opaque) {
	          st.splice(start, i - start, end, "cm-overlay " + style);
	          i = start + 2;
	        } else {
	          for (; start < i; start += 2) {
	            var cur = st[start+1];
	            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
	          }
	        }
	      }, lineClasses);
	    }

	    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
	  }

	  function getLineStyles(cm, line, updateFrontier) {
	    if (!line.styles || line.styles[0] != cm.state.modeGen) {
	      var state = getStateBefore(cm, lineNo(line));
	      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
	      line.stateAfter = state;
	      line.styles = result.styles;
	      if (result.classes) line.styleClasses = result.classes;
	      else if (line.styleClasses) line.styleClasses = null;
	      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
	    }
	    return line.styles;
	  }

	  // Lightweight form of highlight -- proceed over this line and
	  // update state, but don't save a style array. Used for lines that
	  // aren't currently visible.
	  function processLine(cm, text, state, startAt) {
	    var mode = cm.doc.mode;
	    var stream = new StringStream(text, cm.options.tabSize);
	    stream.start = stream.pos = startAt || 0;
	    if (text == "") callBlankLine(mode, state);
	    while (!stream.eol()) {
	      readToken(mode, stream, state);
	      stream.start = stream.pos;
	    }
	  }

	  // Convert a style as returned by a mode (either null, or a string
	  // containing one or more styles) to a CSS style. This is cached,
	  // and also looks for line-wide styles.
	  var styleToClassCache = {}, styleToClassCacheWithMode = {};
	  function interpretTokenStyle(style, options) {
	    if (!style || /^\s*$/.test(style)) return null;
	    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	    return cache[style] ||
	      (cache[style] = style.replace(/\S+/g, "cm-$&"));
	  }

	  // Render the DOM representation of the text of a line. Also builds
	  // up a 'line map', which points at the DOM nodes that represent
	  // specific stretches of text, and is used by the measuring code.
	  // The returned object contains the DOM node, this map, and
	  // information about line-wide styles that were set by the mode.
	  function buildLineContent(cm, lineView) {
	    // The padding-right forces the element to have a 'border', which
	    // is needed on Webkit to be able to get line-level bounding
	    // rectangles for it (in measureChar).
	    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
	    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
	                   col: 0, pos: 0, cm: cm,
	                   trailingSpace: false,
	                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
	    lineView.measure = {};

	    // Iterate over the logical lines that make up this visual line.
	    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	      var line = i ? lineView.rest[i - 1] : lineView.line, order;
	      builder.pos = 0;
	      builder.addToken = buildToken;
	      // Optionally wire in some hacks into the token-rendering
	      // algorithm, to deal with browser quirks.
	      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
	        builder.addToken = buildTokenBadBidi(builder.addToken, order);
	      builder.map = [];
	      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	      if (line.styleClasses) {
	        if (line.styleClasses.bgClass)
	          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
	        if (line.styleClasses.textClass)
	          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
	      }

	      // Ensure at least a single node is present, for measuring.
	      if (builder.map.length == 0)
	        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

	      // Store the map and a cache object for the current logical line
	      if (i == 0) {
	        lineView.measure.map = builder.map;
	        lineView.measure.cache = {};
	      } else {
	        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
	        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
	      }
	    }

	    // See issue #2901
	    if (webkit) {
	      var last = builder.content.lastChild
	      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	        builder.content.className = "cm-tab-wrap-hack";
	    }

	    signal(cm, "renderLine", cm, lineView.line, builder.pre);
	    if (builder.pre.className)
	      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

	    return builder;
	  }

	  function defaultSpecialCharPlaceholder(ch) {
	    var token = elt("span", "\u2022", "cm-invalidchar");
	    token.title = "\\u" + ch.charCodeAt(0).toString(16);
	    token.setAttribute("aria-label", token.title);
	    return token;
	  }

	  // Build up the DOM representation for a single token, and add it to
	  // the line map. Takes care to render special characters separately.
	  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	    if (!text) return;
	    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
	    var special = builder.cm.state.specialChars, mustWrap = false;
	    if (!special.test(text)) {
	      builder.col += text.length;
	      var content = document.createTextNode(displayText);
	      builder.map.push(builder.pos, builder.pos + text.length, content);
	      if (ie && ie_version < 9) mustWrap = true;
	      builder.pos += text.length;
	    } else {
	      var content = document.createDocumentFragment(), pos = 0;
	      while (true) {
	        special.lastIndex = pos;
	        var m = special.exec(text);
	        var skipped = m ? m.index - pos : text.length - pos;
	        if (skipped) {
	          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
	          else content.appendChild(txt);
	          builder.map.push(builder.pos, builder.pos + skipped, txt);
	          builder.col += skipped;
	          builder.pos += skipped;
	        }
	        if (!m) break;
	        pos += skipped + 1;
	        if (m[0] == "\t") {
	          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	          txt.setAttribute("role", "presentation");
	          txt.setAttribute("cm-text", "\t");
	          builder.col += tabWidth;
	        } else if (m[0] == "\r" || m[0] == "\n") {
	          var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	          txt.setAttribute("cm-text", m[0]);
	          builder.col += 1;
	        } else {
	          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
	          txt.setAttribute("cm-text", m[0]);
	          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
	          else content.appendChild(txt);
	          builder.col += 1;
	        }
	        builder.map.push(builder.pos, builder.pos + 1, txt);
	        builder.pos++;
	      }
	    }
	    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
	    if (style || startStyle || endStyle || mustWrap || css) {
	      var fullStyle = style || "";
	      if (startStyle) fullStyle += startStyle;
	      if (endStyle) fullStyle += endStyle;
	      var token = elt("span", [content], fullStyle, css);
	      if (title) token.title = title;
	      return builder.content.appendChild(token);
	    }
	    builder.content.appendChild(content);
	  }

	  function splitSpaces(text, trailingBefore) {
	    if (text.length > 1 && !/  /.test(text)) return text
	    var spaceBefore = trailingBefore, result = ""
	    for (var i = 0; i < text.length; i++) {
	      var ch = text.charAt(i)
	      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	        ch = "\u00a0"
	      result += ch
	      spaceBefore = ch == " "
	    }
	    return result
	  }

	  // Work around nonsense dimensions being reported for stretches of
	  // right-to-left text.
	  function buildTokenBadBidi(inner, order) {
	    return function(builder, text, style, startStyle, endStyle, title, css) {
	      style = style ? style + " cm-force-border" : "cm-force-border";
	      var start = builder.pos, end = start + text.length;
	      for (;;) {
	        // Find the part that overlaps with the start of this text
	        for (var i = 0; i < order.length; i++) {
	          var part = order[i];
	          if (part.to > start && part.from <= start) break;
	        }
	        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
	        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
	        startStyle = null;
	        text = text.slice(part.to - start);
	        start = part.to;
	      }
	    };
	  }

	  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	    var widget = !ignoreWidget && marker.widgetNode;
	    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
	    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	      if (!widget)
	        widget = builder.content.appendChild(document.createElement("span"));
	      widget.setAttribute("cm-marker", marker.id);
	    }
	    if (widget) {
	      builder.cm.display.input.setUneditable(widget);
	      builder.content.appendChild(widget);
	    }
	    builder.pos += size;
	    builder.trailingSpace = false
	  }

	  // Outputs a number of spans to make up a line, taking highlighting
	  // and marked text into account.
	  function insertLineContent(line, builder, styles) {
	    var spans = line.markedSpans, allText = line.text, at = 0;
	    if (!spans) {
	      for (var i = 1; i < styles.length; i+=2)
	        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
	      return;
	    }

	    var len = allText.length, pos = 0, i = 1, text = "", style, css;
	    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
	    for (;;) {
	      if (nextChange == pos) { // Update current marker set
	        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
	        collapsed = null; nextChange = Infinity;
	        var foundBookmarks = [], endStyles
	        for (var j = 0; j < spans.length; ++j) {
	          var sp = spans[j], m = sp.marker;
	          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	            foundBookmarks.push(m);
	          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	              nextChange = sp.to;
	              spanEndStyle = "";
	            }
	            if (m.className) spanStyle += " " + m.className;
	            if (m.css) css = (css ? css + ";" : "") + m.css;
	            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
	            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
	            if (m.title && !title) title = m.title;
	            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	              collapsed = sp;
	          } else if (sp.from > pos && nextChange > sp.from) {
	            nextChange = sp.from;
	          }
	        }
	        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)
	          if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]

	        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)
	          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
	        if (collapsed && (collapsed.from || 0) == pos) {
	          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                             collapsed.marker, collapsed.from == null);
	          if (collapsed.to == null) return;
	          if (collapsed.to == pos) collapsed = false;
	        }
	      }
	      if (pos >= len) break;

	      var upto = Math.min(len, nextChange);
	      while (true) {
	        if (text) {
	          var end = pos + text.length;
	          if (!collapsed) {
	            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
	          }
	          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
	          pos = end;
	          spanStartStyle = "";
	        }
	        text = allText.slice(at, at = styles[i++]);
	        style = interpretTokenStyle(styles[i++], builder.cm.options);
	      }
	    }
	  }

	  // DOCUMENT DATA STRUCTURE

	  // By default, updates that start and end at the beginning of a line
	  // are treated specially, in order to make the association of line
	  // widgets and marker elements with the text behave more intuitive.
	  function isWholeLineUpdate(doc, change) {
	    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
	  }

	  // Perform a change on the document data structure.
	  function updateDoc(doc, change, markedSpans, estimateHeight) {
	    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
	    function update(line, text, spans) {
	      updateLine(line, text, spans, estimateHeight);
	      signalLater(line, "change", line, change);
	    }
	    function linesFor(start, end) {
	      for (var i = start, result = []; i < end; ++i)
	        result.push(new Line(text[i], spansFor(i), estimateHeight));
	      return result;
	    }

	    var from = change.from, to = change.to, text = change.text;
	    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

	    // Adjust the line structure
	    if (change.full) {
	      doc.insert(0, linesFor(0, text.length));
	      doc.remove(text.length, doc.size - text.length);
	    } else if (isWholeLineUpdate(doc, change)) {
	      // This is a whole-line replace. Treated specially to make
	      // sure line objects move the way they are supposed to.
	      var added = linesFor(0, text.length - 1);
	      update(lastLine, lastLine.text, lastSpans);
	      if (nlines) doc.remove(from.line, nlines);
	      if (added.length) doc.insert(from.line, added);
	    } else if (firstLine == lastLine) {
	      if (text.length == 1) {
	        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	      } else {
	        var added = linesFor(1, text.length - 1);
	        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
	        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	        doc.insert(from.line + 1, added);
	      }
	    } else if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	      doc.remove(from.line + 1, nlines);
	    } else {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	      var added = linesFor(1, text.length - 1);
	      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
	      doc.insert(from.line + 1, added);
	    }

	    signalLater(doc, "change", doc, change);
	  }

	  // The document is represented as a BTree consisting of leaves, with
	  // chunk of lines in them, and branches, with up to ten leaves or
	  // other branch nodes below them. The top node is always a branch
	  // node, and is the document object itself (meaning it has
	  // additional methods and properties).
	  //
	  // All nodes have parent links. The tree is used both to go from
	  // line numbers to line objects, and to go from objects to numbers.
	  // It also indexes by height, and is used to convert between height
	  // and line object, and to find the total height of the document.
	  //
	  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

	  function LeafChunk(lines) {
	    this.lines = lines;
	    this.parent = null;
	    for (var i = 0, height = 0; i < lines.length; ++i) {
	      lines[i].parent = this;
	      height += lines[i].height;
	    }
	    this.height = height;
	  }

	  LeafChunk.prototype = {
	    chunkSize: function() { return this.lines.length; },
	    // Remove the n lines at offset 'at'.
	    removeInner: function(at, n) {
	      for (var i = at, e = at + n; i < e; ++i) {
	        var line = this.lines[i];
	        this.height -= line.height;
	        cleanUpLine(line);
	        signalLater(line, "delete");
	      }
	      this.lines.splice(at, n);
	    },
	    // Helper used to collapse a small branch into a single leaf.
	    collapse: function(lines) {
	      lines.push.apply(lines, this.lines);
	    },
	    // Insert the given array of lines at offset 'at', count them as
	    // having the given height.
	    insertInner: function(at, lines, height) {
	      this.height += height;
	      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
	    },
	    // Used to iterate over a part of the tree.
	    iterN: function(at, n, op) {
	      for (var e = at + n; at < e; ++at)
	        if (op(this.lines[at])) return true;
	    }
	  };

	  function BranchChunk(children) {
	    this.children = children;
	    var size = 0, height = 0;
	    for (var i = 0; i < children.length; ++i) {
	      var ch = children[i];
	      size += ch.chunkSize(); height += ch.height;
	      ch.parent = this;
	    }
	    this.size = size;
	    this.height = height;
	    this.parent = null;
	  }

	  BranchChunk.prototype = {
	    chunkSize: function() { return this.size; },
	    removeInner: function(at, n) {
	      this.size -= n;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var rm = Math.min(n, sz - at), oldHeight = child.height;
	          child.removeInner(at, rm);
	          this.height -= oldHeight - child.height;
	          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
	          if ((n -= rm) == 0) break;
	          at = 0;
	        } else at -= sz;
	      }
	      // If the result is smaller than 25 lines, ensure that it is a
	      // single leaf node.
	      if (this.size - n < 25 &&
	          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	        var lines = [];
	        this.collapse(lines);
	        this.children = [new LeafChunk(lines)];
	        this.children[0].parent = this;
	      }
	    },
	    collapse: function(lines) {
	      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
	    },
	    insertInner: function(at, lines, height) {
	      this.size += lines.length;
	      this.height += height;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at <= sz) {
	          child.insertInner(at, lines, height);
	          if (child.lines && child.lines.length > 50) {
	            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	            var remaining = child.lines.length % 25 + 25
	            for (var pos = remaining; pos < child.lines.length;) {
	              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	              child.height -= leaf.height;
	              this.children.splice(++i, 0, leaf);
	              leaf.parent = this;
	            }
	            child.lines = child.lines.slice(0, remaining);
	            this.maybeSpill();
	          }
	          break;
	        }
	        at -= sz;
	      }
	    },
	    // When a node has grown, check whether it should be split.
	    maybeSpill: function() {
	      if (this.children.length <= 10) return;
	      var me = this;
	      do {
	        var spilled = me.children.splice(me.children.length - 5, 5);
	        var sibling = new BranchChunk(spilled);
	        if (!me.parent) { // Become the parent node
	          var copy = new BranchChunk(me.children);
	          copy.parent = me;
	          me.children = [copy, sibling];
	          me = copy;
	       } else {
	          me.size -= sibling.size;
	          me.height -= sibling.height;
	          var myIndex = indexOf(me.parent.children, me);
	          me.parent.children.splice(myIndex + 1, 0, sibling);
	        }
	        sibling.parent = me.parent;
	      } while (me.children.length > 10);
	      me.parent.maybeSpill();
	    },
	    iterN: function(at, n, op) {
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var used = Math.min(n, sz - at);
	          if (child.iterN(at, used, op)) return true;
	          if ((n -= used) == 0) break;
	          at = 0;
	        } else at -= sz;
	      }
	    }
	  };

	  var nextDocId = 0;
	  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
	    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
	    if (firstLine == null) firstLine = 0;

	    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	    this.first = firstLine;
	    this.scrollTop = this.scrollLeft = 0;
	    this.cantEdit = false;
	    this.cleanGeneration = 1;
	    this.frontier = firstLine;
	    var start = Pos(firstLine, 0);
	    this.sel = simpleSelection(start);
	    this.history = new History(null);
	    this.id = ++nextDocId;
	    this.modeOption = mode;
	    this.lineSep = lineSep;
	    this.extend = false;

	    if (typeof text == "string") text = this.splitLines(text);
	    updateDoc(this, {from: start, to: start, text: text});
	    setSelection(this, simpleSelection(start), sel_dontScroll);
	  };

	  Doc.prototype = createObj(BranchChunk.prototype, {
	    constructor: Doc,
	    // Iterate over the document. Supports two forms -- with only one
	    // argument, it calls that for each line in the document. With
	    // three, it iterates over the range given by the first two (with
	    // the second being non-inclusive).
	    iter: function(from, to, op) {
	      if (op) this.iterN(from - this.first, to - from, op);
	      else this.iterN(this.first, this.first + this.size, from);
	    },

	    // Non-public interface for adding and removing lines.
	    insert: function(at, lines) {
	      var height = 0;
	      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
	      this.insertInner(at - this.first, lines, height);
	    },
	    remove: function(at, n) { this.removeInner(at - this.first, n); },

	    // From here, the methods are part of the public interface. Most
	    // are also available from CodeMirror (editor) instances.

	    getValue: function(lineSep) {
	      var lines = getLines(this, this.first, this.first + this.size);
	      if (lineSep === false) return lines;
	      return lines.join(lineSep || this.lineSeparator());
	    },
	    setValue: docMethodOp(function(code) {
	      var top = Pos(this.first, 0), last = this.first + this.size - 1;
	      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                        text: this.splitLines(code), origin: "setValue", full: true}, true);
	      setSelection(this, simpleSelection(top));
	    }),
	    replaceRange: function(code, from, to, origin) {
	      from = clipPos(this, from);
	      to = to ? clipPos(this, to) : from;
	      replaceRange(this, code, from, to, origin);
	    },
	    getRange: function(from, to, lineSep) {
	      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	      if (lineSep === false) return lines;
	      return lines.join(lineSep || this.lineSeparator());
	    },

	    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

	    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
	    getLineNumber: function(line) {return lineNo(line);},

	    getLineHandleVisualStart: function(line) {
	      if (typeof line == "number") line = getLine(this, line);
	      return visualLine(line);
	    },

	    lineCount: function() {return this.size;},
	    firstLine: function() {return this.first;},
	    lastLine: function() {return this.first + this.size - 1;},

	    clipPos: function(pos) {return clipPos(this, pos);},

	    getCursor: function(start) {
	      var range = this.sel.primary(), pos;
	      if (start == null || start == "head") pos = range.head;
	      else if (start == "anchor") pos = range.anchor;
	      else if (start == "end" || start == "to" || start === false) pos = range.to();
	      else pos = range.from();
	      return pos;
	    },
	    listSelections: function() { return this.sel.ranges; },
	    somethingSelected: function() {return this.sel.somethingSelected();},

	    setCursor: docMethodOp(function(line, ch, options) {
	      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	    }),
	    setSelection: docMethodOp(function(anchor, head, options) {
	      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	    }),
	    extendSelection: docMethodOp(function(head, other, options) {
	      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	    }),
	    extendSelections: docMethodOp(function(heads, options) {
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    extendSelectionsBy: docMethodOp(function(f, options) {
	      var heads = map(this.sel.ranges, f);
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    setSelections: docMethodOp(function(ranges, primary, options) {
	      if (!ranges.length) return;
	      for (var i = 0, out = []; i < ranges.length; i++)
	        out[i] = new Range(clipPos(this, ranges[i].anchor),
	                           clipPos(this, ranges[i].head));
	      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
	      setSelection(this, normalizeSelection(out, primary), options);
	    }),
	    addSelection: docMethodOp(function(anchor, head, options) {
	      var ranges = this.sel.ranges.slice(0);
	      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
	    }),

	    getSelection: function(lineSep) {
	      var ranges = this.sel.ranges, lines;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        lines = lines ? lines.concat(sel) : sel;
	      }
	      if (lineSep === false) return lines;
	      else return lines.join(lineSep || this.lineSeparator());
	    },
	    getSelections: function(lineSep) {
	      var parts = [], ranges = this.sel.ranges;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
	        parts[i] = sel;
	      }
	      return parts;
	    },
	    replaceSelection: function(code, collapse, origin) {
	      var dup = [];
	      for (var i = 0; i < this.sel.ranges.length; i++)
	        dup[i] = code;
	      this.replaceSelections(dup, collapse, origin || "+input");
	    },
	    replaceSelections: docMethodOp(function(code, collapse, origin) {
	      var changes = [], sel = this.sel;
	      for (var i = 0; i < sel.ranges.length; i++) {
	        var range = sel.ranges[i];
	        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
	      }
	      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	      for (var i = changes.length - 1; i >= 0; i--)
	        makeChange(this, changes[i]);
	      if (newSel) setSelectionReplaceHistory(this, newSel);
	      else if (this.cm) ensureCursorVisible(this.cm);
	    }),
	    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

	    setExtending: function(val) {this.extend = val;},
	    getExtending: function() {return this.extend;},

	    historySize: function() {
	      var hist = this.history, done = 0, undone = 0;
	      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
	      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
	      return {undo: done, redo: undone};
	    },
	    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

	    markClean: function() {
	      this.cleanGeneration = this.changeGeneration(true);
	    },
	    changeGeneration: function(forceSplit) {
	      if (forceSplit)
	        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
	      return this.history.generation;
	    },
	    isClean: function (gen) {
	      return this.history.generation == (gen || this.cleanGeneration);
	    },

	    getHistory: function() {
	      return {done: copyHistoryArray(this.history.done),
	              undone: copyHistoryArray(this.history.undone)};
	    },
	    setHistory: function(histData) {
	      var hist = this.history = new History(this.history.maxGeneration);
	      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	    },

	    addLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        if (!line[prop]) line[prop] = cls;
	        else if (classTest(cls).test(line[prop])) return false;
	        else line[prop] += " " + cls;
	        return true;
	      });
	    }),
	    removeLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        var cur = line[prop];
	        if (!cur) return false;
	        else if (cls == null) line[prop] = null;
	        else {
	          var found = cur.match(classTest(cls));
	          if (!found) return false;
	          var end = found.index + found[0].length;
	          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	        }
	        return true;
	      });
	    }),

	    addLineWidget: docMethodOp(function(handle, node, options) {
	      return addLineWidget(this, handle, node, options);
	    }),
	    removeLineWidget: function(widget) { widget.clear(); },

	    markText: function(from, to, options) {
	      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
	    },
	    setBookmark: function(pos, options) {
	      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                      insertLeft: options && options.insertLeft,
	                      clearWhenEmpty: false, shared: options && options.shared,
	                      handleMouseEvents: options && options.handleMouseEvents};
	      pos = clipPos(this, pos);
	      return markText(this, pos, pos, realOpts, "bookmark");
	    },
	    findMarksAt: function(pos) {
	      pos = clipPos(this, pos);
	      var markers = [], spans = getLine(this, pos.line).markedSpans;
	      if (spans) for (var i = 0; i < spans.length; ++i) {
	        var span = spans[i];
	        if ((span.from == null || span.from <= pos.ch) &&
	            (span.to == null || span.to >= pos.ch))
	          markers.push(span.marker.parent || span.marker);
	      }
	      return markers;
	    },
	    findMarks: function(from, to, filter) {
	      from = clipPos(this, from); to = clipPos(this, to);
	      var found = [], lineNo = from.line;
	      this.iter(from.line, to.line + 1, function(line) {
	        var spans = line.markedSpans;
	        if (spans) for (var i = 0; i < spans.length; i++) {
	          var span = spans[i];
	          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
	                span.from == null && lineNo != from.line ||
	                span.from != null && lineNo == to.line && span.from >= to.ch) &&
	              (!filter || filter(span.marker)))
	            found.push(span.marker.parent || span.marker);
	        }
	        ++lineNo;
	      });
	      return found;
	    },
	    getAllMarks: function() {
	      var markers = [];
	      this.iter(function(line) {
	        var sps = line.markedSpans;
	        if (sps) for (var i = 0; i < sps.length; ++i)
	          if (sps[i].from != null) markers.push(sps[i].marker);
	      });
	      return markers;
	    },

	    posFromIndex: function(off) {
	      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
	      this.iter(function(line) {
	        var sz = line.text.length + sepSize;
	        if (sz > off) { ch = off; return true; }
	        off -= sz;
	        ++lineNo;
	      });
	      return clipPos(this, Pos(lineNo, ch));
	    },
	    indexFromPos: function (coords) {
	      coords = clipPos(this, coords);
	      var index = coords.ch;
	      if (coords.line < this.first || coords.ch < 0) return 0;
	      var sepSize = this.lineSeparator().length;
	      this.iter(this.first, coords.line, function (line) {
	        index += line.text.length + sepSize;
	      });
	      return index;
	    },

	    copy: function(copyHistory) {
	      var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                        this.modeOption, this.first, this.lineSep);
	      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	      doc.sel = this.sel;
	      doc.extend = false;
	      if (copyHistory) {
	        doc.history.undoDepth = this.history.undoDepth;
	        doc.setHistory(this.getHistory());
	      }
	      return doc;
	    },

	    linkedDoc: function(options) {
	      if (!options) options = {};
	      var from = this.first, to = this.first + this.size;
	      if (options.from != null && options.from > from) from = options.from;
	      if (options.to != null && options.to < to) to = options.to;
	      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
	      if (options.sharedHist) copy.history = this.history;
	      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	      copySharedMarkers(copy, findSharedMarkers(this));
	      return copy;
	    },
	    unlinkDoc: function(other) {
	      if (other instanceof CodeMirror) other = other.doc;
	      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
	        var link = this.linked[i];
	        if (link.doc != other) continue;
	        this.linked.splice(i, 1);
	        other.unlinkDoc(this);
	        detachSharedMarkers(findSharedMarkers(this));
	        break;
	      }
	      // If the histories were shared, split them again
	      if (other.history == this.history) {
	        var splitIds = [other.id];
	        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
	        other.history = new History(null);
	        other.history.done = copyHistoryArray(this.history.done, splitIds);
	        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	      }
	    },
	    iterLinkedDocs: function(f) {linkedDocs(this, f);},

	    getMode: function() {return this.mode;},
	    getEditor: function() {return this.cm;},

	    splitLines: function(str) {
	      if (this.lineSep) return str.split(this.lineSep);
	      return splitLinesAuto(str);
	    },
	    lineSeparator: function() { return this.lineSep || "\n"; }
	  });

	  // Public alias.
	  Doc.prototype.eachLine = Doc.prototype.iter;

	  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
	  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	    CodeMirror.prototype[prop] = (function(method) {
	      return function() {return method.apply(this.doc, arguments);};
	    })(Doc.prototype[prop]);

	  eventMixin(Doc);

	  // Call f for all linked documents.
	  function linkedDocs(doc, f, sharedHistOnly) {
	    function propagate(doc, skip, sharedHist) {
	      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
	        var rel = doc.linked[i];
	        if (rel.doc == skip) continue;
	        var shared = sharedHist && rel.sharedHist;
	        if (sharedHistOnly && !shared) continue;
	        f(rel.doc, shared);
	        propagate(rel.doc, doc, shared);
	      }
	    }
	    propagate(doc, null, true);
	  }

	  // Attach a document to an editor.
	  function attachDoc(cm, doc) {
	    if (doc.cm) throw new Error("This document is already in use.");
	    cm.doc = doc;
	    doc.cm = cm;
	    estimateLineHeights(cm);
	    loadMode(cm);
	    if (!cm.options.lineWrapping) findMaxLine(cm);
	    cm.options.mode = doc.modeOption;
	    regChange(cm);
	  }

	  // LINE UTILITIES

	  // Find the line object corresponding to the given line number.
	  function getLine(doc, n) {
	    n -= doc.first;
	    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
	    for (var chunk = doc; !chunk.lines;) {
	      for (var i = 0;; ++i) {
	        var child = chunk.children[i], sz = child.chunkSize();
	        if (n < sz) { chunk = child; break; }
	        n -= sz;
	      }
	    }
	    return chunk.lines[n];
	  }

	  // Get the part of a document between two positions, as an array of
	  // strings.
	  function getBetween(doc, start, end) {
	    var out = [], n = start.line;
	    doc.iter(start.line, end.line + 1, function(line) {
	      var text = line.text;
	      if (n == end.line) text = text.slice(0, end.ch);
	      if (n == start.line) text = text.slice(start.ch);
	      out.push(text);
	      ++n;
	    });
	    return out;
	  }
	  // Get the lines between from and to, as array of strings.
	  function getLines(doc, from, to) {
	    var out = [];
	    doc.iter(from, to, function(line) { out.push(line.text); });
	    return out;
	  }

	  // Update the height of a line, propagating the height change
	  // upwards to parent nodes.
	  function updateLineHeight(line, height) {
	    var diff = height - line.height;
	    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
	  }

	  // Given a line object, find its line number by walking up through
	  // its parent links.
	  function lineNo(line) {
	    if (line.parent == null) return null;
	    var cur = line.parent, no = indexOf(cur.lines, line);
	    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	      for (var i = 0;; ++i) {
	        if (chunk.children[i] == cur) break;
	        no += chunk.children[i].chunkSize();
	      }
	    }
	    return no + cur.first;
	  }

	  // Find the line at the given vertical position, using the height
	  // information in the document tree.
	  function lineAtHeight(chunk, h) {
	    var n = chunk.first;
	    outer: do {
	      for (var i = 0; i < chunk.children.length; ++i) {
	        var child = chunk.children[i], ch = child.height;
	        if (h < ch) { chunk = child; continue outer; }
	        h -= ch;
	        n += child.chunkSize();
	      }
	      return n;
	    } while (!chunk.lines);
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i], lh = line.height;
	      if (h < lh) break;
	      h -= lh;
	    }
	    return n + i;
	  }


	  // Find the height above the given line.
	  function heightAtLine(lineObj) {
	    lineObj = visualLine(lineObj);

	    var h = 0, chunk = lineObj.parent;
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i];
	      if (line == lineObj) break;
	      else h += line.height;
	    }
	    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	      for (var i = 0; i < p.children.length; ++i) {
	        var cur = p.children[i];
	        if (cur == chunk) break;
	        else h += cur.height;
	      }
	    }
	    return h;
	  }

	  // Get the bidi ordering for the given line (and cache it). Returns
	  // false for lines that are fully left-to-right, and an array of
	  // BidiSpan objects otherwise.
	  function getOrder(line) {
	    var order = line.order;
	    if (order == null) order = line.order = bidiOrdering(line.text);
	    return order;
	  }

	  // HISTORY

	  function History(startGen) {
	    // Arrays of change events and selections. Doing something adds an
	    // event to done and clears undo. Undoing moves events from done
	    // to undone, redoing moves them in the other direction.
	    this.done = []; this.undone = [];
	    this.undoDepth = Infinity;
	    // Used to track when changes can be merged into a single undo
	    // event
	    this.lastModTime = this.lastSelTime = 0;
	    this.lastOp = this.lastSelOp = null;
	    this.lastOrigin = this.lastSelOrigin = null;
	    // Used by the isClean() method
	    this.generation = this.maxGeneration = startGen || 1;
	  }

	  // Create a history change event from an updateDoc-style change
	  // object.
	  function historyChangeFromChange(doc, change) {
	    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
	    return histChange;
	  }

	  // Pop all selection events off the end of a history array. Stop at
	  // a change event.
	  function clearSelectionEvents(array) {
	    while (array.length) {
	      var last = lst(array);
	      if (last.ranges) array.pop();
	      else break;
	    }
	  }

	  // Find the top change event in the history. Pop off selection
	  // events that are in the way.
	  function lastChangeEvent(hist, force) {
	    if (force) {
	      clearSelectionEvents(hist.done);
	      return lst(hist.done);
	    } else if (hist.done.length && !lst(hist.done).ranges) {
	      return lst(hist.done);
	    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	      hist.done.pop();
	      return lst(hist.done);
	    }
	  }

	  // Register a change in the history. Merges changes that are within
	  // a single operation, or are close together with an origin that
	  // allows merging (starting with "+") into a single event.
	  function addChangeToHistory(doc, change, selAfter, opId) {
	    var hist = doc.history;
	    hist.undone.length = 0;
	    var time = +new Date, cur;

	    if ((hist.lastOp == opId ||
	         hist.lastOrigin == change.origin && change.origin &&
	         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
	          change.origin.charAt(0) == "*")) &&
	        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	      // Merge this change into the last event
	      var last = lst(cur.changes);
	      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	        // Optimized case for simple insertion -- don't want to add
	        // new changesets for every character typed
	        last.to = changeEnd(change);
	      } else {
	        // Add new sub-event
	        cur.changes.push(historyChangeFromChange(doc, change));
	      }
	    } else {
	      // Can not be merged, start a new event.
	      var before = lst(hist.done);
	      if (!before || !before.ranges)
	        pushSelectionToHistory(doc.sel, hist.done);
	      cur = {changes: [historyChangeFromChange(doc, change)],
	             generation: hist.generation};
	      hist.done.push(cur);
	      while (hist.done.length > hist.undoDepth) {
	        hist.done.shift();
	        if (!hist.done[0].ranges) hist.done.shift();
	      }
	    }
	    hist.done.push(selAfter);
	    hist.generation = ++hist.maxGeneration;
	    hist.lastModTime = hist.lastSelTime = time;
	    hist.lastOp = hist.lastSelOp = opId;
	    hist.lastOrigin = hist.lastSelOrigin = change.origin;

	    if (!last) signal(doc, "historyAdded");
	  }

	  function selectionEventCanBeMerged(doc, origin, prev, sel) {
	    var ch = origin.charAt(0);
	    return ch == "*" ||
	      ch == "+" &&
	      prev.ranges.length == sel.ranges.length &&
	      prev.somethingSelected() == sel.somethingSelected() &&
	      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
	  }

	  // Called whenever the selection changes, sets the new selection as
	  // the pending selection in the history, and pushes the old pending
	  // selection into the 'done' array when it was significantly
	  // different (in number of selected ranges, emptiness, or time).
	  function addSelectionToHistory(doc, sel, opId, options) {
	    var hist = doc.history, origin = options && options.origin;

	    // A new event is started when the previous origin does not match
	    // the current, or the origins don't allow matching. Origins
	    // starting with * are always merged, those starting with + are
	    // merged when similar and close together in time.
	    if (opId == hist.lastSelOp ||
	        (origin && hist.lastSelOrigin == origin &&
	         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	      hist.done[hist.done.length - 1] = sel;
	    else
	      pushSelectionToHistory(sel, hist.done);

	    hist.lastSelTime = +new Date;
	    hist.lastSelOrigin = origin;
	    hist.lastSelOp = opId;
	    if (options && options.clearRedo !== false)
	      clearSelectionEvents(hist.undone);
	  }

	  function pushSelectionToHistory(sel, dest) {
	    var top = lst(dest);
	    if (!(top && top.ranges && top.equals(sel)))
	      dest.push(sel);
	  }

	  // Used to store marked span information in the history.
	  function attachLocalSpans(doc, change, from, to) {
	    var existing = change["spans_" + doc.id], n = 0;
	    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
	      if (line.markedSpans)
	        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
	      ++n;
	    });
	  }

	  // When un/re-doing restores text containing marked spans, those
	  // that have been explicitly cleared should not be restored.
	  function removeClearedSpans(spans) {
	    if (!spans) return null;
	    for (var i = 0, out; i < spans.length; ++i) {
	      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
	      else if (out) out.push(spans[i]);
	    }
	    return !out ? spans : out.length ? out : null;
	  }

	  // Retrieve and filter the old marked spans stored in a change event.
	  function getOldSpans(doc, change) {
	    var found = change["spans_" + doc.id];
	    if (!found) return null;
	    for (var i = 0, nw = []; i < change.text.length; ++i)
	      nw.push(removeClearedSpans(found[i]));
	    return nw;
	  }

	  // Used both to provide a JSON-safe object in .getHistory, and, when
	  // detaching a document, to split the history in two
	  function copyHistoryArray(events, newGroup, instantiateSel) {
	    for (var i = 0, copy = []; i < events.length; ++i) {
	      var event = events[i];
	      if (event.ranges) {
	        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	        continue;
	      }
	      var changes = event.changes, newChanges = [];
	      copy.push({changes: newChanges});
	      for (var j = 0; j < changes.length; ++j) {
	        var change = changes[j], m;
	        newChanges.push({from: change.from, to: change.to, text: change.text});
	        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
	          if (indexOf(newGroup, Number(m[1])) > -1) {
	            lst(newChanges)[prop] = change[prop];
	            delete change[prop];
	          }
	        }
	      }
	    }
	    return copy;
	  }

	  // Rebasing/resetting history to deal with externally-sourced changes

	  function rebaseHistSelSingle(pos, from, to, diff) {
	    if (to < pos.line) {
	      pos.line += diff;
	    } else if (from < pos.line) {
	      pos.line = from;
	      pos.ch = 0;
	    }
	  }

	  // Tries to rebase an array of history events given a change in the
	  // document. If the change touches the same lines as the event, the
	  // event, and everything 'behind' it, is discarded. If the change is
	  // before the event, the event's positions are updated. Uses a
	  // copy-on-write scheme for the positions, to avoid having to
	  // reallocate them all on every rebase, but also avoid problems with
	  // shared position objects being unsafely updated.
	  function rebaseHistArray(array, from, to, diff) {
	    for (var i = 0; i < array.length; ++i) {
	      var sub = array[i], ok = true;
	      if (sub.ranges) {
	        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	        for (var j = 0; j < sub.ranges.length; j++) {
	          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	        }
	        continue;
	      }
	      for (var j = 0; j < sub.changes.length; ++j) {
	        var cur = sub.changes[j];
	        if (to < cur.from.line) {
	          cur.from = Pos(cur.from.line + diff, cur.from.ch);
	          cur.to = Pos(cur.to.line + diff, cur.to.ch);
	        } else if (from <= cur.to.line) {
	          ok = false;
	          break;
	        }
	      }
	      if (!ok) {
	        array.splice(0, i + 1);
	        i = 0;
	      }
	    }
	  }

	  function rebaseHist(hist, change) {
	    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	    rebaseHistArray(hist.done, from, to, diff);
	    rebaseHistArray(hist.undone, from, to, diff);
	  }

	  // EVENT UTILITIES

	  // Due to the fact that we still support jurassic IE versions, some
	  // compatibility wrappers are needed.

	  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
	    if (e.preventDefault) e.preventDefault();
	    else e.returnValue = false;
	  };
	  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
	    if (e.stopPropagation) e.stopPropagation();
	    else e.cancelBubble = true;
	  };
	  function e_defaultPrevented(e) {
	    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
	  }
	  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

	  function e_target(e) {return e.target || e.srcElement;}
	  function e_button(e) {
	    var b = e.which;
	    if (b == null) {
	      if (e.button & 1) b = 1;
	      else if (e.button & 2) b = 3;
	      else if (e.button & 4) b = 2;
	    }
	    if (mac && e.ctrlKey && b == 1) b = 3;
	    return b;
	  }

	  // EVENT HANDLING

	  // Lightweight event framework. on/off also work on DOM nodes,
	  // registering native DOM handlers.

	  var on = CodeMirror.on = function(emitter, type, f) {
	    if (emitter.addEventListener)
	      emitter.addEventListener(type, f, false);
	    else if (emitter.attachEvent)
	      emitter.attachEvent("on" + type, f);
	    else {
	      var map = emitter._handlers || (emitter._handlers = {});
	      var arr = map[type] || (map[type] = []);
	      arr.push(f);
	    }
	  };

	  var noHandlers = []
	  function getHandlers(emitter, type, copy) {
	    var arr = emitter._handlers && emitter._handlers[type]
	    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers
	    else return arr || noHandlers
	  }

	  var off = CodeMirror.off = function(emitter, type, f) {
	    if (emitter.removeEventListener)
	      emitter.removeEventListener(type, f, false);
	    else if (emitter.detachEvent)
	      emitter.detachEvent("on" + type, f);
	    else {
	      var handlers = getHandlers(emitter, type, false)
	      for (var i = 0; i < handlers.length; ++i)
	        if (handlers[i] == f) { handlers.splice(i, 1); break; }
	    }
	  };

	  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
	    var handlers = getHandlers(emitter, type, true)
	    if (!handlers.length) return;
	    var args = Array.prototype.slice.call(arguments, 2);
	    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
	  };

	  var orphanDelayedCallbacks = null;

	  // Often, we want to signal events at a point where we are in the
	  // middle of some work, but don't want the handler to start calling
	  // other methods on the editor, which might be in an inconsistent
	  // state or simply not expect any other events to happen.
	  // signalLater looks whether there are any handlers, and schedules
	  // them to be executed when the last operation ends, or, if no
	  // operation is active, when a timeout fires.
	  function signalLater(emitter, type /*, values...*/) {
	    var arr = getHandlers(emitter, type, false)
	    if (!arr.length) return;
	    var args = Array.prototype.slice.call(arguments, 2), list;
	    if (operationGroup) {
	      list = operationGroup.delayedCallbacks;
	    } else if (orphanDelayedCallbacks) {
	      list = orphanDelayedCallbacks;
	    } else {
	      list = orphanDelayedCallbacks = [];
	      setTimeout(fireOrphanDelayed, 0);
	    }
	    function bnd(f) {return function(){f.apply(null, args);};};
	    for (var i = 0; i < arr.length; ++i)
	      list.push(bnd(arr[i]));
	  }

	  function fireOrphanDelayed() {
	    var delayed = orphanDelayedCallbacks;
	    orphanDelayedCallbacks = null;
	    for (var i = 0; i < delayed.length; ++i) delayed[i]();
	  }

	  // The DOM events that CodeMirror handles can be overridden by
	  // registering a (non-DOM) handler on the editor for the event name,
	  // and preventDefault-ing the event in that handler.
	  function signalDOMEvent(cm, e, override) {
	    if (typeof e == "string")
	      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
	    signal(cm, override || e.type, cm, e);
	    return e_defaultPrevented(e) || e.codemirrorIgnore;
	  }

	  function signalCursorActivity(cm) {
	    var arr = cm._handlers && cm._handlers.cursorActivity;
	    if (!arr) return;
	    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
	      set.push(arr[i]);
	  }

	  function hasHandler(emitter, type) {
	    return getHandlers(emitter, type).length > 0
	  }

	  // Add on and off methods to a constructor's prototype, to make
	  // registering events on such objects more convenient.
	  function eventMixin(ctor) {
	    ctor.prototype.on = function(type, f) {on(this, type, f);};
	    ctor.prototype.off = function(type, f) {off(this, type, f);};
	  }

	  // MISC UTILITIES

	  // Number of pixels added to scroller and sizer to hide scrollbar
	  var scrollerGap = 30;

	  // Returned or thrown by various protocols to signal 'I'm not
	  // handling this'.
	  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

	  // Reused option objects for setSelection & friends
	  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

	  function Delayed() {this.id = null;}
	  Delayed.prototype.set = function(ms, f) {
	    clearTimeout(this.id);
	    this.id = setTimeout(f, ms);
	  };

	  // Counts the column offset in a string, taking tabs into account.
	  // Used mostly to find indentation.
	  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
	    if (end == null) {
	      end = string.search(/[^\s\u00a0]/);
	      if (end == -1) end = string.length;
	    }
	    for (var i = startIndex || 0, n = startValue || 0;;) {
	      var nextTab = string.indexOf("\t", i);
	      if (nextTab < 0 || nextTab >= end)
	        return n + (end - i);
	      n += nextTab - i;
	      n += tabSize - (n % tabSize);
	      i = nextTab + 1;
	    }
	  };

	  // The inverse of countColumn -- find the offset that corresponds to
	  // a particular column.
	  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
	    for (var pos = 0, col = 0;;) {
	      var nextTab = string.indexOf("\t", pos);
	      if (nextTab == -1) nextTab = string.length;
	      var skipped = nextTab - pos;
	      if (nextTab == string.length || col + skipped >= goal)
	        return pos + Math.min(skipped, goal - col);
	      col += nextTab - pos;
	      col += tabSize - (col % tabSize);
	      pos = nextTab + 1;
	      if (col >= goal) return pos;
	    }
	  }

	  var spaceStrs = [""];
	  function spaceStr(n) {
	    while (spaceStrs.length <= n)
	      spaceStrs.push(lst(spaceStrs) + " ");
	    return spaceStrs[n];
	  }

	  function lst(arr) { return arr[arr.length-1]; }

	  var selectInput = function(node) { node.select(); };
	  if (ios) // Mobile Safari apparently has a bug where select() is broken.
	    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
	  else if (ie) // Suppress mysterious IE10 errors
	    selectInput = function(node) { try { node.select(); } catch(_e) {} };

	  function indexOf(array, elt) {
	    for (var i = 0; i < array.length; ++i)
	      if (array[i] == elt) return i;
	    return -1;
	  }
	  function map(array, f) {
	    var out = [];
	    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
	    return out;
	  }

	  function insertSorted(array, value, score) {
	    var pos = 0, priority = score(value)
	    while (pos < array.length && score(array[pos]) <= priority) pos++
	    array.splice(pos, 0, value)
	  }

	  function nothing() {}

	  function createObj(base, props) {
	    var inst;
	    if (Object.create) {
	      inst = Object.create(base);
	    } else {
	      nothing.prototype = base;
	      inst = new nothing();
	    }
	    if (props) copyObj(props, inst);
	    return inst;
	  };

	  function copyObj(obj, target, overwrite) {
	    if (!target) target = {};
	    for (var prop in obj)
	      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	        target[prop] = obj[prop];
	    return target;
	  }

	  function bind(f) {
	    var args = Array.prototype.slice.call(arguments, 1);
	    return function(){return f.apply(null, args);};
	  }

	  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
	    return /\w/.test(ch) || ch > "\x80" &&
	      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
	  };
	  function isWordChar(ch, helper) {
	    if (!helper) return isWordCharBasic(ch);
	    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
	    return helper.test(ch);
	  }

	  function isEmpty(obj) {
	    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
	    return true;
	  }

	  // Extending unicode characters. A series of a non-extending char +
	  // any number of extending chars is treated as a single unit as far
	  // as editing and measuring is concerned. This is not fully correct,
	  // since some scripts/fonts/browsers also treat other configurations
	  // of code points as a group.
	  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

	  // DOM UTILITIES

	  function elt(tag, content, className, style) {
	    var e = document.createElement(tag);
	    if (className) e.className = className;
	    if (style) e.style.cssText = style;
	    if (typeof content == "string") e.appendChild(document.createTextNode(content));
	    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
	    return e;
	  }

	  var range;
	  if (document.createRange) range = function(node, start, end, endNode) {
	    var r = document.createRange();
	    r.setEnd(endNode || node, end);
	    r.setStart(node, start);
	    return r;
	  };
	  else range = function(node, start, end) {
	    var r = document.body.createTextRange();
	    try { r.moveToElementText(node.parentNode); }
	    catch(e) { return r; }
	    r.collapse(true);
	    r.moveEnd("character", end);
	    r.moveStart("character", start);
	    return r;
	  };

	  function removeChildren(e) {
	    for (var count = e.childNodes.length; count > 0; --count)
	      e.removeChild(e.firstChild);
	    return e;
	  }

	  function removeChildrenAndAdd(parent, e) {
	    return removeChildren(parent).appendChild(e);
	  }

	  var contains = CodeMirror.contains = function(parent, child) {
	    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	      child = child.parentNode;
	    if (parent.contains)
	      return parent.contains(child);
	    do {
	      if (child.nodeType == 11) child = child.host;
	      if (child == parent) return true;
	    } while (child = child.parentNode);
	  };

	  function activeElt() {
	    var activeElement = document.activeElement;
	    while (activeElement && activeElement.root && activeElement.root.activeElement)
	      activeElement = activeElement.root.activeElement;
	    return activeElement;
	  }
	  // Older versions of IE throws unspecified error when touching
	  // document.activeElement in some cases (during loading, in iframe)
	  if (ie && ie_version < 11) activeElt = function() {
	    try { return document.activeElement; }
	    catch(e) { return document.body; }
	  };

	  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
	  var rmClass = CodeMirror.rmClass = function(node, cls) {
	    var current = node.className;
	    var match = classTest(cls).exec(current);
	    if (match) {
	      var after = current.slice(match.index + match[0].length);
	      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	    }
	  };
	  var addClass = CodeMirror.addClass = function(node, cls) {
	    var current = node.className;
	    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
	  };
	  function joinClasses(a, b) {
	    var as = a.split(" ");
	    for (var i = 0; i < as.length; i++)
	      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
	    return b;
	  }

	  // WINDOW-WIDE EVENTS

	  // These must be handled carefully, because naively registering a
	  // handler for each editor will cause the editors to never be
	  // garbage collected.

	  function forEachCodeMirror(f) {
	    if (!document.body.getElementsByClassName) return;
	    var byClass = document.body.getElementsByClassName("CodeMirror");
	    for (var i = 0; i < byClass.length; i++) {
	      var cm = byClass[i].CodeMirror;
	      if (cm) f(cm);
	    }
	  }

	  var globalsRegistered = false;
	  function ensureGlobalHandlers() {
	    if (globalsRegistered) return;
	    registerGlobalHandlers();
	    globalsRegistered = true;
	  }
	  function registerGlobalHandlers() {
	    // When the window resizes, we need to refresh active editors.
	    var resizeTimer;
	    on(window, "resize", function() {
	      if (resizeTimer == null) resizeTimer = setTimeout(function() {
	        resizeTimer = null;
	        forEachCodeMirror(onResize);
	      }, 100);
	    });
	    // When the window loses focus, we want to show the editor as blurred
	    on(window, "blur", function() {
	      forEachCodeMirror(onBlur);
	    });
	  }

	  // FEATURE DETECTION

	  // Detect drag-and-drop
	  var dragAndDrop = function() {
	    // There is *some* kind of drag-and-drop support in IE6-8, but I
	    // couldn't get it to work yet.
	    if (ie && ie_version < 9) return false;
	    var div = elt('div');
	    return "draggable" in div || "dragDrop" in div;
	  }();

	  var zwspSupported;
	  function zeroWidthElement(measure) {
	    if (zwspSupported == null) {
	      var test = elt("span", "\u200b");
	      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	      if (measure.firstChild.offsetHeight != 0)
	        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
	    }
	    var node = zwspSupported ? elt("span", "\u200b") :
	      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	    node.setAttribute("cm-text", "");
	    return node;
	  }

	  // Feature-detect IE's crummy client rect reporting for bidi text
	  var badBidiRects;
	  function hasBadBidiRects(measure) {
	    if (badBidiRects != null) return badBidiRects;
	    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	    var r0 = range(txt, 0, 1).getBoundingClientRect();
	    var r1 = range(txt, 1, 2).getBoundingClientRect();
	    removeChildren(measure);
	    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
	    return badBidiRects = (r1.right - r0.right < 3);
	  }

	  // See if "".split is the broken IE version, if so, provide an
	  // alternative way to split lines.
	  var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
	    var pos = 0, result = [], l = string.length;
	    while (pos <= l) {
	      var nl = string.indexOf("\n", pos);
	      if (nl == -1) nl = string.length;
	      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	      var rt = line.indexOf("\r");
	      if (rt != -1) {
	        result.push(line.slice(0, rt));
	        pos += rt + 1;
	      } else {
	        result.push(line);
	        pos = nl + 1;
	      }
	    }
	    return result;
	  } : function(string){return string.split(/\r\n?|\n/);};

	  var hasSelection = window.getSelection ? function(te) {
	    try { return te.selectionStart != te.selectionEnd; }
	    catch(e) { return false; }
	  } : function(te) {
	    try {var range = te.ownerDocument.selection.createRange();}
	    catch(e) {}
	    if (!range || range.parentElement() != te) return false;
	    return range.compareEndPoints("StartToEnd", range) != 0;
	  };

	  var hasCopyEvent = (function() {
	    var e = elt("div");
	    if ("oncopy" in e) return true;
	    e.setAttribute("oncopy", "return;");
	    return typeof e.oncopy == "function";
	  })();

	  var badZoomedRects = null;
	  function hasBadZoomedRects(measure) {
	    if (badZoomedRects != null) return badZoomedRects;
	    var node = removeChildrenAndAdd(measure, elt("span", "x"));
	    var normal = node.getBoundingClientRect();
	    var fromRange = range(node, 0, 1).getBoundingClientRect();
	    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
	  }

	  // KEY NAMES

	  var keyNames = CodeMirror.keyNames = {
	    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
	    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	  };
	  (function() {
	    // Number keys
	    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
	    // Alphabetic keys
	    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
	    // Function keys
	    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
	  })();

	  // BIDI HELPERS

	  function iterateBidiSections(order, from, to, f) {
	    if (!order) return f(from, to, "ltr");
	    var found = false;
	    for (var i = 0; i < order.length; ++i) {
	      var part = order[i];
	      if (part.from < to && part.to > from || from == to && part.to == from) {
	        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
	        found = true;
	      }
	    }
	    if (!found) f(from, to, "ltr");
	  }

	  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
	  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

	  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
	  function lineRight(line) {
	    var order = getOrder(line);
	    if (!order) return line.text.length;
	    return bidiRight(lst(order));
	  }

	  function lineStart(cm, lineN) {
	    var line = getLine(cm.doc, lineN);
	    var visual = visualLine(line);
	    if (visual != line) lineN = lineNo(visual);
	    var order = getOrder(visual);
	    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
	    return Pos(lineN, ch);
	  }
	  function lineEnd(cm, lineN) {
	    var merged, line = getLine(cm.doc, lineN);
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line;
	      lineN = null;
	    }
	    var order = getOrder(line);
	    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
	    return Pos(lineN == null ? lineNo(line) : lineN, ch);
	  }
	  function lineStartSmart(cm, pos) {
	    var start = lineStart(cm, pos.line);
	    var line = getLine(cm.doc, start.line);
	    var order = getOrder(line);
	    if (!order || order[0].level == 0) {
	      var firstNonWS = Math.max(0, line.text.search(/\S/));
	      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	      return Pos(start.line, inWS ? 0 : firstNonWS);
	    }
	    return start;
	  }

	  function compareBidiLevel(order, a, b) {
	    var linedir = order[0].level;
	    if (a == linedir) return true;
	    if (b == linedir) return false;
	    return a < b;
	  }
	  var bidiOther;
	  function getBidiPartAt(order, pos) {
	    bidiOther = null;
	    for (var i = 0, found; i < order.length; ++i) {
	      var cur = order[i];
	      if (cur.from < pos && cur.to > pos) return i;
	      if ((cur.from == pos || cur.to == pos)) {
	        if (found == null) {
	          found = i;
	        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
	          if (cur.from != cur.to) bidiOther = found;
	          return i;
	        } else {
	          if (cur.from != cur.to) bidiOther = i;
	          return found;
	        }
	      }
	    }
	    return found;
	  }

	  function moveInLine(line, pos, dir, byUnit) {
	    if (!byUnit) return pos + dir;
	    do pos += dir;
	    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
	    return pos;
	  }

	  // This is needed in order to move 'visually' through bi-directional
	  // text -- i.e., pressing left should make the cursor go left, even
	  // when in RTL text. The tricky part is the 'jumps', where RTL and
	  // LTR text touch each other. This often requires the cursor offset
	  // to move more than one unit, in order to visually move one unit.
	  function moveVisually(line, start, dir, byUnit) {
	    var bidi = getOrder(line);
	    if (!bidi) return moveLogically(line, start, dir, byUnit);
	    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
	    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

	    for (;;) {
	      if (target > part.from && target < part.to) return target;
	      if (target == part.from || target == part.to) {
	        if (getBidiPartAt(bidi, target) == pos) return target;
	        part = bidi[pos += dir];
	        return (dir > 0) == part.level % 2 ? part.to : part.from;
	      } else {
	        part = bidi[pos += dir];
	        if (!part) return null;
	        if ((dir > 0) == part.level % 2)
	          target = moveInLine(line, part.to, -1, byUnit);
	        else
	          target = moveInLine(line, part.from, 1, byUnit);
	      }
	    }
	  }

	  function moveLogically(line, start, dir, byUnit) {
	    var target = start + dir;
	    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
	    return target < 0 || target > line.text.length ? null : target;
	  }

	  // Bidirectional ordering algorithm
	  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	  // that this (partially) implements.

	  // One-char codes used for character types:
	  // L (L):   Left-to-Right
	  // R (R):   Right-to-Left
	  // r (AL):  Right-to-Left Arabic
	  // 1 (EN):  European Number
	  // + (ES):  European Number Separator
	  // % (ET):  European Number Terminator
	  // n (AN):  Arabic Number
	  // , (CS):  Common Number Separator
	  // m (NSM): Non-Spacing Mark
	  // b (BN):  Boundary Neutral
	  // s (B):   Paragraph Separator
	  // t (S):   Segment Separator
	  // w (WS):  Whitespace
	  // N (ON):  Other Neutrals

	  // Returns null if characters are ordered as they appear
	  // (left-to-right), or an array of sections ({from, to, level}
	  // objects) in the order in which they occur visually.
	  var bidiOrdering = (function() {
	    // Character types for codepoints 0 to 0xff
	    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	    // Character types for codepoints 0x600 to 0x6ff
	    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
	    function charType(code) {
	      if (code <= 0xf7) return lowTypes.charAt(code);
	      else if (0x590 <= code && code <= 0x5f4) return "R";
	      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
	      else if (0x6ee <= code && code <= 0x8ac) return "r";
	      else if (0x2000 <= code && code <= 0x200b) return "w";
	      else if (code == 0x200c) return "b";
	      else return "L";
	    }

	    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
	    // Browsers seem to always treat the boundaries of block elements as being L.
	    var outerType = "L";

	    function BidiSpan(level, from, to) {
	      this.level = level;
	      this.from = from; this.to = to;
	    }

	    return function(str) {
	      if (!bidiRE.test(str)) return false;
	      var len = str.length, types = [];
	      for (var i = 0, type; i < len; ++i)
	        types.push(type = charType(str.charCodeAt(i)));

	      // W1. Examine each non-spacing mark (NSM) in the level run, and
	      // change the type of the NSM to the type of the previous
	      // character. If the NSM is at the start of the level run, it will
	      // get the type of sor.
	      for (var i = 0, prev = outerType; i < len; ++i) {
	        var type = types[i];
	        if (type == "m") types[i] = prev;
	        else prev = type;
	      }

	      // W2. Search backwards from each instance of a European number
	      // until the first strong type (R, L, AL, or sor) is found. If an
	      // AL is found, change the type of the European number to Arabic
	      // number.
	      // W3. Change all ALs to R.
	      for (var i = 0, cur = outerType; i < len; ++i) {
	        var type = types[i];
	        if (type == "1" && cur == "r") types[i] = "n";
	        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
	      }

	      // W4. A single European separator between two European numbers
	      // changes to a European number. A single common separator between
	      // two numbers of the same type changes to that type.
	      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
	        var type = types[i];
	        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
	        else if (type == "," && prev == types[i+1] &&
	                 (prev == "1" || prev == "n")) types[i] = prev;
	        prev = type;
	      }

	      // W5. A sequence of European terminators adjacent to European
	      // numbers changes to all European numbers.
	      // W6. Otherwise, separators and terminators change to Other
	      // Neutral.
	      for (var i = 0; i < len; ++i) {
	        var type = types[i];
	        if (type == ",") types[i] = "N";
	        else if (type == "%") {
	          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
	          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	          for (var j = i; j < end; ++j) types[j] = replace;
	          i = end - 1;
	        }
	      }

	      // W7. Search backwards from each instance of a European number
	      // until the first strong type (R, L, or sor) is found. If an L is
	      // found, then change the type of the European number to L.
	      for (var i = 0, cur = outerType; i < len; ++i) {
	        var type = types[i];
	        if (cur == "L" && type == "1") types[i] = "L";
	        else if (isStrong.test(type)) cur = type;
	      }

	      // N1. A sequence of neutrals takes the direction of the
	      // surrounding strong text if the text on both sides has the same
	      // direction. European and Arabic numbers act as if they were R in
	      // terms of their influence on neutrals. Start-of-level-run (sor)
	      // and end-of-level-run (eor) are used at level run boundaries.
	      // N2. Any remaining neutrals take the embedding direction.
	      for (var i = 0; i < len; ++i) {
	        if (isNeutral.test(types[i])) {
	          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
	          var before = (i ? types[i-1] : outerType) == "L";
	          var after = (end < len ? types[end] : outerType) == "L";
	          var replace = before || after ? "L" : "R";
	          for (var j = i; j < end; ++j) types[j] = replace;
	          i = end - 1;
	        }
	      }

	      // Here we depart from the documented algorithm, in order to avoid
	      // building up an actual levels array. Since there are only three
	      // levels (0, 1, 2) in an implementation that doesn't take
	      // explicit embedding into account, we can build up the order on
	      // the fly, without following the level-based algorithm.
	      var order = [], m;
	      for (var i = 0; i < len;) {
	        if (countsAsLeft.test(types[i])) {
	          var start = i;
	          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
	          order.push(new BidiSpan(0, start, i));
	        } else {
	          var pos = i, at = order.length;
	          for (++i; i < len && types[i] != "L"; ++i) {}
	          for (var j = pos; j < i;) {
	            if (countsAsNum.test(types[j])) {
	              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
	              var nstart = j;
	              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
	              order.splice(at, 0, new BidiSpan(2, nstart, j));
	              pos = j;
	            } else ++j;
	          }
	          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
	        }
	      }
	      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	        order[0].from = m[0].length;
	        order.unshift(new BidiSpan(0, 0, m[0].length));
	      }
	      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	        lst(order).to -= m[0].length;
	        order.push(new BidiSpan(0, len - m[0].length, len));
	      }
	      if (order[0].level == 2)
	        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
	      if (order[0].level != lst(order).level)
	        order.push(new BidiSpan(order[0].level, len, len));

	      return order;
	    };
	  })();

	  // THE END

	  CodeMirror.version = "5.19.0";

	  return CodeMirror;
	});


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
	 AngularJS v1.4.12
	 (c) 2010-2015 Google, Inc. http://angularjs.org
	 License: MIT
	*/
	(function(R,U,u){'use strict';function A(a){return function(){var b=arguments[0],d;d="["+(a?a+":":"")+b+"] http://errors.angularjs.org/1.4.12/"+(a?a+"/":"")+b;for(b=1;b<arguments.length;b++){d=d+(1==b?"?":"&")+"p"+(b-1)+"=";var c=encodeURIComponent,e;e=arguments[b];e="function"==typeof e?e.toString().replace(/ \{[\s\S]*$/,""):"undefined"==typeof e?"undefined":"string"!=typeof e?JSON.stringify(e):e;d+=c(e)}return Error(d)}}function Aa(a){if(null==a||Ya(a))return!1;if(L(a)||I(a)||D&&a instanceof D)return!0;
	var b="length"in Object(a)&&a.length;return P(b)&&(0<=b&&(b-1 in a||a instanceof Array)||"function"==typeof a.item)}function p(a,b,d){var c,e;if(a)if(H(a))for(c in a)"prototype"==c||"length"==c||"name"==c||a.hasOwnProperty&&!a.hasOwnProperty(c)||b.call(d,a[c],c,a);else if(L(a)||Aa(a)){var f="object"!==typeof a;c=0;for(e=a.length;c<e;c++)(f||c in a)&&b.call(d,a[c],c,a)}else if(a.forEach&&a.forEach!==p)a.forEach(b,d,a);else if(nc(a))for(c in a)b.call(d,a[c],c,a);else if("function"===typeof a.hasOwnProperty)for(c in a)a.hasOwnProperty(c)&&
	b.call(d,a[c],c,a);else for(c in a)sa.call(a,c)&&b.call(d,a[c],c,a);return a}function oc(a,b,d){for(var c=Object.keys(a).sort(),e=0;e<c.length;e++)b.call(d,a[c[e]],c[e]);return c}function pc(a){return function(b,d){a(d,b)}}function Xd(){return++mb}function Mb(a,b,d){for(var c=a.$$hashKey,e=0,f=b.length;e<f;++e){var g=b[e];if(K(g)||H(g))for(var h=Object.keys(g),k=0,m=h.length;k<m;k++){var l=h[k],n=g[l];d&&K(n)?ea(n)?a[l]=new Date(n.valueOf()):La(n)?a[l]=new RegExp(n):n.nodeName?a[l]=n.cloneNode(!0):
	Nb(n)?a[l]=n.clone():(K(a[l])||(a[l]=L(n)?[]:{}),Mb(a[l],[n],!0)):a[l]=n}}c?a.$$hashKey=c:delete a.$$hashKey;return a}function N(a){return Mb(a,ta.call(arguments,1),!1)}function Yd(a){return Mb(a,ta.call(arguments,1),!0)}function ca(a){return parseInt(a,10)}function Ob(a,b){return N(Object.create(a),b)}function v(){}function Za(a){return a}function ma(a){return function(){return a}}function qc(a){return H(a.toString)&&a.toString!==na}function r(a){return"undefined"===typeof a}function w(a){return"undefined"!==
	typeof a}function K(a){return null!==a&&"object"===typeof a}function nc(a){return null!==a&&"object"===typeof a&&!rc(a)}function I(a){return"string"===typeof a}function P(a){return"number"===typeof a}function ea(a){return"[object Date]"===na.call(a)}function H(a){return"function"===typeof a}function La(a){return"[object RegExp]"===na.call(a)}function Ya(a){return a&&a.window===a}function $a(a){return a&&a.$evalAsync&&a.$watch}function Ma(a){return"boolean"===typeof a}function sc(a){return a&&P(a.length)&&
	Zd.test(na.call(a))}function Nb(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function $d(a){var b={};a=a.split(",");var d;for(d=0;d<a.length;d++)b[a[d]]=!0;return b}function oa(a){return M(a.nodeName||a[0]&&a[0].nodeName)}function ab(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function Na(a,b){function d(a,b){var d=b.$$hashKey,e;if(L(a)){e=0;for(var f=a.length;e<f;e++)b.push(c(a[e]))}else if(nc(a))for(e in a)b[e]=c(a[e]);else if(a&&"function"===typeof a.hasOwnProperty)for(e in a)a.hasOwnProperty(e)&&
	(b[e]=c(a[e]));else for(e in a)sa.call(a,e)&&(b[e]=c(a[e]));d?b.$$hashKey=d:delete b.$$hashKey;return b}function c(a){if(!K(a))return a;var b=e.indexOf(a);if(-1!==b)return f[b];if(Ya(a)||$a(a))throw Ba("cpws");var b=!1,c;L(a)?(c=[],b=!0):sc(a)?c=new a.constructor(a):ea(a)?c=new Date(a.getTime()):La(a)?(c=new RegExp(a.source,a.toString().match(/[^\/]*$/)[0]),c.lastIndex=a.lastIndex):"[object Blob]"===na.call(a)?c=new a.constructor([a],{type:a.type}):H(a.cloneNode)?c=a.cloneNode(!0):(c=Object.create(rc(a)),
	b=!0);e.push(a);f.push(c);return b?d(a,c):c}var e=[],f=[];if(b){if(sc(b))throw Ba("cpta");if(a===b)throw Ba("cpi");L(b)?b.length=0:p(b,function(a,c){"$$hashKey"!==c&&delete b[c]});e.push(a);f.push(b);return d(a,b)}return c(a)}function fa(a,b){if(L(a)){b=b||[];for(var d=0,c=a.length;d<c;d++)b[d]=a[d]}else if(K(a))for(d in b=b||{},a)if("$"!==d.charAt(0)||"$"!==d.charAt(1))b[d]=a[d];return b||a}function la(a,b){if(a===b)return!0;if(null===a||null===b)return!1;if(a!==a&&b!==b)return!0;var d=typeof a,
	c;if(d==typeof b&&"object"==d)if(L(a)){if(!L(b))return!1;if((d=a.length)==b.length){for(c=0;c<d;c++)if(!la(a[c],b[c]))return!1;return!0}}else{if(ea(a))return ea(b)?la(a.getTime(),b.getTime()):!1;if(La(a))return La(b)?a.toString()==b.toString():!1;if($a(a)||$a(b)||Ya(a)||Ya(b)||L(b)||ea(b)||La(b))return!1;d=Z();for(c in a)if("$"!==c.charAt(0)&&!H(a[c])){if(!la(a[c],b[c]))return!1;d[c]=!0}for(c in b)if(!(c in d)&&"$"!==c.charAt(0)&&w(b[c])&&!H(b[c]))return!1;return!0}return!1}function bb(a,b,d){return a.concat(ta.call(b,
	d))}function tc(a,b){var d=2<arguments.length?ta.call(arguments,2):[];return!H(b)||b instanceof RegExp?b:d.length?function(){return arguments.length?b.apply(a,bb(d,arguments,0)):b.apply(a,d)}:function(){return arguments.length?b.apply(a,arguments):b.call(a)}}function ae(a,b){var d=b;"string"===typeof a&&"$"===a.charAt(0)&&"$"===a.charAt(1)?d=u:Ya(b)?d="$WINDOW":b&&U===b?d="$DOCUMENT":$a(b)&&(d="$SCOPE");return d}function cb(a,b){if(r(a))return u;P(b)||(b=b?2:null);return JSON.stringify(a,ae,b)}function uc(a){return I(a)?
	JSON.parse(a):a}function vc(a,b){a=a.replace(be,"");var d=Date.parse("Jan 01, 1970 00:00:00 "+a)/6E4;return isNaN(d)?b:d}function Pb(a,b,d){d=d?-1:1;var c=a.getTimezoneOffset();b=vc(b,c);d*=b-c;a=new Date(a.getTime());a.setMinutes(a.getMinutes()+d);return a}function ua(a){a=D(a).clone();try{a.empty()}catch(b){}var d=D("<div>").append(a).html();try{return a[0].nodeType===Oa?M(d):d.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/,function(a,b){return"<"+M(b)})}catch(c){return M(d)}}function wc(a){try{return decodeURIComponent(a)}catch(b){}}
	function xc(a){var b={};p((a||"").split("&"),function(a){var c,e,f;a&&(e=a=a.replace(/\+/g,"%20"),c=a.indexOf("="),-1!==c&&(e=a.substring(0,c),f=a.substring(c+1)),e=wc(e),w(e)&&(f=w(f)?wc(f):!0,sa.call(b,e)?L(b[e])?b[e].push(f):b[e]=[b[e],f]:b[e]=f))});return b}function Qb(a){var b=[];p(a,function(a,c){L(a)?p(a,function(a){b.push(ha(c,!0)+(!0===a?"":"="+ha(a,!0)))}):b.push(ha(c,!0)+(!0===a?"":"="+ha(a,!0)))});return b.length?b.join("&"):""}function nb(a){return ha(a,!0).replace(/%26/gi,"&").replace(/%3D/gi,
	"=").replace(/%2B/gi,"+")}function ha(a,b){return encodeURIComponent(a).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,b?"%20":"+")}function ce(a,b){var d,c,e=Pa.length;for(c=0;c<e;++c)if(d=Pa[c]+b,I(d=a.getAttribute(d)))return d;return null}function de(a,b){var d,c,e={};p(Pa,function(b){b+="app";!d&&a.hasAttribute&&a.hasAttribute(b)&&(d=a,c=a.getAttribute(b))});p(Pa,function(b){b+="app";var e;!d&&(e=a.querySelector("["+b.replace(":",
	"\\:")+"]"))&&(d=e,c=e.getAttribute(b))});d&&(e.strictDi=null!==ce(d,"strict-di"),b(d,c?[c]:[],e))}function yc(a,b,d){K(d)||(d={});d=N({strictDi:!1},d);var c=function(){a=D(a);if(a.injector()){var c=a[0]===U?"document":ua(a);throw Ba("btstrpd",c.replace(/</,"&lt;").replace(/>/,"&gt;"));}b=b||[];b.unshift(["$provide",function(b){b.value("$rootElement",a)}]);d.debugInfoEnabled&&b.push(["$compileProvider",function(a){a.debugInfoEnabled(!0)}]);b.unshift("ng");c=db(b,d.strictDi);c.invoke(["$rootScope",
	"$rootElement","$compile","$injector",function(a,b,c,d){a.$apply(function(){b.data("$injector",d);c(b)(a)})}]);return c},e=/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;R&&e.test(R.name)&&(d.debugInfoEnabled=!0,R.name=R.name.replace(e,""));if(R&&!f.test(R.name))return c();R.name=R.name.replace(f,"");da.resumeBootstrap=function(a){p(a,function(a){b.push(a)});return c()};H(da.resumeDeferredBootstrap)&&da.resumeDeferredBootstrap()}function ee(){R.name="NG_ENABLE_DEBUG_INFO!"+R.name;R.location.reload()}
	function fe(a){a=da.element(a).injector();if(!a)throw Ba("test");return a.get("$$testability")}function zc(a,b){b=b||"_";return a.replace(ge,function(a,c){return(c?b:"")+a.toLowerCase()})}function he(){var a;if(!Ac){var b=ob();(pa=r(b)?R.jQuery:b?R[b]:u)&&pa.fn.on?(D=pa,N(pa.fn,{scope:Qa.scope,isolateScope:Qa.isolateScope,controller:Qa.controller,injector:Qa.injector,inheritedData:Qa.inheritedData}),a=pa.cleanData,pa.cleanData=function(b){var c;if(Rb)Rb=!1;else for(var e=0,f;null!=(f=b[e]);e++)(c=
	pa._data(f,"events"))&&c.$destroy&&pa(f).triggerHandler("$destroy");a(b)}):D=S;da.element=D;Ac=!0}}function pb(a,b,d){if(!a)throw Ba("areq",b||"?",d||"required");return a}function Ra(a,b,d){d&&L(a)&&(a=a[a.length-1]);pb(H(a),b,"not a function, got "+(a&&"object"===typeof a?a.constructor.name||"Object":typeof a));return a}function Sa(a,b){if("hasOwnProperty"===a)throw Ba("badname",b);}function Bc(a,b,d){if(!b)return a;b=b.split(".");for(var c,e=a,f=b.length,g=0;g<f;g++)c=b[g],a&&(a=(e=a)[c]);return!d&&
	H(a)?tc(e,a):a}function qb(a){for(var b=a[0],d=a[a.length-1],c,e=1;b!==d&&(b=b.nextSibling);e++)if(c||a[e]!==b)c||(c=D(ta.call(a,0,e))),c.push(b);return c||a}function Z(){return Object.create(null)}function ie(a){function b(a,b,c){return a[b]||(a[b]=c())}var d=A("$injector"),c=A("ng");a=b(a,"angular",Object);a.$$minErr=a.$$minErr||A;return b(a,"module",function(){var a={};return function(f,g,h){if("hasOwnProperty"===f)throw c("badname","module");g&&a.hasOwnProperty(f)&&(a[f]=null);return b(a,f,function(){function a(b,
	d,e,f){f||(f=c);return function(){f[e||"push"]([b,d,arguments]);return t}}function b(a,d){return function(b,e){e&&H(e)&&(e.$$moduleName=f);c.push([a,d,arguments]);return t}}if(!g)throw d("nomod",f);var c=[],e=[],G=[],z=a("$injector","invoke","push",e),t={_invokeQueue:c,_configBlocks:e,_runBlocks:G,requires:g,name:f,provider:b("$provide","provider"),factory:b("$provide","factory"),service:b("$provide","service"),value:a("$provide","value"),constant:a("$provide","constant","unshift"),decorator:b("$provide",
	"decorator"),animation:b("$animateProvider","register"),filter:b("$filterProvider","register"),controller:b("$controllerProvider","register"),directive:b("$compileProvider","directive"),config:z,run:function(a){G.push(a);return this}};h&&z(h);return t})}})}function je(a){N(a,{bootstrap:yc,copy:Na,extend:N,merge:Yd,equals:la,element:D,forEach:p,injector:db,noop:v,bind:tc,toJson:cb,fromJson:uc,identity:Za,isUndefined:r,isDefined:w,isString:I,isFunction:H,isObject:K,isNumber:P,isElement:Nb,isArray:L,
	version:ke,isDate:ea,lowercase:M,uppercase:rb,callbacks:{counter:0},getTestability:fe,$$minErr:A,$$csp:Ca,reloadWithDebugInfo:ee});Sb=ie(R);Sb("ng",["ngLocale"],["$provide",function(a){a.provider({$$sanitizeUri:le});a.provider("$compile",Cc).directive({a:me,input:Dc,textarea:Dc,form:ne,script:oe,select:pe,style:qe,option:re,ngBind:se,ngBindHtml:te,ngBindTemplate:ue,ngClass:ve,ngClassEven:we,ngClassOdd:xe,ngCloak:ye,ngController:ze,ngForm:Ae,ngHide:Be,ngIf:Ce,ngInclude:De,ngInit:Ee,ngNonBindable:Fe,
	ngPluralize:Ge,ngRepeat:He,ngShow:Ie,ngStyle:Je,ngSwitch:Ke,ngSwitchWhen:Le,ngSwitchDefault:Me,ngOptions:Ne,ngTransclude:Oe,ngModel:Pe,ngList:Qe,ngChange:Re,pattern:Ec,ngPattern:Ec,required:Fc,ngRequired:Fc,minlength:Gc,ngMinlength:Gc,maxlength:Hc,ngMaxlength:Hc,ngValue:Se,ngModelOptions:Te}).directive({ngInclude:Ue}).directive(sb).directive(Ic);a.provider({$anchorScroll:Ve,$animate:We,$animateCss:Xe,$$animateJs:Ye,$$animateQueue:Ze,$$AnimateRunner:$e,$$animateAsyncRun:af,$browser:bf,$cacheFactory:cf,
	$controller:df,$document:ef,$exceptionHandler:ff,$filter:Jc,$$forceReflow:gf,$interpolate:hf,$interval:jf,$http:kf,$httpParamSerializer:lf,$httpParamSerializerJQLike:mf,$httpBackend:nf,$xhrFactory:of,$location:pf,$log:qf,$parse:rf,$rootScope:sf,$q:tf,$$q:uf,$sce:vf,$sceDelegate:wf,$sniffer:xf,$templateCache:yf,$templateRequest:zf,$$testability:Af,$timeout:Bf,$window:Cf,$$rAF:Df,$$jqLite:Ef,$$HashMap:Ff,$$cookieReader:Gf})}])}function eb(a){return a.replace(Hf,function(a,d,c,e){return e?c.toUpperCase():
	c}).replace(If,"Moz$1")}function Kc(a){a=a.nodeType;return 1===a||!a||9===a}function Lc(a,b){var d,c,e=b.createDocumentFragment(),f=[];if(Tb.test(a)){d=d||e.appendChild(b.createElement("div"));c=(Jf.exec(a)||["",""])[1].toLowerCase();c=ja[c]||ja._default;d.innerHTML=c[1]+a.replace(Kf,"<$1></$2>")+c[2];for(c=c[0];c--;)d=d.lastChild;f=bb(f,d.childNodes);d=e.firstChild;d.textContent=""}else f.push(b.createTextNode(a));e.textContent="";e.innerHTML="";p(f,function(a){e.appendChild(a)});return e}function Mc(a,
	b){var d=a.parentNode;d&&d.replaceChild(b,a);b.appendChild(a)}function S(a){if(a instanceof S)return a;var b;I(a)&&(a=T(a),b=!0);if(!(this instanceof S)){if(b&&"<"!=a.charAt(0))throw Ub("nosel");return new S(a)}if(b){b=U;var d;a=(d=Lf.exec(a))?[b.createElement(d[1])]:(d=Lc(a,b))?d.childNodes:[]}Nc(this,a)}function Vb(a){return a.cloneNode(!0)}function tb(a,b){b||ub(a);if(a.querySelectorAll)for(var d=a.querySelectorAll("*"),c=0,e=d.length;c<e;c++)ub(d[c])}function Oc(a,b,d,c){if(w(c))throw Ub("offargs");
	var e=(c=vb(a))&&c.events,f=c&&c.handle;if(f)if(b){var g=function(b){var c=e[b];w(d)&&ab(c||[],d);w(d)&&c&&0<c.length||(a.removeEventListener(b,f,!1),delete e[b])};p(b.split(" "),function(a){g(a);wb[a]&&g(wb[a])})}else for(b in e)"$destroy"!==b&&a.removeEventListener(b,f,!1),delete e[b]}function ub(a,b){var d=a.ng339,c=d&&fb[d];c&&(b?delete c.data[b]:(c.handle&&(c.events.$destroy&&c.handle({},"$destroy"),Oc(a)),delete fb[d],a.ng339=u))}function vb(a,b){var d=a.ng339,d=d&&fb[d];b&&!d&&(a.ng339=d=++Mf,
	d=fb[d]={events:{},data:{},handle:u});return d}function Wb(a,b,d){if(Kc(a)){var c=w(d),e=!c&&b&&!K(b),f=!b;a=(a=vb(a,!e))&&a.data;if(c)a[b]=d;else{if(f)return a;if(e)return a&&a[b];N(a,b)}}}function xb(a,b){return a.getAttribute?-1<(" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").indexOf(" "+b+" "):!1}function yb(a,b){b&&a.setAttribute&&p(b.split(" "),function(b){a.setAttribute("class",T((" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").replace(" "+T(b)+" "," ")))})}function zb(a,
	b){if(b&&a.setAttribute){var d=(" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ");p(b.split(" "),function(a){a=T(a);-1===d.indexOf(" "+a+" ")&&(d+=a+" ")});a.setAttribute("class",T(d))}}function Nc(a,b){if(b)if(b.nodeType)a[a.length++]=b;else{var d=b.length;if("number"===typeof d&&b.window!==b){if(d)for(var c=0;c<d;c++)a[a.length++]=b[c]}else a[a.length++]=b}}function Pc(a,b){return Ab(a,"$"+(b||"ngController")+"Controller")}function Ab(a,b,d){9==a.nodeType&&(a=a.documentElement);for(b=
	L(b)?b:[b];a;){for(var c=0,e=b.length;c<e;c++)if(w(d=D.data(a,b[c])))return d;a=a.parentNode||11===a.nodeType&&a.host}}function Qc(a){for(tb(a,!0);a.firstChild;)a.removeChild(a.firstChild)}function Xb(a,b){b||tb(a);var d=a.parentNode;d&&d.removeChild(a)}function Nf(a,b){b=b||R;if("complete"===b.document.readyState)b.setTimeout(a);else D(b).on("load",a)}function Rc(a,b){var d=Bb[b.toLowerCase()];return d&&Sc[oa(a)]&&d}function Of(a,b){var d=function(c,d){c.isDefaultPrevented=function(){return c.defaultPrevented};
	var f=b[d||c.type],g=f?f.length:0;if(g){if(r(c.immediatePropagationStopped)){var h=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=!0;c.stopPropagation&&c.stopPropagation();h&&h.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};var k=f.specialHandlerWrapper||Pf;1<g&&(f=fa(f));for(var m=0;m<g;m++)c.isImmediatePropagationStopped()||k(a,c,f[m])}};d.elem=a;return d}function Pf(a,b,d){d.call(a,b)}function Qf(a,b,
	d){var c=b.relatedTarget;c&&(c===a||Rf.call(a,c))||d.call(a,b)}function Ef(){this.$get=function(){return N(S,{hasClass:function(a,b){a.attr&&(a=a[0]);return xb(a,b)},addClass:function(a,b){a.attr&&(a=a[0]);return zb(a,b)},removeClass:function(a,b){a.attr&&(a=a[0]);return yb(a,b)}})}}function Da(a,b){var d=a&&a.$$hashKey;if(d)return"function"===typeof d&&(d=a.$$hashKey()),d;d=typeof a;return d="function"==d||"object"==d&&null!==a?a.$$hashKey=d+":"+(b||Xd)():d+":"+a}function Ta(a,b){if(b){var d=0;this.nextUid=
	function(){return++d}}p(a,this.put,this)}function Sf(a){return(a=a.toString().replace(Tc,"").match(Uc))?"function("+(a[1]||"").replace(/[\s\r\n]+/," ")+")":"fn"}function db(a,b){function d(a){return function(b,c){if(K(b))p(b,pc(a));else return a(b,c)}}function c(a,b){Sa(a,"service");if(H(b)||L(b))b=G.instantiate(b);if(!b.$get)throw Ea("pget",a);return n[a+"Provider"]=b}function e(a,b){return function(){var c=t.invoke(b,this);if(r(c))throw Ea("undef",a);return c}}function f(a,b,d){return c(a,{$get:!1!==
	d?e(a,b):b})}function g(a){pb(r(a)||L(a),"modulesToLoad","not an array");var b=[],c;p(a,function(a){function d(a){var b,c;b=0;for(c=a.length;b<c;b++){var e=a[b],f=G.get(e[0]);f[e[1]].apply(f,e[2])}}if(!l.get(a)){l.put(a,!0);try{I(a)?(c=Sb(a),b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):H(a)?b.push(G.invoke(a)):L(a)?b.push(G.invoke(a)):Ra(a,"module")}catch(e){throw L(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1==e.stack.indexOf(e.message)&&(e=e.message+"\n"+
	e.stack),Ea("modulerr",a,e.stack||e.message||e);}}});return b}function h(a,c){function d(b,e){if(a.hasOwnProperty(b)){if(a[b]===k)throw Ea("cdep",b+" <- "+m.join(" <- "));return a[b]}try{return m.unshift(b),a[b]=k,a[b]=c(b,e)}catch(f){throw a[b]===k&&delete a[b],f;}finally{m.shift()}}function e(a,c,f,g){"string"===typeof f&&(g=f,f=null);var k=[],h=db.$$annotate(a,b,g),m,l,q;l=0;for(m=h.length;l<m;l++){q=h[l];if("string"!==typeof q)throw Ea("itkn",q);k.push(f&&f.hasOwnProperty(q)?f[q]:d(q,g))}L(a)&&
	(a=a[m]);return a.apply(c,k)}return{invoke:e,instantiate:function(a,b,c){var d=Object.create((L(a)?a[a.length-1]:a).prototype||null);a=e(a,d,b,c);return K(a)||H(a)?a:d},get:d,annotate:db.$$annotate,has:function(b){return n.hasOwnProperty(b+"Provider")||a.hasOwnProperty(b)}}}b=!0===b;var k={},m=[],l=new Ta([],!0),n={$provide:{provider:d(c),factory:d(f),service:d(function(a,b){return f(a,["$injector",function(a){return a.instantiate(b)}])}),value:d(function(a,b){return f(a,ma(b),!1)}),constant:d(function(a,
	b){Sa(a,"constant");n[a]=b;z[a]=b}),decorator:function(a,b){var c=G.get(a+"Provider"),d=c.$get;c.$get=function(){var a=t.invoke(d,c);return t.invoke(b,null,{$delegate:a})}}}},G=n.$injector=h(n,function(a,b){da.isString(b)&&m.push(b);throw Ea("unpr",m.join(" <- "));}),z={},t=z.$injector=h(z,function(a,b){var c=G.get(a+"Provider",b);return t.invoke(c.$get,c,u,a)});p(g(a),function(a){a&&t.invoke(a)});return t}function Ve(){var a=!0;this.disableAutoScrolling=function(){a=!1};this.$get=["$window","$location",
	"$rootScope",function(b,d,c){function e(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===oa(a))return b=a,!0});return b}function f(a){if(a){a.scrollIntoView();var c;c=g.yOffset;H(c)?c=c():Nb(c)?(c=c[0],c="fixed"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):P(c)||(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=I(a)?a:d.hash();var b;a?(b=h.getElementById(a))?f(b):(b=e(h.getElementsByName(a)))?f(b):"top"===a&&f(null):
	f(null)}var h=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&""===a||Nf(function(){c.$evalAsync(g)})});return g}]}function gb(a,b){if(!a&&!b)return"";if(!a)return b;if(!b)return a;L(a)&&(a=a.join(" "));L(b)&&(b=b.join(" "));return a+" "+b}function Tf(a){I(a)&&(a=a.split(" "));var b=Z();p(a,function(a){a.length&&(b[a]=!0)});return b}function Fa(a){return K(a)?a:{}}function Uf(a,b,d,c){function e(a){try{a.apply(null,ta.call(arguments,1))}finally{if(t--,0===t)for(;F.length;)try{F.pop()()}catch(b){d.error(b)}}}
	function f(){E=null;g();h()}function g(){a:{try{q=l.state;break a}catch(a){}q=void 0}q=r(q)?null:q;la(q,C)&&(q=C);C=q}function h(){if(x!==k.url()||y!==q)x=k.url(),y=q,p(Q,function(a){a(k.url(),q)})}var k=this,m=a.location,l=a.history,n=a.setTimeout,G=a.clearTimeout,z={};k.isMock=!1;var t=0,F=[];k.$$completeOutstandingRequest=e;k.$$incOutstandingRequestCount=function(){t++};k.notifyWhenNoOutstandingRequests=function(a){0===t?a():F.push(a)};var q,y,x=m.href,V=b.find("base"),E=null;g();y=q;k.url=function(b,
	d,e){r(e)&&(e=null);m!==a.location&&(m=a.location);l!==a.history&&(l=a.history);if(b){var f=y===e;if(x===b&&(!c.history||f))return k;var h=x&&Ga(x)===Ga(b);x=b;y=e;if(!c.history||h&&f){if(!h||E)E=b;d?m.replace(b):h?(d=m,e=b.indexOf("#"),e=-1===e?"":b.substr(e),d.hash=e):m.href=b;m.href!==b&&(E=b)}else l[d?"replaceState":"pushState"](e,"",b),g(),y=q;return k}return E||m.href.replace(/%27/g,"'")};k.state=function(){return q};var Q=[],B=!1,C=null;k.onUrlChange=function(b){if(!B){if(c.history)D(a).on("popstate",
	f);D(a).on("hashchange",f);B=!0}Q.push(b);return b};k.$$applicationDestroyed=function(){D(a).off("hashchange popstate",f)};k.$$checkUrlChange=h;k.baseHref=function(){var a=V.attr("href");return a?a.replace(/^(https?\:)?\/\/[^\/]*/,""):""};k.defer=function(a,b){var c;t++;c=n(function(){delete z[c];e(a)},b||0);z[c]=!0;return c};k.defer.cancel=function(a){return z[a]?(delete z[a],G(a),e(v),!0):!1}}function bf(){this.$get=["$window","$log","$sniffer","$document",function(a,b,d,c){return new Uf(a,c,b,
	d)}]}function cf(){this.$get=function(){function a(a,c){function e(a){a!=n&&(G?G==a&&(G=a.n):G=a,f(a.n,a.p),f(a,n),n=a,n.n=null)}function f(a,b){a!=b&&(a&&(a.p=b),b&&(b.n=a))}if(a in b)throw A("$cacheFactory")("iid",a);var g=0,h=N({},c,{id:a}),k=Z(),m=c&&c.capacity||Number.MAX_VALUE,l=Z(),n=null,G=null;return b[a]={put:function(a,b){if(!r(b)){if(m<Number.MAX_VALUE){var c=l[a]||(l[a]={key:a});e(c)}a in k||g++;k[a]=b;g>m&&this.remove(G.key);return b}},get:function(a){if(m<Number.MAX_VALUE){var b=l[a];
	if(!b)return;e(b)}return k[a]},remove:function(a){if(m<Number.MAX_VALUE){var b=l[a];if(!b)return;b==n&&(n=b.p);b==G&&(G=b.n);f(b.n,b.p);delete l[a]}a in k&&(delete k[a],g--)},removeAll:function(){k=Z();g=0;l=Z();n=G=null},destroy:function(){l=h=k=null;delete b[a]},info:function(){return N({},h,{size:g})}}}var b={};a.info=function(){var a={};p(b,function(b,e){a[e]=b.info()});return a};a.get=function(a){return b[a]};return a}}function yf(){this.$get=["$cacheFactory",function(a){return a("templates")}]}
	function Cc(a,b){function d(a,b,c){var d=/^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/,e=Z();p(a,function(a,f){if(a in l)e[f]=l[a];else{var g=a.match(d);if(!g)throw ga("iscp",b,f,a,c?"controller bindings definition":"isolate scope definition");e[f]={mode:g[1][0],collection:"*"===g[2],optional:"?"===g[3],attrName:g[4]||f};g[4]&&(l[a]=e[f])}});return e}function c(a){var b=a.charAt(0);if(!b||b!==M(b))throw ga("baddir",a);if(a!==a.trim())throw ga("baddir",a);}var e={},f=/^\s*directive\:\s*([\w\-]+)\s+(.*)$/,g=
	/(([\w\-]+)(?:\:([^;]+))?;?)/,h=$d("ngSrc,ngSrcset,src,srcset"),k=/^(?:(\^\^?)?(\?)?(\^\^?)?)?/,m=/^(on[a-z]+|formaction)$/,l=Z();this.directive=function z(b,d){Sa(b,"directive");I(b)?(c(b),pb(d,"directiveFactory"),e.hasOwnProperty(b)||(e[b]=[],a.factory(b+"Directive",["$injector","$exceptionHandler",function(a,c){var d=[];p(e[b],function(e,f){try{var g=a.invoke(e);H(g)?g={compile:ma(g)}:!g.compile&&g.link&&(g.compile=ma(g.link));g.priority=g.priority||0;g.index=f;g.name=g.name||b;g.require=g.require||
	g.controller&&g.name;g.restrict=g.restrict||"EA";g.$$moduleName=e.$$moduleName;d.push(g)}catch(h){c(h)}});return d}])),e[b].push(d)):p(b,pc(z));return this};this.aHrefSanitizationWhitelist=function(a){return w(a)?(b.aHrefSanitizationWhitelist(a),this):b.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(a){return w(a)?(b.imgSrcSanitizationWhitelist(a),this):b.imgSrcSanitizationWhitelist()};var n=!0;this.debugInfoEnabled=function(a){return w(a)?(n=a,this):n};this.$get=["$injector",
	"$interpolate","$exceptionHandler","$templateRequest","$parse","$controller","$rootScope","$sce","$animate","$$sanitizeUri",function(a,b,c,l,y,x,V,E,Q,B){function C(a,b){try{a.addClass(b)}catch(c){}}function J(a,b,c,d,e){a instanceof D||(a=D(a));for(var f=/\S+/,g=0,h=a.length;g<h;g++){var k=a[g];k.nodeType===Oa&&k.nodeValue.match(f)&&Mc(k,a[g]=U.createElement("span"))}var m=W(a,b,a,c,d,e);J.$$addScopeClass(a);var l=null;return function(b,c,d){pb(b,"scope");e&&e.needsNewScope&&(b=b.$parent.$new());
	d=d||{};var f=d.parentBoundTranscludeFn,g=d.transcludeControllers;d=d.futureParentElement;f&&f.$$boundTransclude&&(f=f.$$boundTransclude);l||(l=(d=d&&d[0])?"foreignobject"!==oa(d)&&d.toString().match(/SVG/)?"svg":"html":"html");d="html"!==l?D(Yb(l,D("<div>").append(a).html())):c?Qa.clone.call(a):a;if(g)for(var h in g)d.data("$"+h+"Controller",g[h].instance);J.$$addScopeInfo(d,b);c&&c(d,b);m&&m(b,d,d,f);return d}}function W(a,b,c,d,e,f){function g(a,c,d,e){var f,k,m,l,n,B,F;if(q)for(F=Array(c.length),
	l=0;l<h.length;l+=3)f=h[l],F[f]=c[f];else F=c;l=0;for(n=h.length;l<n;)k=F[h[l++]],c=h[l++],f=h[l++],c?(c.scope?(m=a.$new(),J.$$addScopeInfo(D(k),m)):m=a,B=c.transcludeOnThisElement?O(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?O(a,b):null,c(f,m,k,d,B)):f&&f(a,k.childNodes,u,e)}for(var h=[],k,m,l,n,q,B=0;B<a.length;B++){k=new da;m=ia(a[B],[],k,0===B?d:u,e);(f=m.length?$(m,a[B],k,b,c,null,[],[],f):null)&&f.scope&&J.$$addScopeClass(k.$$element);k=f&&f.terminal||!(l=a[B].childNodes)||!l.length?
	null:W(l,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||k)h.push(B,f,k),n=!0,q=q||f;f=null}return n?g:null}function O(a,b,c){return function(d,e,f,g,h){d||(d=a.$new(!1,h),d.$$transcluded=!0);return b(d,e,{parentBoundTranscludeFn:c,transcludeControllers:f,futureParentElement:g})}}function ia(a,b,c,d,e){var h=c.$attr,k;switch(a.nodeType){case 1:qa(b,va(oa(a)),"E",d,e);for(var m,l,n,q=a.attributes,B=0,F=q&&q.length;B<F;B++){var x=!1,J=!1;m=q[B];k=m.name;l=T(m.value);m=
	va(k);if(n=ja.test(m))k=k.replace(Wc,"").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()});(m=m.match(ka))&&A(m[1])&&(x=k,J=k.substr(0,k.length-5)+"end",k=k.substr(0,k.length-6));m=va(k.toLowerCase());h[m]=k;if(n||!c.hasOwnProperty(m))c[m]=l,Rc(a,m)&&(c[m]=!0);X(a,b,l,m,n);qa(b,m,"A",d,e,x,J)}a=a.className;K(a)&&(a=a.animVal);if(I(a)&&""!==a)for(;k=g.exec(a);)m=va(k[2]),qa(b,m,"C",d,e)&&(c[m]=T(k[3])),a=a.substr(k.index+k[0].length);break;case Oa:if(11===Ha)for(;a.parentNode&&a.nextSibling&&
	a.nextSibling.nodeType===Oa;)a.nodeValue+=a.nextSibling.nodeValue,a.parentNode.removeChild(a.nextSibling);P(b,a.nodeValue);break;case 8:try{if(k=f.exec(a.nodeValue))m=va(k[1]),qa(b,m,"M",d,e)&&(c[m]=T(k[2]))}catch(y){}}b.sort(wa);return b}function Ua(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ga("uterdir",b,c);1==a.nodeType&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return D(d)}function s(a,b,c){return function(d,
	e,f,g,k){e=Ua(e[0],b,c);return a(d,e,f,g,k)}}function $(a,b,d,e,f,g,h,m,l){function n(a,b,c,d){if(a){c&&(a=s(a,c,d));a.require=r.require;a.directiveName=w;if(C===r||r.$$isolateScope)a=ba(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=s(b,c,d));b.require=r.require;b.directiveName=w;if(C===r||r.$$isolateScope)b=ba(b,{isolateScope:!0});m.push(b)}}function q(a,b,c,d){var e;if(I(b)){var f=b.match(k);b=b.substring(f[0].length);var g=f[1]||f[3],f="?"===f[2];"^^"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;e||
	(d="$"+b+"Controller",e=g?c.inheritedData(d):c.data(d));if(!e&&!f)throw ga("ctreq",b,a);}else if(L(b))for(e=[],g=0,f=b.length;g<f;g++)e[g]=q(a,b[g],c,d);return e||null}function B(a,b,c,d,e,f){var g=Z(),h;for(h in d){var k=d[h],m={$scope:k===C||k.$$isolateScope?e:f,$element:a,$attrs:b,$transclude:c},l=k.controller;"@"==l&&(l=b[k.name]);m=x(l,m,!0,k.controllerAs);g[k.name]=m;a.data("$"+k.name+"Controller",m.instance)}return g}function y(a,c,e,f,g){function k(a,b,c){var d;$a(a)||(c=b,b=a,a=u);Q&&(d=
	x);c||(c=Q?E.parent():E);return g(a,b,d,c,Ua)}var l,n,F,x,O,E,ia;b===e?(f=d,E=d.$$element):(E=D(e),f=new da(E,d));F=c;C?n=c.$new(!0):t&&(F=c.$parent);g&&(O=k,O.$$boundTransclude=g);z&&(x=B(E,f,O,z,n,c));C&&(J.$$addScopeInfo(E,n,!0,!(W&&(W===C||W===C.$$originalDirective))),J.$$addScopeClass(E,!0),n.$$isolateBindings=C.$$isolateBindings,(ia=aa(c,f,n,n.$$isolateBindings,C))&&n.$on("$destroy",ia));for(var Vc in x){ia=z[Vc];var V=x[Vc],p=ia.$$bindings.bindToController;V.identifier&&p&&(l=aa(F,f,V.instance,
	p,ia));var r=V();r!==V.instance&&(V.instance=r,E.data("$"+ia.name+"Controller",r),l&&l(),l=aa(F,f,V.instance,p,ia))}A=0;for(M=h.length;A<M;A++)l=h[A],ca(l,l.isolateScope?n:c,E,f,l.require&&q(l.directiveName,l.require,E,x),O);var Ua=c;C&&(C.template||null===C.templateUrl)&&(Ua=n);a&&a(Ua,e.childNodes,u,g);for(A=m.length-1;0<=A;A--)l=m[A],ca(l,l.isolateScope?n:c,E,f,l.require&&q(l.directiveName,l.require,E,x),O)}l=l||{};for(var O=-Number.MAX_VALUE,t=l.newScopeDirective,z=l.controllerDirectives,C=l.newIsolateScopeDirective,
	W=l.templateDirective,E=l.nonTlbTranscludeDirective,V=!1,p=!1,Q=l.hasElementTranscludeDirective,$=d.$$element=D(b),r,w,v,qa=e,wa,A=0,M=a.length;A<M;A++){r=a[A];var N=r.$$start,P=r.$$end;N&&($=Ua(b,N,P));v=u;if(O>r.priority)break;if(v=r.scope)r.templateUrl||(K(v)?(Va("new/isolated scope",C||t,r,$),C=r):Va("new/isolated scope",C,r,$)),t=t||r;w=r.name;!r.templateUrl&&r.controller&&(v=r.controller,z=z||Z(),Va("'"+w+"' controller",z[w],r,$),z[w]=r);if(v=r.transclude)V=!0,r.$$tlb||(Va("transclusion",E,
	r,$),E=r),"element"==v?(Q=!0,O=r.priority,v=$,$=d.$$element=D(U.createComment(" "+w+": "+d[w]+" ")),b=$[0],Y(f,ta.call(v,0),b),qa=J(v,e,O,g&&g.name,{nonTlbTranscludeDirective:E})):(v=D(Vb(b)).contents(),$.empty(),qa=J(v,e,u,u,{needsNewScope:r.$$isolateScope||r.$$newScope}));if(r.template)if(p=!0,Va("template",W,r,$),W=r,v=H(r.template)?r.template($,d):r.template,v=ha(v),r.replace){g=r;v=Tb.test(v)?Xc(Yb(r.templateNamespace,T(v))):[];b=v[0];if(1!=v.length||1!==b.nodeType)throw ga("tplrt",w,"");Y(f,
	$,b);v={$attr:{}};var S=ia(b,[],v),Vf=a.splice(A+1,a.length-(A+1));(C||t)&&Yc(S,C,t);a=a.concat(S).concat(Vf);R(d,v);M=a.length}else $.html(v);if(r.templateUrl)p=!0,Va("template",W,r,$),W=r,r.replace&&(g=r),y=Wf(a.splice(A,a.length-A),$,d,f,V&&qa,h,m,{controllerDirectives:z,newScopeDirective:t!==r&&t,newIsolateScopeDirective:C,templateDirective:W,nonTlbTranscludeDirective:E}),M=a.length;else if(r.compile)try{wa=r.compile($,d,qa),H(wa)?n(null,wa,N,P):wa&&n(wa.pre,wa.post,N,P)}catch(X){c(X,ua($))}r.terminal&&
	(y.terminal=!0,O=Math.max(O,r.priority))}y.scope=t&&!0===t.scope;y.transcludeOnThisElement=V;y.templateOnThisElement=p;y.transclude=qa;l.hasElementTranscludeDirective=Q;return y}function Yc(a,b,c){for(var d=0,e=a.length;d<e;d++)a[d]=Ob(a[d],{$$isolateScope:b,$$newScope:c})}function qa(b,f,g,k,h,m,l){if(f===h)return null;h=null;if(e.hasOwnProperty(f)){var n;f=a.get(f+"Directive");for(var q=0,B=f.length;q<B;q++)try{if(n=f[q],(r(k)||k>n.priority)&&-1!=n.restrict.indexOf(g)){m&&(n=Ob(n,{$$start:m,$$end:l}));
	if(!n.$$bindings){var x=n,J=n,y=n.name,O={isolateScope:null,bindToController:null};K(J.scope)&&(!0===J.bindToController?(O.bindToController=d(J.scope,y,!0),O.isolateScope={}):O.isolateScope=d(J.scope,y,!1));K(J.bindToController)&&(O.bindToController=d(J.bindToController,y,!0));if(K(O.bindToController)){var t=J.controller,C=J.controllerAs;if(!t)throw ga("noctrl",y);var E;a:{var J=t,W=C;if(W&&I(W))E=W;else{if(I(J)){var ia=Zc.exec(J);if(ia){E=ia[3];break a}}E=void 0}}if(!E)throw ga("noident",y);}var V=
	x.$$bindings=O;K(V.isolateScope)&&(n.$$isolateBindings=V.isolateScope)}b.push(n);h=n}}catch(p){c(p)}}return h}function A(b){if(e.hasOwnProperty(b))for(var c=a.get(b+"Directive"),d=0,f=c.length;d<f;d++)if(b=c[d],b.multiElement)return!0;return!1}function R(a,b){var c=b.$attr,d=a.$attr,e=a.$$element;p(a,function(d,e){"$"!=e.charAt(0)&&(b[e]&&b[e]!==d&&(d+=("style"===e?";":" ")+b[e]),a.$set(e,d,!0,c[e]))});p(b,function(b,f){"class"==f?(C(e,b),a["class"]=(a["class"]?a["class"]+" ":"")+b):"style"==f?(e.attr("style",
	e.attr("style")+";"+b),a.style=(a.style?a.style+";":"")+b):"$"==f.charAt(0)||a.hasOwnProperty(f)||(a[f]=b,d[f]=c[f])})}function Wf(a,b,c,d,e,f,g,k){var h=[],m,n,B=b[0],F=a.shift(),x=Ob(F,{templateUrl:null,transclude:null,replace:null,$$originalDirective:F}),J=H(F.templateUrl)?F.templateUrl(b,c):F.templateUrl,y=F.templateNamespace;b.empty();l(J).then(function(l){var q,t;l=ha(l);if(F.replace){l=Tb.test(l)?Xc(Yb(y,T(l))):[];q=l[0];if(1!=l.length||1!==q.nodeType)throw ga("tplrt",F.name,J);l={$attr:{}};
	Y(d,b,q);var z=ia(q,[],l);K(F.scope)&&Yc(z,!0);a=z.concat(a);R(c,l)}else q=B,b.html(l);a.unshift(x);m=$(a,q,c,e,b,F,f,g,k);p(d,function(a,c){a==q&&(d[c]=b[0])});for(n=W(b[0].childNodes,e);h.length;){l=h.shift();t=h.shift();var E=h.shift(),V=h.shift(),z=b[0];if(!l.$$destroyed){if(t!==B){var Q=t.className;k.hasElementTranscludeDirective&&F.replace||(z=Vb(q));Y(E,D(t),z);C(D(z),Q)}t=m.transcludeOnThisElement?O(l,m.transclude,V):V;m(n,l,z,d,t)}}h=null});return function(a,b,c,d,e){a=e;b.$$destroyed||(h?
	h.push(b,c,d,a):(m.transcludeOnThisElement&&(a=O(b,m.transclude,e)),m(n,b,c,d,a)))}}function wa(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function Va(a,b,c,d){function e(a){return a?" (module: "+a+")":""}if(b)throw ga("multidir",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,ua(d));}function P(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&J.$$addBindingClass(a);return function(a,c){var e=
	c.parent();b||J.$$addBindingClass(e);J.$$addBindingInfo(e,d.expressions);a.$watch(d,function(a){c[0].nodeValue=a})}}})}function Yb(a,b){a=M(a||"html");switch(a){case "svg":case "math":var c=U.createElement("div");c.innerHTML="<"+a+">"+b+"</"+a+">";return c.childNodes[0].childNodes;default:return b}}function S(a,b){if("srcdoc"==b)return E.HTML;var c=oa(a);if("xlinkHref"==b||"form"==c&&"action"==b||"img"!=c&&("src"==b||"ngSrc"==b))return E.RESOURCE_URL}function X(a,c,d,e,f){var g=S(a,e);f=h[e]||f;var k=
	b(d,!0,g,f);if(k){if("multiple"===e&&"select"===oa(a))throw ga("selmulti",ua(a));c.push({priority:100,compile:function(){return{pre:function(a,c,h){c=h.$$observers||(h.$$observers=Z());if(m.test(e))throw ga("nodomevents");var l=h[e];l!==d&&(k=l&&b(l,!0,g,f),d=l);k&&(h[e]=k(a),(c[e]||(c[e]=[])).$$inter=!0,(h.$$observers&&h.$$observers[e].$$scope||a).$watch(k,function(a,b){"class"===e&&a!=b?h.$updateClass(a,b):h.$set(e,a)}))}}}})}}function Y(a,b,c){var d=b[0],e=b.length,f=d.parentNode,g,h;if(a)for(g=
	0,h=a.length;g<h;g++)if(a[g]==d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=U.createDocumentFragment();a.appendChild(d);D.hasData(d)&&(D.data(c,D.data(d)),pa?(Rb=!0,pa.cleanData([d])):delete D.cache[d[D.expando]]);d=1;for(e=b.length;d<e;d++)f=b[d],D(f).remove(),a.appendChild(f),delete b[d];b[0]=c;b.length=1}function ba(a,b){return N(function(){return a.apply(null,arguments)},a,b)}function ca(a,
	b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,ua(d))}}function aa(a,c,d,e,f){var g=[];p(e,function(e,h){var k=e.attrName,m=e.optional,l,n,q,B;switch(e.mode){case "@":m||sa.call(c,k)||(d[h]=c[k]=void 0);c.$observe(k,function(a){I(a)&&(d[h]=a)});c.$$observers[k].$$scope=a;l=c[k];I(l)?d[h]=b(l)(a):Ma(l)&&(d[h]=l);break;case "=":if(!sa.call(c,k)){if(m)break;c[k]=void 0}if(m&&!c[k])break;n=y(c[k]);B=n.literal?la:function(a,b){return a===b||a!==a&&b!==b};q=n.assign||function(){l=d[h]=n(a);throw ga("nonassign",
	c[k],k,f.name);};l=d[h]=n(a);m=function(b){B(b,d[h])||(B(b,l)?q(a,b=d[h]):d[h]=b);return l=b};m.$stateful=!0;m=e.collection?a.$watchCollection(c[k],m):a.$watch(y(c[k],m),null,n.literal);g.push(m);break;case "&":n=c.hasOwnProperty(k)?y(c[k]):v;if(n===v&&m)break;d[h]=function(b){return n(a,b)}}});return g.length&&function(){for(var a=0,b=g.length;a<b;++a)g[a]()}}var da=function(a,b){if(b){var c=Object.keys(b),d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a};
	da.prototype={$normalize:va,$addClass:function(a){a&&0<a.length&&Q.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&Q.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=$c(a,b);c&&c.length&&Q.addClass(this.$$element,c);(c=$c(b,a))&&c.length&&Q.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=Rc(this.$$element[0],a),g=ad[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=zc(a,"-"));f=
	oa(this.$$element);if("a"===f&&"href"===a||"img"===f&&"src"===a)this[a]=b=B(b,"src"===a);else if("img"===f&&"srcset"===a&&w(b)){for(var f="",g=T(b),k=/(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/,k=/\s/.test(g)?k:/(,)/,g=g.split(k),k=Math.floor(g.length/2),m=0;m<k;m++)var l=2*m,f=f+B(T(g[l]),!0),f=f+(" "+T(g[l+1]));g=T(g[2*m]).split(/\s/);f+=B(T(g[0]),!0);2===g.length&&(f+=" "+T(g[1]));this[a]=b=f}!1!==d&&(null===b||r(b)?this.$$element.removeAttr(e):this.$$element.attr(e,b));(a=this.$$observers)&&p(a[h],
	function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=Z()),e=d[a]||(d[a]=[]);e.push(b);V.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||r(c[a])||b(c[a])});return function(){ab(e,b)}}};var ea=b.startSymbol(),fa=b.endSymbol(),ha="{{"==ea&&"}}"==fa?Za:function(a){return a.replace(/\{\{/g,ea).replace(/}}/g,fa)},ja=/^ngAttr[A-Z]/,ka=/^(.+)Start$/;J.$$addBindingInfo=n?function(a,b){var c=a.data("$binding")||[];L(b)?c=c.concat(b):c.push(b);a.data("$binding",
	c)}:v;J.$$addBindingClass=n?function(a){C(a,"ng-binding")}:v;J.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:v;J.$$addScopeClass=n?function(a,b){C(a,b?"ng-isolate-scope":"ng-scope")}:v;return J}]}function va(a){return eb(a.replace(Wc,""))}function $c(a,b){var d="",c=a.split(/\s+/),e=b.split(/\s+/),f=0;a:for(;f<c.length;f++){for(var g=c[f],h=0;h<e.length;h++)if(g==e[h])continue a;d+=(0<d.length?" ":"")+g}return d}function Xc(a){a=D(a);var b=a.length;
	if(1>=b)return a;for(;b--;)8===a[b].nodeType&&Xf.call(a,b,1);return a}function df(){var a={},b=!1;this.register=function(b,c){Sa(b,"controller");K(b)?N(a,b):a[b]=c};this.allowGlobals=function(){b=!0};this.$get=["$injector","$window",function(d,c){function e(a,b,c,d){if(!a||!K(a.$scope))throw A("$controller")("noscp",d,b);a.$scope[b]=c}return function(f,g,h,k){var m,l,n;h=!0===h;k&&I(k)&&(n=k);if(I(f)){k=f.match(Zc);if(!k)throw Yf("ctrlfmt",f);l=k[1];n=n||k[3];f=a.hasOwnProperty(l)?a[l]:Bc(g.$scope,
	l,!0)||(b?Bc(c,l,!0):u);Ra(f,l,!0)}if(h)return h=(L(f)?f[f.length-1]:f).prototype,m=Object.create(h||null),n&&e(g,n,m,l||f.name),N(function(){var a=d.invoke(f,m,g,l);a!==m&&(K(a)||H(a))&&(m=a,n&&e(g,n,m,l||f.name));return m},{instance:m,identifier:n});m=d.instantiate(f,g,l);n&&e(g,n,m,l||f.name);return m}}]}function ef(){this.$get=["$window",function(a){return D(a.document)}]}function ff(){this.$get=["$log",function(a){return function(b,d){a.error.apply(a,arguments)}}]}function Zb(a){return K(a)?
	ea(a)?a.toISOString():cb(a):a}function lf(){this.$get=function(){return function(a){if(!a)return"";var b=[];oc(a,function(a,c){null===a||r(a)||(L(a)?p(a,function(a,d){b.push(ha(c)+"="+ha(Zb(a)))}):b.push(ha(c)+"="+ha(Zb(a))))});return b.join("&")}}}function mf(){this.$get=function(){return function(a){function b(a,e,f){null===a||r(a)||(L(a)?p(a,function(a,c){b(a,e+"["+(K(a)?c:"")+"]")}):K(a)&&!ea(a)?oc(a,function(a,c){b(a,e+(f?"":"[")+c+(f?"":"]"))}):d.push(ha(e)+"="+ha(Zb(a))))}if(!a)return"";var d=
	[];b(a,"",!0);return d.join("&")}}}function $b(a,b){if(I(a)){var d=a.replace(Zf,"").trim();if(d){var c=b("Content-Type");(c=c&&0===c.indexOf(bd))||(c=(c=d.match($f))&&ag[c[0]].test(d));c&&(a=uc(d))}}return a}function cd(a){var b=Z(),d;I(a)?p(a.split("\n"),function(a){d=a.indexOf(":");var e=M(T(a.substr(0,d)));a=T(a.substr(d+1));e&&(b[e]=b[e]?b[e]+", "+a:a)}):K(a)&&p(a,function(a,d){var f=M(d),g=T(a);f&&(b[f]=b[f]?b[f]+", "+g:g)});return b}function dd(a){var b;return function(d){b||(b=cd(a));return d?
	(d=b[M(d)],void 0===d&&(d=null),d):b}}function ed(a,b,d,c){if(H(c))return c(a,b,d);p(c,function(c){a=c(a,b,d)});return a}function kf(){var a=this.defaults={transformResponse:[$b],transformRequest:[function(a){return K(a)&&"[object File]"!==na.call(a)&&"[object Blob]"!==na.call(a)&&"[object FormData]"!==na.call(a)?cb(a):a}],headers:{common:{Accept:"application/json, text/plain, */*"},post:fa(ac),put:fa(ac),patch:fa(ac)},xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",paramSerializer:"$httpParamSerializer"},
	b=!1;this.useApplyAsync=function(a){return w(a)?(b=!!a,this):b};var d=!0;this.useLegacyPromiseExtensions=function(a){return w(a)?(d=!!a,this):d};var c=this.interceptors=[];this.$get=["$httpBackend","$$cookieReader","$cacheFactory","$rootScope","$q","$injector",function(e,f,g,h,k,m){function l(b){function c(a){var b=N({},a);b.data=ed(a.data,a.headers,a.status,f.transformResponse);a=a.status;return 200<=a&&300>a?b:k.reject(b)}function e(a,b){var c,d={};p(a,function(a,e){H(a)?(c=a(b),null!=c&&(d[e]=
	c)):d[e]=a});return d}if(!da.isObject(b))throw A("$http")("badreq",b);if(!I(b.url))throw A("$http")("badreq",b.url);var f=N({method:"get",transformRequest:a.transformRequest,transformResponse:a.transformResponse,paramSerializer:a.paramSerializer},b);f.headers=function(b){var c=a.headers,d=N({},b.headers),f,g,h,c=N({},c.common,c[M(b.method)]);a:for(f in c){g=M(f);for(h in d)if(M(h)===g)continue a;d[f]=c[f]}return e(d,fa(b))}(b);f.method=rb(f.method);f.paramSerializer=I(f.paramSerializer)?m.get(f.paramSerializer):
	f.paramSerializer;var g=[function(b){var d=b.headers,e=ed(b.data,dd(d),u,b.transformRequest);r(e)&&p(d,function(a,b){"content-type"===M(b)&&delete d[b]});r(b.withCredentials)&&!r(a.withCredentials)&&(b.withCredentials=a.withCredentials);return n(b,e).then(c,c)},u],h=k.when(f);for(p(t,function(a){(a.request||a.requestError)&&g.unshift(a.request,a.requestError);(a.response||a.responseError)&&g.push(a.response,a.responseError)});g.length;){b=g.shift();var l=g.shift(),h=h.then(b,l)}d?(h.success=function(a){Ra(a,
	"fn");h.then(function(b){a(b.data,b.status,b.headers,f)});return h},h.error=function(a){Ra(a,"fn");h.then(null,function(b){a(b.data,b.status,b.headers,f)});return h}):(h.success=fd("success"),h.error=fd("error"));return h}function n(c,d){function g(a,c,d,e){function f(){m(c,a,d,e)}C&&(200<=a&&300>a?C.put(O,[a,c,cd(d),e]):C.remove(O));b?h.$applyAsync(f):(f(),h.$$phase||h.$apply())}function m(a,b,d,e){b=-1<=b?b:0;(200<=b&&300>b?p.resolve:p.reject)({data:a,status:b,headers:dd(d),config:c,statusText:e})}
	function n(a){m(a.data,a.status,fa(a.headers()),a.statusText)}function t(){var a=l.pendingRequests.indexOf(c);-1!==a&&l.pendingRequests.splice(a,1)}var p=k.defer(),B=p.promise,C,J,W=c.headers,O=G(c.url,c.paramSerializer(c.params));l.pendingRequests.push(c);B.then(t,t);!c.cache&&!a.cache||!1===c.cache||"GET"!==c.method&&"JSONP"!==c.method||(C=K(c.cache)?c.cache:K(a.cache)?a.cache:z);C&&(J=C.get(O),w(J)?J&&H(J.then)?J.then(n,n):L(J)?m(J[1],J[0],fa(J[2]),J[3]):m(J,200,{},"OK"):C.put(O,B));r(J)&&((J=
	gd(c.url)?f()[c.xsrfCookieName||a.xsrfCookieName]:u)&&(W[c.xsrfHeaderName||a.xsrfHeaderName]=J),e(c.method,O,d,g,W,c.timeout,c.withCredentials,c.responseType));return B}function G(a,b){0<b.length&&(a+=(-1==a.indexOf("?")?"?":"&")+b);return a}var z=g("$http");a.paramSerializer=I(a.paramSerializer)?m.get(a.paramSerializer):a.paramSerializer;var t=[];p(c,function(a){t.unshift(I(a)?m.get(a):m.invoke(a))});l.pendingRequests=[];(function(a){p(arguments,function(a){l[a]=function(b,c){return l(N({},c||{},
	{method:a,url:b}))}})})("get","delete","head","jsonp");(function(a){p(arguments,function(a){l[a]=function(b,c,d){return l(N({},d||{},{method:a,url:b,data:c}))}})})("post","put","patch");l.defaults=a;return l}]}function of(){this.$get=function(){return function(){return new R.XMLHttpRequest}}}function nf(){this.$get=["$browser","$window","$document","$xhrFactory",function(a,b,d,c){return bg(a,c,a.defer,b.angular.callbacks,d[0])}]}function bg(a,b,d,c,e){function f(a,b,d){var f=e.createElement("script"),
	l=null;f.type="text/javascript";f.src=a;f.async=!0;l=function(a){f.removeEventListener("load",l,!1);f.removeEventListener("error",l,!1);e.body.removeChild(f);f=null;var g=-1,z="unknown";a&&("load"!==a.type||c[b].called||(a={type:"error"}),z=a.type,g="error"===a.type?404:200);d&&d(g,z)};f.addEventListener("load",l,!1);f.addEventListener("error",l,!1);e.body.appendChild(f);return l}return function(e,h,k,m,l,n,G,z){function t(){y&&y();x&&x.abort()}function F(b,c,e,f,g){w(E)&&d.cancel(E);y=x=null;b(c,
	e,f,g);a.$$completeOutstandingRequest(v)}a.$$incOutstandingRequestCount();h=h||a.url();if("jsonp"==M(e)){var q="_"+(c.counter++).toString(36);c[q]=function(a){c[q].data=a;c[q].called=!0};var y=f(h.replace("JSON_CALLBACK","angular.callbacks."+q),q,function(a,b){F(m,a,c[q].data,"",b);c[q]=v})}else{var x=b(e,h);x.open(e,h,!0);p(l,function(a,b){w(a)&&x.setRequestHeader(b,a)});x.onload=function(){var a=x.statusText||"",b="response"in x?x.response:x.responseText,c=1223===x.status?204:x.status;0===c&&(c=
	b?200:"file"==xa(h).protocol?404:0);F(m,c,b,x.getAllResponseHeaders(),a)};e=function(){F(m,-1,null,null,"")};x.onerror=e;x.onabort=e;G&&(x.withCredentials=!0);if(z)try{x.responseType=z}catch(V){if("json"!==z)throw V;}x.send(r(k)?null:k)}if(0<n)var E=d(t,n);else n&&H(n.then)&&n.then(t)}}function hf(){var a="{{",b="}}";this.startSymbol=function(b){return b?(a=b,this):a};this.endSymbol=function(a){return a?(b=a,this):b};this.$get=["$parse","$exceptionHandler","$sce",function(d,c,e){function f(a){return"\\\\\\"+
	a}function g(c){return c.replace(l,a).replace(n,b)}function h(f,h,l,n){function q(a){try{var b=a;a=l?e.getTrusted(l,b):e.valueOf(b);var d;if(n&&!w(a))d=a;else if(null==a)d="";else{switch(typeof a){case "string":break;case "number":a=""+a;break;default:a=cb(a)}d=a}return d}catch(g){c(Ia.interr(f,g))}}n=!!n;for(var y,x,p=0,E=[],Q=[],B=f.length,C=[],J=[];p<B;)if(-1!=(y=f.indexOf(a,p))&&-1!=(x=f.indexOf(b,y+k)))p!==y&&C.push(g(f.substring(p,y))),p=f.substring(y+k,x),E.push(p),Q.push(d(p,q)),p=x+m,J.push(C.length),
	C.push("");else{p!==B&&C.push(g(f.substring(p)));break}l&&1<C.length&&Ia.throwNoconcat(f);if(!h||E.length){var W=function(a){for(var b=0,c=E.length;b<c;b++){if(n&&r(a[b]))return;C[J[b]]=a[b]}return C.join("")};return N(function(a){var b=0,d=E.length,e=Array(d);try{for(;b<d;b++)e[b]=Q[b](a);return W(e)}catch(g){c(Ia.interr(f,g))}},{exp:f,expressions:E,$$watchDelegate:function(a,b){var c;return a.$watchGroup(Q,function(d,e){var f=W(d);H(b)&&b.call(this,f,d!==e?c:f,a);c=f})}})}}var k=a.length,m=b.length,
	l=new RegExp(a.replace(/./g,f),"g"),n=new RegExp(b.replace(/./g,f),"g");h.startSymbol=function(){return a};h.endSymbol=function(){return b};return h}]}function jf(){this.$get=["$rootScope","$window","$q","$$q",function(a,b,d,c){function e(e,h,k,m){var l=4<arguments.length,n=l?ta.call(arguments,4):[],G=b.setInterval,z=b.clearInterval,t=0,F=w(m)&&!m,q=(F?c:d).defer(),y=q.promise;k=w(k)?k:0;y.then(null,null,l?function(){e.apply(null,n)}:e);y.$$intervalId=G(function(){q.notify(t++);0<k&&t>=k&&(q.resolve(t),
	z(y.$$intervalId),delete f[y.$$intervalId]);F||a.$apply()},h);f[y.$$intervalId]=q;return y}var f={};e.cancel=function(a){return a&&a.$$intervalId in f?(f[a.$$intervalId].reject("canceled"),b.clearInterval(a.$$intervalId),delete f[a.$$intervalId],!0):!1};return e}]}function bc(a){a=a.split("/");for(var b=a.length;b--;)a[b]=nb(a[b]);return a.join("/")}function hd(a,b){var d=xa(a);b.$$protocol=d.protocol;b.$$host=d.hostname;b.$$port=ca(d.port)||cg[d.protocol]||null}function id(a,b){var d="/"!==a.charAt(0);
	d&&(a="/"+a);var c=xa(a);b.$$path=decodeURIComponent(d&&"/"===c.pathname.charAt(0)?c.pathname.substring(1):c.pathname);b.$$search=xc(c.search);b.$$hash=decodeURIComponent(c.hash);b.$$path&&"/"!=b.$$path.charAt(0)&&(b.$$path="/"+b.$$path)}function ra(a,b){if(0===b.indexOf(a))return b.substr(a.length)}function Ga(a){var b=a.indexOf("#");return-1==b?a:a.substr(0,b)}function hb(a){return a.replace(/(#.+)|#$/,"$1")}function cc(a,b,d){this.$$html5=!0;d=d||"";hd(a,this);this.$$parse=function(a){var d=ra(b,
	a);if(!I(d))throw Cb("ipthprfx",a,b);id(d,this);this.$$path||(this.$$path="/");this.$$compose()};this.$$compose=function(){var a=Qb(this.$$search),d=this.$$hash?"#"+nb(this.$$hash):"";this.$$url=bc(this.$$path)+(a?"?"+a:"")+d;this.$$absUrl=b+this.$$url.substr(1)};this.$$parseLinkUrl=function(c,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,g;w(f=ra(a,c))?(g=f,g=w(f=ra(d,f))?b+(ra("/",f)||f):a+g):w(f=ra(b,c))?g=b+f:b==c+"/"&&(g=b);g&&this.$$parse(g);return!!g}}function dc(a,b,d){hd(a,this);
	this.$$parse=function(c){var e=ra(a,c)||ra(b,c),f;r(e)||"#"!==e.charAt(0)?this.$$html5?f=e:(f="",r(e)&&(a=c,this.replace())):(f=ra(d,e),r(f)&&(f=e));id(f,this);c=this.$$path;var e=a,g=/^\/[A-Z]:(\/.*)/;0===f.indexOf(e)&&(f=f.replace(e,""));g.exec(f)||(c=(f=g.exec(c))?f[1]:c);this.$$path=c;this.$$compose()};this.$$compose=function(){var b=Qb(this.$$search),e=this.$$hash?"#"+nb(this.$$hash):"";this.$$url=bc(this.$$path)+(b?"?"+b:"")+e;this.$$absUrl=a+(this.$$url?d+this.$$url:"")};this.$$parseLinkUrl=
	function(b,d){return Ga(a)==Ga(b)?(this.$$parse(b),!0):!1}}function jd(a,b,d){this.$$html5=!0;dc.apply(this,arguments);this.$$parseLinkUrl=function(c,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,g;a==Ga(c)?f=c:(g=ra(b,c))?f=a+d+g:b===c+"/"&&(f=b);f&&this.$$parse(f);return!!f};this.$$compose=function(){var b=Qb(this.$$search),e=this.$$hash?"#"+nb(this.$$hash):"";this.$$url=bc(this.$$path)+(b?"?"+b:"")+e;this.$$absUrl=a+d+this.$$url}}function Db(a){return function(){return this[a]}}function kd(a,
	b){return function(d){if(r(d))return this[a];this[a]=b(d);this.$$compose();return this}}function pf(){var a="",b={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(b){return w(b)?(a=b,this):a};this.html5Mode=function(a){return Ma(a)?(b.enabled=a,this):K(a)?(Ma(a.enabled)&&(b.enabled=a.enabled),Ma(a.requireBase)&&(b.requireBase=a.requireBase),Ma(a.rewriteLinks)&&(b.rewriteLinks=a.rewriteLinks),this):b};this.$get=["$rootScope","$browser","$sniffer","$rootElement","$window",function(d,
	c,e,f,g){function h(a,b,d){var e=m.url(),f=m.$$state;try{c.url(a,b,d),m.$$state=c.state()}catch(g){throw m.url(e),m.$$state=f,g;}}function k(a,b){d.$broadcast("$locationChangeSuccess",m.absUrl(),a,m.$$state,b)}var m,l;l=c.baseHref();var n=c.url(),G;if(b.enabled){if(!l&&b.requireBase)throw Cb("nobase");G=n.substring(0,n.indexOf("/",n.indexOf("//")+2))+(l||"/");l=e.history?cc:jd}else G=Ga(n),l=dc;var z=G.substr(0,Ga(G).lastIndexOf("/")+1);m=new l(G,z,"#"+a);m.$$parseLinkUrl(n,n);m.$$state=c.state();
	var t=/^\s*(javascript|mailto):/i;f.on("click",function(a){if(b.rewriteLinks&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!=a.which&&2!=a.button){for(var e=D(a.target);"a"!==oa(e[0]);)if(e[0]===f[0]||!(e=e.parent())[0])return;var h=e.prop("href"),k=e.attr("href")||e.attr("xlink:href");K(h)&&"[object SVGAnimatedString]"===h.toString()&&(h=xa(h.animVal).href);t.test(h)||!h||e.attr("target")||a.isDefaultPrevented()||!m.$$parseLinkUrl(h,k)||(a.preventDefault(),m.absUrl()!=c.url()&&(d.$apply(),g.angular["ff-684208-preventDefault"]=
	!0))}});hb(m.absUrl())!=hb(n)&&c.url(m.absUrl(),!0);var F=!0;c.onUrlChange(function(a,b){r(ra(z,a))?g.location.href=a:(d.$evalAsync(function(){var c=m.absUrl(),e=m.$$state,f;a=hb(a);m.$$parse(a);m.$$state=b;f=d.$broadcast("$locationChangeStart",a,c,b,e).defaultPrevented;m.absUrl()===a&&(f?(m.$$parse(c),m.$$state=e,h(c,!1,e)):(F=!1,k(c,e)))}),d.$$phase||d.$digest())});d.$watch(function(){var a=hb(c.url()),b=hb(m.absUrl()),f=c.state(),g=m.$$replace,l=a!==b||m.$$html5&&e.history&&f!==m.$$state;if(F||
	l)F=!1,d.$evalAsync(function(){var b=m.absUrl(),c=d.$broadcast("$locationChangeStart",b,a,m.$$state,f).defaultPrevented;m.absUrl()===b&&(c?(m.$$parse(a),m.$$state=f):(l&&h(b,g,f===m.$$state?null:m.$$state),k(a,f)))});m.$$replace=!1});return m}]}function qf(){var a=!0,b=this;this.debugEnabled=function(b){return w(b)?(a=b,this):a};this.$get=["$window",function(d){function c(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+a.message+"\n"+a.stack:a.stack:a.sourceURL&&
	(a=a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=d.console||{},e=b[a]||b.log||v;a=!1;try{a=!!e.apply}catch(k){}return a?function(){var a=[];p(arguments,function(b){a.push(c(b))});return e.apply(b,a)}:function(a,b){e(a,null==b?"":b)}}return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){a&&c.apply(b,arguments)}}()}}]}function Wa(a,b){if("__defineGetter__"===a||"__defineSetter__"===a||"__lookupGetter__"===a||"__lookupSetter__"===
	a||"__proto__"===a)throw aa("isecfld",b);return a}function ld(a,b){a+="";if(!I(a))throw aa("iseccst",b);return a}function ya(a,b){if(a){if(a.constructor===a)throw aa("isecfn",b);if(a.window===a)throw aa("isecwindow",b);if(a.children&&(a.nodeName||a.prop&&a.attr&&a.find))throw aa("isecdom",b);if(a===Object)throw aa("isecobj",b);}return a}function md(a,b){if(a){if(a.constructor===a)throw aa("isecfn",b);if(a===dg||a===eg||a===fg)throw aa("isecff",b);}}function Eb(a,b){if(a&&(a===(0).constructor||a===
	(!1).constructor||a==="".constructor||a==={}.constructor||a===[].constructor||a===Function.constructor))throw aa("isecaf",b);}function gg(a,b){return"undefined"!==typeof a?a:b}function nd(a,b){return"undefined"===typeof a?b:"undefined"===typeof b?a:a+b}function X(a,b){var d,c;switch(a.type){case s.Program:d=!0;p(a.body,function(a){X(a.expression,b);d=d&&a.expression.constant});a.constant=d;break;case s.Literal:a.constant=!0;a.toWatch=[];break;case s.UnaryExpression:X(a.argument,b);a.constant=a.argument.constant;
	a.toWatch=a.argument.toWatch;break;case s.BinaryExpression:X(a.left,b);X(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.left.toWatch.concat(a.right.toWatch);break;case s.LogicalExpression:X(a.left,b);X(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.constant?[]:[a];break;case s.ConditionalExpression:X(a.test,b);X(a.alternate,b);X(a.consequent,b);a.constant=a.test.constant&&a.alternate.constant&&a.consequent.constant;a.toWatch=a.constant?[]:[a];break;case s.Identifier:a.constant=
	!1;a.toWatch=[a];break;case s.MemberExpression:X(a.object,b);a.computed&&X(a.property,b);a.constant=a.object.constant&&(!a.computed||a.property.constant);a.toWatch=[a];break;case s.CallExpression:d=a.filter?!b(a.callee.name).$stateful:!1;c=[];p(a.arguments,function(a){X(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=a.filter&&!b(a.callee.name).$stateful?c:[a];break;case s.AssignmentExpression:X(a.left,b);X(a.right,b);a.constant=a.left.constant&&a.right.constant;
	a.toWatch=[a];break;case s.ArrayExpression:d=!0;c=[];p(a.elements,function(a){X(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=c;break;case s.ObjectExpression:d=!0;c=[];p(a.properties,function(a){X(a.value,b);d=d&&a.value.constant;a.value.constant||c.push.apply(c,a.value.toWatch)});a.constant=d;a.toWatch=c;break;case s.ThisExpression:a.constant=!1,a.toWatch=[]}}function od(a){if(1==a.length){a=a[0].expression;var b=a.toWatch;return 1!==b.length?b:b[0]!==a?b:u}}
	function pd(a){return a.type===s.Identifier||a.type===s.MemberExpression}function qd(a){if(1===a.body.length&&pd(a.body[0].expression))return{type:s.AssignmentExpression,left:a.body[0].expression,right:{type:s.NGValueParameter},operator:"="}}function rd(a){return 0===a.body.length||1===a.body.length&&(a.body[0].expression.type===s.Literal||a.body[0].expression.type===s.ArrayExpression||a.body[0].expression.type===s.ObjectExpression)}function sd(a,b){this.astBuilder=a;this.$filter=b}function td(a,
	b){this.astBuilder=a;this.$filter=b}function Fb(a){return"constructor"==a}function ec(a){return H(a.valueOf)?a.valueOf():hg.call(a)}function rf(){var a=Z(),b=Z();this.$get=["$filter",function(d){function c(c,f,n){var x,p,E;n=n||t;switch(typeof c){case "string":E=c=c.trim();var r=n?b:a;x=r[E];if(!x){":"===c.charAt(0)&&":"===c.charAt(1)&&(p=!0,c=c.substring(2));x=n?z:G;var B=new fc(x);x=(new gc(B,d,x)).parse(c);x.constant?x.$$watchDelegate=m:p?x.$$watchDelegate=x.literal?k:h:x.inputs&&(x.$$watchDelegate=
	g);n&&(x=e(x));r[E]=x}return l(x,f);case "function":return l(c,f);default:return l(v,f)}}function e(a){function b(c,d,e,f){var g=t;t=!0;try{return a(c,d,e,f)}finally{t=g}}if(!a)return a;b.$$watchDelegate=a.$$watchDelegate;b.assign=e(a.assign);b.constant=a.constant;b.literal=a.literal;for(var c=0;a.inputs&&c<a.inputs.length;++c)a.inputs[c]=e(a.inputs[c]);b.inputs=a.inputs;return b}function f(a,b){return null==a||null==b?a===b:"object"===typeof a&&(a=ec(a),"object"===typeof a)?!1:a===b||a!==a&&b!==
	b}function g(a,b,c,d,e){var g=d.inputs,h;if(1===g.length){var k=f,g=g[0];return a.$watch(function(a){var b=g(a);f(b,k)||(h=d(a,u,u,[b]),k=b&&ec(b));return h},b,c,e)}for(var m=[],l=[],n=0,G=g.length;n<G;n++)m[n]=f,l[n]=null;return a.$watch(function(a){for(var b=!1,c=0,e=g.length;c<e;c++){var k=g[c](a);if(b||(b=!f(k,m[c])))l[c]=k,m[c]=k&&ec(k)}b&&(h=d(a,u,u,l));return h},b,c,e)}function h(a,b,c,d){var e,f;return e=a.$watch(function(a){return d(a)},function(a,c,d){f=a;H(b)&&b.apply(this,arguments);w(a)&&
	d.$$postDigest(function(){w(f)&&e()})},c)}function k(a,b,c,d){function e(a){var b=!0;p(a,function(a){w(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,c,d){g=a;H(b)&&b.call(this,a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function m(a,b,c,d){var e;return e=a.$watch(function(a){return d(a)},function(a,c,d){H(b)&&b.apply(this,arguments);e()},c)}function l(a,b){if(!b)return a;var c=a.$$watchDelegate,d=!1,c=c!==k&&c!==h?function(c,e,f,g){f=d&&g?g[0]:a(c,
	e,f,g);return b(f,c,e)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return w(e)?c:e};a.$$watchDelegate&&a.$$watchDelegate!==g?c.$$watchDelegate=a.$$watchDelegate:b.$stateful||(c.$$watchDelegate=g,d=!a.inputs,c.inputs=a.inputs?a.inputs:[a]);return c}var n=Ca().noUnsafeEval,G={csp:n,expensiveChecks:!1},z={csp:n,expensiveChecks:!0},t=!1;c.$$runningExpensiveChecks=function(){return t};return c}]}function tf(){this.$get=["$rootScope","$exceptionHandler",function(a,b){return ud(function(b){a.$evalAsync(b)},
	b)}]}function uf(){this.$get=["$browser","$exceptionHandler",function(a,b){return ud(function(b){a.defer(b)},b)}]}function ud(a,b){function d(a,b,c){function d(b){return function(c){e||(e=!0,b.call(a,c))}}var e=!1;return[d(b),d(c)]}function c(){this.$$state={status:0}}function e(a,b){return function(c){b.call(a,c)}}function f(c){!c.processScheduled&&c.pending&&(c.processScheduled=!0,a(function(){var a,d,e;e=c.pending;c.processScheduled=!1;c.pending=u;for(var f=0,g=e.length;f<g;++f){d=e[f][0];a=e[f][c.status];
	try{H(a)?d.resolve(a(c.value)):1===c.status?d.resolve(c.value):d.reject(c.value)}catch(h){d.reject(h),b(h)}}}))}function g(){this.promise=new c;this.resolve=e(this,this.resolve);this.reject=e(this,this.reject);this.notify=e(this,this.notify)}var h=A("$q",TypeError);N(c.prototype,{then:function(a,b,c){if(r(a)&&r(b)&&r(c))return this;var d=new g;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&f(this.$$state);return d.promise},"catch":function(a){return this.then(null,
	a)},"finally":function(a,b){return this.then(function(b){return m(b,!0,a)},function(b){return m(b,!1,a)},b)}});N(g.prototype,{resolve:function(a){this.promise.$$state.status||(a===this.promise?this.$$reject(h("qcycle",a)):this.$$resolve(a))},$$resolve:function(a){var c,e;e=d(this,this.$$resolve,this.$$reject);try{if(K(a)||H(a))c=a&&a.then;H(c)?(this.promise.$$state.status=-1,c.call(a,e[0],e[1],this.notify)):(this.promise.$$state.value=a,this.promise.$$state.status=1,f(this.promise.$$state))}catch(g){e[1](g),
	b(g)}},reject:function(a){this.promise.$$state.status||this.$$reject(a)},$$reject:function(a){this.promise.$$state.value=a;this.promise.$$state.status=2;f(this.promise.$$state)},notify:function(c){var d=this.promise.$$state.pending;0>=this.promise.$$state.status&&d&&d.length&&a(function(){for(var a,e,f=0,g=d.length;f<g;f++){e=d[f][0];a=d[f][3];try{e.notify(H(a)?a(c):c)}catch(h){b(h)}}})}});var k=function(a,b){var c=new g;b?c.resolve(a):c.reject(a);return c.promise},m=function(a,b,c){var d=null;try{H(c)&&
	(d=c())}catch(e){return k(e,!1)}return d&&H(d.then)?d.then(function(){return k(a,b)},function(a){return k(a,!1)}):k(a,b)},l=function(a,b,c,d){var e=new g;e.resolve(a);return e.promise.then(b,c,d)},n=function z(a){if(!H(a))throw h("norslvr",a);if(!(this instanceof z))return new z(a);var b=new g;a(function(a){b.resolve(a)},function(a){b.reject(a)});return b.promise};n.defer=function(){return new g};n.reject=function(a){var b=new g;b.reject(a);return b.promise};n.when=l;n.resolve=l;n.all=function(a){var b=
	new g,c=0,d=L(a)?[]:{};p(a,function(a,e){c++;l(a).then(function(a){d.hasOwnProperty(e)||(d[e]=a,--c||b.resolve(d))},function(a){d.hasOwnProperty(e)||b.reject(a)})});0===c&&b.resolve(d);return b.promise};return n}function Df(){this.$get=["$window","$timeout",function(a,b){var d=a.requestAnimationFrame||a.webkitRequestAnimationFrame,c=a.cancelAnimationFrame||a.webkitCancelAnimationFrame||a.webkitCancelRequestAnimationFrame,e=!!d,f=e?function(a){var b=d(a);return function(){c(b)}}:function(a){var c=
	b(a,16.66,!1);return function(){b.cancel(c)}};f.supported=e;return f}]}function sf(){function a(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++mb;this.$$ChildScope=null}b.prototype=a;return b}var b=10,d=A("$rootScope"),c=null,e=null;this.digestTtl=function(a){arguments.length&&(b=a);return b};this.$get=["$injector","$exceptionHandler","$parse","$browser",function(f,g,h,k){function m(a){a.currentScope.$$destroyed=
	!0}function l(a){9===Ha&&(a.$$childHead&&l(a.$$childHead),a.$$nextSibling&&l(a.$$nextSibling));a.$parent=a.$$nextSibling=a.$$prevSibling=a.$$childHead=a.$$childTail=a.$root=a.$$watchers=null}function n(){this.$id=++mb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function G(a){if(x.$$phase)throw d("inprog",
	x.$$phase);x.$$phase=a}function z(a,b){do a.$$watchersCount+=b;while(a=a.$parent)}function t(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function F(){}function q(){for(;Q.length;)try{Q.shift()()}catch(a){g(a)}e=null}function y(){null===e&&(e=k.defer(function(){x.$apply(q)}))}n.prototype={constructor:n,$new:function(b,c){var d;c=c||this;b?(d=new n,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=a(this)),d=new this.$$ChildScope);
	d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!=this)&&d.$on("$destroy",m);return d},$watch:function(a,b,d,e){var f=h(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var g=this,k=g.$$watchers,m={fn:b,last:F,get:f,exp:e||a,eq:!!d};c=null;H(b)||(m.fn=v);k||(k=g.$$watchers=[]);k.unshift(m);z(this,1);return function(){0<=ab(k,m)&&z(g,-1);c=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=
	!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var m=!0;g.$evalAsync(function(){m&&b(e,e,g)});return function(){m=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});p(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!r(e)){if(K(e))if(Aa(e))for(f!==
	n&&(f=n,p=f.length=0,m++),a=e.length,p!==a&&(m++,f.length=p=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(m++,f[b]=g);else{f!==q&&(f=q={},p=0,m++);a=0;for(b in e)sa.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(m++,f[b]=g)):(p++,f[b]=g,m++));if(p>a)for(b in m++,f)sa.call(e,b)||(p--,delete f[b])}else f!==e&&(f=e,m++);return m}}c.$stateful=!0;var d=this,e,f,g,k=1<b.length,m=0,l=h(a,c),n=[],q={},G=!0,p=0;return this.$watch(l,function(){G?(G=!1,b(e,e,d)):b(e,g,d);if(k)if(K(e))if(Aa(e)){g=
	Array(e.length);for(var a=0;a<e.length;a++)g[a]=e[a]}else for(a in g={},e)sa.call(e,a)&&(g[a]=e[a]);else g=e})},$digest:function(){var a,f,h,m,l,n,p,z,y=b,t,r=[],Q,u;G("$digest");k.$$checkUrlChange();this===x&&null!==e&&(k.defer.cancel(e),q());c=null;do{z=!1;for(t=this;s.length;){try{u=s.shift(),u.scope.$eval(u.expression,u.locals)}catch(w){g(w)}c=null}a:do{if(n=t.$$watchers)for(p=n.length;p--;)try{if(a=n[p])if(l=a.get,(f=l(t))!==(h=a.last)&&!(a.eq?la(f,h):"number"===typeof f&&"number"===typeof h&&
	isNaN(f)&&isNaN(h)))z=!0,c=a,a.last=a.eq?Na(f,null):f,m=a.fn,m(f,h===F?f:h,t),5>y&&(Q=4-y,r[Q]||(r[Q]=[]),r[Q].push({msg:H(a.exp)?"fn: "+(a.exp.name||a.exp.toString()):a.exp,newVal:f,oldVal:h}));else if(a===c){z=!1;break a}}catch(v){g(v)}if(!(n=t.$$watchersCount&&t.$$childHead||t!==this&&t.$$nextSibling))for(;t!==this&&!(n=t.$$nextSibling);)t=t.$parent}while(t=n);if((z||s.length)&&!y--)throw x.$$phase=null,d("infdig",b,r);}while(z||s.length);for(x.$$phase=null;E.length;)try{E.shift()()}catch(D){g(D)}},
	$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");this.$$destroyed=!0;this===x&&k.$$applicationDestroyed();z(this,-this.$$watchersCount);for(var b in this.$$listenerCount)t(this,this.$$listenerCount[b],b);a&&a.$$childHead==this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail==this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);
	this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=v;this.$on=this.$watch=this.$watchGroup=function(){return v};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return h(a)(this,b)},$evalAsync:function(a,b){x.$$phase||s.length||k.defer(function(){s.length&&x.$digest()});s.push({scope:this,expression:h(a),locals:b})},$$postDigest:function(a){E.push(a)},$apply:function(a){try{G("$apply");try{return this.$eval(a)}finally{x.$$phase=null}}catch(b){g(b)}finally{try{x.$digest()}catch(c){throw g(c),
	c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&Q.push(b);a=h(a);y()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,t(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,f=!1,h={name:a,targetScope:e,stopPropagation:function(){f=!0},preventDefault:function(){h.defaultPrevented=
	!0},defaultPrevented:!1},k=bb([h],arguments,1),m,l;do{d=e.$$listeners[a]||c;h.currentScope=e;m=0;for(l=d.length;m<l;m++)if(d[m])try{d[m].apply(null,k)}catch(n){g(n)}else d.splice(m,1),m--,l--;if(f)return h.currentScope=null,h;e=e.$parent}while(e);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var f=bb([e],arguments,1),h,k;c=d;){e.currentScope=
	c;d=c.$$listeners[a]||[];h=0;for(k=d.length;h<k;h++)if(d[h])try{d[h].apply(null,f)}catch(m){g(m)}else d.splice(h,1),h--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}e.currentScope=null;return e}};var x=new n,s=x.$$asyncQueue=[],E=x.$$postDigestQueue=[],Q=x.$$applyAsyncQueue=[];return x}]}function le(){var a=/^\s*(https?|ftp|mailto|tel|file):/,b=/^\s*((https?|ftp|file|blob):|data:image\/)/;this.aHrefSanitizationWhitelist=
	function(b){return w(b)?(a=b,this):a};this.imgSrcSanitizationWhitelist=function(a){return w(a)?(b=a,this):b};this.$get=function(){return function(d,c){var e=c?b:a,f;f=xa(d).href;return""===f||f.match(e)?d:"unsafe:"+f}}}function ig(a){if("self"===a)return a;if(I(a)){if(-1<a.indexOf("***"))throw za("iwcard",a);a=vd(a).replace("\\*\\*",".*").replace("\\*","[^:/.?&;]*");return new RegExp("^"+a+"$")}if(La(a))return new RegExp("^"+a.source+"$");throw za("imatcher");}function wd(a){var b=[];w(a)&&p(a,function(a){b.push(ig(a))});
	return b}function wf(){this.SCE_CONTEXTS=ka;var a=["self"],b=[];this.resourceUrlWhitelist=function(b){arguments.length&&(a=wd(b));return a};this.resourceUrlBlacklist=function(a){arguments.length&&(b=wd(a));return b};this.$get=["$injector",function(d){function c(a,b){return"self"===a?gd(b):!!a.exec(b.href)}function e(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};
	return b}var f=function(a){throw za("unsafe");};d.has("$sanitize")&&(f=d.get("$sanitize"));var g=e(),h={};h[ka.HTML]=e(g);h[ka.CSS]=e(g);h[ka.URL]=e(g);h[ka.JS]=e(g);h[ka.RESOURCE_URL]=e(h[ka.URL]);return{trustAs:function(a,b){var c=h.hasOwnProperty(a)?h[a]:null;if(!c)throw za("icontext",a,b);if(null===b||r(b)||""===b)return b;if("string"!==typeof b)throw za("itype",a);return new c(b)},getTrusted:function(d,e){if(null===e||r(e)||""===e)return e;var g=h.hasOwnProperty(d)?h[d]:null;if(g&&e instanceof
	g)return e.$$unwrapTrustedValue();if(d===ka.RESOURCE_URL){var g=xa(e.toString()),n,p,z=!1;n=0;for(p=a.length;n<p;n++)if(c(a[n],g)){z=!0;break}if(z)for(n=0,p=b.length;n<p;n++)if(c(b[n],g)){z=!1;break}if(z)return e;throw za("insecurl",e.toString());}if(d===ka.HTML)return f(e);throw za("unsafe");},valueOf:function(a){return a instanceof g?a.$$unwrapTrustedValue():a}}}]}function vf(){var a=!0;this.enabled=function(b){arguments.length&&(a=!!b);return a};this.$get=["$parse","$sceDelegate",function(b,d){if(a&&
	8>Ha)throw za("iequirks");var c=fa(ka);c.isEnabled=function(){return a};c.trustAs=d.trustAs;c.getTrusted=d.getTrusted;c.valueOf=d.valueOf;a||(c.trustAs=c.getTrusted=function(a,b){return b},c.valueOf=Za);c.parseAs=function(a,d){var e=b(d);return e.literal&&e.constant?e:b(d,function(b){return c.getTrusted(a,b)})};var e=c.parseAs,f=c.getTrusted,g=c.trustAs;p(ka,function(a,b){var d=M(b);c[eb("parse_as_"+d)]=function(b){return e(a,b)};c[eb("get_trusted_"+d)]=function(b){return f(a,b)};c[eb("trust_as_"+
	d)]=function(b){return g(a,b)}});return c}]}function xf(){this.$get=["$window","$document",function(a,b){var d={},c=ca((/android (\d+)/.exec(M((a.navigator||{}).userAgent))||[])[1]),e=/Boxee/i.test((a.navigator||{}).userAgent),f=b[0]||{},g,h=/^(Moz|webkit|ms)(?=[A-Z])/,k=f.body&&f.body.style,m=!1,l=!1;if(k){for(var n in k)if(m=h.exec(n)){g=m[0];g=g.substr(0,1).toUpperCase()+g.substr(1);break}g||(g="WebkitOpacity"in k&&"webkit");m=!!("transition"in k||g+"Transition"in k);l=!!("animation"in k||g+"Animation"in
	k);!c||m&&l||(m=I(k.webkitTransition),l=I(k.webkitAnimation))}return{history:!(!a.history||!a.history.pushState||4>c||e),hasEvent:function(a){if("input"===a&&11>=Ha)return!1;if(r(d[a])){var b=f.createElement("div");d[a]="on"+a in b}return d[a]},csp:Ca(),vendorPrefix:g,transitions:m,animations:l,android:c}}]}function zf(){this.$get=["$templateCache","$http","$q","$sce",function(a,b,d,c){function e(f,g){e.totalPendingRequests++;if(!I(f)||r(a.get(f)))f=c.getTrustedResourceUrl(f);var h=b.defaults&&b.defaults.transformResponse;
	L(h)?h=h.filter(function(a){return a!==$b}):h===$b&&(h=null);return b.get(f,{cache:a,transformResponse:h})["finally"](function(){e.totalPendingRequests--}).then(function(b){a.put(f,b.data);return b.data},function(a){if(!g)throw ga("tpload",f,a.status,a.statusText);return d.reject(a)})}e.totalPendingRequests=0;return e}]}function Af(){this.$get=["$rootScope","$browser","$location",function(a,b,d){return{findBindings:function(a,b,d){a=a.getElementsByClassName("ng-binding");var g=[];p(a,function(a){var c=
	da.element(a).data("$binding");c&&p(c,function(c){d?(new RegExp("(^|\\s)"+vd(b)+"(\\s|\\||$)")).test(c)&&g.push(a):-1!=c.indexOf(b)&&g.push(a)})});return g},findModels:function(a,b,d){for(var g=["ng-","data-ng-","ng\\:"],h=0;h<g.length;++h){var k=a.querySelectorAll("["+g[h]+"model"+(d?"=":"*=")+'"'+b+'"]');if(k.length)return k}},getLocation:function(){return d.url()},setLocation:function(b){b!==d.url()&&(d.url(b),a.$digest())},whenStable:function(a){b.notifyWhenNoOutstandingRequests(a)}}}]}function Bf(){this.$get=
	["$rootScope","$browser","$q","$$q","$exceptionHandler",function(a,b,d,c,e){function f(f,k,m){H(f)||(m=k,k=f,f=v);var l=ta.call(arguments,3),n=w(m)&&!m,p=(n?c:d).defer(),z=p.promise,t;t=b.defer(function(){try{p.resolve(f.apply(null,l))}catch(b){p.reject(b),e(b)}finally{delete g[z.$$timeoutId]}n||a.$apply()},k);z.$$timeoutId=t;g[t]=p;return z}var g={};f.cancel=function(a){return a&&a.$$timeoutId in g?(g[a.$$timeoutId].reject("canceled"),delete g[a.$$timeoutId],b.defer.cancel(a.$$timeoutId)):!1};return f}]}
	function xa(a){Ha&&(Y.setAttribute("href",a),a=Y.href);Y.setAttribute("href",a);return{href:Y.href,protocol:Y.protocol?Y.protocol.replace(/:$/,""):"",host:Y.host,search:Y.search?Y.search.replace(/^\?/,""):"",hash:Y.hash?Y.hash.replace(/^#/,""):"",hostname:Y.hostname,port:Y.port,pathname:"/"===Y.pathname.charAt(0)?Y.pathname:"/"+Y.pathname}}function gd(a){a=I(a)?xa(a):a;return a.protocol===xd.protocol&&a.host===xd.host}function Cf(){this.$get=ma(R)}function yd(a){function b(a){try{return decodeURIComponent(a)}catch(b){return a}}
	var d=a[0]||{},c={},e="";return function(){var a,g,h,k,m;a=d.cookie||"";if(a!==e)for(e=a,a=e.split("; "),c={},h=0;h<a.length;h++)g=a[h],k=g.indexOf("="),0<k&&(m=b(g.substring(0,k)),r(c[m])&&(c[m]=b(g.substring(k+1))));return c}}function Gf(){this.$get=yd}function Jc(a){function b(d,c){if(K(d)){var e={};p(d,function(a,c){e[c]=b(c,a)});return e}return a.factory(d+"Filter",c)}this.register=b;this.$get=["$injector",function(a){return function(b){return a.get(b+"Filter")}}];b("currency",zd);b("date",Ad);
	b("filter",jg);b("json",kg);b("limitTo",lg);b("lowercase",mg);b("number",Bd);b("orderBy",Cd);b("uppercase",ng)}function jg(){return function(a,b,d){if(!Aa(a)){if(null==a)return a;throw A("filter")("notarray",a);}var c;switch(hc(b)){case "function":break;case "boolean":case "null":case "number":case "string":c=!0;case "object":b=og(b,d,c);break;default:return a}return Array.prototype.filter.call(a,b)}}function og(a,b,d){var c=K(a)&&"$"in a;!0===b?b=la:H(b)||(b=function(a,b){if(r(a))return!1;if(null===
	a||null===b)return a===b;if(K(b)||K(a)&&!qc(a))return!1;a=M(""+a);b=M(""+b);return-1!==a.indexOf(b)});return function(e){return c&&!K(e)?Ja(e,a.$,b,!1):Ja(e,a,b,d)}}function Ja(a,b,d,c,e){var f=hc(a),g=hc(b);if("string"===g&&"!"===b.charAt(0))return!Ja(a,b.substring(1),d,c);if(L(a))return a.some(function(a){return Ja(a,b,d,c)});switch(f){case "object":var h;if(c){for(h in a)if("$"!==h.charAt(0)&&Ja(a[h],b,d,!0))return!0;return e?!1:Ja(a,b,d,!1)}if("object"===g){for(h in b)if(e=b[h],!H(e)&&!r(e)&&
	(f="$"===h,!Ja(f?a:a[h],e,d,f,f)))return!1;return!0}return d(a,b);case "function":return!1;default:return d(a,b)}}function hc(a){return null===a?"null":typeof a}function zd(a){var b=a.NUMBER_FORMATS;return function(a,c,e){r(c)&&(c=b.CURRENCY_SYM);r(e)&&(e=b.PATTERNS[1].maxFrac);return null==a?a:Dd(a,b.PATTERNS[1],b.GROUP_SEP,b.DECIMAL_SEP,e).replace(/\u00A4/g,c)}}function Bd(a){var b=a.NUMBER_FORMATS;return function(a,c){return null==a?a:Dd(a,b.PATTERNS[0],b.GROUP_SEP,b.DECIMAL_SEP,c)}}function pg(a){var b=
	0,d,c,e,f,g;-1<(c=a.indexOf(Ed))&&(a=a.replace(Ed,""));0<(e=a.search(/e/i))?(0>c&&(c=e),c+=+a.slice(e+1),a=a.substring(0,e)):0>c&&(c=a.length);for(e=0;a.charAt(e)==ic;e++);if(e==(g=a.length))d=[0],c=1;else{for(g--;a.charAt(g)==ic;)g--;c-=e;d=[];for(f=0;e<=g;e++,f++)d[f]=+a.charAt(e)}c>Fd&&(d=d.splice(0,Fd-1),b=c-1,c=1);return{d:d,e:b,i:c}}function qg(a,b,d,c){var e=a.d,f=e.length-a.i;b=r(b)?Math.min(Math.max(d,f),c):+b;d=b+a.i;c=e[d];if(0<d)e.splice(d);else{a.i=1;e.length=d=b+1;for(var g=0;g<d;g++)e[g]=
	0}for(5<=c&&e[d-1]++;f<b;f++)e.push(0);if(b=e.reduceRight(function(a,b,c,d){b+=a;d[c]=b%10;return Math.floor(b/10)},0))e.unshift(b),a.i++}function Dd(a,b,d,c,e){if(!I(a)&&!P(a)||isNaN(a))return"";var f=!isFinite(a),g=!1,h=Math.abs(a)+"",k="";if(f)k="\u221e";else{g=pg(h);qg(g,e,b.minFrac,b.maxFrac);k=g.d;h=g.i;e=g.e;f=[];for(g=k.reduce(function(a,b){return a&&!b},!0);0>h;)k.unshift(0),h++;0<h?f=k.splice(h,k.length):(f=k,k=[0]);h=[];for(k.length>=b.lgSize&&h.unshift(k.splice(-b.lgSize,k.length).join(""));k.length>
	b.gSize;)h.unshift(k.splice(-b.gSize,k.length).join(""));k.length&&h.unshift(k.join(""));k=h.join(d);f.length&&(k+=c+f.join(""));e&&(k+="e+"+e)}return 0>a&&!g?b.negPre+k+b.negSuf:b.posPre+k+b.posSuf}function Gb(a,b,d){var c="";0>a&&(c="-",a=-a);for(a=""+a;a.length<b;)a=ic+a;d&&(a=a.substr(a.length-b));return c+a}function ba(a,b,d,c){d=d||0;return function(e){e=e["get"+a]();if(0<d||e>-d)e+=d;0===e&&-12==d&&(e=12);return Gb(e,b,c)}}function Hb(a,b){return function(d,c){var e=d["get"+a](),f=rb(b?"SHORT"+
	a:a);return c[f][e]}}function Gd(a){var b=(new Date(a,0,1)).getDay();return new Date(a,0,(4>=b?5:12)-b)}function Hd(a){return function(b){var d=Gd(b.getFullYear());b=+new Date(b.getFullYear(),b.getMonth(),b.getDate()+(4-b.getDay()))-+d;b=1+Math.round(b/6048E5);return Gb(b,a)}}function jc(a,b){return 0>=a.getFullYear()?b.ERAS[0]:b.ERAS[1]}function Ad(a){function b(a){var b;if(b=a.match(d)){a=new Date(0);var f=0,g=0,h=b[8]?a.setUTCFullYear:a.setFullYear,k=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=ca(b[9]+
	b[10]),g=ca(b[9]+b[11]));h.call(a,ca(b[1]),ca(b[2])-1,ca(b[3]));f=ca(b[4]||0)-f;g=ca(b[5]||0)-g;h=ca(b[6]||0);b=Math.round(1E3*parseFloat("0."+(b[7]||0)));k.call(a,f,g,h,b)}return a}var d=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;return function(c,d,f){var g="",h=[],k,m;d=d||"mediumDate";d=a.DATETIME_FORMATS[d]||d;I(c)&&(c=rg.test(c)?ca(c):b(c));P(c)&&(c=new Date(c));if(!ea(c)||!isFinite(c.getTime()))return c;for(;d;)(m=sg.exec(d))?(h=bb(h,
	m,1),d=h.pop()):(h.push(d),d=null);var l=c.getTimezoneOffset();f&&(l=vc(f,l),c=Pb(c,f,!0));p(h,function(b){k=tg[b];g+=k?k(c,a.DATETIME_FORMATS,l):"''"===b?"'":b.replace(/(^'|'$)/g,"").replace(/''/g,"'")});return g}}function kg(){return function(a,b){r(b)&&(b=2);return cb(a,b)}}function lg(){return function(a,b,d){b=Infinity===Math.abs(Number(b))?Number(b):ca(b);if(isNaN(b))return a;P(a)&&(a=a.toString());if(!L(a)&&!I(a))return a;d=!d||isNaN(d)?0:ca(d);d=0>d?Math.max(0,a.length+d):d;return 0<=b?a.slice(d,
	d+b):0===d?a.slice(b,a.length):a.slice(Math.max(0,d+b),d)}}function Cd(a){function b(b,d){d=d?-1:1;return b.map(function(b){var c=1,h=Za;if(H(b))h=b;else if(I(b)){if("+"==b.charAt(0)||"-"==b.charAt(0))c="-"==b.charAt(0)?-1:1,b=b.substring(1);if(""!==b&&(h=a(b),h.constant))var k=h(),h=function(a){return a[k]}}return{get:h,descending:c*d}})}function d(a){switch(typeof a){case "number":case "boolean":case "string":return!0;default:return!1}}return function(a,e,f){if(!Aa(a))return a;L(e)||(e=[e]);0===
	e.length&&(e=["+"]);var g=b(e,f);g.push({get:function(){return{}},descending:f?-1:1});a=Array.prototype.map.call(a,function(a,b){return{value:a,predicateValues:g.map(function(c){var e=c.get(a);c=typeof e;if(null===e)c="string",e="null";else if("string"===c)e=e.toLowerCase();else if("object"===c)a:{if("function"===typeof e.valueOf&&(e=e.valueOf(),d(e)))break a;if(qc(e)&&(e=e.toString(),d(e)))break a;e=b}return{value:e,type:c}})}});a.sort(function(a,b){for(var c=0,d=0,e=g.length;d<e;++d){var c=a.predicateValues[d],
	f=b.predicateValues[d],p=0;c.type===f.type?c.value!==f.value&&(p=c.value<f.value?-1:1):p=c.type<f.type?-1:1;if(c=p*g[d].descending)break}return c});return a=a.map(function(a){return a.value})}}function Ka(a){H(a)&&(a={link:a});a.restrict=a.restrict||"AC";return ma(a)}function Id(a,b,d,c,e){var f=this,g=[];f.$error={};f.$$success={};f.$pending=u;f.$name=e(b.name||b.ngForm||"")(d);f.$dirty=!1;f.$pristine=!0;f.$valid=!0;f.$invalid=!1;f.$submitted=!1;f.$$parentForm=Ib;f.$rollbackViewValue=function(){p(g,
	function(a){a.$rollbackViewValue()})};f.$commitViewValue=function(){p(g,function(a){a.$commitViewValue()})};f.$addControl=function(a){Sa(a.$name,"input");g.push(a);a.$name&&(f[a.$name]=a);a.$$parentForm=f};f.$$renameControl=function(a,b){var c=a.$name;f[c]===a&&delete f[c];f[b]=a;a.$name=b};f.$removeControl=function(a){a.$name&&f[a.$name]===a&&delete f[a.$name];p(f.$pending,function(b,c){f.$setValidity(c,null,a)});p(f.$error,function(b,c){f.$setValidity(c,null,a)});p(f.$$success,function(b,c){f.$setValidity(c,
	null,a)});ab(g,a);a.$$parentForm=Ib};Jd({ctrl:this,$element:a,set:function(a,b,c){var d=a[b];d?-1===d.indexOf(c)&&d.push(c):a[b]=[c]},unset:function(a,b,c){var d=a[b];d&&(ab(d,c),0===d.length&&delete a[b])},$animate:c});f.$setDirty=function(){c.removeClass(a,Xa);c.addClass(a,Jb);f.$dirty=!0;f.$pristine=!1;f.$$parentForm.$setDirty()};f.$setPristine=function(){c.setClass(a,Xa,Jb+" ng-submitted");f.$dirty=!1;f.$pristine=!0;f.$submitted=!1;p(g,function(a){a.$setPristine()})};f.$setUntouched=function(){p(g,
	function(a){a.$setUntouched()})};f.$setSubmitted=function(){c.addClass(a,"ng-submitted");f.$submitted=!0;f.$$parentForm.$setSubmitted()}}function kc(a){a.$formatters.push(function(b){return a.$isEmpty(b)?b:b.toString()})}function ib(a,b,d,c,e,f){var g=M(b[0].type);if(!e.android){var h=!1;b.on("compositionstart",function(a){h=!0});b.on("compositionend",function(){h=!1;m()})}var k,m=function(a){k&&(f.defer.cancel(k),k=null);if(!h){var e=b.val();a=a&&a.type;"password"===g||d.ngTrim&&"false"===d.ngTrim||
	(e=T(e));(c.$viewValue!==e||""===e&&c.$$hasNativeValidators)&&c.$setViewValue(e,a)}};if(e.hasEvent("input"))b.on("input",m);else{var l=function(a,b,c){k||(k=f.defer(function(){k=null;b&&b.value===c||m(a)}))};b.on("keydown",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||l(a,this,this.value)});if(e.hasEvent("paste"))b.on("paste cut",l)}b.on("change",m);if(Kd[g]&&c.$$hasNativeValidators&&g===d.type)b.on("keydown wheel mousedown",function(a){if(!k){var b=this.validity,c=b.badInput,d=b.typeMismatch;
	k=f.defer(function(){k=null;b.badInput===c&&b.typeMismatch===d||m(a)})}});c.$render=function(){var a=c.$isEmpty(c.$viewValue)?"":c.$viewValue;b.val()!==a&&b.val(a)}}function Kb(a,b){return function(d,c){var e,f;if(ea(d))return d;if(I(d)){'"'==d.charAt(0)&&'"'==d.charAt(d.length-1)&&(d=d.substring(1,d.length-1));if(ug.test(d))return new Date(d);a.lastIndex=0;if(e=a.exec(d))return e.shift(),f=c?{yyyy:c.getFullYear(),MM:c.getMonth()+1,dd:c.getDate(),HH:c.getHours(),mm:c.getMinutes(),ss:c.getSeconds(),
	sss:c.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},p(e,function(a,c){c<b.length&&(f[b[c]]=+a)}),new Date(f.yyyy,f.MM-1,f.dd,f.HH,f.mm,f.ss||0,1E3*f.sss||0)}return NaN}}function jb(a,b,d,c){return function(e,f,g,h,k,m,l){function n(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function p(a){return w(a)&&!ea(a)?d(a)||u:a}Ld(e,f,g,h);ib(e,f,g,h,k,m);var z=h&&h.$options&&h.$options.timezone,t;h.$$parserName=a;h.$parsers.push(function(a){return h.$isEmpty(a)?null:b.test(a)?
	(a=d(a,t),z&&(a=Pb(a,z)),a):u});h.$formatters.push(function(a){if(a&&!ea(a))throw kb("datefmt",a);if(n(a))return(t=a)&&z&&(t=Pb(t,z,!0)),l("date")(a,c,z);t=null;return""});if(w(g.min)||g.ngMin){var s;h.$validators.min=function(a){return!n(a)||r(s)||d(a)>=s};g.$observe("min",function(a){s=p(a);h.$validate()})}if(w(g.max)||g.ngMax){var q;h.$validators.max=function(a){return!n(a)||r(q)||d(a)<=q};g.$observe("max",function(a){q=p(a);h.$validate()})}}}function Ld(a,b,d,c){(c.$$hasNativeValidators=K(b[0].validity))&&
	c.$parsers.push(function(a){var c=b.prop("validity")||{};return c.badInput&&!c.typeMismatch?u:a})}function Md(a,b,d,c,e){if(w(c)){a=a(c);if(!a.constant)throw kb("constexpr",d,c);return a(b)}return e}function lc(a,b){a="ngClass"+a;return["$animate",function(d){function c(a,b){var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],l=0;l<b.length;l++)if(e==b[l])continue a;c.push(e)}return c}function e(a){var b=[];return L(a)?(p(a,function(a){b=b.concat(e(a))}),b):I(a)?a.split(" "):K(a)?(p(a,function(a,c){a&&
	(b=b.concat(c.split(" ")))}),b):a}return{restrict:"AC",link:function(f,g,h){function k(a){a=m(a,1);h.$addClass(a)}function m(a,b){var c=g.data("$classCounts")||Z(),d=[];p(a,function(a){if(0<b||c[a])c[a]=(c[a]||0)+b,c[a]===+(0<b)&&d.push(a)});g.data("$classCounts",c);return d.join(" ")}function l(a,b){var e=c(b,a),f=c(a,b),e=m(e,1),f=m(f,-1);e&&e.length&&d.addClass(g,e);f&&f.length&&d.removeClass(g,f)}function n(a){if(!0===b||f.$index%2===b){var c=e(a||[]);if(!r)k(c);else if(!la(a,r)){var d=e(r);l(d,
	c)}}r=L(a)?a.map(function(a){return fa(a)}):fa(a)}var r;f.$watch(h[a],n,!0);h.$observe("class",function(b){n(f.$eval(h[a]))});"ngClass"!==a&&f.$watch("$index",function(c,d){var g=c&1;if(g!==(d&1)){var l=e(f.$eval(h[a]));g===b?k(l):(g=m(l,-1),h.$removeClass(g))}})}}}]}function Jd(a){function b(a,b){b&&!f[a]?(k.addClass(e,a),f[a]=!0):!b&&f[a]&&(k.removeClass(e,a),f[a]=!1)}function d(a,c){a=a?"-"+zc(a,"-"):"";b(lb+a,!0===c);b(Nd+a,!1===c)}var c=a.ctrl,e=a.$element,f={},g=a.set,h=a.unset,k=a.$animate;
	f[Nd]=!(f[lb]=e.hasClass(lb));c.$setValidity=function(a,e,f){r(e)?(c.$pending||(c.$pending={}),g(c.$pending,a,f)):(c.$pending&&h(c.$pending,a,f),Od(c.$pending)&&(c.$pending=u));Ma(e)?e?(h(c.$error,a,f),g(c.$$success,a,f)):(g(c.$error,a,f),h(c.$$success,a,f)):(h(c.$error,a,f),h(c.$$success,a,f));c.$pending?(b(Pd,!0),c.$valid=c.$invalid=u,d("",null)):(b(Pd,!1),c.$valid=Od(c.$error),c.$invalid=!c.$valid,d("",c.$valid));e=c.$pending&&c.$pending[a]?u:c.$error[a]?!1:c.$$success[a]?!0:null;d(a,e);c.$$parentForm.$setValidity(a,
	e,c)}}function Od(a){if(a)for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}var vg=/^\/(.+)\/([a-z]*)$/,M=function(a){return I(a)?a.toLowerCase():a},sa=Object.prototype.hasOwnProperty,rb=function(a){return I(a)?a.toUpperCase():a},Ha,D,pa,ta=[].slice,Xf=[].splice,wg=[].push,na=Object.prototype.toString,rc=Object.getPrototypeOf,Ba=A("ng"),da=R.angular||(R.angular={}),Sb,mb=0;Ha=U.documentMode;v.$inject=[];Za.$inject=[];var L=Array.isArray,Zd=/^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/,
	T=function(a){return I(a)?a.trim():a},vd=function(a){return a.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Ca=function(){if(!w(Ca.rules)){var a=U.querySelector("[ng-csp]")||U.querySelector("[data-ng-csp]");if(a){var b=a.getAttribute("ng-csp")||a.getAttribute("data-ng-csp");Ca.rules={noUnsafeEval:!b||-1!==b.indexOf("no-unsafe-eval"),noInlineStyle:!b||-1!==b.indexOf("no-inline-style")}}else{a=Ca;try{new Function(""),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,noInlineStyle:!1}}}return Ca.rules},
	ob=function(){if(w(ob.name_))return ob.name_;var a,b,d=Pa.length,c,e;for(b=0;b<d;++b)if(c=Pa[b],a=U.querySelector("["+c.replace(":","\\:")+"jq]")){e=a.getAttribute(c+"jq");break}return ob.name_=e},be=/:/g,Pa=["ng-","data-ng-","ng:","x-ng-"],ge=/[A-Z]/g,Ac=!1,Rb,Oa=3,ke={full:"1.4.12",major:1,minor:4,dot:12,codeName:"cultural-conservation"};S.expando="ng339";var fb=S.cache={},Mf=1;S._data=function(a){return this.cache[a[this.expando]]||{}};var Hf=/([\:\-\_]+(.))/g,If=/^moz([A-Z])/,wb={mouseleave:"mouseout",
	mouseenter:"mouseover"},Ub=A("jqLite"),Lf=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,Tb=/<|&#?\w+;/,Jf=/<([\w:-]+)/,Kf=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,ja={option:[1,'<select multiple="multiple">',"</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ja.optgroup=ja.option;ja.tbody=ja.tfoot=ja.colgroup=ja.caption=ja.thead;
	ja.th=ja.td;var Rf=Node.prototype.contains||function(a){return!!(this.compareDocumentPosition(a)&16)},Qa=S.prototype={ready:function(a){function b(){d||(d=!0,a())}var d=!1;"complete"===U.readyState?setTimeout(b):(this.on("DOMContentLoaded",b),S(R).on("load",b))},toString:function(){var a=[];p(this,function(b){a.push(""+b)});return"["+a.join(", ")+"]"},eq:function(a){return 0<=a?D(this[a]):D(this[this.length+a])},length:0,push:wg,sort:[].sort,splice:[].splice},Bb={};p("multiple selected checked disabled readOnly required open".split(" "),
	function(a){Bb[M(a)]=a});var Sc={};p("input select option textarea button form details".split(" "),function(a){Sc[a]=!0});var ad={ngMinlength:"minlength",ngMaxlength:"maxlength",ngMin:"min",ngMax:"max",ngPattern:"pattern"};p({data:Wb,removeData:ub,hasData:function(a){for(var b in fb[a.ng339])return!0;return!1}},function(a,b){S[b]=a});p({data:Wb,inheritedData:Ab,scope:function(a){return D.data(a,"$scope")||Ab(a.parentNode||a,["$isolateScope","$scope"])},isolateScope:function(a){return D.data(a,"$isolateScope")||
	D.data(a,"$isolateScopeNoTemplate")},controller:Pc,injector:function(a){return Ab(a,"$injector")},removeAttr:function(a,b){a.removeAttribute(b)},hasClass:xb,css:function(a,b,d){b=eb(b);if(w(d))a.style[b]=d;else return a.style[b]},attr:function(a,b,d){var c=a.nodeType;if(c!==Oa&&2!==c&&8!==c)if(c=M(b),Bb[c])if(w(d))d?(a[b]=!0,a.setAttribute(b,c)):(a[b]=!1,a.removeAttribute(c));else return a[b]||(a.attributes.getNamedItem(b)||v).specified?c:u;else if(w(d))a.setAttribute(b,d);else if(a.getAttribute)return a=
	a.getAttribute(b,2),null===a?u:a},prop:function(a,b,d){if(w(d))a[b]=d;else return a[b]},text:function(){function a(a,d){if(r(d)){var c=a.nodeType;return 1===c||c===Oa?a.textContent:""}a.textContent=d}a.$dv="";return a}(),val:function(a,b){if(r(b)){if(a.multiple&&"select"===oa(a)){var d=[];p(a.options,function(a){a.selected&&d.push(a.value||a.text)});return 0===d.length?null:d}return a.value}a.value=b},html:function(a,b){if(r(b))return a.innerHTML;tb(a,!0);a.innerHTML=b},empty:Qc},function(a,b){S.prototype[b]=
	function(b,c){var e,f,g=this.length;if(a!==Qc&&r(2==a.length&&a!==xb&&a!==Pc?b:c)){if(K(b)){for(e=0;e<g;e++)if(a===Wb)a(this[e],b);else for(f in b)a(this[e],f,b[f]);return this}e=a.$dv;g=r(e)?Math.min(g,1):g;for(f=0;f<g;f++){var h=a(this[f],b,c);e=e?e+h:h}return e}for(e=0;e<g;e++)a(this[e],b,c);return this}});p({removeData:ub,on:function(a,b,d,c){if(w(c))throw Ub("onargs");if(Kc(a)){c=vb(a,!0);var e=c.events,f=c.handle;f||(f=c.handle=Of(a,e));c=0<=b.indexOf(" ")?b.split(" "):[b];for(var g=c.length,
	h=function(b,c,g){var h=e[b];h||(h=e[b]=[],h.specialHandlerWrapper=c,"$destroy"===b||g||a.addEventListener(b,f,!1));h.push(d)};g--;)b=c[g],wb[b]?(h(wb[b],Qf),h(b,u,!0)):h(b)}},off:Oc,one:function(a,b,d){a=D(a);a.on(b,function e(){a.off(b,d);a.off(b,e)});a.on(b,d)},replaceWith:function(a,b){var d,c=a.parentNode;tb(a);p(new S(b),function(b){d?c.insertBefore(b,d.nextSibling):c.replaceChild(b,a);d=b})},children:function(a){var b=[];p(a.childNodes,function(a){1===a.nodeType&&b.push(a)});return b},contents:function(a){return a.contentDocument||
	a.childNodes||[]},append:function(a,b){var d=a.nodeType;if(1===d||11===d){b=new S(b);for(var d=0,c=b.length;d<c;d++)a.appendChild(b[d])}},prepend:function(a,b){if(1===a.nodeType){var d=a.firstChild;p(new S(b),function(b){a.insertBefore(b,d)})}},wrap:function(a,b){Mc(a,D(b).eq(0).clone()[0])},remove:Xb,detach:function(a){Xb(a,!0)},after:function(a,b){var d=a,c=a.parentNode;b=new S(b);for(var e=0,f=b.length;e<f;e++){var g=b[e];c.insertBefore(g,d.nextSibling);d=g}},addClass:zb,removeClass:yb,toggleClass:function(a,
	b,d){b&&p(b.split(" "),function(b){var e=d;r(e)&&(e=!xb(a,b));(e?zb:yb)(a,b)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,b){return a.getElementsByTagName?a.getElementsByTagName(b):[]},clone:Vb,triggerHandler:function(a,b,d){var c,e,f=b.type||b,g=vb(a);if(g=(g=g&&g.events)&&g[f])c={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=
	!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:v,type:f,target:a},b.type&&(c=N(c,b)),b=fa(g),e=d?[c].concat(d):[c],p(b,function(b){c.isImmediatePropagationStopped()||b.apply(a,e)})}},function(a,b){S.prototype[b]=function(b,c,e){for(var f,g=0,h=this.length;g<h;g++)r(f)?(f=a(this[g],b,c,e),w(f)&&(f=D(f))):Nc(f,a(this[g],b,c,e));return w(f)?f:this};S.prototype.bind=S.prototype.on;S.prototype.unbind=S.prototype.off});Ta.prototype={put:function(a,
	b){this[Da(a,this.nextUid)]=b},get:function(a){return this[Da(a,this.nextUid)]},remove:function(a){var b=this[a=Da(a,this.nextUid)];delete this[a];return b}};var Ff=[function(){this.$get=[function(){return Ta}]}],Uc=/^[^\(]*\(\s*([^\)]*)\)/m,xg=/,/,yg=/^\s*(_?)(\S+?)\1\s*$/,Tc=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,Ea=A("$injector");db.$$annotate=function(a,b,d){var c;if("function"===typeof a){if(!(c=a.$inject)){c=[];if(a.length){if(b)throw I(d)&&d||(d=a.name||Sf(a)),Ea("strictdi",d);b=a.toString().replace(Tc,
	"");b=b.match(Uc);p(b[1].split(xg),function(a){a.replace(yg,function(a,b,d){c.push(d)})})}a.$inject=c}}else L(a)?(b=a.length-1,Ra(a[b],"fn"),c=a.slice(0,b)):Ra(a,"fn",!0);return c};var Qd=A("$animate"),Ye=function(){this.$get=function(){}},Ze=function(){var a=new Ta,b=[];this.$get=["$$AnimateRunner","$rootScope",function(d,c){function e(a,b,c){var d=!1;b&&(b=I(b)?b.split(" "):L(b)?b:[],p(b,function(b){b&&(d=!0,a[b]=c)}));return d}function f(){p(b,function(b){var c=a.get(b);if(c){var d=Tf(b.attr("class")),
	e="",f="";p(c,function(a,b){a!==!!d[b]&&(a?e+=(e.length?" ":"")+b:f+=(f.length?" ":"")+b)});p(b,function(a){e&&zb(a,e);f&&yb(a,f)});a.remove(b)}});b.length=0}return{enabled:v,on:v,off:v,pin:v,push:function(g,h,k,m){m&&m();k=k||{};k.from&&g.css(k.from);k.to&&g.css(k.to);if(k.addClass||k.removeClass)if(h=k.addClass,m=k.removeClass,k=a.get(g)||{},h=e(k,h,!0),m=e(k,m,!1),h||m)a.put(g,k),b.push(g),1===b.length&&c.$$postDigest(f);g=new d;g.complete();return g}}}]},We=["$provide",function(a){var b=this;
	this.$$registeredAnimations=Object.create(null);this.register=function(d,c){if(d&&"."!==d.charAt(0))throw Qd("notcsel",d);var e=d+"-animation";b.$$registeredAnimations[d.substr(1)]=e;a.factory(e,c)};this.classNameFilter=function(a){if(1===arguments.length&&(this.$$classNameFilter=a instanceof RegExp?a:null)&&/(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString()))throw Qd("nongcls","ng-animate");return this.$$classNameFilter};this.$get=["$$animateQueue",function(a){function b(a,c,d){if(d){var h;
	a:{for(h=0;h<d.length;h++){var k=d[h];if(1===k.nodeType){h=k;break a}}h=void 0}!h||h.parentNode||h.previousElementSibling||(d=null)}d?d.after(a):c.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},enter:function(e,f,g,h){f=f&&D(f);g=g&&D(g);f=f||g.parent();b(e,f,g);return a.push(e,"enter",Fa(h))},move:function(e,f,g,h){f=f&&D(f);g=g&&D(g);f=f||g.parent();b(e,f,g);return a.push(e,"move",Fa(h))},leave:function(b,c){return a.push(b,"leave",Fa(c),function(){b.remove()})},
	addClass:function(b,c,g){g=Fa(g);g.addClass=gb(g.addclass,c);return a.push(b,"addClass",g)},removeClass:function(b,c,g){g=Fa(g);g.removeClass=gb(g.removeClass,c);return a.push(b,"removeClass",g)},setClass:function(b,c,g,h){h=Fa(h);h.addClass=gb(h.addClass,c);h.removeClass=gb(h.removeClass,g);return a.push(b,"setClass",h)},animate:function(b,c,g,h,k){k=Fa(k);k.from=k.from?N(k.from,c):c;k.to=k.to?N(k.to,g):g;k.tempClasses=gb(k.tempClasses,h||"ng-inline-animate");return a.push(b,"animate",k)}}}]}],af=
	function(){this.$get=["$$rAF",function(a){function b(b){d.push(b);1<d.length||a(function(){for(var a=0;a<d.length;a++)d[a]();d=[]})}var d=[];return function(){var a=!1;b(function(){a=!0});return function(d){a?d():b(d)}}}]},$e=function(){this.$get=["$q","$sniffer","$$animateAsyncRun","$document","$timeout",function(a,b,d,c,e){function f(a){this.setHost(a);var b=d();this._doneCallbacks=[];this._tick=function(a){var d=c[0];d&&d.hidden?e(a,0,!1):b(a)};this._state=0}f.chain=function(a,b){function c(){if(d===
	a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};f.all=function(a,b){function c(f){e=e&&f;++d===a.length&&b(e)}var d=0,e=!0;p(a,function(a){a.done(c)})};f.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===this._state?a():this._doneCallbacks.push(a)},progress:v,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},"catch":function(a){return this.getPromise()["catch"](a)},
	"finally":function(a){return this.getPromise()["finally"](a)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&this.host.end();this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._tick(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(p(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=
	0,this._state=2)}};return f}]},Xe=function(){this.$get=["$$rAF","$q","$$AnimateRunner",function(a,b,d){return function(b,e){function f(){a(function(){g.addClass&&(b.addClass(g.addClass),g.addClass=null);g.removeClass&&(b.removeClass(g.removeClass),g.removeClass=null);g.to&&(b.css(g.to),g.to=null);h||k.complete();h=!0});return k}var g=e||{};g.$$prepared||(g=Na(g));g.cleanupStyles&&(g.from=g.to=null);g.from&&(b.css(g.from),g.from=null);var h,k=new d;return{start:f,end:f}}}]},ga=A("$compile");Cc.$inject=
	["$provide","$$sanitizeUriProvider"];var Wc=/^((?:x|data)[\:\-_])/i,Yf=A("$controller"),Zc=/^(\S+)(\s+as\s+([\w$]+))?$/,gf=function(){this.$get=["$document",function(a){return function(b){b?!b.nodeType&&b instanceof D&&(b=b[0]):b=a[0].body;return b.offsetWidth+1}}]},bd="application/json",ac={"Content-Type":bd+";charset=utf-8"},$f=/^\[|^\{(?!\{)/,ag={"[":/]$/,"{":/}$/},Zf=/^\)\]\}',?\n/,zg=A("$http"),fd=function(a){return function(){throw zg("legacy",a);}},Ia=da.$interpolateMinErr=A("$interpolate");
	Ia.throwNoconcat=function(a){throw Ia("noconcat",a);};Ia.interr=function(a,b){return Ia("interr",a,b.toString())};var Ag=/^([^\?#]*)(\?([^#]*))?(#(.*))?$/,cg={http:80,https:443,ftp:21},Cb=A("$location"),Bg={$$html5:!1,$$replace:!1,absUrl:Db("$$absUrl"),url:function(a){if(r(a))return this.$$url;var b=Ag.exec(a);(b[1]||""===a)&&this.path(decodeURIComponent(b[1]));(b[2]||b[1]||""===a)&&this.search(b[3]||"");this.hash(b[5]||"");return this},protocol:Db("$$protocol"),host:Db("$$host"),port:Db("$$port"),
	path:kd("$$path",function(a){a=null!==a?a.toString():"";return"/"==a.charAt(0)?a:"/"+a}),search:function(a,b){switch(arguments.length){case 0:return this.$$search;case 1:if(I(a)||P(a))a=a.toString(),this.$$search=xc(a);else if(K(a))a=Na(a,{}),p(a,function(b,c){null==b&&delete a[c]}),this.$$search=a;else throw Cb("isrcharg");break;default:r(b)||null===b?delete this.$$search[a]:this.$$search[a]=b}this.$$compose();return this},hash:kd("$$hash",function(a){return null!==a?a.toString():""}),replace:function(){this.$$replace=
	!0;return this}};p([jd,dc,cc],function(a){a.prototype=Object.create(Bg);a.prototype.state=function(b){if(!arguments.length)return this.$$state;if(a!==cc||!this.$$html5)throw Cb("nostate");this.$$state=r(b)?null:b;return this}});var aa=A("$parse"),dg=Function.prototype.call,eg=Function.prototype.apply,fg=Function.prototype.bind,Lb=Z();p("+ - * / % === !== == != < > <= >= && || ! = |".split(" "),function(a){Lb[a]=!0});var Cg={n:"\n",f:"\f",r:"\r",t:"\t",v:"\v","'":"'",'"':'"'},fc=function(a){this.options=
	a};fc.prototype={constructor:fc,lex:function(a){this.text=a;this.index=0;for(this.tokens=[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'"'===a||"'"===a)this.readString(a);else if(this.isNumber(a)||"."===a&&this.isNumber(this.peek()))this.readNumber();else if(this.isIdent(a))this.readIdent();else if(this.is(a,"(){}[].,;:?"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;else{var b=a+this.peek(),d=b+this.peek(2),c=Lb[b],e=Lb[d];
	Lb[a]||c||e?(a=e?d:c?b:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=a.length):this.throwError("Unexpected next character ",this.index,this.index+1)}return this.tokens},is:function(a,b){return-1!==b.indexOf(a)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return"0"<=a&&"9">=a&&"string"===typeof a},isWhitespace:function(a){return" "===a||"\r"===a||"\t"===a||"\n"===a||"\v"===a||"\u00a0"===a},isIdent:function(a){return"a"<=
	a&&"z">=a||"A"<=a&&"Z">=a||"_"===a||"$"===a},isExpOperator:function(a){return"-"===a||"+"===a||this.isNumber(a)},throwError:function(a,b,d){d=d||this.index;b=w(b)?"s "+b+"-"+this.index+" ["+this.text.substring(b,d)+"]":" "+d;throw aa("lexerr",a,b,this.text);},readNumber:function(){for(var a="",b=this.index;this.index<this.text.length;){var d=M(this.text.charAt(this.index));if("."==d||this.isNumber(d))a+=d;else{var c=this.peek();if("e"==d&&this.isExpOperator(c))a+=d;else if(this.isExpOperator(d)&&
	c&&this.isNumber(c)&&"e"==a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||c&&this.isNumber(c)||"e"!=a.charAt(a.length-1))break;else this.throwError("Invalid exponent")}this.index++}this.tokens.push({index:b,text:a,constant:!0,value:Number(a)})},readIdent:function(){for(var a=this.index;this.index<this.text.length;){var b=this.text.charAt(this.index);if(!this.isIdent(b)&&!this.isNumber(b))break;this.index++}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var b=
	this.index;this.index++;for(var d="",c=a,e=!1;this.index<this.text.length;){var f=this.text.charAt(this.index),c=c+f;if(e)"u"===f?(e=this.text.substring(this.index+1,this.index+5),e.match(/[\da-f]{4}/i)||this.throwError("Invalid unicode escape [\\u"+e+"]"),this.index+=4,d+=String.fromCharCode(parseInt(e,16))):d+=Cg[f]||f,e=!1;else if("\\"===f)e=!0;else{if(f===a){this.index++;this.tokens.push({index:b,text:c,constant:!0,value:d});return}d+=f}this.index++}this.throwError("Unterminated quote",b)}};var s=
	function(a,b){this.lexer=a;this.options=b};s.Program="Program";s.ExpressionStatement="ExpressionStatement";s.AssignmentExpression="AssignmentExpression";s.ConditionalExpression="ConditionalExpression";s.LogicalExpression="LogicalExpression";s.BinaryExpression="BinaryExpression";s.UnaryExpression="UnaryExpression";s.CallExpression="CallExpression";s.MemberExpression="MemberExpression";s.Identifier="Identifier";s.Literal="Literal";s.ArrayExpression="ArrayExpression";s.Property="Property";s.ObjectExpression=
	"ObjectExpression";s.ThisExpression="ThisExpression";s.NGValueParameter="NGValueParameter";s.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError("is an unexpected token",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek("}",")",";","]")&&a.push(this.expressionStatement()),!this.expect(";"))return{type:s.Program,body:a}},expressionStatement:function(){return{type:s.ExpressionStatement,
	expression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect("|");)a=this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();this.expect("=")&&(a={type:s.AssignmentExpression,left:a,right:this.assignment(),operator:"="});return a},ternary:function(){var a=this.logicalOR(),b,d;return this.expect("?")&&(b=this.expression(),this.consume(":"))?(d=this.expression(),{type:s.ConditionalExpression,test:a,alternate:b,
	consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect("||");)a={type:s.LogicalExpression,operator:"||",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect("&&");)a={type:s.LogicalExpression,operator:"&&",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),b;b=this.expect("==","!=","===","!==");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.relational()};return a},relational:function(){for(var a=
	this.additive(),b;b=this.expect("<",">","<=",">=");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),b;b=this.expect("+","-");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),b;b=this.expect("*","/","%");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.unary()};return a},unary:function(){var a;return(a=this.expect("+",
	"-","!"))?{type:s.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},primary:function(){var a;this.expect("(")?(a=this.filterChain(),this.consume(")")):this.expect("[")?a=this.arrayDeclaration():this.expect("{")?a=this.object():this.constants.hasOwnProperty(this.peek().text)?a=Na(this.constants[this.consume().text]):this.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError("not a primary expression",this.peek());for(var b;b=this.expect("(",
	"[",".");)"("===b.text?(a={type:s.CallExpression,callee:a,arguments:this.parseArguments()},this.consume(")")):"["===b.text?(a={type:s.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume("]")):"."===b.text?a={type:s.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError("IMPOSSIBLE");return a},filter:function(a){a=[a];for(var b={type:s.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(":");)a.push(this.expression());return b},
	parseArguments:function(){var a=[];if(")"!==this.peekToken().text){do a.push(this.expression());while(this.expect(","))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError("is not a valid identifier",a);return{type:s.Identifier,name:a.text}},constant:function(){return{type:s.Literal,value:this.consume().value}},arrayDeclaration:function(){var a=[];if("]"!==this.peekToken().text){do{if(this.peek("]"))break;a.push(this.expression())}while(this.expect(","))}this.consume("]");
	return{type:s.ArrayExpression,elements:a}},object:function(){var a=[],b;if("}"!==this.peekToken().text){do{if(this.peek("}"))break;b={type:s.Property,kind:"init"};this.peek().constant?b.key=this.constant():this.peek().identifier?b.key=this.identifier():this.throwError("invalid key",this.peek());this.consume(":");b.value=this.expression();a.push(b)}while(this.expect(","))}this.consume("}");return{type:s.ObjectExpression,properties:a}},throwError:function(a,b){throw aa("syntax",b.text,a,b.index+1,this.text,
	this.text.substring(b.index));},consume:function(a){if(0===this.tokens.length)throw aa("ueoe",this.text);var b=this.expect(a);b||this.throwError("is unexpected, expecting ["+a+"]",this.peek());return b},peekToken:function(){if(0===this.tokens.length)throw aa("ueoe",this.text);return this.tokens[0]},peek:function(a,b,d,c){return this.peekAhead(0,a,b,d,c)},peekAhead:function(a,b,d,c,e){if(this.tokens.length>a){a=this.tokens[a];var f=a.text;if(f===b||f===d||f===c||f===e||!(b||d||c||e))return a}return!1},
	expect:function(a,b,d,c){return(a=this.peek(a,b,d,c))?(this.tokens.shift(),a):!1},constants:{"true":{type:s.Literal,value:!0},"false":{type:s.Literal,value:!1},"null":{type:s.Literal,value:null},undefined:{type:s.Literal,value:u},"this":{type:s.ThisExpression}}};sd.prototype={compile:function(a,b){var d=this,c=this.astBuilder.ast(a);this.state={nextId:0,filters:{},expensiveChecks:b,fn:{vars:[],body:[],own:{}},assign:{vars:[],body:[],own:{}},inputs:[]};X(c,d.$filter);var e="",f;this.stage="assign";
	if(f=qd(c))this.state.computing="assign",e=this.nextId(),this.recurse(f,e),this.return_(e),e="fn.assign="+this.generateFunction("assign","s,v,l");f=od(c.body);d.stage="inputs";p(f,function(a,b){var c="fn"+b;d.state[c]={vars:[],body:[],own:{}};d.state.computing=c;var e=d.nextId();d.recurse(a,e);d.return_(e);d.state.inputs.push(c);a.watchId=b});this.state.computing="fn";this.stage="main";this.recurse(c);e='"'+this.USE+" "+this.STRICT+'";\n'+this.filterPrefix()+"var fn="+this.generateFunction("fn","s,l,a,i")+
	e+this.watchFns()+"return fn;";e=(new Function("$filter","ensureSafeMemberName","ensureSafeObject","ensureSafeFunction","getStringValue","ensureSafeAssignContext","ifDefined","plus","text",e))(this.$filter,Wa,ya,md,ld,Eb,gg,nd,a);this.state=this.stage=u;e.literal=rd(c);e.constant=c.constant;return e},USE:"use",STRICT:"strict",watchFns:function(){var a=[],b=this.state.inputs,d=this;p(b,function(b){a.push("var "+b+"="+d.generateFunction(b,"s"))});b.length&&a.push("fn.inputs=["+b.join(",")+"];");return a.join("")},
	generateFunction:function(a,b){return"function("+b+"){"+this.varsPrefix(a)+this.body(a)+"};"},filterPrefix:function(){var a=[],b=this;p(this.state.filters,function(d,c){a.push(d+"=$filter("+b.escape(c)+")")});return a.length?"var "+a.join(",")+";":""},varsPrefix:function(a){return this.state[a].vars.length?"var "+this.state[a].vars.join(",")+";":""},body:function(a){return this.state[a].body.join("")},recurse:function(a,b,d,c,e,f){var g,h,k=this,m,l;c=c||v;if(!f&&w(a.watchId))b=b||this.nextId(),this.if_("i",
	this.lazyAssign(b,this.computedMember("i",a.watchId)),this.lazyRecurse(a,b,d,c,e,!0));else switch(a.type){case s.Program:p(a.body,function(b,c){k.recurse(b.expression,u,u,function(a){h=a});c!==a.body.length-1?k.current().body.push(h,";"):k.return_(h)});break;case s.Literal:l=this.escape(a.value);this.assign(b,l);c(l);break;case s.UnaryExpression:this.recurse(a.argument,u,u,function(a){h=a});l=a.operator+"("+this.ifDefined(h,0)+")";this.assign(b,l);c(l);break;case s.BinaryExpression:this.recurse(a.left,
	u,u,function(a){g=a});this.recurse(a.right,u,u,function(a){h=a});l="+"===a.operator?this.plus(g,h):"-"===a.operator?this.ifDefined(g,0)+a.operator+this.ifDefined(h,0):"("+g+")"+a.operator+"("+h+")";this.assign(b,l);c(l);break;case s.LogicalExpression:b=b||this.nextId();k.recurse(a.left,b);k.if_("&&"===a.operator?b:k.not(b),k.lazyRecurse(a.right,b));c(b);break;case s.ConditionalExpression:b=b||this.nextId();k.recurse(a.test,b);k.if_(b,k.lazyRecurse(a.alternate,b),k.lazyRecurse(a.consequent,b));c(b);
	break;case s.Identifier:b=b||this.nextId();d&&(d.context="inputs"===k.stage?"s":this.assign(this.nextId(),this.getHasOwnProperty("l",a.name)+"?l:s"),d.computed=!1,d.name=a.name);Wa(a.name);k.if_("inputs"===k.stage||k.not(k.getHasOwnProperty("l",a.name)),function(){k.if_("inputs"===k.stage||"s",function(){e&&1!==e&&k.if_(k.not(k.nonComputedMember("s",a.name)),k.lazyAssign(k.nonComputedMember("s",a.name),"{}"));k.assign(b,k.nonComputedMember("s",a.name))})},b&&k.lazyAssign(b,k.nonComputedMember("l",
	a.name)));(k.state.expensiveChecks||Fb(a.name))&&k.addEnsureSafeObject(b);c(b);break;case s.MemberExpression:g=d&&(d.context=this.nextId())||this.nextId();b=b||this.nextId();k.recurse(a.object,g,u,function(){k.if_(k.notNull(g),function(){e&&1!==e&&k.addEnsureSafeAssignContext(g);if(a.computed)h=k.nextId(),k.recurse(a.property,h),k.getStringValue(h),k.addEnsureSafeMemberName(h),e&&1!==e&&k.if_(k.not(k.computedMember(g,h)),k.lazyAssign(k.computedMember(g,h),"{}")),l=k.ensureSafeObject(k.computedMember(g,
	h)),k.assign(b,l),d&&(d.computed=!0,d.name=h);else{Wa(a.property.name);e&&1!==e&&k.if_(k.not(k.nonComputedMember(g,a.property.name)),k.lazyAssign(k.nonComputedMember(g,a.property.name),"{}"));l=k.nonComputedMember(g,a.property.name);if(k.state.expensiveChecks||Fb(a.property.name))l=k.ensureSafeObject(l);k.assign(b,l);d&&(d.computed=!1,d.name=a.property.name)}},function(){k.assign(b,"undefined")});c(b)},!!e);break;case s.CallExpression:b=b||this.nextId();a.filter?(h=k.filter(a.callee.name),m=[],p(a.arguments,
	function(a){var b=k.nextId();k.recurse(a,b);m.push(b)}),l=h+"("+m.join(",")+")",k.assign(b,l),c(b)):(h=k.nextId(),g={},m=[],k.recurse(a.callee,h,g,function(){k.if_(k.notNull(h),function(){k.addEnsureSafeFunction(h);p(a.arguments,function(a){k.recurse(a,k.nextId(),u,function(a){m.push(k.ensureSafeObject(a))})});g.name?(k.state.expensiveChecks||k.addEnsureSafeObject(g.context),l=k.member(g.context,g.name,g.computed)+"("+m.join(",")+")"):l=h+"("+m.join(",")+")";l=k.ensureSafeObject(l);k.assign(b,l)},
	function(){k.assign(b,"undefined")});c(b)}));break;case s.AssignmentExpression:h=this.nextId();g={};if(!pd(a.left))throw aa("lval");this.recurse(a.left,u,g,function(){k.if_(k.notNull(g.context),function(){k.recurse(a.right,h);k.addEnsureSafeObject(k.member(g.context,g.name,g.computed));k.addEnsureSafeAssignContext(g.context);l=k.member(g.context,g.name,g.computed)+a.operator+h;k.assign(b,l);c(b||l)})},1);break;case s.ArrayExpression:m=[];p(a.elements,function(a){k.recurse(a,k.nextId(),u,function(a){m.push(a)})});
	l="["+m.join(",")+"]";this.assign(b,l);c(l);break;case s.ObjectExpression:m=[];p(a.properties,function(a){k.recurse(a.value,k.nextId(),u,function(b){m.push(k.escape(a.key.type===s.Identifier?a.key.name:""+a.key.value)+":"+b)})});l="{"+m.join(",")+"}";this.assign(b,l);c(l);break;case s.ThisExpression:this.assign(b,"s");c("s");break;case s.NGValueParameter:this.assign(b,"v"),c("v")}},getHasOwnProperty:function(a,b){var d=a+"."+b,c=this.current().own;c.hasOwnProperty(d)||(c[d]=this.nextId(!1,a+"&&("+
	this.escape(b)+" in "+a+")"));return c[d]},assign:function(a,b){if(a)return this.current().body.push(a,"=",b,";"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,b){return"ifDefined("+a+","+this.escape(b)+")"},plus:function(a,b){return"plus("+a+","+b+")"},return_:function(a){this.current().body.push("return ",a,";")},if_:function(a,b,d){if(!0===a)b();else{var c=this.current().body;c.push("if(",a,
	"){");b();c.push("}");d&&(c.push("else{"),d(),c.push("}"))}},not:function(a){return"!("+a+")"},notNull:function(a){return a+"!=null"},nonComputedMember:function(a,b){return a+"."+b},computedMember:function(a,b){return a+"["+b+"]"},member:function(a,b,d){return d?this.computedMember(a,b):this.nonComputedMember(a,b)},addEnsureSafeObject:function(a){this.current().body.push(this.ensureSafeObject(a),";")},addEnsureSafeMemberName:function(a){this.current().body.push(this.ensureSafeMemberName(a),";")},
	addEnsureSafeFunction:function(a){this.current().body.push(this.ensureSafeFunction(a),";")},addEnsureSafeAssignContext:function(a){this.current().body.push(this.ensureSafeAssignContext(a),";")},ensureSafeObject:function(a){return"ensureSafeObject("+a+",text)"},ensureSafeMemberName:function(a){return"ensureSafeMemberName("+a+",text)"},ensureSafeFunction:function(a){return"ensureSafeFunction("+a+",text)"},getStringValue:function(a){this.assign(a,"getStringValue("+a+",text)")},ensureSafeAssignContext:function(a){return"ensureSafeAssignContext("+
	a+",text)"},lazyRecurse:function(a,b,d,c,e,f){var g=this;return function(){g.recurse(a,b,d,c,e,f)}},lazyAssign:function(a,b){var d=this;return function(){d.assign(a,b)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,stringEscapeFn:function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(I(a))return"'"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+"'";if(P(a))return a.toString();if(!0===a)return"true";if(!1===a)return"false";if(null===a)return"null";if("undefined"===
	typeof a)return"undefined";throw aa("esc");},nextId:function(a,b){var d="v"+this.state.nextId++;a||this.current().vars.push(d+(b?"="+b:""));return d},current:function(){return this.state[this.state.computing]}};td.prototype={compile:function(a,b){var d=this,c=this.astBuilder.ast(a);this.expression=a;this.expensiveChecks=b;X(c,d.$filter);var e,f;if(e=qd(c))f=this.recurse(e);e=od(c.body);var g;e&&(g=[],p(e,function(a,b){var c=d.recurse(a);a.input=c;g.push(c);a.watchId=b}));var h=[];p(c.body,function(a){h.push(d.recurse(a.expression))});
	e=0===c.body.length?function(){}:1===c.body.length?h[0]:function(a,b){var c;p(h,function(d){c=d(a,b)});return c};f&&(e.assign=function(a,b,c){return f(a,c,b)});g&&(e.inputs=g);e.literal=rd(c);e.constant=c.constant;return e},recurse:function(a,b,d){var c,e,f=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case s.Literal:return this.value(a.value,b);case s.UnaryExpression:return e=this.recurse(a.argument),this["unary"+a.operator](e,b);case s.BinaryExpression:return c=this.recurse(a.left),
	e=this.recurse(a.right),this["binary"+a.operator](c,e,b);case s.LogicalExpression:return c=this.recurse(a.left),e=this.recurse(a.right),this["binary"+a.operator](c,e,b);case s.ConditionalExpression:return this["ternary?:"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),b);case s.Identifier:return Wa(a.name,f.expression),f.identifier(a.name,f.expensiveChecks||Fb(a.name),b,d,f.expression);case s.MemberExpression:return c=this.recurse(a.object,!1,!!d),a.computed||(Wa(a.property.name,
	f.expression),e=a.property.name),a.computed&&(e=this.recurse(a.property)),a.computed?this.computedMember(c,e,b,d,f.expression):this.nonComputedMember(c,e,f.expensiveChecks,b,d,f.expression);case s.CallExpression:return g=[],p(a.arguments,function(a){g.push(f.recurse(a))}),a.filter&&(e=this.$filter(a.callee.name)),a.filter||(e=this.recurse(a.callee,!0)),a.filter?function(a,c,d,f){for(var n=[],p=0;p<g.length;++p)n.push(g[p](a,c,d,f));a=e.apply(u,n,f);return b?{context:u,name:u,value:a}:a}:function(a,
	c,d,l){var n=e(a,c,d,l),p;if(null!=n.value){ya(n.context,f.expression);md(n.value,f.expression);p=[];for(var r=0;r<g.length;++r)p.push(ya(g[r](a,c,d,l),f.expression));p=ya(n.value.apply(n.context,p),f.expression)}return b?{value:p}:p};case s.AssignmentExpression:return c=this.recurse(a.left,!0,1),e=this.recurse(a.right),function(a,d,g,l){var n=c(a,d,g,l);a=e(a,d,g,l);ya(n.value,f.expression);Eb(n.context);n.context[n.name]=a;return b?{value:a}:a};case s.ArrayExpression:return g=[],p(a.elements,function(a){g.push(f.recurse(a))}),
	function(a,c,d,e){for(var f=[],p=0;p<g.length;++p)f.push(g[p](a,c,d,e));return b?{value:f}:f};case s.ObjectExpression:return g=[],p(a.properties,function(a){g.push({key:a.key.type===s.Identifier?a.key.name:""+a.key.value,value:f.recurse(a.value)})}),function(a,c,d,e){for(var f={},p=0;p<g.length;++p)f[g[p].key]=g[p].value(a,c,d,e);return b?{value:f}:f};case s.ThisExpression:return function(a){return b?{value:a}:a};case s.NGValueParameter:return function(a,c,d,e){return b?{value:d}:d}}},"unary+":function(a,
	b){return function(d,c,e,f){d=a(d,c,e,f);d=w(d)?+d:0;return b?{value:d}:d}},"unary-":function(a,b){return function(d,c,e,f){d=a(d,c,e,f);d=w(d)?-d:0;return b?{value:d}:d}},"unary!":function(a,b){return function(d,c,e,f){d=!a(d,c,e,f);return b?{value:d}:d}},"binary+":function(a,b,d){return function(c,e,f,g){var h=a(c,e,f,g);c=b(c,e,f,g);h=nd(h,c);return d?{value:h}:h}},"binary-":function(a,b,d){return function(c,e,f,g){var h=a(c,e,f,g);c=b(c,e,f,g);h=(w(h)?h:0)-(w(c)?c:0);return d?{value:h}:h}},"binary*":function(a,
	b,d){return function(c,e,f,g){c=a(c,e,f,g)*b(c,e,f,g);return d?{value:c}:c}},"binary/":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)/b(c,e,f,g);return d?{value:c}:c}},"binary%":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)%b(c,e,f,g);return d?{value:c}:c}},"binary===":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)===b(c,e,f,g);return d?{value:c}:c}},"binary!==":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)!==b(c,e,f,g);return d?{value:c}:c}},"binary==":function(a,b,
	d){return function(c,e,f,g){c=a(c,e,f,g)==b(c,e,f,g);return d?{value:c}:c}},"binary!=":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)!=b(c,e,f,g);return d?{value:c}:c}},"binary<":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)<b(c,e,f,g);return d?{value:c}:c}},"binary>":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)>b(c,e,f,g);return d?{value:c}:c}},"binary<=":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)<=b(c,e,f,g);return d?{value:c}:c}},"binary>=":function(a,b,d){return function(c,
	e,f,g){c=a(c,e,f,g)>=b(c,e,f,g);return d?{value:c}:c}},"binary&&":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)&&b(c,e,f,g);return d?{value:c}:c}},"binary||":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)||b(c,e,f,g);return d?{value:c}:c}},"ternary?:":function(a,b,d,c){return function(e,f,g,h){e=a(e,f,g,h)?b(e,f,g,h):d(e,f,g,h);return c?{value:e}:e}},value:function(a,b){return function(){return b?{context:u,name:u,value:a}:a}},identifier:function(a,b,d,c,e){return function(f,g,h,k){f=
	g&&a in g?g:f;c&&1!==c&&f&&!f[a]&&(f[a]={});g=f?f[a]:u;b&&ya(g,e);return d?{context:f,name:a,value:g}:g}},computedMember:function(a,b,d,c,e){return function(f,g,h,k){var m=a(f,g,h,k),l,n;null!=m&&(l=b(f,g,h,k),l=ld(l),Wa(l,e),c&&1!==c&&(Eb(m),m&&!m[l]&&(m[l]={})),n=m[l],ya(n,e));return d?{context:m,name:l,value:n}:n}},nonComputedMember:function(a,b,d,c,e,f){return function(g,h,k,m){g=a(g,h,k,m);e&&1!==e&&(Eb(g),g&&!g[b]&&(g[b]={}));h=null!=g?g[b]:u;(d||Fb(b))&&ya(h,f);return c?{context:g,name:b,value:h}:
	h}},inputs:function(a,b){return function(d,c,e,f){return f?f[b]:a(d,c,e)}}};var gc=function(a,b,d){this.lexer=a;this.$filter=b;this.options=d;this.ast=new s(this.lexer);this.astCompiler=d.csp?new td(this.ast,b):new sd(this.ast,b)};gc.prototype={constructor:gc,parse:function(a){return this.astCompiler.compile(a,this.options.expensiveChecks)}};var hg=Object.prototype.valueOf,za=A("$sce"),ka={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},ga=A("$compile"),Y=U.createElement("a"),
	xd=xa(R.location.href);yd.$inject=["$document"];Jc.$inject=["$provide"];var Fd=22,Ed=".",ic="0";zd.$inject=["$locale"];Bd.$inject=["$locale"];var tg={yyyy:ba("FullYear",4),yy:ba("FullYear",2,0,!0),y:ba("FullYear",1),MMMM:Hb("Month"),MMM:Hb("Month",!0),MM:ba("Month",2,1),M:ba("Month",1,1),dd:ba("Date",2),d:ba("Date",1),HH:ba("Hours",2),H:ba("Hours",1),hh:ba("Hours",2,-12),h:ba("Hours",1,-12),mm:ba("Minutes",2),m:ba("Minutes",1),ss:ba("Seconds",2),s:ba("Seconds",1),sss:ba("Milliseconds",3),EEEE:Hb("Day"),
	EEE:Hb("Day",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?"+":"")+(Gb(Math[0<a?"floor":"ceil"](a/60),2)+Gb(Math.abs(a%60),2))},ww:Hd(2),w:Hd(1),G:jc,GG:jc,GGG:jc,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},sg=/((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,rg=/^\-?\d+$/;Ad.$inject=["$locale"];var mg=ma(M),ng=ma(rb);Cd.$inject=["$parse"];var me=ma({restrict:"E",compile:function(a,
	b){if(!b.href&&!b.xlinkHref)return function(a,b){if("a"===b[0].nodeName.toLowerCase()){var e="[object SVGAnimatedString]"===na.call(b.prop("href"))?"xlink:href":"href";b.on("click",function(a){b.attr(e)||a.preventDefault()})}}}}),sb={};p(Bb,function(a,b){function d(a,d,e){a.$watch(e[c],function(a){e.$set(b,!!a)})}if("multiple"!=a){var c=va("ng-"+b),e=d;"checked"===a&&(e=function(a,b,e){e.ngModel!==e[c]&&d(a,b,e)});sb[c]=function(){return{restrict:"A",priority:100,link:e}}}});p(ad,function(a,b){sb[b]=
	function(){return{priority:100,link:function(a,c,e){if("ngPattern"===b&&"/"==e.ngPattern.charAt(0)&&(c=e.ngPattern.match(vg))){e.$set("ngPattern",new RegExp(c[1],c[2]));return}a.$watch(e[b],function(a){e.$set(b,a)})}}}});p(["src","srcset","href"],function(a){var b=va("ng-"+a);sb[b]=function(){return{priority:99,link:function(d,c,e){var f=a,g=a;"href"===a&&"[object SVGAnimatedString]"===na.call(c.prop("href"))&&(g="xlinkHref",e.$attr[g]="xlink:href",f=null);e.$observe(b,function(b){b?(e.$set(g,b),
	Ha&&f&&c.prop(f,e[g])):"href"===a&&e.$set(g,null)})}}}});var Ib={$addControl:v,$$renameControl:function(a,b){a.$name=b},$removeControl:v,$setValidity:v,$setDirty:v,$setPristine:v,$setSubmitted:v};Id.$inject=["$element","$attrs","$scope","$animate","$interpolate"];var Rd=function(a){return["$timeout","$parse",function(b,d){function c(a){return""===a?d('this[""]').assign:d(a).assign||v}return{name:"form",restrict:a?"EAC":"E",require:["form","^^?form"],controller:Id,compile:function(d,f){d.addClass(Xa).addClass(lb);
	var g=f.name?"name":a&&f.ngForm?"ngForm":!1;return{pre:function(a,d,e,f){var n=f[0];if(!("action"in e)){var p=function(b){a.$apply(function(){n.$commitViewValue();n.$setSubmitted()});b.preventDefault()};d[0].addEventListener("submit",p,!1);d.on("$destroy",function(){b(function(){d[0].removeEventListener("submit",p,!1)},0,!1)})}(f[1]||n.$$parentForm).$addControl(n);var r=g?c(n.$name):v;g&&(r(a,n),e.$observe(g,function(b){n.$name!==b&&(r(a,u),n.$$parentForm.$$renameControl(n,b),r=c(n.$name),r(a,n))}));
	d.on("$destroy",function(){n.$$parentForm.$removeControl(n);r(a,u);N(n,Ib)})}}}}}]},ne=Rd(),Ae=Rd(!0),ug=/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/,Dg=/^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i,Eg=/^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,Fg=/^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,Sd=/^(\d{4})-(\d{2})-(\d{2})$/,Td=/^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
	mc=/^(\d{4})-W(\d\d)$/,Ud=/^(\d{4})-(\d\d)$/,Vd=/^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,Kd=Z();p(["date","datetime-local","month","time","week"],function(a){Kd[a]=!0});var Wd={text:function(a,b,d,c,e,f){ib(a,b,d,c,e,f);kc(c)},date:jb("date",Sd,Kb(Sd,["yyyy","MM","dd"]),"yyyy-MM-dd"),"datetime-local":jb("datetimelocal",Td,Kb(Td,"yyyy MM dd HH mm ss sss".split(" ")),"yyyy-MM-ddTHH:mm:ss.sss"),time:jb("time",Vd,Kb(Vd,["HH","mm","ss","sss"]),"HH:mm:ss.sss"),week:jb("week",mc,function(a,b){if(ea(a))return a;
	if(I(a)){mc.lastIndex=0;var d=mc.exec(a);if(d){var c=+d[1],e=+d[2],f=d=0,g=0,h=0,k=Gd(c),e=7*(e-1);b&&(d=b.getHours(),f=b.getMinutes(),g=b.getSeconds(),h=b.getMilliseconds());return new Date(c,0,k.getDate()+e,d,f,g,h)}}return NaN},"yyyy-Www"),month:jb("month",Ud,Kb(Ud,["yyyy","MM"]),"yyyy-MM"),number:function(a,b,d,c,e,f){Ld(a,b,d,c);ib(a,b,d,c,e,f);c.$$parserName="number";c.$parsers.push(function(a){return c.$isEmpty(a)?null:Fg.test(a)?parseFloat(a):u});c.$formatters.push(function(a){if(!c.$isEmpty(a)){if(!P(a))throw kb("numfmt",
	a);a=a.toString()}return a});if(w(d.min)||d.ngMin){var g;c.$validators.min=function(a){return c.$isEmpty(a)||r(g)||a>=g};d.$observe("min",function(a){w(a)&&!P(a)&&(a=parseFloat(a,10));g=P(a)&&!isNaN(a)?a:u;c.$validate()})}if(w(d.max)||d.ngMax){var h;c.$validators.max=function(a){return c.$isEmpty(a)||r(h)||a<=h};d.$observe("max",function(a){w(a)&&!P(a)&&(a=parseFloat(a,10));h=P(a)&&!isNaN(a)?a:u;c.$validate()})}},url:function(a,b,d,c,e,f){ib(a,b,d,c,e,f);kc(c);c.$$parserName="url";c.$validators.url=
	function(a,b){var d=a||b;return c.$isEmpty(d)||Dg.test(d)}},email:function(a,b,d,c,e,f){ib(a,b,d,c,e,f);kc(c);c.$$parserName="email";c.$validators.email=function(a,b){var d=a||b;return c.$isEmpty(d)||Eg.test(d)}},radio:function(a,b,d,c){r(d.name)&&b.attr("name",++mb);b.on("click",function(a){b[0].checked&&c.$setViewValue(d.value,a&&a.type)});c.$render=function(){b[0].checked=d.value==c.$viewValue};d.$observe("value",c.$render)},checkbox:function(a,b,d,c,e,f,g,h){var k=Md(h,a,"ngTrueValue",d.ngTrueValue,
	!0),m=Md(h,a,"ngFalseValue",d.ngFalseValue,!1);b.on("click",function(a){c.$setViewValue(b[0].checked,a&&a.type)});c.$render=function(){b[0].checked=c.$viewValue};c.$isEmpty=function(a){return!1===a};c.$formatters.push(function(a){return la(a,k)});c.$parsers.push(function(a){return a?k:m})},hidden:v,button:v,submit:v,reset:v,file:v},Dc=["$browser","$sniffer","$filter","$parse",function(a,b,d,c){return{restrict:"E",require:["?ngModel"],link:{pre:function(e,f,g,h){h[0]&&(Wd[M(g.type)]||Wd.text)(e,f,
	g,h[0],b,a,d,c)}}}}],Gg=/^(true|false|\d+)$/,Se=function(){return{restrict:"A",priority:100,compile:function(a,b){return Gg.test(b.ngValue)?function(a,b,e){e.$set("value",a.$eval(e.ngValue))}:function(a,b,e){a.$watch(e.ngValue,function(a){e.$set("value",a)})}}}},se=["$compile",function(a){return{restrict:"AC",compile:function(b){a.$$addBindingClass(b);return function(b,c,e){a.$$addBindingInfo(c,e.ngBind);c=c[0];b.$watch(e.ngBind,function(a){c.textContent=r(a)?"":a})}}}}],ue=["$interpolate","$compile",
	function(a,b){return{compile:function(d){b.$$addBindingClass(d);return function(c,d,f){c=a(d.attr(f.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];f.$observe("ngBindTemplate",function(a){d.textContent=r(a)?"":a})}}}}],te=["$sce","$parse","$compile",function(a,b,d){return{restrict:"A",compile:function(c,e){var f=b(e.ngBindHtml),g=b(e.ngBindHtml,function(b){return a.valueOf(b)});d.$$addBindingClass(c);return function(b,c,e){d.$$addBindingInfo(c,e.ngBindHtml);b.$watch(g,function(){var d=
	f(b);c.html(a.getTrustedHtml(d)||"")})}}}}],Re=ma({restrict:"A",require:"ngModel",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),ve=lc("",!0),xe=lc("Odd",0),we=lc("Even",1),ye=Ka({compile:function(a,b){b.$set("ngCloak",u);a.removeClass("ng-cloak")}}),ze=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],Ic={},Hg={blur:!0,focus:!0};p("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),
	function(a){var b=va("ng-"+a);Ic[b]=["$parse","$rootScope",function(d,c){return{restrict:"A",compile:function(e,f){var g=d(f[b],null,!0);return function(b,d){d.on(a,function(d){var e=function(){g(b,{$event:d})};Hg[a]&&c.$$phase?b.$evalAsync(e):b.$apply(e)})}}}}]});var Ce=["$animate",function(a){return{multiElement:!0,transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,link:function(b,d,c,e,f){var g,h,k;b.$watch(c.ngIf,function(b){b?h||f(function(b,e){h=e;b[b.length++]=U.createComment(" end ngIf: "+
	c.ngIf+" ");g={clone:b};a.enter(b,d.parent(),d)}):(k&&(k.remove(),k=null),h&&(h.$destroy(),h=null),g&&(k=qb(g.clone),a.leave(k).then(function(){k=null}),g=null))})}}}],De=["$templateRequest","$anchorScroll","$animate",function(a,b,d){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:da.noop,compile:function(c,e){var f=e.ngInclude||e.src,g=e.onload||"",h=e.autoscroll;return function(c,e,l,n,p){var r=0,t,s,q,y=function(){s&&(s.remove(),s=null);t&&(t.$destroy(),t=null);q&&
	(d.leave(q).then(function(){s=null}),s=q,q=null)};c.$watch(f,function(f){var l=function(){!w(h)||h&&!c.$eval(h)||b()},s=++r;f?(a(f,!0).then(function(a){if(!c.$$destroyed&&s===r){var b=c.$new();n.template=a;a=p(b,function(a){y();d.enter(a,null,e).then(l)});t=b;q=a;t.$emit("$includeContentLoaded",f);c.$eval(g)}},function(){c.$$destroyed||s!==r||(y(),c.$emit("$includeContentError",f))}),c.$emit("$includeContentRequested",f)):(y(),n.template=null)})}}}}],Ue=["$compile",function(a){return{restrict:"ECA",
	priority:-400,require:"ngInclude",link:function(b,d,c,e){/SVG/.test(d[0].toString())?(d.empty(),a(Lc(e.template,U).childNodes)(b,function(a){d.append(a)},{futureParentElement:d})):(d.html(e.template),a(d.contents())(b))}}}],Ee=Ka({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),Qe=function(){return{restrict:"A",priority:100,require:"ngModel",link:function(a,b,d,c){var e=b.attr(d.$attr.ngList)||", ",f="false"!==d.ngTrim,g=f?T(e):e;c.$parsers.push(function(a){if(!r(a)){var b=
	[];a&&p(a.split(g),function(a){a&&b.push(f?T(a):a)});return b}});c.$formatters.push(function(a){return L(a)?a.join(e):u});c.$isEmpty=function(a){return!a||!a.length}}}},lb="ng-valid",Nd="ng-invalid",Xa="ng-pristine",Jb="ng-dirty",Pd="ng-pending",kb=A("ngModel"),Ig=["$scope","$exceptionHandler","$attrs","$element","$parse","$animate","$timeout","$rootScope","$q","$interpolate",function(a,b,d,c,e,f,g,h,k,m){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=u;this.$validators={};this.$asyncValidators=
	{};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=u;this.$name=m(d.name||"",!1)(a);this.$$parentForm=Ib;var l=e(d.ngModel),n=l.assign,s=l,z=n,t=null,F,q=this;this.$$setOptions=function(a){if((q.$options=a)&&a.getterSetter){var b=e(d.ngModel+"()"),f=e(d.ngModel+"($$$p)");s=function(a){var c=l(a);H(c)&&(c=b(a));return c};z=function(a,
	b){H(l(a))?f(a,{$$$p:q.$modelValue}):n(a,q.$modelValue)}}else if(!l.assign)throw kb("nonassign",d.ngModel,ua(c));};this.$render=v;this.$isEmpty=function(a){return r(a)||""===a||null===a||a!==a};var y=0;Jd({ctrl:this,$element:c,set:function(a,b){a[b]=!0},unset:function(a,b){delete a[b]},$animate:f});this.$setPristine=function(){q.$dirty=!1;q.$pristine=!0;f.removeClass(c,Jb);f.addClass(c,Xa)};this.$setDirty=function(){q.$dirty=!0;q.$pristine=!1;f.removeClass(c,Xa);f.addClass(c,Jb);q.$$parentForm.$setDirty()};
	this.$setUntouched=function(){q.$touched=!1;q.$untouched=!0;f.setClass(c,"ng-untouched","ng-touched")};this.$setTouched=function(){q.$touched=!0;q.$untouched=!1;f.setClass(c,"ng-touched","ng-untouched")};this.$rollbackViewValue=function(){g.cancel(t);q.$viewValue=q.$$lastCommittedViewValue;q.$render()};this.$validate=function(){if(!P(q.$modelValue)||!isNaN(q.$modelValue)){var a=q.$$rawModelValue,b=q.$valid,c=q.$modelValue,d=q.$options&&q.$options.allowInvalid;q.$$runValidators(a,q.$$lastCommittedViewValue,
	function(e){d||b===e||(q.$modelValue=e?a:u,q.$modelValue!==c&&q.$$writeModelToScope())})}};this.$$runValidators=function(a,b,c){function d(){var c=!0;p(q.$validators,function(d,e){var g=d(a,b);c=c&&g;f(e,g)});return c?!0:(p(q.$asyncValidators,function(a,b){f(b,null)}),!1)}function e(){var c=[],d=!0;p(q.$asyncValidators,function(e,g){var h=e(a,b);if(!h||!H(h.then))throw kb("nopromise",h);f(g,u);c.push(h.then(function(){f(g,!0)},function(a){d=!1;f(g,!1)}))});c.length?k.all(c).then(function(){g(d)},
	v):g(!0)}function f(a,b){h===y&&q.$setValidity(a,b)}function g(a){h===y&&c(a)}y++;var h=y;(function(){var a=q.$$parserName||"parse";if(r(F))f(a,null);else return F||(p(q.$validators,function(a,b){f(b,null)}),p(q.$asyncValidators,function(a,b){f(b,null)})),f(a,F),F;return!0})()?d()?e():g(!1):g(!1)};this.$commitViewValue=function(){var a=q.$viewValue;g.cancel(t);if(q.$$lastCommittedViewValue!==a||""===a&&q.$$hasNativeValidators)q.$$lastCommittedViewValue=a,q.$pristine&&this.$setDirty(),this.$$parseAndValidate()};
	this.$$parseAndValidate=function(){var b=q.$$lastCommittedViewValue;if(F=r(b)?u:!0)for(var c=0;c<q.$parsers.length;c++)if(b=q.$parsers[c](b),r(b)){F=!1;break}P(q.$modelValue)&&isNaN(q.$modelValue)&&(q.$modelValue=s(a));var d=q.$modelValue,e=q.$options&&q.$options.allowInvalid;q.$$rawModelValue=b;e&&(q.$modelValue=b,q.$modelValue!==d&&q.$$writeModelToScope());q.$$runValidators(b,q.$$lastCommittedViewValue,function(a){e||(q.$modelValue=a?b:u,q.$modelValue!==d&&q.$$writeModelToScope())})};this.$$writeModelToScope=
	function(){z(a,q.$modelValue);p(q.$viewChangeListeners,function(a){try{a()}catch(c){b(c)}})};this.$setViewValue=function(a,b){q.$viewValue=a;q.$options&&!q.$options.updateOnDefault||q.$$debounceViewValueCommit(b)};this.$$debounceViewValueCommit=function(b){var c=0,d=q.$options;d&&w(d.debounce)&&(d=d.debounce,P(d)?c=d:P(d[b])?c=d[b]:P(d["default"])&&(c=d["default"]));g.cancel(t);c?t=g(function(){q.$commitViewValue()},c):h.$$phase?q.$commitViewValue():a.$apply(function(){q.$commitViewValue()})};a.$watch(function(){var b=
	s(a);if(b!==q.$modelValue&&(q.$modelValue===q.$modelValue||b===b)){q.$modelValue=q.$$rawModelValue=b;F=u;for(var c=q.$formatters,d=c.length,e=b;d--;)e=c[d](e);q.$viewValue!==e&&(q.$viewValue=q.$$lastCommittedViewValue=e,q.$render(),q.$$runValidators(b,e,v))}return b})}],Pe=["$rootScope",function(a){return{restrict:"A",require:["ngModel","^?form","^?ngModelOptions"],controller:Ig,priority:1,compile:function(b){b.addClass(Xa).addClass("ng-untouched").addClass(lb);return{pre:function(a,b,e,f){var g=
	f[0];b=f[1]||g.$$parentForm;g.$$setOptions(f[2]&&f[2].$options);b.$addControl(g);e.$observe("name",function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on("$destroy",function(){g.$$parentForm.$removeControl(g)})},post:function(b,c,e,f){var g=f[0];if(g.$options&&g.$options.updateOn)c.on(g.$options.updateOn,function(a){g.$$debounceViewValueCommit(a&&a.type)});c.on("blur",function(c){g.$touched||(a.$$phase?b.$evalAsync(g.$setTouched):b.$apply(g.$setTouched))})}}}}}],Jg=/(\s+|^)default(\s+|$)/,
	Te=function(){return{restrict:"A",controller:["$scope","$attrs",function(a,b){var d=this;this.$options=Na(a.$eval(b.ngModelOptions));w(this.$options.updateOn)?(this.$options.updateOnDefault=!1,this.$options.updateOn=T(this.$options.updateOn.replace(Jg,function(){d.$options.updateOnDefault=!0;return" "}))):this.$options.updateOnDefault=!0}]}},Fe=Ka({terminal:!0,priority:1E3}),Kg=A("ngOptions"),Lg=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
	Ne=["$compile","$parse",function(a,b){function d(a,c,d){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function m(a){var b;if(!p&&Aa(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&"$"!==c.charAt(0)&&b.push(c)}return b}var l=a.match(Lg);if(!l)throw Kg("iexp",a,ua(c));var n=l[5]||l[7],p=l[6];a=/ as /.test(l[0])&&l[1];var r=l[9];c=b(l[2]?l[1]:n);var s=a&&b(a)||c,u=r&&b(r),q=r?function(a,b){return u(d,b)}:function(a){return Da(a)},y=function(a,
	b){return q(a,C(a,b))},x=b(l[2]||l[1]),w=b(l[3]||""),E=b(l[4]||""),v=b(l[8]),B={},C=p?function(a,b){B[p]=b;B[n]=a;return B}:function(a){B[n]=a;return B};return{trackBy:r,getTrackByValue:y,getWatchables:b(v,function(a){var b=[];a=a||[];for(var c=m(a),e=c.length,f=0;f<e;f++){var g=a===c?f:c[f],k=C(a[g],g),g=q(a[g],k);b.push(g);if(l[2]||l[1])g=x(d,k),b.push(g);l[4]&&(k=E(d,k),b.push(k))}return b}),getOptions:function(){for(var a=[],b={},c=v(d)||[],f=m(c),g=f.length,l=0;l<g;l++){var n=c===f?l:f[l],p=
	C(c[n],n),u=s(d,p),n=q(u,p),F=x(d,p),G=w(d,p),p=E(d,p),u=new e(n,u,F,G,p);a.push(u);b[n]=u}return{items:a,selectValueMap:b,getOptionFromViewValue:function(a){return b[y(a)]},getViewValueFromOption:function(a){return r?da.copy(a.viewValue):a.viewValue}}}}}var c=U.createElement("option"),e=U.createElement("optgroup");return{restrict:"A",terminal:!0,require:["select","?ngModel"],link:{pre:function(a,b,c,d){d[0].registerOption=v},post:function(b,g,h,k){function m(a,b){a.element=b;b.disabled=a.disabled;
	a.label!==b.label&&(b.label=a.label,b.textContent=a.label);a.value!==b.value&&(b.value=a.selectValue)}function l(a,b,c,d){b&&M(b.nodeName)===c?c=b:(c=d.cloneNode(!1),b?a.insertBefore(c,b):a.appendChild(c));return c}function n(a){for(var b;a;)b=a.nextSibling,Xb(a),a=b}function r(a){var b=y&&y[0],c=v&&v[0];if(b||c)for(;a&&(a===b||a===c||8===a.nodeType||"option"===oa(a)&&""===a.value);)a=a.nextSibling;return a}function s(){var a=B&&u.readValue();B=C.getOptions();var b={},d=g[0].firstChild;E&&g.prepend(y);
	d=r(d);B.items.forEach(function(a){var f,h;a.group?(f=b[a.group],f||(f=l(g[0],d,"optgroup",e),d=f.nextSibling,f.label=a.group,f=b[a.group]={groupElement:f,currentOptionElement:f.firstChild}),h=l(f.groupElement,f.currentOptionElement,"option",c),m(a,h),f.currentOptionElement=h.nextSibling):(h=l(g[0],d,"option",c),m(a,h),d=h.nextSibling)});Object.keys(b).forEach(function(a){n(b[a].currentOptionElement)});n(d);t.$render();if(!t.$isEmpty(a)){var f=u.readValue();(C.trackBy||q?la(a,f):a===f)||(t.$setViewValue(f),
	t.$render())}}var t=k[1];if(t){var u=k[0],q=h.multiple,y;k=0;for(var x=g.children(),w=x.length;k<w;k++)if(""===x[k].value){y=x.eq(k);break}var E=!!y,v=D(c.cloneNode(!1));v.val("?");var B,C=d(h.ngOptions,g,b);q?(t.$isEmpty=function(a){return!a||0===a.length},u.writeValue=function(a){B.items.forEach(function(a){a.element.selected=!1});a&&a.forEach(function(a){(a=B.getOptionFromViewValue(a))&&!a.disabled&&(a.element.selected=!0)})},u.readValue=function(){var a=g.val()||[],b=[];p(a,function(a){(a=B.selectValueMap[a])&&
	!a.disabled&&b.push(B.getViewValueFromOption(a))});return b},C.trackBy&&b.$watchCollection(function(){if(L(t.$viewValue))return t.$viewValue.map(function(a){return C.getTrackByValue(a)})},function(){t.$render()})):(u.writeValue=function(a){var b=B.getOptionFromViewValue(a);b&&!b.disabled?(g[0].value!==b.selectValue&&(v.remove(),E||y.remove(),g[0].value=b.selectValue,b.element.selected=!0),b.element.setAttribute("selected","selected")):null===a||E?(v.remove(),E||g.prepend(y),g.val(""),y.prop("selected",
	!0),y.attr("selected",!0)):(E||y.remove(),g.prepend(v),g.val("?"),v.prop("selected",!0),v.attr("selected",!0))},u.readValue=function(){var a=B.selectValueMap[g.val()];return a&&!a.disabled?(E||y.remove(),v.remove(),B.getViewValueFromOption(a)):null},C.trackBy&&b.$watch(function(){return C.getTrackByValue(t.$viewValue)},function(){t.$render()}));E?(y.remove(),a(y)(b),y.removeClass("ng-scope")):y=D(c.cloneNode(!1));s();b.$watchCollection(C.getWatchables,s)}}}}}],Ge=["$locale","$interpolate","$log",
	function(a,b,d){var c=/{}/g,e=/^when(Minus)?(.+)$/;return{link:function(f,g,h){function k(a){g.text(a||"")}var m=h.count,l=h.$attr.when&&g.attr(h.$attr.when),n=h.offset||0,s=f.$eval(l)||{},u={},t=b.startSymbol(),w=b.endSymbol(),q=t+m+"-"+n+w,y=da.noop,x;p(h,function(a,b){var c=e.exec(b);c&&(c=(c[1]?"-":"")+M(c[2]),s[c]=g.attr(h.$attr[b]))});p(s,function(a,d){u[d]=b(a.replace(c,q))});f.$watch(m,function(b){var c=parseFloat(b),e=isNaN(c);e||c in s||(c=a.pluralCat(c-n));c===x||e&&P(x)&&isNaN(x)||(y(),
	e=u[c],r(e)?(null!=b&&d.debug("ngPluralize: no rule defined for '"+c+"' in "+l),y=v,k()):y=f.$watch(e,k),x=c)})}}}],He=["$parse","$animate",function(a,b){var d=A("ngRepeat"),c=function(a,b,c,d,k,m,l){a[c]=d;k&&(a[k]=m);a.$index=b;a.$first=0===b;a.$last=b===l-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(b&1))};return{restrict:"A",multiElement:!0,transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(e,f){var g=f.ngRepeat,h=U.createComment(" end ngRepeat: "+g+" "),k=g.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
	if(!k)throw d("iexp",g);var m=k[1],l=k[2],n=k[3],r=k[4],k=m.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);if(!k)throw d("iidexp",m);var s=k[3]||k[1],t=k[2];if(n&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(n)||/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(n)))throw d("badident",n);var v,q,y,x,w={$id:Da};r?v=a(r):(y=function(a,b){return Da(b)},x=function(a){return a});return function(a,e,f,k,m){v&&(q=function(b,c,d){t&&(w[t]=b);w[s]=c;w.$index=
	d;return v(a,w)});var r=Z();a.$watchCollection(l,function(f){var k,l,v=e[0],w,B=Z(),C,F,D,G,H,A,I;n&&(a[n]=f);if(Aa(f))H=f,l=q||y;else for(I in l=q||x,H=[],f)sa.call(f,I)&&"$"!==I.charAt(0)&&H.push(I);C=H.length;I=Array(C);for(k=0;k<C;k++)if(F=f===H?k:H[k],D=f[F],G=l(F,D,k),r[G])A=r[G],delete r[G],B[G]=A,I[k]=A;else{if(B[G])throw p(I,function(a){a&&a.scope&&(r[a.id]=a)}),d("dupes",g,G,D);I[k]={id:G,scope:u,clone:u};B[G]=!0}for(w in r){A=r[w];G=qb(A.clone);b.leave(G);if(G[0].parentNode)for(k=0,l=G.length;k<
	l;k++)G[k].$$NG_REMOVED=!0;A.scope.$destroy()}for(k=0;k<C;k++)if(F=f===H?k:H[k],D=f[F],A=I[k],A.scope){w=v;do w=w.nextSibling;while(w&&w.$$NG_REMOVED);A.clone[0]!=w&&b.move(qb(A.clone),null,v);v=A.clone[A.clone.length-1];c(A.scope,k,s,D,t,F,C)}else m(function(a,d){A.scope=d;var e=h.cloneNode(!1);a[a.length++]=e;b.enter(a,null,v);v=e;A.clone=a;B[A.id]=A;c(A.scope,k,s,D,t,F,C)});r=B})}}}}],Ie=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(b,d,c){b.$watch(c.ngShow,function(b){a[b?
	"removeClass":"addClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],Be=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(b,d,c){b.$watch(c.ngHide,function(b){a[b?"addClass":"removeClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],Je=Ka(function(a,b,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&p(d,function(a,c){b.css(c,"")});a&&b.css(a)},!0)}),Ke=["$animate",function(a){return{require:"ngSwitch",controller:["$scope",function(){this.cases={}}],link:function(b,
	d,c,e){var f=[],g=[],h=[],k=[],m=function(a,b){return function(){a.splice(b,1)}};b.$watch(c.ngSwitch||c.on,function(b){var c,d;c=0;for(d=h.length;c<d;++c)a.cancel(h[c]);c=h.length=0;for(d=k.length;c<d;++c){var r=qb(g[c].clone);k[c].$destroy();(h[c]=a.leave(r)).then(m(h,c))}g.length=0;k.length=0;(f=e.cases["!"+b]||e.cases["?"])&&p(f,function(b){b.transclude(function(c,d){k.push(d);var e=b.element;c[c.length++]=U.createComment(" end ngSwitchWhen: ");g.push({clone:c});a.enter(c,e.parent(),e)})})})}}}],
	Le=Ka({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,b,d,c,e){c.cases["!"+d.ngSwitchWhen]=c.cases["!"+d.ngSwitchWhen]||[];c.cases["!"+d.ngSwitchWhen].push({transclude:e,element:b})}}),Me=Ka({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,b,d,c,e){c.cases["?"]=c.cases["?"]||[];c.cases["?"].push({transclude:e,element:b})}}),Oe=Ka({restrict:"EAC",link:function(a,b,d,c,e){if(!e)throw A("ngTransclude")("orphan",ua(b));e(function(a){b.empty();
	b.append(a)})}}),oe=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(b,d){"text/ng-template"==d.type&&a.put(d.id,b[0].text)}}}],Mg={$setViewValue:v,$render:v},Ng=["$element","$scope","$attrs",function(a,b,d){var c=this,e=new Ta;c.ngModelCtrl=Mg;c.unknownOption=D(U.createElement("option"));c.renderUnknownOption=function(b){b="? "+Da(b)+" ?";c.unknownOption.val(b);a.prepend(c.unknownOption);a.val(b)};b.$on("$destroy",function(){c.renderUnknownOption=v});c.removeUnknownOption=
	function(){c.unknownOption.parent()&&c.unknownOption.remove()};c.readValue=function(){c.removeUnknownOption();return a.val()};c.writeValue=function(b){c.hasOption(b)?(c.removeUnknownOption(),a.val(b),""===b&&c.emptyOption.prop("selected",!0)):null==b&&c.emptyOption?(c.removeUnknownOption(),a.val("")):c.renderUnknownOption(b)};c.addOption=function(a,b){if(8!==b[0].nodeType){Sa(a,'"option value"');""===a&&(c.emptyOption=b);var d=e.get(a)||0;e.put(a,d+1);c.ngModelCtrl.$render();b[0].hasAttribute("selected")&&
	(b[0].selected=!0)}};c.removeOption=function(a){var b=e.get(a);b&&(1===b?(e.remove(a),""===a&&(c.emptyOption=u)):e.put(a,b-1))};c.hasOption=function(a){return!!e.get(a)};c.registerOption=function(a,b,d,e,m){if(e){var l;d.$observe("value",function(a){w(l)&&c.removeOption(l);l=a;c.addOption(a,b)})}else m?a.$watch(m,function(a,e){d.$set("value",a);e!==a&&c.removeOption(e);c.addOption(a,b)}):c.addOption(d.value,b);b.on("$destroy",function(){c.removeOption(d.value);c.ngModelCtrl.$render()})}}],pe=function(){return{restrict:"E",
	require:["select","?ngModel"],controller:Ng,priority:1,link:{pre:function(a,b,d,c){var e=c[1];if(e){var f=c[0];f.ngModelCtrl=e;b.on("change",function(){a.$apply(function(){e.$setViewValue(f.readValue())})});if(d.multiple){f.readValue=function(){var a=[];p(b.find("option"),function(b){b.selected&&a.push(b.value)});return a};f.writeValue=function(a){var c=new Ta(a);p(b.find("option"),function(a){a.selected=w(c.get(a.value))})};var g,h=NaN;a.$watch(function(){h!==e.$viewValue||la(g,e.$viewValue)||(g=
	fa(e.$viewValue),e.$render());h=e.$viewValue});e.$isEmpty=function(a){return!a||0===a.length}}}},post:function(a,b,d,c){var e=c[1];if(e){var f=c[0];e.$render=function(){f.writeValue(e.$viewValue)}}}}}},re=["$interpolate",function(a){return{restrict:"E",priority:100,compile:function(b,d){if(w(d.value))var c=a(d.value,!0);else{var e=a(b.text(),!0);e||d.$set("value",b.text())}return function(a,b,d){var k=b.parent();(k=k.data("$selectController")||k.parent().data("$selectController"))&&k.registerOption(a,
	b,d,c,e)}}}}],qe=ma({restrict:"E",terminal:!1}),Fc=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){c&&(d.required=!0,c.$validators.required=function(a,b){return!d.required||!c.$isEmpty(b)},d.$observe("required",function(){c.$validate()}))}}},Ec=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){if(c){var e,f=d.ngPattern||d.pattern;d.$observe("pattern",function(a){I(a)&&0<a.length&&(a=new RegExp("^"+a+"$"));if(a&&!a.test)throw A("ngPattern")("noregexp",
	f,a,ua(b));e=a||u;c.$validate()});c.$validators.pattern=function(a,b){return c.$isEmpty(b)||r(e)||e.test(b)}}}}},Hc=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){if(c){var e=-1;d.$observe("maxlength",function(a){a=ca(a);e=isNaN(a)?-1:a;c.$validate()});c.$validators.maxlength=function(a,b){return 0>e||c.$isEmpty(b)||b.length<=e}}}}},Gc=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){if(c){var e=0;d.$observe("minlength",function(a){e=ca(a)||0;c.$validate()});
	c.$validators.minlength=function(a,b){return c.$isEmpty(b)||b.length>=e}}}}};R.angular.bootstrap?R.console&&console.log("WARNING: Tried to load angular more than once."):(he(),je(da),da.module("ngLocale",[],["$provide",function(a){function b(a){a+="";var b=a.indexOf(".");return-1==b?0:a.length-b-1}a.value("$locale",{DATETIME_FORMATS:{AMPMS:["AM","PM"],DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ERANAMES:["Before Christ","Anno Domini"],ERAS:["BC","AD"],FIRSTDAYOFWEEK:6,
	MONTH:"January February March April May June July August September October November December".split(" "),SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "),SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),STANDALONEMONTH:"January February March April May June July August September October November December".split(" "),WEEKENDRANGE:[5,6],fullDate:"EEEE, MMMM d, y",longDate:"MMMM d, y",medium:"MMM d, y h:mm:ss a",mediumDate:"MMM d, y",mediumTime:"h:mm:ss a","short":"M/d/yy h:mm a",
	shortDate:"M/d/yy",shortTime:"h:mm a"},NUMBER_FORMATS:{CURRENCY_SYM:"$",DECIMAL_SEP:".",GROUP_SEP:",",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:"-",negSuf:"",posPre:"",posSuf:""},{gSize:3,lgSize:3,maxFrac:2,minFrac:2,minInt:1,negPre:"-\u00a4",negSuf:"",posPre:"\u00a4",posSuf:""}]},id:"en-us",localeID:"en_US",pluralCat:function(a,c){var e=a|0,f=c;u===f&&(f=Math.min(b(a),3));Math.pow(10,f);return 1==e&&0==f?"one":"other"}})}]),D(U).ready(function(){de(U,yc)}))})(window,document);
	!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
	//# sourceMappingURL=angular.min.js.map


	/*** EXPORTS FROM exports-loader ***/
	module.exports = angular;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _UtilsObjectProperties = __webpack_require__(21);

	var Entry = (function () {
	    function Entry(entityName, values, identifierValue) {
	        _classCallCheck(this, Entry);

	        this._entityName = entityName;
	        this.values = values || {};
	        this._identifierValue = identifierValue;
	        this.listValues = {};
	    }

	    _createClass(Entry, [{
	        key: 'transformToRest',

	        /**
	         * Transform an Entry to a JS object for the REST API Request
	         *
	         * @return {Object}
	         */
	        value: function transformToRest(fields) {

	            var restEntry = (0, _UtilsObjectProperties.clone)(this.values);
	            fields.forEach(function (field) {
	                var fieldName = field.name();
	                if (fieldName in restEntry) {
	                    restEntry[fieldName] = field.getTransformedValue(restEntry[fieldName], restEntry);
	                }
	            });

	            return (0, _UtilsObjectProperties.cloneAndNest)(restEntry);
	        }
	    }, {
	        key: 'entityName',
	        get: function get() {
	            return this._entityName;
	        }
	    }, {
	        key: 'identifierValue',
	        get: function get() {
	            return this._identifierValue;
	        }
	    }], [{
	        key: 'createForFields',
	        value: function createForFields(fields, entityName) {
	            var entry = new Entry(entityName);
	            fields.forEach(function (field) {
	                entry.values[field.name()] = field.defaultValue();
	            });
	            return entry;
	        }

	        /**
	         * Map a JS object from the REST API Response to an Entry
	         *
	         * @return {Entry}
	         */
	    }, {
	        key: 'createFromRest',
	        value: function createFromRest(restEntry) {
	            var fields = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	            var entityName = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
	            var identifierName = arguments.length <= 3 || arguments[3] === undefined ? 'id' : arguments[3];

	            if (!restEntry || Object.keys(restEntry).length == 0) {
	                return Entry.createForFields(fields, entityName);
	            }
	            var excludedFields = fields.filter(function (f) {
	                return !f.flattenable();
	            }).map(function (f) {
	                return f.name();
	            });

	            var values = (0, _UtilsObjectProperties.cloneAndFlatten)(restEntry, excludedFields);

	            fields.forEach(function (field) {
	                var fieldName = field.name();
	                values[fieldName] = field.getMappedValue(values[fieldName], values);
	            });

	            return new Entry(entityName, values, values[identifierName]);
	        }

	        /**
	         * Map an array of JS objects from the REST API Response to an array of Entries
	         *
	         * @return {Array[Entry]}
	         */
	    }, {
	        key: 'createArrayFromRest',
	        value: function createArrayFromRest(restEntries, fields, entityName, identifierName) {
	            return restEntries.map(function (e) {
	                return Entry.createFromRest(e, fields, entityName, identifierName);
	            });
	        }
	    }]);

	    return Entry;
	})();

	exports['default'] = Entry;
	module.exports = exports['default'];
	//# sourceMappingURL=Entry.js.map

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Entry = __webpack_require__(4);

	var _Entry2 = _interopRequireDefault(_Entry);

	var _UtilsReferenceExtractor = __webpack_require__(10);

	var _UtilsReferenceExtractor2 = _interopRequireDefault(_UtilsReferenceExtractor);

	var _UtilsObjectProperties = __webpack_require__(21);

	var View = (function () {
	    function View(name) {
	        _classCallCheck(this, View);

	        this.entity = null;
	        this._actions = null;
	        this._title = false;
	        this._description = '';
	        this._template = null;

	        this._enabled = false;
	        this._fields = [];
	        this._type = null;
	        this._name = name;
	        this._order = 0;
	        this._errorMessage = null;
	        this._url = null;
	        this._prepare = null;
	    }

	    _createClass(View, [{
	        key: 'title',
	        value: function title(_title) {
	            if (!arguments.length) return this._title;
	            this._title = _title;
	            return this;
	        }
	    }, {
	        key: 'description',
	        value: function description() {
	            if (arguments.length) {
	                this._description = arguments[0];
	                return this;
	            }

	            return this._description;
	        }
	    }, {
	        key: 'name',
	        value: function name(_name) {
	            if (!arguments.length) {
	                return this._name || this.entity.name() + '_' + this._type;
	            }

	            this._name = _name;
	            return this;
	        }
	    }, {
	        key: 'disable',
	        value: function disable() {
	            this._enabled = false;

	            return this;
	        }
	    }, {
	        key: 'enable',
	        value: function enable() {
	            this._enabled = true;

	            return this;
	        }

	        /**
	         * @deprecated Use getter "enabled" instead
	         */
	    }, {
	        key: 'isEnabled',
	        value: function isEnabled() {
	            return this.enabled;
	        }

	        /**
	         * @deprecated Use getter "entity" instead
	         */
	    }, {
	        key: 'getEntity',
	        value: function getEntity() {
	            return this.entity;
	        }

	        /**
	         * @deprecated Specify entity at view creation or use "entity" setter instead
	         */
	    }, {
	        key: 'setEntity',
	        value: function setEntity(entity) {
	            this.entity = entity;
	            if (!this._name) {
	                this._name = entity.name() + '_' + this._type;
	            }

	            return this;
	        }

	        /*
	         * Supports various syntax
	         * fields([ Field1, Field2 ])
	         * fields(Field1, Field2)
	         * fields([Field1, {Field2, Field3}])
	         * fields(Field1, {Field2, Field3})
	         * fields({Field2, Field3})
	         */
	    }, {
	        key: 'fields',
	        value: function fields() {
	            if (!arguments.length) return this._fields;

	            [].slice.call(arguments).map(function (argument) {
	                var _this = this;

	                View.flatten(argument).map(function (arg) {
	                    return _this.addField(arg);
	                });
	            }, this);

	            return this;
	        }
	    }, {
	        key: 'hasFields',
	        value: function hasFields() {
	            return this.fields.length > 0;
	        }
	    }, {
	        key: 'removeFields',
	        value: function removeFields() {
	            this._fields = [];
	            return this;
	        }
	    }, {
	        key: 'getFields',
	        value: function getFields() {
	            return this._fields;
	        }
	    }, {
	        key: 'getField',
	        value: function getField(fieldName) {
	            return this._fields.filter(function (f) {
	                return f.name() === fieldName;
	            })[0];
	        }
	    }, {
	        key: 'getFieldsOfType',
	        value: function getFieldsOfType(type) {
	            return this._fields.filter(function (f) {
	                return f.type() === type;
	            });
	        }
	    }, {
	        key: 'addField',
	        value: function addField(field) {
	            if (field.order() === null) {
	                field.order(this._fields.length, true);
	            }
	            this._fields.push(field);
	            this._fields = this._fields.sort(function (a, b) {
	                return a.order() - b.order();
	            });

	            return this;
	        }
	    }, {
	        key: 'order',
	        value: function order(_order) {
	            if (!arguments.length) return this._order;
	            this._order = _order;
	            return this;
	        }
	    }, {
	        key: 'getReferences',
	        value: function getReferences(withRemoteComplete) {
	            return _UtilsReferenceExtractor2['default'].getReferences(this._fields, withRemoteComplete);
	        }
	    }, {
	        key: 'getNonOptimizedReferences',
	        value: function getNonOptimizedReferences(withRemoteComplete) {
	            return _UtilsReferenceExtractor2['default'].getNonOptimizedReferences(this._fields, withRemoteComplete);
	        }
	    }, {
	        key: 'getOptimizedReferences',
	        value: function getOptimizedReferences(withRemoteComplete) {
	            return _UtilsReferenceExtractor2['default'].getOptimizedReferences(this._fields, withRemoteComplete);
	        }
	    }, {
	        key: 'getReferencedLists',
	        value: function getReferencedLists() {
	            return _UtilsReferenceExtractor2['default'].getReferencedLists(this._fields);
	        }
	    }, {
	        key: 'template',
	        value: function template(_template) {
	            if (!arguments.length) {
	                return this._template;
	            }

	            this._template = _template;

	            return this;
	        }
	    }, {
	        key: 'identifier',
	        value: function identifier() {
	            return this.entity.identifier();
	        }
	    }, {
	        key: 'actions',
	        value: function actions(_actions) {
	            if (!arguments.length) return this._actions;
	            this._actions = _actions;
	            return this;
	        }
	    }, {
	        key: 'getErrorMessage',
	        value: function getErrorMessage(response) {
	            if (typeof this._errorMessage === 'function') {
	                return this._errorMessage(response);
	            }

	            return this._errorMessage;
	        }
	    }, {
	        key: 'errorMessage',
	        value: function errorMessage(_errorMessage) {
	            if (!arguments.length) return this._errorMessage;
	            this._errorMessage = _errorMessage;
	            return this;
	        }
	    }, {
	        key: 'url',
	        value: function url(_url) {
	            if (!arguments.length) return this._url;
	            this._url = _url;
	            return this;
	        }
	    }, {
	        key: 'getUrl',
	        value: function getUrl(identifierValue) {
	            if (typeof this._url === 'function') {
	                return this._url(identifierValue);
	            }

	            return this._url;
	        }
	    }, {
	        key: 'validate',
	        value: function validate(entry) {
	            this._fields.map(function (field) {
	                var validation = field.validation();

	                if (typeof validation.validator === 'function') {
	                    validation.validator(entry.values[field.name()], entry.values);
	                }
	            });
	        }

	        /**
	         * Map a JS object from the REST API Response to an Entry
	         */
	    }, {
	        key: 'mapEntry',
	        value: function mapEntry(restEntry) {
	            return _Entry2['default'].createFromRest(restEntry, this._fields, this.entity.name(), this.entity.identifier().name());
	        }
	    }, {
	        key: 'mapEntries',
	        value: function mapEntries(restEntries) {
	            return _Entry2['default'].createArrayFromRest(restEntries, this._fields, this.entity.name(), this.entity.identifier().name());
	        }

	        /**
	         * Transform an Entry to a JS object for the REST API Request
	         */
	    }, {
	        key: 'transformEntry',
	        value: function transformEntry(entry) {
	            return entry.transformToRest(this._fields);
	        }

	        /**
	         * Add a function to be executed before the view renders
	         *
	         * This is the ideal place to prefetch related entities and manipulate
	         * the dataStore.
	         *
	         * The syntax depends on the framework calling the function.
	         *
	         * With ng-admin, the function can be an angular injectable, listing
	         * required dependencies in an array. Among other, the function can receive
	         * the following services:
	         *  - query: the query object (an object representation of the main request
	         *    query string)
	         *  - datastore: where the Entries are stored. The dataStore is accessible
	         *    during rendering
	         *  - view: the current View object
	         *  - entry: the current Entry instance (except in listView)
	         *  - Entry: the Entry constructor (required to transform an object from
	         *    the REST response to an Entry)
	         *  - window: the window object. If you need to fetch anything other than an
	         *    entry and pass it to the view layer, it's the only way.
	         *
	         * The function can be asynchronous, in which case it should return
	         * a Promise.
	         *
	         * @example
	         *
	         *     post.listView().prepare(['datastore', 'view', 'Entry', function(datastore, view, Entry) {
	         *       const posts = datastore.getEntries(view.getEntity().uniqueId);
	         *       const authorIds = posts.map(post => post.values.authorId).join(',');
	         *       return fetch('http://myapi.com/authors?id[]=' + authorIds)
	         *          .then(response => response.json())
	         *          .then(authors => Entry.createArrayFromRest(
	         *              authors,
	         *              [new Field('first_name'), new Field('last_name')],
	         *              'author'
	         *          ))
	         *          .then(authorEntries => datastore.setEntries('authors', authorEntries));
	         *     }]);
	         */
	    }, {
	        key: 'prepare',
	        value: function prepare(_prepare) {
	            if (!arguments.length) return this._prepare;
	            this._prepare = _prepare;
	            return this;
	        }
	    }, {
	        key: 'doPrepare',
	        value: function doPrepare() {
	            return this._prepare.apply(this, arguments);
	        }
	    }, {
	        key: 'enabled',
	        get: function get() {
	            return this._enabled || !!this._fields.length;
	        }
	    }, {
	        key: 'type',
	        get: function get() {
	            return this._type;
	        }
	    }], [{
	        key: 'flatten',
	        value: function flatten(arg) {
	            if (arg.constructor.name === 'Object') {
	                console.warn('Passing literal of Field to fields method is deprecated use array instead');
	                var result = [];
	                for (var fieldName in arg) {
	                    result = result.concat(View.flatten(arg[fieldName]));
	                }
	                return result;
	            }
	            if (Array.isArray(arg)) {
	                return arg.reduce(function (previous, current) {
	                    return previous.concat(View.flatten(current));
	                }, []);
	            }
	            // arg is a scalar
	            return [arg];
	        }
	    }]);

	    return View;
	})();

	exports['default'] = View;
	module.exports = exports['default'];
	//# sourceMappingURL=View.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _View2 = __webpack_require__(5);

	var _View3 = _interopRequireDefault(_View2);

	var _UtilsOrderElement = __webpack_require__(22);

	var _UtilsOrderElement2 = _interopRequireDefault(_UtilsOrderElement);

	var ListView = (function (_View) {
	    _inherits(ListView, _View);

	    function ListView(name) {
	        _classCallCheck(this, ListView);

	        _get(Object.getPrototypeOf(ListView.prototype), 'constructor', this).call(this, name);

	        this._type = 'ListView';
	        this._perPage = 30;
	        this._infinitePagination = false;
	        this._listActions = [];
	        this._batchActions = ['delete'];
	        this._filters = [];
	        this._permanentFilters = {};
	        this._exportFields = null;
	        this._exportOptions = {};
	        this._entryCssClasses = null;

	        this._sortField = 'id';
	        this._sortDir = 'DESC';
	    }

	    _createClass(ListView, [{
	        key: 'perPage',
	        value: function perPage() {
	            if (!arguments.length) {
	                return this._perPage;
	            }
	            this._perPage = arguments[0];
	            return this;
	        }

	        /** @deprecated Use perPage instead */
	    }, {
	        key: 'limit',
	        value: function limit() {
	            if (!arguments.length) {
	                return this.perPage();
	            }
	            return this.perPage(arguments[0]);
	        }
	    }, {
	        key: 'sortField',
	        value: function sortField() {
	            if (arguments.length) {
	                this._sortField = arguments[0];
	                return this;
	            }

	            return this._sortField;
	        }
	    }, {
	        key: 'sortDir',
	        value: function sortDir() {
	            if (arguments.length) {
	                this._sortDir = arguments[0];
	                return this;
	            }

	            return this._sortDir;
	        }
	    }, {
	        key: 'getSortFieldName',
	        value: function getSortFieldName() {
	            return this.name() + '.' + this._sortField;
	        }
	    }, {
	        key: 'infinitePagination',
	        value: function infinitePagination() {
	            if (arguments.length) {
	                this._infinitePagination = arguments[0];
	                return this;
	            }

	            return this._infinitePagination;
	        }
	    }, {
	        key: 'actions',
	        value: function actions(_actions) {
	            if (!arguments.length) {
	                return this._actions;
	            }

	            this._actions = _actions;

	            return this;
	        }
	    }, {
	        key: 'exportFields',
	        value: function exportFields(_exportFields) {
	            if (!arguments.length) {
	                return this._exportFields;
	            }

	            this._exportFields = _exportFields;

	            return this;
	        }
	    }, {
	        key: 'exportOptions',
	        value: function exportOptions(_exportOptions) {
	            if (!arguments.length) {
	                return this._exportOptions;
	            }

	            this._exportOptions = _exportOptions;

	            return this;
	        }
	    }, {
	        key: 'batchActions',
	        value: function batchActions(actions) {
	            if (!arguments.length) {
	                return this._batchActions;
	            }

	            this._batchActions = actions;

	            return this;
	        }

	        /**
	         * Define permanent filters to be added to the REST API calls
	         *
	         *     posts.listView().permanentFilters({
	         *        published: true
	         *     });
	         *     // related API call will be /posts?published=true
	         *
	         * @param {Object} filters list of filters to apply to the call
	         */
	    }, {
	        key: 'permanentFilters',
	        value: function permanentFilters(filters) {
	            if (!arguments.length) {
	                return this._permanentFilters;
	            }

	            this._permanentFilters = filters;

	            return this;
	        }

	        /**
	         * Define filters the user can add to the datagrid
	         *
	         *     posts.listView().filters([
	         *       nga.field('title'),
	         *       nga.field('age', 'number')
	         *     ]);
	         *
	         * @param {Field[]} filters list of filters to add to the GUI
	         */
	    }, {
	        key: 'filters',
	        value: function filters(_filters) {
	            if (!arguments.length) {
	                return this._filters;
	            }

	            this._filters = _UtilsOrderElement2['default'].order(_filters);

	            return this;
	        }
	    }, {
	        key: 'getFilterReferences',
	        value: function getFilterReferences(withRemoteComplete) {
	            var result = {};
	            var lists = this._filters.filter(function (f) {
	                return f.type() === 'reference';
	            });

	            var filterFunction = null;
	            if (withRemoteComplete === true) {
	                filterFunction = function (f) {
	                    return f.remoteComplete();
	                };
	            } else if (withRemoteComplete === false) {
	                filterFunction = function (f) {
	                    return !f.remoteComplete();
	                };
	            }

	            if (filterFunction !== null) {
	                lists = lists.filter(filterFunction);
	            }

	            for (var i = 0, c = lists.length; i < c; i++) {
	                var list = lists[i];
	                result[list.name()] = list;
	            }

	            return result;
	        }
	    }, {
	        key: 'listActions',
	        value: function listActions(actions) {
	            if (!arguments.length) {
	                return this._listActions;
	            }

	            this._listActions = actions;

	            return this;
	        }
	    }, {
	        key: 'entryCssClasses',
	        value: function entryCssClasses(classes) {
	            if (!arguments.length) {
	                return this._entryCssClasses;
	            }

	            this._entryCssClasses = classes;

	            return this;
	        }
	    }, {
	        key: 'getEntryCssClasses',
	        value: function getEntryCssClasses(entry) {
	            if (!this._entryCssClasses) {
	                return '';
	            }

	            if (this._entryCssClasses.constructor === Array) {
	                return this._entryCssClasses.join(' ');
	            }

	            if (typeof this._entryCssClasses === 'function') {
	                return this._entryCssClasses(entry);
	            }

	            return this._entryCssClasses;
	        }
	    }]);

	    return ListView;
	})(_View3['default']);

	exports['default'] = ListView;
	module.exports = exports['default'];
	//# sourceMappingURL=ListView.js.map

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _UtilsStringUtils = __webpack_require__(23);

	var _UtilsStringUtils2 = _interopRequireDefault(_UtilsStringUtils);

	var _FieldField = __webpack_require__(1);

	var _FieldField2 = _interopRequireDefault(_FieldField);

	var _ViewDashboardView = __webpack_require__(181);

	var _ViewDashboardView2 = _interopRequireDefault(_ViewDashboardView);

	var _ViewMenuView = __webpack_require__(185);

	var _ViewMenuView2 = _interopRequireDefault(_ViewMenuView);

	var _ViewListView = __webpack_require__(6);

	var _ViewListView2 = _interopRequireDefault(_ViewListView);

	var _ViewCreateView = __webpack_require__(180);

	var _ViewCreateView2 = _interopRequireDefault(_ViewCreateView);

	var _ViewEditView = __webpack_require__(183);

	var _ViewEditView2 = _interopRequireDefault(_ViewEditView);

	var _ViewDeleteView = __webpack_require__(182);

	var _ViewDeleteView2 = _interopRequireDefault(_ViewDeleteView);

	var _ViewShowView = __webpack_require__(186);

	var _ViewShowView2 = _interopRequireDefault(_ViewShowView);

	var _ViewBatchDeleteView = __webpack_require__(179);

	var _ViewBatchDeleteView2 = _interopRequireDefault(_ViewBatchDeleteView);

	var _ViewExportView = __webpack_require__(184);

	var _ViewExportView2 = _interopRequireDefault(_ViewExportView);

	var index = 0;

	var Entity = (function () {
	    function Entity(name) {
	        _classCallCheck(this, Entity);

	        this._name = name;
	        this._uniqueId = this._name + '_' + index++;
	        this._baseApiUrl = null;
	        this._label = null;
	        this._identifierField = new _FieldField2["default"]("id");
	        this._isReadOnly = false;
	        this._errorMessage = null;
	        this._order = 0;
	        this._url = null;
	        this._createMethod = null; // manually set the HTTP-method for create operation, defaults to post
	        this._updateMethod = null; // manually set the HTTP-method for update operation, defaults to put
	        this._retrieveMethod = null; // manually set the HTTP-method for the get operation, defaults to get
	        this._deleteMethod = null; // manually set the HTTP-method for the delete operation, defaults to delete

	        this._initViews();
	    }

	    _createClass(Entity, [{
	        key: "label",
	        value: function label() {
	            if (arguments.length) {
	                this._label = arguments[0];
	                return this;
	            }

	            if (this._label === null) {
	                return _UtilsStringUtils2["default"].camelCase(this._name);
	            }

	            return this._label;
	        }
	    }, {
	        key: "name",
	        value: function name() {
	            if (arguments.length) {
	                this._name = arguments[0];
	                return this;
	            }

	            return this._name;
	        }
	    }, {
	        key: "menuView",
	        value: function menuView() {
	            return this._views["MenuView"];
	        }
	    }, {
	        key: "dashboardView",
	        value: function dashboardView() {
	            return this._views["DashboardView"];
	        }
	    }, {
	        key: "listView",
	        value: function listView() {
	            return this._views["ListView"];
	        }
	    }, {
	        key: "creationView",
	        value: function creationView() {
	            return this._views["CreateView"];
	        }
	    }, {
	        key: "editionView",
	        value: function editionView() {
	            return this._views["EditView"];
	        }
	    }, {
	        key: "deletionView",
	        value: function deletionView() {
	            return this._views["DeleteView"];
	        }
	    }, {
	        key: "batchDeleteView",
	        value: function batchDeleteView() {
	            return this._views["BatchDeleteView"];
	        }
	    }, {
	        key: "exportView",
	        value: function exportView() {
	            return this._views["ExportView"];
	        }
	    }, {
	        key: "showView",
	        value: function showView() {
	            return this._views["ShowView"];
	        }
	    }, {
	        key: "baseApiUrl",
	        value: function baseApiUrl(_baseApiUrl) {
	            if (!arguments.length) return this._baseApiUrl;
	            this._baseApiUrl = _baseApiUrl;
	            return this;
	        }
	    }, {
	        key: "_initViews",
	        value: function _initViews() {
	            this._views = {
	                "DashboardView": new _ViewDashboardView2["default"]().setEntity(this),
	                "MenuView": new _ViewMenuView2["default"]().setEntity(this),
	                "ListView": new _ViewListView2["default"]().setEntity(this),
	                "CreateView": new _ViewCreateView2["default"]().setEntity(this),
	                "EditView": new _ViewEditView2["default"]().setEntity(this),
	                "DeleteView": new _ViewDeleteView2["default"]().setEntity(this),
	                "BatchDeleteView": new _ViewBatchDeleteView2["default"]().setEntity(this),
	                "ExportView": new _ViewExportView2["default"]().setEntity(this),
	                "ShowView": new _ViewShowView2["default"]().setEntity(this)
	            };
	        }
	    }, {
	        key: "identifier",
	        value: function identifier(value) {
	            if (!arguments.length) return this._identifierField;
	            if (!(value instanceof _FieldField2["default"])) {
	                throw new Error('Entity ' + this.name() + ': identifier must be an instance of Field.');
	            }
	            this._identifierField = value;
	            return this;
	        }
	    }, {
	        key: "readOnly",
	        value: function readOnly() {
	            this._isReadOnly = true;

	            this._views["CreateView"].disable();
	            this._views["EditView"].disable();
	            this._views["DeleteView"].disable();
	            this._views["BatchDeleteView"].disable();

	            return this;
	        }
	    }, {
	        key: "getErrorMessage",
	        value: function getErrorMessage(response) {
	            if (typeof this._errorMessage === 'function') {
	                return this._errorMessage(response);
	            }

	            return this._errorMessage;
	        }
	    }, {
	        key: "errorMessage",
	        value: function errorMessage(_errorMessage) {
	            if (!arguments.length) return this._errorMessage;
	            this._errorMessage = _errorMessage;
	            return this;
	        }
	    }, {
	        key: "order",
	        value: function order(_order) {
	            if (!arguments.length) return this._order;
	            this._order = _order;
	            return this;
	        }
	    }, {
	        key: "url",
	        value: function url(_url) {
	            if (!arguments.length) return this._url;
	            this._url = _url;
	            return this;
	        }
	    }, {
	        key: "getUrl",
	        value: function getUrl(viewType, identifierValue, identifierName) {
	            if (typeof this._url === 'function') {
	                return this._url(this.name(), viewType, identifierValue, identifierName);
	            }

	            return this._url;
	        }
	    }, {
	        key: "createMethod",
	        value: function createMethod(_createMethod) {
	            if (!arguments.length) return this._createMethod;
	            this._createMethod = _createMethod;
	            return this;
	        }
	    }, {
	        key: "updateMethod",
	        value: function updateMethod(_updateMethod) {
	            if (!arguments.length) return this._updateMethod;
	            this._updateMethod = _updateMethod;
	            return this;
	        }
	    }, {
	        key: "retrieveMethod",
	        value: function retrieveMethod(_retrieveMethod) {
	            if (!arguments.length) return this._retrieveMethod;
	            this._retrieveMethod = _retrieveMethod;
	            return this;
	        }
	    }, {
	        key: "deleteMethod",
	        value: function deleteMethod(_deleteMethod) {
	            if (!arguments.length) return this._deleteMethod;
	            this._deleteMethod = _deleteMethod;
	            return this;
	        }
	    }, {
	        key: "uniqueId",
	        get: function get() {
	            return this._uniqueId;
	        }
	    }, {
	        key: "views",
	        get: function get() {
	            return this._views;
	        }
	    }, {
	        key: "isReadOnly",
	        get: function get() {
	            return this._isReadOnly;
	        }
	    }]);

	    return Entity;
	})();

	exports["default"] = Entity;
	module.exports = exports["default"];
	//# sourceMappingURL=Entity.js.map

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var ChoiceField = (function (_Field) {
	    _inherits(ChoiceField, _Field);

	    function ChoiceField(name) {
	        _classCallCheck(this, ChoiceField);

	        _get(Object.getPrototypeOf(ChoiceField.prototype), "constructor", this).call(this, name);
	        this._type = "choice";
	        this._choices = [];
	    }

	    _createClass(ChoiceField, [{
	        key: "choices",
	        value: function choices(_choices) {
	            if (!arguments.length) return this._choices;
	            this._choices = _choices;

	            return this;
	        }
	    }, {
	        key: "getLabelForChoice",
	        value: function getLabelForChoice(value, entry) {
	            var choices = typeof this._choices === 'function' ? this._choices(entry) : this._choices;
	            var choice = choices.filter(function (c) {
	                return c.value == value;
	            }).pop();
	            return choice ? choice.label : null;
	        }
	    }]);

	    return ChoiceField;
	})(_Field3["default"]);

	exports["default"] = ChoiceField;
	module.exports = exports["default"];
	//# sourceMappingURL=ChoiceField.js.map

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var ReferenceField = (function (_Field) {
	    _inherits(ReferenceField, _Field);

	    function ReferenceField(name) {
	        _classCallCheck(this, ReferenceField);

	        _get(Object.getPrototypeOf(ReferenceField.prototype), 'constructor', this).call(this, name);
	        this._type = 'reference';
	        this._targetEntity = null;
	        this._targetField = null;
	        this._perPage = 30;
	        this._permanentFilters = null;
	        this._sortField = null;
	        this._sortDir = null;
	        this._singleApiCall = false;
	        this._detailLink = true;
	        this._remoteComplete = false;
	        this._remoteCompleteOptions = {
	            refreshDelay: 500
	        };
	    }

	    _createClass(ReferenceField, [{
	        key: 'perPage',
	        value: function perPage(_perPage) {
	            if (!arguments.length) return this._perPage;
	            this._perPage = _perPage;
	            return this;
	        }
	    }, {
	        key: 'datagridName',
	        value: function datagridName() {
	            return this._targetEntity.name() + '_ListView';
	        }
	    }, {
	        key: 'targetEntity',
	        value: function targetEntity(entity) {
	            if (!arguments.length) {
	                return this._targetEntity;
	            }
	            this._targetEntity = entity;

	            return this;
	        }
	    }, {
	        key: 'targetField',
	        value: function targetField(field) {
	            if (!arguments.length) return this._targetField;
	            this._targetField = field;

	            return this;
	        }

	        /**
	         * Define permanent filters to be added to the REST API calls
	         *
	         *     nga.field('post_id', 'reference').permanentFilters({
	         *        published: true
	         *     });
	         *     // related API call will be /posts/:id?published=true
	         *
	         * @param {Object} filters list of filters to apply to the call
	         */
	    }, {
	        key: 'permanentFilters',
	        value: function permanentFilters(filters) {
	            if (!arguments.length) {
	                return this._permanentFilters;
	            }

	            this._permanentFilters = filters;

	            return this;
	        }

	        /**
	         * @deprecated use permanentFilters() instead
	         */
	    }, {
	        key: 'filters',
	        value: function filters(_filters) {
	            console.warn('ReferenceField.filters() is deprecated, please use ReferenceField.permanentFilters() instead');
	            return this.permanentFilters(_filters);
	        }
	    }, {
	        key: 'sortField',
	        value: function sortField() {
	            if (arguments.length) {
	                this._sortField = arguments[0];
	                return this;
	            }

	            return this._sortField;
	        }
	    }, {
	        key: 'sortDir',
	        value: function sortDir() {
	            if (arguments.length) {
	                this._sortDir = arguments[0];
	                return this;
	            }

	            return this._sortDir;
	        }
	    }, {
	        key: 'singleApiCall',
	        value: function singleApiCall(_singleApiCall) {
	            if (!arguments.length) return this._singleApiCall;
	            this._singleApiCall = _singleApiCall;
	            return this;
	        }
	    }, {
	        key: 'hasSingleApiCall',
	        value: function hasSingleApiCall() {
	            return typeof this._singleApiCall === 'function';
	        }
	    }, {
	        key: 'getSingleApiCall',
	        value: function getSingleApiCall(identifiers) {
	            return this.hasSingleApiCall() ? this._singleApiCall(identifiers) : this._singleApiCall;
	        }
	    }, {
	        key: 'getIdentifierValues',
	        value: function getIdentifierValues(rawValues) {
	            var results = {};
	            var identifierName = this._name;
	            for (var i = 0, l = rawValues.length; i < l; i++) {
	                var identifier = rawValues[i][identifierName];
	                if (identifier == null) {
	                    continue;
	                }

	                if (identifier instanceof Array) {
	                    for (var j in identifier) {
	                        results[identifier[j]] = true;
	                    }
	                    continue;
	                }

	                results[identifier] = true;
	            }

	            return Object.keys(results);
	        }
	    }, {
	        key: 'getSortFieldName',
	        value: function getSortFieldName() {
	            if (!this.sortField()) {
	                return null;
	            }

	            return this._targetEntity.name() + '_ListView.' + this.sortField();
	        }

	        /**
	         * Enable autocompletion using REST API for choices.
	         *
	         * Available options are:
	         *
	         * * `refreshDelay`: minimal delay between two API calls in milliseconds. By default: 500.
	         * * `searchQuery`: a function returning the parameters to add to the query string basd on the input string.
	         *
	         *       new ReferenceField('authors')
	         *           .targetEntity(author)
	         *           .targetField(new Field('name'))
	         *           .remoteComplete(true, {
	         *               refreshDelay: 300,
	         *               // populate choices from the response of GET /tags?q=XXX
	         *               searchQuery: function(search) { return { q: search }; }
	         *           })
	         *           .perPage(10) // limit the number of results to 10
	         *
	         * @param {Boolean} remoteComplete true to enable remote complete. False by default
	         * @param {Object} options Remote completion options (optional)
	         */
	    }, {
	        key: 'remoteComplete',
	        value: function remoteComplete(_remoteComplete, options) {
	            if (!arguments.length) return this._remoteComplete;
	            this._remoteComplete = _remoteComplete;
	            if (options) {
	                this.remoteCompleteOptions(options);
	            }
	            return this;
	        }
	    }, {
	        key: 'remoteCompleteOptions',
	        value: function remoteCompleteOptions(options) {
	            if (!arguments.length) return this._remoteCompleteOptions;
	            this._remoteCompleteOptions = options;
	            return this;
	        }
	    }]);

	    return ReferenceField;
	})(_Field3['default']);

	exports['default'] = ReferenceField;
	module.exports = exports['default'];
	//# sourceMappingURL=ReferenceField.js.map

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	exports['default'] = {

	    getReferencedLists: function getReferencedLists(fields) {
	        return this.indexByName(fields.filter(function (f) {
	            return f.type() === 'referenced_list';
	        }));
	    },
	    getReferences: function getReferences(fields, withRemoteComplete) {
	        var optimized = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	        var references = fields.filter(function (f) {
	            return f.type() === 'reference' || f.type() === 'reference_many';
	        });
	        if (withRemoteComplete === true) {
	            references = references.filter(function (r) {
	                return r.remoteComplete();
	            });
	        } else if (withRemoteComplete === false) {
	            references = references.filter(function (r) {
	                return !r.remoteComplete();
	            });
	        }
	        if (optimized !== null) {
	            references = references.filter(function (r) {
	                return r.hasSingleApiCall() === optimized;
	            });
	        }
	        return this.indexByName(references);
	    },
	    getNonOptimizedReferences: function getNonOptimizedReferences(fields, withRemoteComplete) {
	        return this.getReferences(fields, withRemoteComplete, false);
	    },
	    getOptimizedReferences: function getOptimizedReferences(fields, withRemoteComplete) {
	        return this.getReferences(fields, withRemoteComplete, true);
	    },
	    indexByName: function indexByName(references) {
	        return references.reduce(function (referencesByName, reference) {
	            referencesByName[reference.name()] = reference;
	            return referencesByName;
	        }, {});
	    }
	};
	module.exports = exports['default'];
	//# sourceMappingURL=ReferenceExtractor.js.map

/***/ },
/* 11 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(11).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12).setImmediate, __webpack_require__(12).clearImmediate))

/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * State-based routing for AngularJS
	 * @version v0.2.18
	 * @link http://angular-ui.github.com/
	 * @license MIT License, http://www.opensource.org/licenses/MIT
	 */

	/* commonjs package manager support (eg componentjs) */
	if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports){
	  module.exports = 'ui.router';
	}

	(function (window, angular, undefined) {
	/*jshint globalstrict:true*/
	/*global angular:false*/
	'use strict';

	var isDefined = angular.isDefined,
	    isFunction = angular.isFunction,
	    isString = angular.isString,
	    isObject = angular.isObject,
	    isArray = angular.isArray,
	    forEach = angular.forEach,
	    extend = angular.extend,
	    copy = angular.copy,
	    toJson = angular.toJson;

	function inherit(parent, extra) {
	  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
	}

	function merge(dst) {
	  forEach(arguments, function(obj) {
	    if (obj !== dst) {
	      forEach(obj, function(value, key) {
	        if (!dst.hasOwnProperty(key)) dst[key] = value;
	      });
	    }
	  });
	  return dst;
	}

	/**
	 * Finds the common ancestor path between two states.
	 *
	 * @param {Object} first The first state.
	 * @param {Object} second The second state.
	 * @return {Array} Returns an array of state names in descending order, not including the root.
	 */
	function ancestors(first, second) {
	  var path = [];

	  for (var n in first.path) {
	    if (first.path[n] !== second.path[n]) break;
	    path.push(first.path[n]);
	  }
	  return path;
	}

	/**
	 * IE8-safe wrapper for `Object.keys()`.
	 *
	 * @param {Object} object A JavaScript object.
	 * @return {Array} Returns the keys of the object as an array.
	 */
	function objectKeys(object) {
	  if (Object.keys) {
	    return Object.keys(object);
	  }
	  var result = [];

	  forEach(object, function(val, key) {
	    result.push(key);
	  });
	  return result;
	}

	/**
	 * IE8-safe wrapper for `Array.prototype.indexOf()`.
	 *
	 * @param {Array} array A JavaScript array.
	 * @param {*} value A value to search the array for.
	 * @return {Number} Returns the array index value of `value`, or `-1` if not present.
	 */
	function indexOf(array, value) {
	  if (Array.prototype.indexOf) {
	    return array.indexOf(value, Number(arguments[2]) || 0);
	  }
	  var len = array.length >>> 0, from = Number(arguments[2]) || 0;
	  from = (from < 0) ? Math.ceil(from) : Math.floor(from);

	  if (from < 0) from += len;

	  for (; from < len; from++) {
	    if (from in array && array[from] === value) return from;
	  }
	  return -1;
	}

	/**
	 * Merges a set of parameters with all parameters inherited between the common parents of the
	 * current state and a given destination state.
	 *
	 * @param {Object} currentParams The value of the current state parameters ($stateParams).
	 * @param {Object} newParams The set of parameters which will be composited with inherited params.
	 * @param {Object} $current Internal definition of object representing the current state.
	 * @param {Object} $to Internal definition of object representing state to transition to.
	 */
	function inheritParams(currentParams, newParams, $current, $to) {
	  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

	  for (var i in parents) {
	    if (!parents[i] || !parents[i].params) continue;
	    parentParams = objectKeys(parents[i].params);
	    if (!parentParams.length) continue;

	    for (var j in parentParams) {
	      if (indexOf(inheritList, parentParams[j]) >= 0) continue;
	      inheritList.push(parentParams[j]);
	      inherited[parentParams[j]] = currentParams[parentParams[j]];
	    }
	  }
	  return extend({}, inherited, newParams);
	}

	/**
	 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
	 *
	 * @param {Object} a The first object.
	 * @param {Object} b The second object.
	 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
	 *                     it defaults to the list of keys in `a`.
	 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
	 */
	function equalForKeys(a, b, keys) {
	  if (!keys) {
	    keys = [];
	    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
	  }

	  for (var i=0; i<keys.length; i++) {
	    var k = keys[i];
	    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
	  }
	  return true;
	}

	/**
	 * Returns the subset of an object, based on a list of keys.
	 *
	 * @param {Array} keys
	 * @param {Object} values
	 * @return {Boolean} Returns a subset of `values`.
	 */
	function filterByKeys(keys, values) {
	  var filtered = {};

	  forEach(keys, function (name) {
	    filtered[name] = values[name];
	  });
	  return filtered;
	}

	// like _.indexBy
	// when you know that your index values will be unique, or you want last-one-in to win
	function indexBy(array, propName) {
	  var result = {};
	  forEach(array, function(item) {
	    result[item[propName]] = item;
	  });
	  return result;
	}

	// extracted from underscore.js
	// Return a copy of the object only containing the whitelisted properties.
	function pick(obj) {
	  var copy = {};
	  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
	  forEach(keys, function(key) {
	    if (key in obj) copy[key] = obj[key];
	  });
	  return copy;
	}

	// extracted from underscore.js
	// Return a copy of the object omitting the blacklisted properties.
	function omit(obj) {
	  var copy = {};
	  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
	  for (var key in obj) {
	    if (indexOf(keys, key) == -1) copy[key] = obj[key];
	  }
	  return copy;
	}

	function pluck(collection, key) {
	  var result = isArray(collection) ? [] : {};

	  forEach(collection, function(val, i) {
	    result[i] = isFunction(key) ? key(val) : val[key];
	  });
	  return result;
	}

	function filter(collection, callback) {
	  var array = isArray(collection);
	  var result = array ? [] : {};
	  forEach(collection, function(val, i) {
	    if (callback(val, i)) {
	      result[array ? result.length : i] = val;
	    }
	  });
	  return result;
	}

	function map(collection, callback) {
	  var result = isArray(collection) ? [] : {};

	  forEach(collection, function(val, i) {
	    result[i] = callback(val, i);
	  });
	  return result;
	}

	/**
	 * @ngdoc overview
	 * @name ui.router.util
	 *
	 * @description
	 * # ui.router.util sub-module
	 *
	 * This module is a dependency of other sub-modules. Do not include this module as a dependency
	 * in your angular app (use {@link ui.router} module instead).
	 *
	 */
	angular.module('ui.router.util', ['ng']);

	/**
	 * @ngdoc overview
	 * @name ui.router.router
	 * 
	 * @requires ui.router.util
	 *
	 * @description
	 * # ui.router.router sub-module
	 *
	 * This module is a dependency of other sub-modules. Do not include this module as a dependency
	 * in your angular app (use {@link ui.router} module instead).
	 */
	angular.module('ui.router.router', ['ui.router.util']);

	/**
	 * @ngdoc overview
	 * @name ui.router.state
	 * 
	 * @requires ui.router.router
	 * @requires ui.router.util
	 *
	 * @description
	 * # ui.router.state sub-module
	 *
	 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
	 * in your angular app (use {@link ui.router} module instead).
	 * 
	 */
	angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

	/**
	 * @ngdoc overview
	 * @name ui.router
	 *
	 * @requires ui.router.state
	 *
	 * @description
	 * # ui.router
	 * 
	 * ## The main module for ui.router 
	 * There are several sub-modules included with the ui.router module, however only this module is needed
	 * as a dependency within your angular app. The other modules are for organization purposes. 
	 *
	 * The modules are:
	 * * ui.router - the main "umbrella" module
	 * * ui.router.router - 
	 * 
	 * *You'll need to include **only** this module as the dependency within your angular app.*
	 * 
	 * <pre>
	 * <!doctype html>
	 * <html ng-app="myApp">
	 * <head>
	 *   <script src="js/angular.js"></script>
	 *   <!-- Include the ui-router script -->
	 *   <script src="js/angular-ui-router.min.js"></script>
	 *   <script>
	 *     // ...and add 'ui.router' as a dependency
	 *     var myApp = angular.module('myApp', ['ui.router']);
	 *   </script>
	 * </head>
	 * <body>
	 * </body>
	 * </html>
	 * </pre>
	 */
	angular.module('ui.router', ['ui.router.state']);

	angular.module('ui.router.compat', ['ui.router']);

	/**
	 * @ngdoc object
	 * @name ui.router.util.$resolve
	 *
	 * @requires $q
	 * @requires $injector
	 *
	 * @description
	 * Manages resolution of (acyclic) graphs of promises.
	 */
	$Resolve.$inject = ['$q', '$injector'];
	function $Resolve(  $q,    $injector) {
	  
	  var VISIT_IN_PROGRESS = 1,
	      VISIT_DONE = 2,
	      NOTHING = {},
	      NO_DEPENDENCIES = [],
	      NO_LOCALS = NOTHING,
	      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
	  

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$resolve#study
	   * @methodOf ui.router.util.$resolve
	   *
	   * @description
	   * Studies a set of invocables that are likely to be used multiple times.
	   * <pre>
	   * $resolve.study(invocables)(locals, parent, self)
	   * </pre>
	   * is equivalent to
	   * <pre>
	   * $resolve.resolve(invocables, locals, parent, self)
	   * </pre>
	   * but the former is more efficient (in fact `resolve` just calls `study` 
	   * internally).
	   *
	   * @param {object} invocables Invocable objects
	   * @return {function} a function to pass in locals, parent and self
	   */
	  this.study = function (invocables) {
	    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
	    var invocableKeys = objectKeys(invocables || {});
	    
	    // Perform a topological sort of invocables to build an ordered plan
	    var plan = [], cycle = [], visited = {};
	    function visit(value, key) {
	      if (visited[key] === VISIT_DONE) return;
	      
	      cycle.push(key);
	      if (visited[key] === VISIT_IN_PROGRESS) {
	        cycle.splice(0, indexOf(cycle, key));
	        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
	      }
	      visited[key] = VISIT_IN_PROGRESS;
	      
	      if (isString(value)) {
	        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);
	      } else {
	        var params = $injector.annotate(value);
	        forEach(params, function (param) {
	          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
	        });
	        plan.push(key, value, params);
	      }
	      
	      cycle.pop();
	      visited[key] = VISIT_DONE;
	    }
	    forEach(invocables, visit);
	    invocables = cycle = visited = null; // plan is all that's required
	    
	    function isResolve(value) {
	      return isObject(value) && value.then && value.$$promises;
	    }
	    
	    return function (locals, parent, self) {
	      if (isResolve(locals) && self === undefined) {
	        self = parent; parent = locals; locals = null;
	      }
	      if (!locals) locals = NO_LOCALS;
	      else if (!isObject(locals)) {
	        throw new Error("'locals' must be an object");
	      }       
	      if (!parent) parent = NO_PARENT;
	      else if (!isResolve(parent)) {
	        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
	      }
	      
	      // To complete the overall resolution, we have to wait for the parent
	      // promise and for the promise for each invokable in our plan.
	      var resolution = $q.defer(),
	          result = resolution.promise,
	          promises = result.$$promises = {},
	          values = extend({}, locals),
	          wait = 1 + plan.length/3,
	          merged = false;
	          
	      function done() {
	        // Merge parent values we haven't got yet and publish our own $$values
	        if (!--wait) {
	          if (!merged) merge(values, parent.$$values); 
	          result.$$values = values;
	          result.$$promises = result.$$promises || true; // keep for isResolve()
	          delete result.$$inheritedValues;
	          resolution.resolve(values);
	        }
	      }
	      
	      function fail(reason) {
	        result.$$failure = reason;
	        resolution.reject(reason);
	      }

	      // Short-circuit if parent has already failed
	      if (isDefined(parent.$$failure)) {
	        fail(parent.$$failure);
	        return result;
	      }
	      
	      if (parent.$$inheritedValues) {
	        merge(values, omit(parent.$$inheritedValues, invocableKeys));
	      }

	      // Merge parent values if the parent has already resolved, or merge
	      // parent promises and wait if the parent resolve is still in progress.
	      extend(promises, parent.$$promises);
	      if (parent.$$values) {
	        merged = merge(values, omit(parent.$$values, invocableKeys));
	        result.$$inheritedValues = omit(parent.$$values, invocableKeys);
	        done();
	      } else {
	        if (parent.$$inheritedValues) {
	          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
	        }        
	        parent.then(done, fail);
	      }
	      
	      // Process each invocable in the plan, but ignore any where a local of the same name exists.
	      for (var i=0, ii=plan.length; i<ii; i+=3) {
	        if (locals.hasOwnProperty(plan[i])) done();
	        else invoke(plan[i], plan[i+1], plan[i+2]);
	      }
	      
	      function invoke(key, invocable, params) {
	        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
	        var invocation = $q.defer(), waitParams = 0;
	        function onfailure(reason) {
	          invocation.reject(reason);
	          fail(reason);
	        }
	        // Wait for any parameter that we have a promise for (either from parent or from this
	        // resolve; in that case study() will have made sure it's ordered before us in the plan).
	        forEach(params, function (dep) {
	          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
	            waitParams++;
	            promises[dep].then(function (result) {
	              values[dep] = result;
	              if (!(--waitParams)) proceed();
	            }, onfailure);
	          }
	        });
	        if (!waitParams) proceed();
	        function proceed() {
	          if (isDefined(result.$$failure)) return;
	          try {
	            invocation.resolve($injector.invoke(invocable, self, values));
	            invocation.promise.then(function (result) {
	              values[key] = result;
	              done();
	            }, onfailure);
	          } catch (e) {
	            onfailure(e);
	          }
	        }
	        // Publish promise synchronously; invocations further down in the plan may depend on it.
	        promises[key] = invocation.promise;
	      }
	      
	      return result;
	    };
	  };
	  
	  /**
	   * @ngdoc function
	   * @name ui.router.util.$resolve#resolve
	   * @methodOf ui.router.util.$resolve
	   *
	   * @description
	   * Resolves a set of invocables. An invocable is a function to be invoked via 
	   * `$injector.invoke()`, and can have an arbitrary number of dependencies. 
	   * An invocable can either return a value directly,
	   * or a `$q` promise. If a promise is returned it will be resolved and the 
	   * resulting value will be used instead. Dependencies of invocables are resolved 
	   * (in this order of precedence)
	   *
	   * - from the specified `locals`
	   * - from another invocable that is part of this `$resolve` call
	   * - from an invocable that is inherited from a `parent` call to `$resolve` 
	   *   (or recursively
	   * - from any ancestor `$resolve` of that parent).
	   *
	   * The return value of `$resolve` is a promise for an object that contains 
	   * (in this order of precedence)
	   *
	   * - any `locals` (if specified)
	   * - the resolved return values of all injectables
	   * - any values inherited from a `parent` call to `$resolve` (if specified)
	   *
	   * The promise will resolve after the `parent` promise (if any) and all promises 
	   * returned by injectables have been resolved. If any invocable 
	   * (or `$injector.invoke`) throws an exception, or if a promise returned by an 
	   * invocable is rejected, the `$resolve` promise is immediately rejected with the 
	   * same error. A rejection of a `parent` promise (if specified) will likewise be 
	   * propagated immediately. Once the `$resolve` promise has been rejected, no 
	   * further invocables will be called.
	   * 
	   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`
	   * to throw an error. As a special case, an injectable can depend on a parameter 
	   * with the same name as the injectable, which will be fulfilled from the `parent` 
	   * injectable of the same name. This allows inherited values to be decorated. 
	   * Note that in this case any other injectable in the same `$resolve` with the same
	   * dependency would see the decorated value, not the inherited value.
	   *
	   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an 
	   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) 
	   * exception.
	   *
	   * Invocables are invoked eagerly as soon as all dependencies are available. 
	   * This is true even for dependencies inherited from a `parent` call to `$resolve`.
	   *
	   * As a special case, an invocable can be a string, in which case it is taken to 
	   * be a service name to be passed to `$injector.get()`. This is supported primarily 
	   * for backwards-compatibility with the `resolve` property of `$routeProvider` 
	   * routes.
	   *
	   * @param {object} invocables functions to invoke or 
	   * `$injector` services to fetch.
	   * @param {object} locals  values to make available to the injectables
	   * @param {object} parent  a promise returned by another call to `$resolve`.
	   * @param {object} self  the `this` for the invoked methods
	   * @return {object} Promise for an object that contains the resolved return value
	   * of all invocables, as well as any inherited and local values.
	   */
	  this.resolve = function (invocables, locals, parent, self) {
	    return this.study(invocables)(locals, parent, self);
	  };
	}

	angular.module('ui.router.util').service('$resolve', $Resolve);


	/**
	 * @ngdoc object
	 * @name ui.router.util.$templateFactory
	 *
	 * @requires $http
	 * @requires $templateCache
	 * @requires $injector
	 *
	 * @description
	 * Service. Manages loading of templates.
	 */
	$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
	function $TemplateFactory(  $http,   $templateCache,   $injector) {

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$templateFactory#fromConfig
	   * @methodOf ui.router.util.$templateFactory
	   *
	   * @description
	   * Creates a template from a configuration object. 
	   *
	   * @param {object} config Configuration object for which to load a template. 
	   * The following properties are search in the specified order, and the first one 
	   * that is defined is used to create the template:
	   *
	   * @param {string|object} config.template html string template or function to 
	   * load via {@link ui.router.util.$templateFactory#fromString fromString}.
	   * @param {string|object} config.templateUrl url to load or a function returning 
	   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
	   * @param {Function} config.templateProvider function to invoke via 
	   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
	   * @param {object} params  Parameters to pass to the template function.
	   * @param {object} locals Locals to pass to `invoke` if the template is loaded 
	   * via a `templateProvider`. Defaults to `{ params: params }`.
	   *
	   * @return {string|object}  The template html as a string, or a promise for 
	   * that string,or `null` if no template is configured.
	   */
	  this.fromConfig = function (config, params, locals) {
	    return (
	      isDefined(config.template) ? this.fromString(config.template, params) :
	      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
	      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
	      null
	    );
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$templateFactory#fromString
	   * @methodOf ui.router.util.$templateFactory
	   *
	   * @description
	   * Creates a template from a string or a function returning a string.
	   *
	   * @param {string|object} template html template as a string or function that 
	   * returns an html template as a string.
	   * @param {object} params Parameters to pass to the template function.
	   *
	   * @return {string|object} The template html as a string, or a promise for that 
	   * string.
	   */
	  this.fromString = function (template, params) {
	    return isFunction(template) ? template(params) : template;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$templateFactory#fromUrl
	   * @methodOf ui.router.util.$templateFactory
	   * 
	   * @description
	   * Loads a template from the a URL via `$http` and `$templateCache`.
	   *
	   * @param {string|Function} url url of the template to load, or a function 
	   * that returns a url.
	   * @param {Object} params Parameters to pass to the url function.
	   * @return {string|Promise.<string>} The template html as a string, or a promise 
	   * for that string.
	   */
	  this.fromUrl = function (url, params) {
	    if (isFunction(url)) url = url(params);
	    if (url == null) return null;
	    else return $http
	        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})
	        .then(function(response) { return response.data; });
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$templateFactory#fromProvider
	   * @methodOf ui.router.util.$templateFactory
	   *
	   * @description
	   * Creates a template by invoking an injectable provider function.
	   *
	   * @param {Function} provider Function to invoke via `$injector.invoke`
	   * @param {Object} params Parameters for the template.
	   * @param {Object} locals Locals to pass to `invoke`. Defaults to 
	   * `{ params: params }`.
	   * @return {string|Promise.<string>} The template html as a string, or a promise 
	   * for that string.
	   */
	  this.fromProvider = function (provider, params, locals) {
	    return $injector.invoke(provider, null, locals || { params: params });
	  };
	}

	angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

	var $$UMFP; // reference to $UrlMatcherFactoryProvider

	/**
	 * @ngdoc object
	 * @name ui.router.util.type:UrlMatcher
	 *
	 * @description
	 * Matches URLs against patterns and extracts named parameters from the path or the search
	 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
	 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
	 * do not influence whether or not a URL is matched, but their values are passed through into
	 * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
	 *
	 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
	 * syntax, which optionally allows a regular expression for the parameter to be specified:
	 *
	 * * `':'` name - colon placeholder
	 * * `'*'` name - catch-all placeholder
	 * * `'{' name '}'` - curly placeholder
	 * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
	 *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
	 *
	 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
	 * must be unique within the pattern (across both path and search parameters). For colon
	 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
	 * number of characters other than '/'. For catch-all placeholders the path parameter matches
	 * any number of characters.
	 *
	 * Examples:
	 *
	 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
	 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
	 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
	 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
	 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
	 * * `'/user/{id:[^/]*}'` - Same as the previous example.
	 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
	 *   parameter consists of 1 to 8 hex digits.
	 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
	 *   path into the parameter 'path'.
	 * * `'/files/*path'` - ditto.
	 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
	 *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
	 *
	 * @param {string} pattern  The pattern to compile into a matcher.
	 * @param {Object} config  A configuration object hash:
	 * @param {Object=} parentMatcher Used to concatenate the pattern/config onto
	 *   an existing UrlMatcher
	 *
	 * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
	 * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
	 *
	 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
	 *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
	 *   non-null) will start with this prefix.
	 *
	 * @property {string} source  The pattern that was passed into the constructor
	 *
	 * @property {string} sourcePath  The path portion of the source property
	 *
	 * @property {string} sourceSearch  The search portion of the source property
	 *
	 * @property {string} regex  The constructed regex that will be used to match against the url when
	 *   it is time to determine which url will match.
	 *
	 * @returns {Object}  New `UrlMatcher` object
	 */
	function UrlMatcher(pattern, config, parentMatcher) {
	  config = extend({ params: {} }, isObject(config) ? config : {});

	  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
	  //   '*' name
	  //   ':' name
	  //   '{' name '}'
	  //   '{' name ':' regexp '}'
	  // The regular expression is somewhat complicated due to the need to allow curly braces
	  // inside the regular expression. The placeholder regexp breaks down as follows:
	  //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
	  //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
	  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
	  //    [^{}\\]+                       - anything other than curly braces or backslash
	  //    \\.                            - a backslash escape
	  //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
	  var placeholder       = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
	      searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
	      compiled = '^', last = 0, m,
	      segments = this.segments = [],
	      parentParams = parentMatcher ? parentMatcher.params : {},
	      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
	      paramNames = [];

	  function addParameter(id, type, config, location) {
	    paramNames.push(id);
	    if (parentParams[id]) return parentParams[id];
	    if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
	    if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
	    params[id] = new $$UMFP.Param(id, type, config, location);
	    return params[id];
	  }

	  function quoteRegExp(string, pattern, squash, optional) {
	    var surroundPattern = ['',''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
	    if (!pattern) return result;
	    switch(squash) {
	      case false: surroundPattern = ['(', ')' + (optional ? "?" : "")]; break;
	      case true:
	        result = result.replace(/\/$/, '');
	        surroundPattern = ['(?:\/(', ')|\/)?'];
	      break;
	      default:    surroundPattern = ['(' + squash + "|", ')?']; break;
	    }
	    return result + surroundPattern[0] + pattern + surroundPattern[1];
	  }

	  this.source = pattern;

	  // Split into static segments separated by path parameter placeholders.
	  // The number of segments is always 1 more than the number of parameters.
	  function matchDetails(m, isSearch) {
	    var id, regexp, segment, type, cfg, arrayMode;
	    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
	    cfg         = config.params[id];
	    segment     = pattern.substring(last, m.index);
	    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);

	    if (regexp) {
	      type      = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });
	    }

	    return {
	      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg
	    };
	  }

	  var p, param, segment;
	  while ((m = placeholder.exec(pattern))) {
	    p = matchDetails(m, false);
	    if (p.segment.indexOf('?') >= 0) break; // we're into the search part

	    param = addParameter(p.id, p.type, p.cfg, "path");
	    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
	    segments.push(p.segment);
	    last = placeholder.lastIndex;
	  }
	  segment = pattern.substring(last);

	  // Find any search parameter names and remove them from the last segment
	  var i = segment.indexOf('?');

	  if (i >= 0) {
	    var search = this.sourceSearch = segment.substring(i);
	    segment = segment.substring(0, i);
	    this.sourcePath = pattern.substring(0, last + i);

	    if (search.length > 0) {
	      last = 0;
	      while ((m = searchPlaceholder.exec(search))) {
	        p = matchDetails(m, true);
	        param = addParameter(p.id, p.type, p.cfg, "search");
	        last = placeholder.lastIndex;
	        // check if ?&
	      }
	    }
	  } else {
	    this.sourcePath = pattern;
	    this.sourceSearch = '';
	  }

	  compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
	  segments.push(segment);

	  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
	  this.prefix = segments[0];
	  this.$$paramNames = paramNames;
	}

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:UrlMatcher#concat
	 * @methodOf ui.router.util.type:UrlMatcher
	 *
	 * @description
	 * Returns a new matcher for a pattern constructed by appending the path part and adding the
	 * search parameters of the specified pattern to this pattern. The current pattern is not
	 * modified. This can be understood as creating a pattern for URLs that are relative to (or
	 * suffixes of) the current pattern.
	 *
	 * @example
	 * The following two matchers are equivalent:
	 * <pre>
	 * new UrlMatcher('/user/{id}?q').concat('/details?date');
	 * new UrlMatcher('/user/{id}/details?q&date');
	 * </pre>
	 *
	 * @param {string} pattern  The pattern to append.
	 * @param {Object} config  An object hash of the configuration for the matcher.
	 * @returns {UrlMatcher}  A matcher for the concatenated pattern.
	 */
	UrlMatcher.prototype.concat = function (pattern, config) {
	  // Because order of search parameters is irrelevant, we can add our own search
	  // parameters to the end of the new pattern. Parse the new pattern by itself
	  // and then join the bits together, but it's much easier to do this on a string level.
	  var defaultConfig = {
	    caseInsensitive: $$UMFP.caseInsensitive(),
	    strict: $$UMFP.strictMode(),
	    squash: $$UMFP.defaultSquashPolicy()
	  };
	  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
	};

	UrlMatcher.prototype.toString = function () {
	  return this.source;
	};

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:UrlMatcher#exec
	 * @methodOf ui.router.util.type:UrlMatcher
	 *
	 * @description
	 * Tests the specified path against this matcher, and returns an object containing the captured
	 * parameter values, or null if the path does not match. The returned object contains the values
	 * of any search parameters that are mentioned in the pattern, but their value may be null if
	 * they are not present in `searchParams`. This means that search parameters are always treated
	 * as optional.
	 *
	 * @example
	 * <pre>
	 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
	 *   x: '1', q: 'hello'
	 * });
	 * // returns { id: 'bob', q: 'hello', r: null }
	 * </pre>
	 *
	 * @param {string} path  The URL path to match, e.g. `$location.path()`.
	 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
	 * @returns {Object}  The captured parameter values.
	 */
	UrlMatcher.prototype.exec = function (path, searchParams) {
	  var m = this.regexp.exec(path);
	  if (!m) return null;
	  searchParams = searchParams || {};

	  var paramNames = this.parameters(), nTotal = paramNames.length,
	    nPath = this.segments.length - 1,
	    values = {}, i, j, cfg, paramName;

	  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

	  function decodePathArray(string) {
	    function reverseString(str) { return str.split("").reverse().join(""); }
	    function unquoteDashes(str) { return str.replace(/\\-/g, "-"); }

	    var split = reverseString(string).split(/-(?!\\)/);
	    var allReversed = map(split, reverseString);
	    return map(allReversed, unquoteDashes).reverse();
	  }

	  var param, paramVal;
	  for (i = 0; i < nPath; i++) {
	    paramName = paramNames[i];
	    param = this.params[paramName];
	    paramVal = m[i+1];
	    // if the param value matches a pre-replace pair, replace the value before decoding.
	    for (j = 0; j < param.replace.length; j++) {
	      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
	    }
	    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
	    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
	    values[paramName] = param.value(paramVal);
	  }
	  for (/**/; i < nTotal; i++) {
	    paramName = paramNames[i];
	    values[paramName] = this.params[paramName].value(searchParams[paramName]);
	    param = this.params[paramName];
	    paramVal = searchParams[paramName];
	    for (j = 0; j < param.replace.length; j++) {
	      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
	    }
	    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
	    values[paramName] = param.value(paramVal);
	  }

	  return values;
	};

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:UrlMatcher#parameters
	 * @methodOf ui.router.util.type:UrlMatcher
	 *
	 * @description
	 * Returns the names of all path and search parameters of this pattern in an unspecified order.
	 *
	 * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
	 *    pattern has no parameters, an empty array is returned.
	 */
	UrlMatcher.prototype.parameters = function (param) {
	  if (!isDefined(param)) return this.$$paramNames;
	  return this.params[param] || null;
	};

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:UrlMatcher#validates
	 * @methodOf ui.router.util.type:UrlMatcher
	 *
	 * @description
	 * Checks an object hash of parameters to validate their correctness according to the parameter
	 * types of this `UrlMatcher`.
	 *
	 * @param {Object} params The object hash of parameters to validate.
	 * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
	 */
	UrlMatcher.prototype.validates = function (params) {
	  return this.params.$$validates(params);
	};

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:UrlMatcher#format
	 * @methodOf ui.router.util.type:UrlMatcher
	 *
	 * @description
	 * Creates a URL that matches this pattern by substituting the specified values
	 * for the path and search parameters. Null values for path parameters are
	 * treated as empty strings.
	 *
	 * @example
	 * <pre>
	 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
	 * // returns '/user/bob?q=yes'
	 * </pre>
	 *
	 * @param {Object} values  the values to substitute for the parameters in this pattern.
	 * @returns {string}  the formatted URL (path and optionally search part).
	 */
	UrlMatcher.prototype.format = function (values) {
	  values = values || {};
	  var segments = this.segments, params = this.parameters(), paramset = this.params;
	  if (!this.validates(values)) return null;

	  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];

	  function encodeDashes(str) { // Replace dashes with encoded "\-"
	    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });
	  }

	  for (i = 0; i < nTotal; i++) {
	    var isPathParam = i < nPath;
	    var name = params[i], param = paramset[name], value = param.value(values[name]);
	    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
	    var squash = isDefaultValue ? param.squash : false;
	    var encoded = param.type.encode(value);

	    if (isPathParam) {
	      var nextSegment = segments[i + 1];
	      var isFinalPathParam = i + 1 === nPath;

	      if (squash === false) {
	        if (encoded != null) {
	          if (isArray(encoded)) {
	            result += map(encoded, encodeDashes).join("-");
	          } else {
	            result += encodeURIComponent(encoded);
	          }
	        }
	        result += nextSegment;
	      } else if (squash === true) {
	        var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
	        result += nextSegment.match(capture)[1];
	      } else if (isString(squash)) {
	        result += squash + nextSegment;
	      }

	      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);
	    } else {
	      if (encoded == null || (isDefaultValue && squash !== false)) continue;
	      if (!isArray(encoded)) encoded = [ encoded ];
	      if (encoded.length === 0) continue;
	      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
	      result += (search ? '&' : '?') + (name + '=' + encoded);
	      search = true;
	    }
	  }

	  return result;
	};

	/**
	 * @ngdoc object
	 * @name ui.router.util.type:Type
	 *
	 * @description
	 * Implements an interface to define custom parameter types that can be decoded from and encoded to
	 * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}
	 * objects when matching or formatting URLs, or comparing or validating parameter values.
	 *
	 * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more
	 * information on registering custom types.
	 *
	 * @param {Object} config  A configuration object which contains the custom type definition.  The object's
	 *        properties will override the default methods and/or pattern in `Type`'s public interface.
	 * @example
	 * <pre>
	 * {
	 *   decode: function(val) { return parseInt(val, 10); },
	 *   encode: function(val) { return val && val.toString(); },
	 *   equals: function(a, b) { return this.is(a) && a === b; },
	 *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },
	 *   pattern: /\d+/
	 * }
	 * </pre>
	 *
	 * @property {RegExp} pattern The regular expression pattern used to match values of this type when
	 *           coming from a substring of a URL.
	 *
	 * @returns {Object}  Returns a new `Type` object.
	 */
	function Type(config) {
	  extend(this, config);
	}

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:Type#is
	 * @methodOf ui.router.util.type:Type
	 *
	 * @description
	 * Detects whether a value is of a particular type. Accepts a native (decoded) value
	 * and determines whether it matches the current `Type` object.
	 *
	 * @param {*} val  The value to check.
	 * @param {string} key  Optional. If the type check is happening in the context of a specific
	 *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the
	 *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.
	 * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.
	 */
	Type.prototype.is = function(val, key) {
	  return true;
	};

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:Type#encode
	 * @methodOf ui.router.util.type:Type
	 *
	 * @description
	 * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the
	 * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it
	 * only needs to be a representation of `val` that has been coerced to a string.
	 *
	 * @param {*} val  The value to encode.
	 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
	 *        meta-programming of `Type` objects.
	 * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.
	 */
	Type.prototype.encode = function(val, key) {
	  return val;
	};

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:Type#decode
	 * @methodOf ui.router.util.type:Type
	 *
	 * @description
	 * Converts a parameter value (from URL string or transition param) to a custom/native value.
	 *
	 * @param {string} val  The URL parameter value to decode.
	 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
	 *        meta-programming of `Type` objects.
	 * @returns {*}  Returns a custom representation of the URL parameter value.
	 */
	Type.prototype.decode = function(val, key) {
	  return val;
	};

	/**
	 * @ngdoc function
	 * @name ui.router.util.type:Type#equals
	 * @methodOf ui.router.util.type:Type
	 *
	 * @description
	 * Determines whether two decoded values are equivalent.
	 *
	 * @param {*} a  A value to compare against.
	 * @param {*} b  A value to compare against.
	 * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.
	 */
	Type.prototype.equals = function(a, b) {
	  return a == b;
	};

	Type.prototype.$subPattern = function() {
	  var sub = this.pattern.toString();
	  return sub.substr(1, sub.length - 2);
	};

	Type.prototype.pattern = /.*/;

	Type.prototype.toString = function() { return "{Type:" + this.name + "}"; };

	/** Given an encoded string, or a decoded object, returns a decoded object */
	Type.prototype.$normalize = function(val) {
	  return this.is(val) ? val : this.decode(val);
	};

	/*
	 * Wraps an existing custom Type as an array of Type, depending on 'mode'.
	 * e.g.:
	 * - urlmatcher pattern "/path?{queryParam[]:int}"
	 * - url: "/path?queryParam=1&queryParam=2
	 * - $stateParams.queryParam will be [1, 2]
	 * if `mode` is "auto", then
	 * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
	 * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
	 */
	Type.prototype.$asArray = function(mode, isSearch) {
	  if (!mode) return this;
	  if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");

	  function ArrayType(type, mode) {
	    function bindTo(type, callbackName) {
	      return function() {
	        return type[callbackName].apply(type, arguments);
	      };
	    }

	    // Wrap non-array value as array
	    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }
	    // Unwrap array value for "auto" mode. Return undefined for empty array.
	    function arrayUnwrap(val) {
	      switch(val.length) {
	        case 0: return undefined;
	        case 1: return mode === "auto" ? val[0] : val;
	        default: return val;
	      }
	    }
	    function falsey(val) { return !val; }

	    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
	    function arrayHandler(callback, allTruthyMode) {
	      return function handleArray(val) {
	        if (isArray(val) && val.length === 0) return val;
	        val = arrayWrap(val);
	        var result = map(val, callback);
	        if (allTruthyMode === true)
	          return filter(result, falsey).length === 0;
	        return arrayUnwrap(result);
	      };
	    }

	    // Wraps type (.equals) functions to operate on each value of an array
	    function arrayEqualsHandler(callback) {
	      return function handleArray(val1, val2) {
	        var left = arrayWrap(val1), right = arrayWrap(val2);
	        if (left.length !== right.length) return false;
	        for (var i = 0; i < left.length; i++) {
	          if (!callback(left[i], right[i])) return false;
	        }
	        return true;
	      };
	    }

	    this.encode = arrayHandler(bindTo(type, 'encode'));
	    this.decode = arrayHandler(bindTo(type, 'decode'));
	    this.is     = arrayHandler(bindTo(type, 'is'), true);
	    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
	    this.pattern = type.pattern;
	    this.$normalize = arrayHandler(bindTo(type, '$normalize'));
	    this.name = type.name;
	    this.$arrayMode = mode;
	  }

	  return new ArrayType(this, mode);
	};



	/**
	 * @ngdoc object
	 * @name ui.router.util.$urlMatcherFactory
	 *
	 * @description
	 * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory
	 * is also available to providers under the name `$urlMatcherFactoryProvider`.
	 */
	function $UrlMatcherFactory() {
	  $$UMFP = this;

	  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;

	  // Use tildes to pre-encode slashes.
	  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,
	  // and bidirectional encoding/decoding fails.
	  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character
	  function valToString(val) { return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val; }
	  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val; }

	  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
	    "string": {
	      encode: valToString,
	      decode: valFromString,
	      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.
	      // In 0.2.x, string params are optional by default for backwards compat
	      is: function(val) { return val == null || !isDefined(val) || typeof val === "string"; },
	      pattern: /[^/]*/
	    },
	    "int": {
	      encode: valToString,
	      decode: function(val) { return parseInt(val, 10); },
	      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },
	      pattern: /\d+/
	    },
	    "bool": {
	      encode: function(val) { return val ? 1 : 0; },
	      decode: function(val) { return parseInt(val, 10) !== 0; },
	      is: function(val) { return val === true || val === false; },
	      pattern: /0|1/
	    },
	    "date": {
	      encode: function (val) {
	        if (!this.is(val))
	          return undefined;
	        return [ val.getFullYear(),
	          ('0' + (val.getMonth() + 1)).slice(-2),
	          ('0' + val.getDate()).slice(-2)
	        ].join("-");
	      },
	      decode: function (val) {
	        if (this.is(val)) return val;
	        var match = this.capture.exec(val);
	        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
	      },
	      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },
	      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },
	      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
	      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
	    },
	    "json": {
	      encode: angular.toJson,
	      decode: angular.fromJson,
	      is: angular.isObject,
	      equals: angular.equals,
	      pattern: /[^/]*/
	    },
	    "any": { // does not encode/decode
	      encode: angular.identity,
	      decode: angular.identity,
	      equals: angular.equals,
	      pattern: /.*/
	    }
	  };

	  function getDefaultConfig() {
	    return {
	      strict: isStrictMode,
	      caseInsensitive: isCaseInsensitive
	    };
	  }

	  function isInjectable(value) {
	    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
	  }

	  /**
	   * [Internal] Get the default value of a parameter, which may be an injectable function.
	   */
	  $UrlMatcherFactory.$$getDefaultValue = function(config) {
	    if (!isInjectable(config.value)) return config.value;
	    if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
	    return injector.invoke(config.value);
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$urlMatcherFactory#caseInsensitive
	   * @methodOf ui.router.util.$urlMatcherFactory
	   *
	   * @description
	   * Defines whether URL matching should be case sensitive (the default behavior), or not.
	   *
	   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;
	   * @returns {boolean} the current value of caseInsensitive
	   */
	  this.caseInsensitive = function(value) {
	    if (isDefined(value))
	      isCaseInsensitive = value;
	    return isCaseInsensitive;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$urlMatcherFactory#strictMode
	   * @methodOf ui.router.util.$urlMatcherFactory
	   *
	   * @description
	   * Defines whether URLs should match trailing slashes, or not (the default behavior).
	   *
	   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.
	   * @returns {boolean} the current value of strictMode
	   */
	  this.strictMode = function(value) {
	    if (isDefined(value))
	      isStrictMode = value;
	    return isStrictMode;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy
	   * @methodOf ui.router.util.$urlMatcherFactory
	   *
	   * @description
	   * Sets the default behavior when generating or matching URLs with default parameter values.
	   *
	   * @param {string} value A string that defines the default parameter URL squashing behavior.
	   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
	   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
	   *             parameter is surrounded by slashes, squash (remove) one slash from the URL
	   *    any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
	   *             the parameter value from the URL and replace it with this string.
	   */
	  this.defaultSquashPolicy = function(value) {
	    if (!isDefined(value)) return defaultSquashPolicy;
	    if (value !== true && value !== false && !isString(value))
	      throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
	    defaultSquashPolicy = value;
	    return value;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$urlMatcherFactory#compile
	   * @methodOf ui.router.util.$urlMatcherFactory
	   *
	   * @description
	   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.
	   *
	   * @param {string} pattern  The URL pattern.
	   * @param {Object} config  The config object hash.
	   * @returns {UrlMatcher}  The UrlMatcher.
	   */
	  this.compile = function (pattern, config) {
	    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$urlMatcherFactory#isMatcher
	   * @methodOf ui.router.util.$urlMatcherFactory
	   *
	   * @description
	   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.
	   *
	   * @param {Object} object  The object to perform the type check against.
	   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by
	   *          implementing all the same methods.
	   */
	  this.isMatcher = function (o) {
	    if (!isObject(o)) return false;
	    var result = true;

	    forEach(UrlMatcher.prototype, function(val, name) {
	      if (isFunction(val)) {
	        result = result && (isDefined(o[name]) && isFunction(o[name]));
	      }
	    });
	    return result;
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.util.$urlMatcherFactory#type
	   * @methodOf ui.router.util.$urlMatcherFactory
	   *
	   * @description
	   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to
	   * generate URLs with typed parameters.
	   *
	   * @param {string} name  The type name.
	   * @param {Object|Function} definition   The type definition. See
	   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.
	   * @param {Object|Function} definitionFn (optional) A function that is injected before the app
	   *        runtime starts.  The result of this function is merged into the existing `definition`.
	   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.
	   *
	   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.
	   *
	   * @example
	   * This is a simple example of a custom type that encodes and decodes items from an
	   * array, using the array index as the URL-encoded value:
	   *
	   * <pre>
	   * var list = ['John', 'Paul', 'George', 'Ringo'];
	   *
	   * $urlMatcherFactoryProvider.type('listItem', {
	   *   encode: function(item) {
	   *     // Represent the list item in the URL using its corresponding index
	   *     return list.indexOf(item);
	   *   },
	   *   decode: function(item) {
	   *     // Look up the list item by index
	   *     return list[parseInt(item, 10)];
	   *   },
	   *   is: function(item) {
	   *     // Ensure the item is valid by checking to see that it appears
	   *     // in the list
	   *     return list.indexOf(item) > -1;
	   *   }
	   * });
	   *
	   * $stateProvider.state('list', {
	   *   url: "/list/{item:listItem}",
	   *   controller: function($scope, $stateParams) {
	   *     console.log($stateParams.item);
	   *   }
	   * });
	   *
	   * // ...
	   *
	   * // Changes URL to '/list/3', logs "Ringo" to the console
	   * $state.go('list', { item: "Ringo" });
	   * </pre>
	   *
	   * This is a more complex example of a type that relies on dependency injection to
	   * interact with services, and uses the parameter name from the URL to infer how to
	   * handle encoding and decoding parameter values:
	   *
	   * <pre>
	   * // Defines a custom type that gets a value from a service,
	   * // where each service gets different types of values from
	   * // a backend API:
	   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {
	   *
	   *   // Matches up services to URL parameter names
	   *   var services = {
	   *     user: Users,
	   *     post: Posts
	   *   };
	   *
	   *   return {
	   *     encode: function(object) {
	   *       // Represent the object in the URL using its unique ID
	   *       return object.id;
	   *     },
	   *     decode: function(value, key) {
	   *       // Look up the object by ID, using the parameter
	   *       // name (key) to call the correct service
	   *       return services[key].findById(value);
	   *     },
	   *     is: function(object, key) {
	   *       // Check that object is a valid dbObject
	   *       return angular.isObject(object) && object.id && services[key];
	   *     }
	   *     equals: function(a, b) {
	   *       // Check the equality of decoded objects by comparing
	   *       // their unique IDs
	   *       return a.id === b.id;
	   *     }
	   *   };
	   * });
	   *
	   * // In a config() block, you can then attach URLs with
	   * // type-annotated parameters:
	   * $stateProvider.state('users', {
	   *   url: "/users",
	   *   // ...
	   * }).state('users.item', {
	   *   url: "/{user:dbObject}",
	   *   controller: function($scope, $stateParams) {
	   *     // $stateParams.user will now be an object returned from
	   *     // the Users service
	   *   },
	   *   // ...
	   * });
	   * </pre>
	   */
	  this.type = function (name, definition, definitionFn) {
	    if (!isDefined(definition)) return $types[name];
	    if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");

	    $types[name] = new Type(extend({ name: name }, definition));
	    if (definitionFn) {
	      typeQueue.push({ name: name, def: definitionFn });
	      if (!enqueue) flushTypeQueue();
	    }
	    return this;
	  };

	  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s
	  function flushTypeQueue() {
	    while(typeQueue.length) {
	      var type = typeQueue.shift();
	      if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
	      angular.extend($types[type.name], injector.invoke(type.def));
	    }
	  }

	  // Register default types. Store them in the prototype of $types.
	  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });
	  $types = inherit($types, {});

	  /* No need to document $get, since it returns this */
	  this.$get = ['$injector', function ($injector) {
	    injector = $injector;
	    enqueue = false;
	    flushTypeQueue();

	    forEach(defaultTypes, function(type, name) {
	      if (!$types[name]) $types[name] = new Type(type);
	    });
	    return this;
	  }];

	  this.Param = function Param(id, type, config, location) {
	    var self = this;
	    config = unwrapShorthand(config);
	    type = getType(config, type, location);
	    var arrayMode = getArrayMode();
	    type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
	    if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
	      config.value = ""; // for 0.2.x; in 0.3.0+ do not automatically default to ""
	    var isOptional = config.value !== undefined;
	    var squash = getSquashPolicy(config, isOptional);
	    var replace = getReplace(config, arrayMode, isOptional, squash);

	    function unwrapShorthand(config) {
	      var keys = isObject(config) ? objectKeys(config) : [];
	      var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 &&
	                        indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
	      if (isShorthand) config = { value: config };
	      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };
	      return config;
	    }

	    function getType(config, urlType, location) {
	      if (config.type && urlType) throw new Error("Param '"+id+"' has two type configurations.");
	      if (urlType) return urlType;
	      if (!config.type) return (location === "config" ? $types.any : $types.string);

	      if (angular.isString(config.type))
	        return $types[config.type];
	      if (config.type instanceof Type)
	        return config.type;
	      return new Type(config.type);
	    }

	    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
	    function getArrayMode() {
	      var arrayDefaults = { array: (location === "search" ? "auto" : false) };
	      var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
	      return extend(arrayDefaults, arrayParamNomenclature, config).array;
	    }

	    /**
	     * returns false, true, or the squash value to indicate the "default parameter url squash policy".
	     */
	    function getSquashPolicy(config, isOptional) {
	      var squash = config.squash;
	      if (!isOptional || squash === false) return false;
	      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
	      if (squash === true || isString(squash)) return squash;
	      throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
	    }

	    function getReplace(config, arrayMode, isOptional, squash) {
	      var replace, configuredKeys, defaultPolicy = [
	        { from: "",   to: (isOptional || arrayMode ? undefined : "") },
	        { from: null, to: (isOptional || arrayMode ? undefined : "") }
	      ];
	      replace = isArray(config.replace) ? config.replace : [];
	      if (isString(squash))
	        replace.push({ from: squash, to: undefined });
	      configuredKeys = map(replace, function(item) { return item.from; } );
	      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);
	    }

	    /**
	     * [Internal] Get the default value of a parameter, which may be an injectable function.
	     */
	    function $$getDefaultValue() {
	      if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
	      var defaultValue = injector.invoke(config.$$fn);
	      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
	        throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
	      return defaultValue;
	    }

	    /**
	     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
	     * default value, which may be the result of an injectable function.
	     */
	    function $value(value) {
	      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }
	      function $replace(value) {
	        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });
	        return replacement.length ? replacement[0] : value;
	      }
	      value = $replace(value);
	      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
	    }

	    function toString() { return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}"; }

	    extend(this, {
	      id: id,
	      type: type,
	      location: location,
	      array: arrayMode,
	      squash: squash,
	      replace: replace,
	      isOptional: isOptional,
	      value: $value,
	      dynamic: undefined,
	      config: config,
	      toString: toString
	    });
	  };

	  function ParamSet(params) {
	    extend(this, params || {});
	  }

	  ParamSet.prototype = {
	    $$new: function() {
	      return inherit(this, extend(new ParamSet(), { $$parent: this}));
	    },
	    $$keys: function () {
	      var keys = [], chain = [], parent = this,
	        ignore = objectKeys(ParamSet.prototype);
	      while (parent) { chain.push(parent); parent = parent.$$parent; }
	      chain.reverse();
	      forEach(chain, function(paramset) {
	        forEach(objectKeys(paramset), function(key) {
	            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
	        });
	      });
	      return keys;
	    },
	    $$values: function(paramValues) {
	      var values = {}, self = this;
	      forEach(self.$$keys(), function(key) {
	        values[key] = self[key].value(paramValues && paramValues[key]);
	      });
	      return values;
	    },
	    $$equals: function(paramValues1, paramValues2) {
	      var equal = true, self = this;
	      forEach(self.$$keys(), function(key) {
	        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
	        if (!self[key].type.equals(left, right)) equal = false;
	      });
	      return equal;
	    },
	    $$validates: function $$validate(paramValues) {
	      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
	      for (i = 0; i < keys.length; i++) {
	        param = this[keys[i]];
	        rawVal = paramValues[keys[i]];
	        if ((rawVal === undefined || rawVal === null) && param.isOptional)
	          break; // There was no parameter value, but the param is optional
	        normalized = param.type.$normalize(rawVal);
	        if (!param.type.is(normalized))
	          return false; // The value was not of the correct Type, and could not be decoded to the correct Type
	        encoded = param.type.encode(normalized);
	        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
	          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp
	      }
	      return true;
	    },
	    $$parent: undefined
	  };

	  this.ParamSet = ParamSet;
	}

	// Register as a provider so it's available to other providers
	angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
	angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);

	/**
	 * @ngdoc object
	 * @name ui.router.router.$urlRouterProvider
	 *
	 * @requires ui.router.util.$urlMatcherFactoryProvider
	 * @requires $locationProvider
	 *
	 * @description
	 * `$urlRouterProvider` has the responsibility of watching `$location`. 
	 * When `$location` changes it runs through a list of rules one by one until a 
	 * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify 
	 * a url in a state configuration. All urls are compiled into a UrlMatcher object.
	 *
	 * There are several methods on `$urlRouterProvider` that make it useful to use directly
	 * in your module config.
	 */
	$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
	function $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {
	  var rules = [], otherwise = null, interceptDeferred = false, listener;

	  // Returns a string that is a prefix of all strings matching the RegExp
	  function regExpPrefix(re) {
	    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
	    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
	  }

	  // Interpolates matched values into a String.replace()-style pattern
	  function interpolate(pattern, match) {
	    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
	      return match[what === '$' ? 0 : Number(what)];
	    });
	  }

	  /**
	   * @ngdoc function
	   * @name ui.router.router.$urlRouterProvider#rule
	   * @methodOf ui.router.router.$urlRouterProvider
	   *
	   * @description
	   * Defines rules that are used by `$urlRouterProvider` to find matches for
	   * specific URLs.
	   *
	   * @example
	   * <pre>
	   * var app = angular.module('app', ['ui.router.router']);
	   *
	   * app.config(function ($urlRouterProvider) {
	   *   // Here's an example of how you might allow case insensitive urls
	   *   $urlRouterProvider.rule(function ($injector, $location) {
	   *     var path = $location.path(),
	   *         normalized = path.toLowerCase();
	   *
	   *     if (path !== normalized) {
	   *       return normalized;
	   *     }
	   *   });
	   * });
	   * </pre>
	   *
	   * @param {function} rule Handler function that takes `$injector` and `$location`
	   * services as arguments. You can use them to return a valid path as a string.
	   *
	   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
	   */
	  this.rule = function (rule) {
	    if (!isFunction(rule)) throw new Error("'rule' must be a function");
	    rules.push(rule);
	    return this;
	  };

	  /**
	   * @ngdoc object
	   * @name ui.router.router.$urlRouterProvider#otherwise
	   * @methodOf ui.router.router.$urlRouterProvider
	   *
	   * @description
	   * Defines a path that is used when an invalid route is requested.
	   *
	   * @example
	   * <pre>
	   * var app = angular.module('app', ['ui.router.router']);
	   *
	   * app.config(function ($urlRouterProvider) {
	   *   // if the path doesn't match any of the urls you configured
	   *   // otherwise will take care of routing the user to the
	   *   // specified url
	   *   $urlRouterProvider.otherwise('/index');
	   *
	   *   // Example of using function rule as param
	   *   $urlRouterProvider.otherwise(function ($injector, $location) {
	   *     return '/a/valid/url';
	   *   });
	   * });
	   * </pre>
	   *
	   * @param {string|function} rule The url path you want to redirect to or a function 
	   * rule that returns the url path. The function version is passed two params: 
	   * `$injector` and `$location` services, and must return a url string.
	   *
	   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
	   */
	  this.otherwise = function (rule) {
	    if (isString(rule)) {
	      var redirect = rule;
	      rule = function () { return redirect; };
	    }
	    else if (!isFunction(rule)) throw new Error("'rule' must be a function");
	    otherwise = rule;
	    return this;
	  };


	  function handleIfMatch($injector, handler, match) {
	    if (!match) return false;
	    var result = $injector.invoke(handler, handler, { $match: match });
	    return isDefined(result) ? result : true;
	  }

	  /**
	   * @ngdoc function
	   * @name ui.router.router.$urlRouterProvider#when
	   * @methodOf ui.router.router.$urlRouterProvider
	   *
	   * @description
	   * Registers a handler for a given url matching. 
	   * 
	   * If the handler is a string, it is
	   * treated as a redirect, and is interpolated according to the syntax of match
	   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
	   *
	   * If the handler is a function, it is injectable. It gets invoked if `$location`
	   * matches. You have the option of inject the match object as `$match`.
	   *
	   * The handler can return
	   *
	   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
	   *   will continue trying to find another one that matches.
	   * - **string** which is treated as a redirect and passed to `$location.url()`
	   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
	   *
	   * @example
	   * <pre>
	   * var app = angular.module('app', ['ui.router.router']);
	   *
	   * app.config(function ($urlRouterProvider) {
	   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
	   *     if ($state.$current.navigable !== state ||
	   *         !equalForKeys($match, $stateParams) {
	   *      $state.transitionTo(state, $match, false);
	   *     }
	   *   });
	   * });
	   * </pre>
	   *
	   * @param {string|object} what The incoming path that you want to redirect.
	   * @param {string|function} handler The path you want to redirect your user to.
	   */
	  this.when = function (what, handler) {
	    var redirect, handlerIsString = isString(handler);
	    if (isString(what)) what = $urlMatcherFactory.compile(what);

	    if (!handlerIsString && !isFunction(handler) && !isArray(handler))
	      throw new Error("invalid 'handler' in when()");

	    var strategies = {
	      matcher: function (what, handler) {
	        if (handlerIsString) {
	          redirect = $urlMatcherFactory.compile(handler);
	          handler = ['$match', function ($match) { return redirect.format($match); }];
	        }
	        return extend(function ($injector, $location) {
	          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
	        }, {
	          prefix: isString(what.prefix) ? what.prefix : ''
	        });
	      },
	      regex: function (what, handler) {
	        if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

	        if (handlerIsString) {
	          redirect = handler;
	          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
	        }
	        return extend(function ($injector, $location) {
	          return handleIfMatch($injector, handler, what.exec($location.path()));
	        }, {
	          prefix: regExpPrefix(what)
	        });
	      }
	    };

	    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

	    for (var n in check) {
	      if (check[n]) return this.rule(strategies[n](what, handler));
	    }

	    throw new Error("invalid 'what' in when()");
	  };

	  /**
	   * @ngdoc function
	   * @name ui.router.router.$urlRouterProvider#deferIntercept
	   * @methodOf ui.router.router.$urlRouterProvider
	   *
	   * @description
	   * Disables (or enables) deferring location change interception.
	   *
	   * If you wish to customize the behavior of syncing the URL (for example, if you wish to
	   * defer a transition but maintain the current URL), call this method at configuration time.
	   * Then, at run time, call `$urlRouter.listen()` after you have configured your own
	   * `$locationChangeSuccess` event handler.
	   *
	   * @example
	   * <pre>
	   * var app = angular.module('app', ['ui.router.router']);
	   *
	   * app.config(function ($urlRouterProvider) {
	   *
	   *   // Prevent $urlRouter from automatically intercepting URL changes;
	   *   // this allows you to configure custom behavior in between
	   *   // location changes and route synchronization:
	   *   $urlRouterProvider.deferIntercept();
	   *
	   * }).run(function ($rootScope, $urlRouter, UserService) {
	   *
	   *   $rootScope.$on('$locationChangeSuccess', function(e) {
	   *     // UserService is an example service for managing user state
	   *     if (UserService.isLoggedIn()) return;
	   *
	   *     // Prevent $urlRouter's default handler from firing
	   *     e.preventDefault();
	   *
	   *     UserService.handleLogin().then(function() {
	   *       // Once the user has logged in, sync the current URL
	   *       // to the router:
	   *       $urlRouter.sync();
	   *     });
	   *   });
	   *
	   *   // Configures $urlRouter's listener *after* your custom listener
	   *   $urlRouter.listen();
	   * });
	   * </pre>
	   *
	   * @param {boolean} defer Indicates whether to defer location change interception. Passing
	            no parameter is equivalent to `true`.
	   */
	  this.deferIntercept = function (defer) {
	    if (defer === undefined) defer = true;
	    interceptDeferred = defer;
	  };

	  /**
	   * @ngdoc object
	   * @name ui.router.router.$urlRouter
	   *
	   * @requires $location
	   * @requires $rootScope
	   * @requires $injector
	   * @requires $browser
	   *
	   * @description
	   *
	   */
	  this.$get = $get;
	  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
	  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {

	    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;

	    function appendBasePath(url, isHtml5, absolute) {
	      if (baseHref === '/') return url;
	      if (isHtml5) return baseHref.slice(0, -1) + url;
	      if (absolute) return baseHref.slice(1) + url;
	      return url;
	    }

	    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
	    function update(evt) {
	      if (evt && evt.defaultPrevented) return;
	      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
	      lastPushedUrl = undefined;
	      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573
	      //if (ignoreUpdate) return true;

	      function check(rule) {
	        var handled = rule($injector, $location);

	        if (!handled) return false;
	        if (isString(handled)) $location.replace().url(handled);
	        return true;
	      }
	      var n = rules.length, i;

	      for (i = 0; i < n; i++) {
	        if (check(rules[i])) return;
	      }
	      // always check otherwise last to allow dynamic updates to the set of rules
	      if (otherwise) check(otherwise);
	    }

	    function listen() {
	      listener = listener || $rootScope.$on('$locationChangeSuccess', update);
	      return listener;
	    }

	    if (!interceptDeferred) listen();

	    return {
	      /**
	       * @ngdoc function
	       * @name ui.router.router.$urlRouter#sync
	       * @methodOf ui.router.router.$urlRouter
	       *
	       * @description
	       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
	       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
	       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
	       * with the transition by calling `$urlRouter.sync()`.
	       *
	       * @example
	       * <pre>
	       * angular.module('app', ['ui.router'])
	       *   .run(function($rootScope, $urlRouter) {
	       *     $rootScope.$on('$locationChangeSuccess', function(evt) {
	       *       // Halt state change from even starting
	       *       evt.preventDefault();
	       *       // Perform custom logic
	       *       var meetsRequirement = ...
	       *       // Continue with the update and state transition if logic allows
	       *       if (meetsRequirement) $urlRouter.sync();
	       *     });
	       * });
	       * </pre>
	       */
	      sync: function() {
	        update();
	      },

	      listen: function() {
	        return listen();
	      },

	      update: function(read) {
	        if (read) {
	          location = $location.url();
	          return;
	        }
	        if ($location.url() === location) return;

	        $location.url(location);
	        $location.replace();
	      },

	      push: function(urlMatcher, params, options) {
	         var url = urlMatcher.format(params || {});

	        // Handle the special hash param, if needed
	        if (url !== null && params && params['#']) {
	            url += '#' + params['#'];
	        }

	        $location.url(url);
	        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
	        if (options && options.replace) $location.replace();
	      },

	      /**
	       * @ngdoc function
	       * @name ui.router.router.$urlRouter#href
	       * @methodOf ui.router.router.$urlRouter
	       *
	       * @description
	       * A URL generation method that returns the compiled URL for a given
	       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
	       *
	       * @example
	       * <pre>
	       * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
	       *   person: "bob"
	       * });
	       * // $bob == "/about/bob";
	       * </pre>
	       *
	       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
	       * @param {object=} params An object of parameter values to fill the matcher's required parameters.
	       * @param {object=} options Options object. The options are:
	       *
	       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
	       *
	       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
	       */
	      href: function(urlMatcher, params, options) {
	        if (!urlMatcher.validates(params)) return null;

	        var isHtml5 = $locationProvider.html5Mode();
	        if (angular.isObject(isHtml5)) {
	          isHtml5 = isHtml5.enabled;
	        }

	        isHtml5 = isHtml5 && $sniffer.history;
	        
	        var url = urlMatcher.format(params);
	        options = options || {};

	        if (!isHtml5 && url !== null) {
	          url = "#" + $locationProvider.hashPrefix() + url;
	        }

	        // Handle special hash param, if needed
	        if (url !== null && params && params['#']) {
	          url += '#' + params['#'];
	        }

	        url = appendBasePath(url, isHtml5, options.absolute);

	        if (!options.absolute || !url) {
	          return url;
	        }

	        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();
	        port = (port === 80 || port === 443 ? '' : ':' + port);

	        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
	      }
	    };
	  }
	}

	angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

	/**
	 * @ngdoc object
	 * @name ui.router.state.$stateProvider
	 *
	 * @requires ui.router.router.$urlRouterProvider
	 * @requires ui.router.util.$urlMatcherFactoryProvider
	 *
	 * @description
	 * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
	 * on state.
	 *
	 * A state corresponds to a "place" in the application in terms of the overall UI and
	 * navigation. A state describes (via the controller / template / view properties) what
	 * the UI looks like and does at that place.
	 *
	 * States often have things in common, and the primary way of factoring out these
	 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
	 * nested states.
	 *
	 * The `$stateProvider` provides interfaces to declare these states for your app.
	 */
	$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
	function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {

	  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';

	  // Builds state properties from definition passed to registerState()
	  var stateBuilder = {

	    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
	    // state.children = [];
	    // if (parent) parent.children.push(state);
	    parent: function(state) {
	      if (isDefined(state.parent) && state.parent) return findState(state.parent);
	      // regex matches any valid composite state name
	      // would match "contact.list" but not "contacts"
	      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
	      return compositeName ? findState(compositeName[1]) : root;
	    },

	    // inherit 'data' from parent and override by own values (if any)
	    data: function(state) {
	      if (state.parent && state.parent.data) {
	        state.data = state.self.data = inherit(state.parent.data, state.data);
	      }
	      return state.data;
	    },

	    // Build a URLMatcher if necessary, either via a relative or absolute URL
	    url: function(state) {
	      var url = state.url, config = { params: state.params || {} };

	      if (isString(url)) {
	        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);
	        return (state.parent.navigable || root).url.concat(url, config);
	      }

	      if (!url || $urlMatcherFactory.isMatcher(url)) return url;
	      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
	    },

	    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
	    navigable: function(state) {
	      return state.url ? state : (state.parent ? state.parent.navigable : null);
	    },

	    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
	    ownParams: function(state) {
	      var params = state.url && state.url.params || new $$UMFP.ParamSet();
	      forEach(state.params || {}, function(config, id) {
	        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
	      });
	      return params;
	    },

	    // Derive parameters for this state and ensure they're a super-set of parent's parameters
	    params: function(state) {
	      var ownParams = pick(state.ownParams, state.ownParams.$$keys());
	      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
	    },

	    // If there is no explicit multi-view configuration, make one up so we don't have
	    // to handle both cases in the view directive later. Note that having an explicit
	    // 'views' property will mean the default unnamed view properties are ignored. This
	    // is also a good time to resolve view names to absolute names, so everything is a
	    // straight lookup at link time.
	    views: function(state) {
	      var views = {};

	      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
	        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
	        views[name] = view;
	      });
	      return views;
	    },

	    // Keep a full path from the root down to this state as this is needed for state activation.
	    path: function(state) {
	      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
	    },

	    // Speed up $state.contains() as it's used a lot
	    includes: function(state) {
	      var includes = state.parent ? extend({}, state.parent.includes) : {};
	      includes[state.name] = true;
	      return includes;
	    },

	    $delegates: {}
	  };

	  function isRelative(stateName) {
	    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
	  }

	  function findState(stateOrName, base) {
	    if (!stateOrName) return undefined;

	    var isStr = isString(stateOrName),
	        name  = isStr ? stateOrName : stateOrName.name,
	        path  = isRelative(name);

	    if (path) {
	      if (!base) throw new Error("No reference point given for path '"  + name + "'");
	      base = findState(base);
	      
	      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

	      for (; i < pathLength; i++) {
	        if (rel[i] === "" && i === 0) {
	          current = base;
	          continue;
	        }
	        if (rel[i] === "^") {
	          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
	          current = current.parent;
	          continue;
	        }
	        break;
	      }
	      rel = rel.slice(i).join(".");
	      name = current.name + (current.name && rel ? "." : "") + rel;
	    }
	    var state = states[name];

	    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
	      return state;
	    }
	    return undefined;
	  }

	  function queueState(parentName, state) {
	    if (!queue[parentName]) {
	      queue[parentName] = [];
	    }
	    queue[parentName].push(state);
	  }

	  function flushQueuedChildren(parentName) {
	    var queued = queue[parentName] || [];
	    while(queued.length) {
	      registerState(queued.shift());
	    }
	  }

	  function registerState(state) {
	    // Wrap a new object around the state so we can store our private details easily.
	    state = inherit(state, {
	      self: state,
	      resolve: state.resolve || {},
	      toString: function() { return this.name; }
	    });

	    var name = state.name;
	    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
	    if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");

	    // Get parent name
	    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))
	        : (isString(state.parent)) ? state.parent
	        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name
	        : '';

	    // If parent is not registered yet, add state to queue and register later
	    if (parentName && !states[parentName]) {
	      return queueState(parentName, state.self);
	    }

	    for (var key in stateBuilder) {
	      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
	    }
	    states[name] = state;

	    // Register the state in the global state list and with $urlRouter if necessary.
	    if (!state[abstractKey] && state.url) {
	      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
	        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
	          $state.transitionTo(state, $match, { inherit: true, location: false });
	        }
	      }]);
	    }

	    // Register any queued children
	    flushQueuedChildren(name);

	    return state;
	  }

	  // Checks text to see if it looks like a glob.
	  function isGlob (text) {
	    return text.indexOf('*') > -1;
	  }

	  // Returns true if glob matches current $state name.
	  function doesStateMatchGlob (glob) {
	    var globSegments = glob.split('.'),
	        segments = $state.$current.name.split('.');

	    //match single stars
	    for (var i = 0, l = globSegments.length; i < l; i++) {
	      if (globSegments[i] === '*') {
	        segments[i] = '*';
	      }
	    }

	    //match greedy starts
	    if (globSegments[0] === '**') {
	       segments = segments.slice(indexOf(segments, globSegments[1]));
	       segments.unshift('**');
	    }
	    //match greedy ends
	    if (globSegments[globSegments.length - 1] === '**') {
	       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
	       segments.push('**');
	    }

	    if (globSegments.length != segments.length) {
	      return false;
	    }

	    return segments.join('') === globSegments.join('');
	  }


	  // Implicit root state that is always active
	  root = registerState({
	    name: '',
	    url: '^',
	    views: null,
	    'abstract': true
	  });
	  root.navigable = null;


	  /**
	   * @ngdoc function
	   * @name ui.router.state.$stateProvider#decorator
	   * @methodOf ui.router.state.$stateProvider
	   *
	   * @description
	   * Allows you to extend (carefully) or override (at your own peril) the 
	   * `stateBuilder` object used internally by `$stateProvider`. This can be used 
	   * to add custom functionality to ui-router, for example inferring templateUrl 
	   * based on the state name.
	   *
	   * When passing only a name, it returns the current (original or decorated) builder
	   * function that matches `name`.
	   *
	   * The builder functions that can be decorated are listed below. Though not all
	   * necessarily have a good use case for decoration, that is up to you to decide.
	   *
	   * In addition, users can attach custom decorators, which will generate new 
	   * properties within the state's internal definition. There is currently no clear 
	   * use-case for this beyond accessing internal states (i.e. $state.$current), 
	   * however, expect this to become increasingly relevant as we introduce additional 
	   * meta-programming features.
	   *
	   * **Warning**: Decorators should not be interdependent because the order of 
	   * execution of the builder functions in non-deterministic. Builder functions 
	   * should only be dependent on the state definition object and super function.
	   *
	   *
	   * Existing builder functions and current return values:
	   *
	   * - **parent** `{object}` - returns the parent state object.
	   * - **data** `{object}` - returns state data, including any inherited data that is not
	   *   overridden by own values (if any).
	   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
	   *   or `null`.
	   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is 
	   *   navigable).
	   * - **params** `{object}` - returns an array of state params that are ensured to 
	   *   be a super-set of parent's params.
	   * - **views** `{object}` - returns a views object where each key is an absolute view 
	   *   name (i.e. "viewName@stateName") and each value is the config object 
	   *   (template, controller) for the view. Even when you don't use the views object 
	   *   explicitly on a state config, one is still created for you internally.
	   *   So by decorating this builder function you have access to decorating template 
	   *   and controller properties.
	   * - **ownParams** `{object}` - returns an array of params that belong to the state, 
	   *   not including any params defined by ancestor states.
	   * - **path** `{string}` - returns the full path from the root down to this state. 
	   *   Needed for state activation.
	   * - **includes** `{object}` - returns an object that includes every state that 
	   *   would pass a `$state.includes()` test.
	   *
	   * @example
	   * <pre>
	   * // Override the internal 'views' builder with a function that takes the state
	   * // definition, and a reference to the internal function being overridden:
	   * $stateProvider.decorator('views', function (state, parent) {
	   *   var result = {},
	   *       views = parent(state);
	   *
	   *   angular.forEach(views, function (config, name) {
	   *     var autoName = (state.name + '.' + name).replace('.', '/');
	   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
	   *     result[name] = config;
	   *   });
	   *   return result;
	   * });
	   *
	   * $stateProvider.state('home', {
	   *   views: {
	   *     'contact.list': { controller: 'ListController' },
	   *     'contact.item': { controller: 'ItemController' }
	   *   }
	   * });
	   *
	   * // ...
	   *
	   * $state.go('home');
	   * // Auto-populates list and item views with /partials/home/contact/list.html,
	   * // and /partials/home/contact/item.html, respectively.
	   * </pre>
	   *
	   * @param {string} name The name of the builder function to decorate. 
	   * @param {object} func A function that is responsible for decorating the original 
	   * builder function. The function receives two parameters:
	   *
	   *   - `{object}` - state - The state config object.
	   *   - `{object}` - super - The original builder function.
	   *
	   * @return {object} $stateProvider - $stateProvider instance
	   */
	  this.decorator = decorator;
	  function decorator(name, func) {
	    /*jshint validthis: true */
	    if (isString(name) && !isDefined(func)) {
	      return stateBuilder[name];
	    }
	    if (!isFunction(func) || !isString(name)) {
	      return this;
	    }
	    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
	      stateBuilder.$delegates[name] = stateBuilder[name];
	    }
	    stateBuilder[name] = func;
	    return this;
	  }

	  /**
	   * @ngdoc function
	   * @name ui.router.state.$stateProvider#state
	   * @methodOf ui.router.state.$stateProvider
	   *
	   * @description
	   * Registers a state configuration under a given state name. The stateConfig object
	   * has the following acceptable properties.
	   *
	   * @param {string} name A unique state name, e.g. "home", "about", "contacts".
	   * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
	   * @param {object} stateConfig State configuration object.
	   * @param {string|function=} stateConfig.template
	   * <a id='template'></a>
	   *   html template as a string or a function that returns
	   *   an html template as a string which should be used by the uiView directives. This property 
	   *   takes precedence over templateUrl.
	   *   
	   *   If `template` is a function, it will be called with the following parameters:
	   *
	   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
	   *     applying the current state
	   *
	   * <pre>template:
	   *   "<h1>inline template definition</h1>" +
	   *   "<div ui-view></div>"</pre>
	   * <pre>template: function(params) {
	   *       return "<h1>generated template</h1>"; }</pre>
	   * </div>
	   *
	   * @param {string|function=} stateConfig.templateUrl
	   * <a id='templateUrl'></a>
	   *
	   *   path or function that returns a path to an html
	   *   template that should be used by uiView.
	   *   
	   *   If `templateUrl` is a function, it will be called with the following parameters:
	   *
	   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by 
	   *     applying the current state
	   *
	   * <pre>templateUrl: "home.html"</pre>
	   * <pre>templateUrl: function(params) {
	   *     return myTemplates[params.pageId]; }</pre>
	   *
	   * @param {function=} stateConfig.templateProvider
	   * <a id='templateProvider'></a>
	   *    Provider function that returns HTML content string.
	   * <pre> templateProvider:
	   *       function(MyTemplateService, params) {
	   *         return MyTemplateService.getTemplate(params.pageId);
	   *       }</pre>
	   *
	   * @param {string|function=} stateConfig.controller
	   * <a id='controller'></a>
	   *
	   *  Controller fn that should be associated with newly
	   *   related scope or the name of a registered controller if passed as a string.
	   *   Optionally, the ControllerAs may be declared here.
	   * <pre>controller: "MyRegisteredController"</pre>
	   * <pre>controller:
	   *     "MyRegisteredController as fooCtrl"}</pre>
	   * <pre>controller: function($scope, MyService) {
	   *     $scope.data = MyService.getData(); }</pre>
	   *
	   * @param {function=} stateConfig.controllerProvider
	   * <a id='controllerProvider'></a>
	   *
	   * Injectable provider function that returns the actual controller or string.
	   * <pre>controllerProvider:
	   *   function(MyResolveData) {
	   *     if (MyResolveData.foo)
	   *       return "FooCtrl"
	   *     else if (MyResolveData.bar)
	   *       return "BarCtrl";
	   *     else return function($scope) {
	   *       $scope.baz = "Qux";
	   *     }
	   *   }</pre>
	   *
	   * @param {string=} stateConfig.controllerAs
	   * <a id='controllerAs'></a>
	   * 
	   * A controller alias name. If present the controller will be
	   *   published to scope under the controllerAs name.
	   * <pre>controllerAs: "myCtrl"</pre>
	   *
	   * @param {string|object=} stateConfig.parent
	   * <a id='parent'></a>
	   * Optionally specifies the parent state of this state.
	   *
	   * <pre>parent: 'parentState'</pre>
	   * <pre>parent: parentState // JS variable</pre>
	   *
	   * @param {object=} stateConfig.resolve
	   * <a id='resolve'></a>
	   *
	   * An optional map&lt;string, function&gt; of dependencies which
	   *   should be injected into the controller. If any of these dependencies are promises, 
	   *   the router will wait for them all to be resolved before the controller is instantiated.
	   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
	   *   and the values of the resolved promises are injected into any controllers that reference them.
	   *   If any  of the promises are rejected the $stateChangeError event is fired.
	   *
	   *   The map object is:
	   *   
	   *   - key - {string}: name of dependency to be injected into controller
	   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, 
	   *     it is injected and return value it treated as dependency. If result is a promise, it is 
	   *     resolved before its value is injected into controller.
	   *
	   * <pre>resolve: {
	   *     myResolve1:
	   *       function($http, $stateParams) {
	   *         return $http.get("/api/foos/"+stateParams.fooID);
	   *       }
	   *     }</pre>
	   *
	   * @param {string=} stateConfig.url
	   * <a id='url'></a>
	   *
	   *   A url fragment with optional parameters. When a state is navigated or
	   *   transitioned to, the `$stateParams` service will be populated with any 
	   *   parameters that were passed.
	   *
	   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for
	   *   more details on acceptable patterns )
	   *
	   * examples:
	   * <pre>url: "/home"
	   * url: "/users/:userid"
	   * url: "/books/{bookid:[a-zA-Z_-]}"
	   * url: "/books/{categoryid:int}"
	   * url: "/books/{publishername:string}/{categoryid:int}"
	   * url: "/messages?before&after"
	   * url: "/messages?{before:date}&{after:date}"
	   * url: "/messages/:mailboxid?{before:date}&{after:date}"
	   * </pre>
	   *
	   * @param {object=} stateConfig.views
	   * <a id='views'></a>
	   * an optional map&lt;string, object&gt; which defined multiple views, or targets views
	   * manually/explicitly.
	   *
	   * Examples:
	   *
	   * Targets three named `ui-view`s in the parent state's template
	   * <pre>views: {
	   *     header: {
	   *       controller: "headerCtrl",
	   *       templateUrl: "header.html"
	   *     }, body: {
	   *       controller: "bodyCtrl",
	   *       templateUrl: "body.html"
	   *     }, footer: {
	   *       controller: "footCtrl",
	   *       templateUrl: "footer.html"
	   *     }
	   *   }</pre>
	   *
	   * Targets named `ui-view="header"` from grandparent state 'top''s template, and named `ui-view="body" from parent state's template.
	   * <pre>views: {
	   *     'header@top': {
	   *       controller: "msgHeaderCtrl",
	   *       templateUrl: "msgHeader.html"
	   *     }, 'body': {
	   *       controller: "messagesCtrl",
	   *       templateUrl: "messages.html"
	   *     }
	   *   }</pre>
	   *
	   * @param {boolean=} [stateConfig.abstract=false]
	   * <a id='abstract'></a>
	   * An abstract state will never be directly activated,
	   *   but can provide inherited properties to its common children states.
	   * <pre>abstract: true</pre>
	   *
	   * @param {function=} stateConfig.onEnter
	   * <a id='onEnter'></a>
	   *
	   * Callback function for when a state is entered. Good way
	   *   to trigger an action or dispatch an event, such as opening a dialog.
	   * If minifying your scripts, make sure to explicitly annotate this function,
	   * because it won't be automatically annotated by your build tools.
	   *
	   * <pre>onEnter: function(MyService, $stateParams) {
	   *     MyService.foo($stateParams.myParam);
	   * }</pre>
	   *
	   * @param {function=} stateConfig.onExit
	   * <a id='onExit'></a>
	   *
	   * Callback function for when a state is exited. Good way to
	   *   trigger an action or dispatch an event, such as opening a dialog.
	   * If minifying your scripts, make sure to explicitly annotate this function,
	   * because it won't be automatically annotated by your build tools.
	   *
	   * <pre>onExit: function(MyService, $stateParams) {
	   *     MyService.cleanup($stateParams.myParam);
	   * }</pre>
	   *
	   * @param {boolean=} [stateConfig.reloadOnSearch=true]
	   * <a id='reloadOnSearch'></a>
	   *
	   * If `false`, will not retrigger the same state
	   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). 
	   *   Useful for when you'd like to modify $location.search() without triggering a reload.
	   * <pre>reloadOnSearch: false</pre>
	   *
	   * @param {object=} stateConfig.data
	   * <a id='data'></a>
	   *
	   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is
	   *   prototypally inherited.  In other words, adding a data property to a state adds it to
	   *   the entire subtree via prototypal inheritance.
	   *
	   * <pre>data: {
	   *     requiredRole: 'foo'
	   * } </pre>
	   *
	   * @param {object=} stateConfig.params
	   * <a id='params'></a>
	   *
	   * A map which optionally configures parameters declared in the `url`, or
	   *   defines additional non-url parameters.  For each parameter being
	   *   configured, add a configuration object keyed to the name of the parameter.
	   *
	   *   Each parameter configuration object may contain the following properties:
	   *
	   *   - ** value ** - {object|function=}: specifies the default value for this
	   *     parameter.  This implicitly sets this parameter as optional.
	   *
	   *     When UI-Router routes to a state and no value is
	   *     specified for this parameter in the URL or transition, the
	   *     default value will be used instead.  If `value` is a function,
	   *     it will be injected and invoked, and the return value used.
	   *
	   *     *Note*: `undefined` is treated as "no default value" while `null`
	   *     is treated as "the default value is `null`".
	   *
	   *     *Shorthand*: If you only need to configure the default value of the
	   *     parameter, you may use a shorthand syntax.   In the **`params`**
	   *     map, instead mapping the param name to a full parameter configuration
	   *     object, simply set map it to the default parameter value, e.g.:
	   *
	   * <pre>// define a parameter's default value
	   * params: {
	   *     param1: { value: "defaultValue" }
	   * }
	   * // shorthand default values
	   * params: {
	   *     param1: "defaultValue",
	   *     param2: "param2Default"
	   * }</pre>
	   *
	   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
	   *     treated as an array of values.  If you specified a Type, the value will be
	   *     treated as an array of the specified Type.  Note: query parameter values
	   *     default to a special `"auto"` mode.
	   *
	   *     For query parameters in `"auto"` mode, if multiple  values for a single parameter
	   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values
	   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if
	   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single
	   *     value (e.g.: `{ foo: '1' }`).
	   *
	   * <pre>params: {
	   *     param1: { array: true }
	   * }</pre>
	   *
	   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when
	   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the
	   *     configured default squash policy.
	   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})
	   *
	   *   There are three squash settings:
	   *
	   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL
	   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed
	   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.
	   *       This can allow for cleaner looking URLs.
	   *     - `"<arbitrary string>"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.
	   *
	   * <pre>params: {
	   *     param1: {
	   *       value: "defaultId",
	   *       squash: true
	   * } }
	   * // squash "defaultValue" to "~"
	   * params: {
	   *     param1: {
	   *       value: "defaultValue",
	   *       squash: "~"
	   * } }
	   * </pre>
	   *
	   *
	   * @example
	   * <pre>
	   * // Some state name examples
	   *
	   * // stateName can be a single top-level name (must be unique).
	   * $stateProvider.state("home", {});
	   *
	   * // Or it can be a nested state name. This state is a child of the
	   * // above "home" state.
	   * $stateProvider.state("home.newest", {});
	   *
	   * // Nest states as deeply as needed.
	   * $stateProvider.state("home.newest.abc.xyz.inception", {});
	   *
	   * // state() returns $stateProvider, so you can chain state declarations.
	   * $stateProvider
	   *   .state("home", {})
	   *   .state("about", {})
	   *   .state("contacts", {});
	   * </pre>
	   *
	   */
	  this.state = state;
	  function state(name, definition) {
	    /*jshint validthis: true */
	    if (isObject(name)) definition = name;
	    else definition.name = name;
	    registerState(definition);
	    return this;
	  }

	  /**
	   * @ngdoc object
	   * @name ui.router.state.$state
	   *
	   * @requires $rootScope
	   * @requires $q
	   * @requires ui.router.state.$view
	   * @requires $injector
	   * @requires ui.router.util.$resolve
	   * @requires ui.router.state.$stateParams
	   * @requires ui.router.router.$urlRouter
	   *
	   * @property {object} params A param object, e.g. {sectionId: section.id)}, that 
	   * you'd like to test against the current active state.
	   * @property {object} current A reference to the state's config object. However 
	   * you passed it in. Useful for accessing custom data.
	   * @property {object} transition Currently pending transition. A promise that'll 
	   * resolve or reject.
	   *
	   * @description
	   * `$state` service is responsible for representing states as well as transitioning
	   * between them. It also provides interfaces to ask for current state or even states
	   * you're coming from.
	   */
	  this.$get = $get;
	  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
	  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {

	    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
	    var TransitionPrevented = $q.reject(new Error('transition prevented'));
	    var TransitionAborted = $q.reject(new Error('transition aborted'));
	    var TransitionFailed = $q.reject(new Error('transition failed'));

	    // Handles the case where a state which is the target of a transition is not found, and the user
	    // can optionally retry or defer the transition
	    function handleRedirect(redirect, state, params, options) {
	      /**
	       * @ngdoc event
	       * @name ui.router.state.$state#$stateNotFound
	       * @eventOf ui.router.state.$state
	       * @eventType broadcast on root scope
	       * @description
	       * Fired when a requested state **cannot be found** using the provided state name during transition.
	       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
	       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
	       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
	       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
	       *
	       * @param {Object} event Event object.
	       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
	       * @param {State} fromState Current state object.
	       * @param {Object} fromParams Current state params.
	       *
	       * @example
	       *
	       * <pre>
	       * // somewhere, assume lazy.state has not been defined
	       * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
	       *
	       * // somewhere else
	       * $scope.$on('$stateNotFound',
	       * function(event, unfoundState, fromState, fromParams){
	       *     console.log(unfoundState.to); // "lazy.state"
	       *     console.log(unfoundState.toParams); // {a:1, b:2}
	       *     console.log(unfoundState.options); // {inherit:false} + default options
	       * })
	       * </pre>
	       */
	      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);

	      if (evt.defaultPrevented) {
	        $urlRouter.update();
	        return TransitionAborted;
	      }

	      if (!evt.retry) {
	        return null;
	      }

	      // Allow the handler to return a promise to defer state lookup retry
	      if (options.$retry) {
	        $urlRouter.update();
	        return TransitionFailed;
	      }
	      var retryTransition = $state.transition = $q.when(evt.retry);

	      retryTransition.then(function() {
	        if (retryTransition !== $state.transition) return TransitionSuperseded;
	        redirect.options.$retry = true;
	        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
	      }, function() {
	        return TransitionAborted;
	      });
	      $urlRouter.update();

	      return retryTransition;
	    }

	    root.locals = { resolve: null, globals: { $stateParams: {} } };

	    $state = {
	      params: {},
	      current: root.self,
	      $current: root,
	      transition: null
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$state#reload
	     * @methodOf ui.router.state.$state
	     *
	     * @description
	     * A method that force reloads the current state. All resolves are re-resolved,
	     * controllers reinstantiated, and events re-fired.
	     *
	     * @example
	     * <pre>
	     * var app angular.module('app', ['ui.router']);
	     *
	     * app.controller('ctrl', function ($scope, $state) {
	     *   $scope.reload = function(){
	     *     $state.reload();
	     *   }
	     * });
	     * </pre>
	     *
	     * `reload()` is just an alias for:
	     * <pre>
	     * $state.transitionTo($state.current, $stateParams, { 
	     *   reload: true, inherit: false, notify: true
	     * });
	     * </pre>
	     *
	     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.
	     * @example
	     * <pre>
	     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' 
	     * //and current state is 'contacts.detail.item'
	     * var app angular.module('app', ['ui.router']);
	     *
	     * app.controller('ctrl', function ($scope, $state) {
	     *   $scope.reload = function(){
	     *     //will reload 'contact.detail' and 'contact.detail.item' states
	     *     $state.reload('contact.detail');
	     *   }
	     * });
	     * </pre>
	     *
	     * `reload()` is just an alias for:
	     * <pre>
	     * $state.transitionTo($state.current, $stateParams, { 
	     *   reload: true, inherit: false, notify: true
	     * });
	     * </pre>

	     * @returns {promise} A promise representing the state of the new transition. See
	     * {@link ui.router.state.$state#methods_go $state.go}.
	     */
	    $state.reload = function reload(state) {
	      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$state#go
	     * @methodOf ui.router.state.$state
	     *
	     * @description
	     * Convenience method for transitioning to a new state. `$state.go` calls 
	     * `$state.transitionTo` internally but automatically sets options to 
	     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. 
	     * This allows you to easily use an absolute or relative to path and specify 
	     * only the parameters you'd like to update (while letting unspecified parameters 
	     * inherit from the currently active ancestor states).
	     *
	     * @example
	     * <pre>
	     * var app = angular.module('app', ['ui.router']);
	     *
	     * app.controller('ctrl', function ($scope, $state) {
	     *   $scope.changeState = function () {
	     *     $state.go('contact.detail');
	     *   };
	     * });
	     * </pre>
	     * <img src='../ngdoc_assets/StateGoExamples.png'/>
	     *
	     * @param {string} to Absolute state name or relative state path. Some examples:
	     *
	     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
	     * - `$state.go('^')` - will go to a parent state
	     * - `$state.go('^.sibling')` - will go to a sibling state
	     * - `$state.go('.child.grandchild')` - will go to grandchild state
	     *
	     * @param {object=} params A map of the parameters that will be sent to the state, 
	     * will populate $stateParams. Any parameters that are not specified will be inherited from currently 
	     * defined parameters. Only parameters specified in the state definition can be overridden, new 
	     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters
	     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
	     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
	     * will get you all current parameters, etc.
	     * @param {object=} options Options object. The options are:
	     *
	     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
	     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
	     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
	     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
	     *    defines which state to be relative from.
	     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
	     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params
	     *    have changed.  It will reload the resolves and views of the current state and parent states.
	     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \
	     *    the transition reloads the resolves and views for that matched state, and all its children states.
	     *
	     * @returns {promise} A promise representing the state of the new transition.
	     *
	     * Possible success values:
	     *
	     * - $state.current
	     *
	     * <br/>Possible rejection values:
	     *
	     * - 'transition superseded' - when a newer transition has been started after this one
	     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
	     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
	     *   when a `$stateNotFound` `event.retry` promise errors.
	     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
	     * - *resolve error* - when an error has occurred with a `resolve`
	     *
	     */
	    $state.go = function go(to, params, options) {
	      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$state#transitionTo
	     * @methodOf ui.router.state.$state
	     *
	     * @description
	     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
	     * uses `transitionTo` internally. `$state.go` is recommended in most situations.
	     *
	     * @example
	     * <pre>
	     * var app = angular.module('app', ['ui.router']);
	     *
	     * app.controller('ctrl', function ($scope, $state) {
	     *   $scope.changeState = function () {
	     *     $state.transitionTo('contact.detail');
	     *   };
	     * });
	     * </pre>
	     *
	     * @param {string} to State name.
	     * @param {object=} toParams A map of the parameters that will be sent to the state,
	     * will populate $stateParams.
	     * @param {object=} options Options object. The options are:
	     *
	     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
	     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
	     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
	     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), 
	     *    defines which state to be relative from.
	     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
	     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params 
	     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
	     *    use this when you want to force a reload when *everything* is the same, including search params.
	     *    if String, then will reload the state with the name given in reload, and any children.
	     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.
	     *
	     * @returns {promise} A promise representing the state of the new transition. See
	     * {@link ui.router.state.$state#methods_go $state.go}.
	     */
	    $state.transitionTo = function transitionTo(to, toParams, options) {
	      toParams = toParams || {};
	      options = extend({
	        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
	      }, options || {});

	      var from = $state.$current, fromParams = $state.params, fromPath = from.path;
	      var evt, toState = findState(to, options.relative);

	      // Store the hash param for later (since it will be stripped out by various methods)
	      var hash = toParams['#'];

	      if (!isDefined(toState)) {
	        var redirect = { to: to, toParams: toParams, options: options };
	        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

	        if (redirectResult) {
	          return redirectResult;
	        }

	        // Always retry once if the $stateNotFound was not prevented
	        // (handles either redirect changed or state lazy-definition)
	        to = redirect.to;
	        toParams = redirect.toParams;
	        options = redirect.options;
	        toState = findState(to, options.relative);

	        if (!isDefined(toState)) {
	          if (!options.relative) throw new Error("No such state '" + to + "'");
	          throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
	        }
	      }
	      if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
	      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
	      if (!toState.params.$$validates(toParams)) return TransitionFailed;

	      toParams = toState.params.$$values(toParams);
	      to = toState;

	      var toPath = to.path;

	      // Starting from the root of the path, keep all levels that haven't changed
	      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];

	      if (!options.reload) {
	        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
	          locals = toLocals[keep] = state.locals;
	          keep++;
	          state = toPath[keep];
	        }
	      } else if (isString(options.reload) || isObject(options.reload)) {
	        if (isObject(options.reload) && !options.reload.name) {
	          throw new Error('Invalid reload state object');
	        }
	        
	        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
	        if (options.reload && !reloadState) {
	          throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
	        }

	        while (state && state === fromPath[keep] && state !== reloadState) {
	          locals = toLocals[keep] = state.locals;
	          keep++;
	          state = toPath[keep];
	        }
	      }

	      // If we're going to the same state and all locals are kept, we've got nothing to do.
	      // But clear 'transition', as we still want to cancel any other pending transitions.
	      // TODO: We may not want to bump 'transition' if we're called from a location change
	      // that we've initiated ourselves, because we might accidentally abort a legitimate
	      // transition initiated from code?
	      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
	        if (hash) toParams['#'] = hash;
	        $state.params = toParams;
	        copy($state.params, $stateParams);
	        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
	        if (options.location && to.navigable && to.navigable.url) {
	          $urlRouter.push(to.navigable.url, toParams, {
	            $$avoidResync: true, replace: options.location === 'replace'
	          });
	          $urlRouter.update(true);
	        }
	        $state.transition = null;
	        return $q.when($state.current);
	      }

	      // Filter parameters before we pass them to event handlers etc.
	      toParams = filterByKeys(to.params.$$keys(), toParams || {});
	      
	      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart
	      if (hash) toParams['#'] = hash;
	      
	      // Broadcast start event and cancel the transition if requested
	      if (options.notify) {
	        /**
	         * @ngdoc event
	         * @name ui.router.state.$state#$stateChangeStart
	         * @eventOf ui.router.state.$state
	         * @eventType broadcast on root scope
	         * @description
	         * Fired when the state transition **begins**. You can use `event.preventDefault()`
	         * to prevent the transition from happening and then the transition promise will be
	         * rejected with a `'transition prevented'` value.
	         *
	         * @param {Object} event Event object.
	         * @param {State} toState The state being transitioned to.
	         * @param {Object} toParams The params supplied to the `toState`.
	         * @param {State} fromState The current state, pre-transition.
	         * @param {Object} fromParams The params supplied to the `fromState`.
	         *
	         * @example
	         *
	         * <pre>
	         * $rootScope.$on('$stateChangeStart',
	         * function(event, toState, toParams, fromState, fromParams){
	         *     event.preventDefault();
	         *     // transitionTo() promise will be rejected with
	         *     // a 'transition prevented' error
	         * })
	         * </pre>
	         */
	        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
	          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
	          //Don't update and resync url if there's been a new transition started. see issue #2238, #600
	          if ($state.transition == null) $urlRouter.update();
	          return TransitionPrevented;
	        }
	      }

	      // Resolve locals for the remaining states, but don't update any global state just
	      // yet -- if anything fails to resolve the current state needs to remain untouched.
	      // We also set up an inheritance chain for the locals here. This allows the view directive
	      // to quickly look up the correct definition for each view in the current state. Even
	      // though we create the locals object itself outside resolveState(), it is initially
	      // empty and gets filled asynchronously. We need to keep track of the promise for the
	      // (fully resolved) current locals, and pass this down the chain.
	      var resolved = $q.when(locals);

	      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
	        locals = toLocals[l] = inherit(locals);
	        resolved = resolveState(state, toParams, state === to, resolved, locals, options);
	      }

	      // Once everything is resolved, we are ready to perform the actual transition
	      // and return a promise for the new state. We also keep track of what the
	      // current promise is, so that we can detect overlapping transitions and
	      // keep only the outcome of the last transition.
	      var transition = $state.transition = resolved.then(function () {
	        var l, entering, exiting;

	        if ($state.transition !== transition) return TransitionSuperseded;

	        // Exit 'from' states not kept
	        for (l = fromPath.length - 1; l >= keep; l--) {
	          exiting = fromPath[l];
	          if (exiting.self.onExit) {
	            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
	          }
	          exiting.locals = null;
	        }

	        // Enter 'to' states not kept
	        for (l = keep; l < toPath.length; l++) {
	          entering = toPath[l];
	          entering.locals = toLocals[l];
	          if (entering.self.onEnter) {
	            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
	          }
	        }

	        // Run it again, to catch any transitions in callbacks
	        if ($state.transition !== transition) return TransitionSuperseded;

	        // Update globals in $state
	        $state.$current = to;
	        $state.current = to.self;
	        $state.params = toParams;
	        copy($state.params, $stateParams);
	        $state.transition = null;

	        if (options.location && to.navigable) {
	          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
	            $$avoidResync: true, replace: options.location === 'replace'
	          });
	        }

	        if (options.notify) {
	        /**
	         * @ngdoc event
	         * @name ui.router.state.$state#$stateChangeSuccess
	         * @eventOf ui.router.state.$state
	         * @eventType broadcast on root scope
	         * @description
	         * Fired once the state transition is **complete**.
	         *
	         * @param {Object} event Event object.
	         * @param {State} toState The state being transitioned to.
	         * @param {Object} toParams The params supplied to the `toState`.
	         * @param {State} fromState The current state, pre-transition.
	         * @param {Object} fromParams The params supplied to the `fromState`.
	         */
	          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
	        }
	        $urlRouter.update(true);

	        return $state.current;
	      }, function (error) {
	        if ($state.transition !== transition) return TransitionSuperseded;

	        $state.transition = null;
	        /**
	         * @ngdoc event
	         * @name ui.router.state.$state#$stateChangeError
	         * @eventOf ui.router.state.$state
	         * @eventType broadcast on root scope
	         * @description
	         * Fired when an **error occurs** during transition. It's important to note that if you
	         * have any errors in your resolve functions (javascript errors, non-existent services, etc)
	         * they will not throw traditionally. You must listen for this $stateChangeError event to
	         * catch **ALL** errors.
	         *
	         * @param {Object} event Event object.
	         * @param {State} toState The state being transitioned to.
	         * @param {Object} toParams The params supplied to the `toState`.
	         * @param {State} fromState The current state, pre-transition.
	         * @param {Object} fromParams The params supplied to the `fromState`.
	         * @param {Error} error The resolve error object.
	         */
	        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

	        if (!evt.defaultPrevented) {
	            $urlRouter.update();
	        }

	        return $q.reject(error);
	      });

	      return transition;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$state#is
	     * @methodOf ui.router.state.$state
	     *
	     * @description
	     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
	     * but only checks for the full state name. If params is supplied then it will be
	     * tested for strict equality against the current active params object, so all params
	     * must match with none missing and no extras.
	     *
	     * @example
	     * <pre>
	     * $state.$current.name = 'contacts.details.item';
	     *
	     * // absolute name
	     * $state.is('contact.details.item'); // returns true
	     * $state.is(contactDetailItemStateObject); // returns true
	     *
	     * // relative name (. and ^), typically from a template
	     * // E.g. from the 'contacts.details' template
	     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
	     * </pre>
	     *
	     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
	     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
	     * to test against the current active state.
	     * @param {object=} options An options object.  The options are:
	     *
	     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
	     * test relative to `options.relative` state (or name).
	     *
	     * @returns {boolean} Returns true if it is the state.
	     */
	    $state.is = function is(stateOrName, params, options) {
	      options = extend({ relative: $state.$current }, options || {});
	      var state = findState(stateOrName, options.relative);

	      if (!isDefined(state)) { return undefined; }
	      if ($state.$current !== state) { return false; }
	      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$state#includes
	     * @methodOf ui.router.state.$state
	     *
	     * @description
	     * A method to determine if the current active state is equal to or is the child of the
	     * state stateName. If any params are passed then they will be tested for a match as well.
	     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
	     *
	     * @example
	     * Partial and relative names
	     * <pre>
	     * $state.$current.name = 'contacts.details.item';
	     *
	     * // Using partial names
	     * $state.includes("contacts"); // returns true
	     * $state.includes("contacts.details"); // returns true
	     * $state.includes("contacts.details.item"); // returns true
	     * $state.includes("contacts.list"); // returns false
	     * $state.includes("about"); // returns false
	     *
	     * // Using relative names (. and ^), typically from a template
	     * // E.g. from the 'contacts.details' template
	     * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
	     * </pre>
	     *
	     * Basic globbing patterns
	     * <pre>
	     * $state.$current.name = 'contacts.details.item.url';
	     *
	     * $state.includes("*.details.*.*"); // returns true
	     * $state.includes("*.details.**"); // returns true
	     * $state.includes("**.item.**"); // returns true
	     * $state.includes("*.details.item.url"); // returns true
	     * $state.includes("*.details.*.url"); // returns true
	     * $state.includes("*.details.*"); // returns false
	     * $state.includes("item.**"); // returns false
	     * </pre>
	     *
	     * @param {string} stateOrName A partial name, relative name, or glob pattern
	     * to be searched for within the current state name.
	     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
	     * that you'd like to test against the current active state.
	     * @param {object=} options An options object.  The options are:
	     *
	     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
	     * .includes will test relative to `options.relative` state (or name).
	     *
	     * @returns {boolean} Returns true if it does include the state
	     */
	    $state.includes = function includes(stateOrName, params, options) {
	      options = extend({ relative: $state.$current }, options || {});
	      if (isString(stateOrName) && isGlob(stateOrName)) {
	        if (!doesStateMatchGlob(stateOrName)) {
	          return false;
	        }
	        stateOrName = $state.$current.name;
	      }

	      var state = findState(stateOrName, options.relative);
	      if (!isDefined(state)) { return undefined; }
	      if (!isDefined($state.$current.includes[state.name])) { return false; }
	      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
	    };


	    /**
	     * @ngdoc function
	     * @name ui.router.state.$state#href
	     * @methodOf ui.router.state.$state
	     *
	     * @description
	     * A url generation method that returns the compiled url for the given state populated with the given params.
	     *
	     * @example
	     * <pre>
	     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
	     * </pre>
	     *
	     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
	     * @param {object=} params An object of parameter values to fill the state's required parameters.
	     * @param {object=} options Options object. The options are:
	     *
	     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
	     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
	     *    ancestor with a valid url).
	     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
	     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
	     *    defines which state to be relative from.
	     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
	     * 
	     * @returns {string} compiled state url
	     */
	    $state.href = function href(stateOrName, params, options) {
	      options = extend({
	        lossy:    true,
	        inherit:  true,
	        absolute: false,
	        relative: $state.$current
	      }, options || {});

	      var state = findState(stateOrName, options.relative);

	      if (!isDefined(state)) return null;
	      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
	      
	      var nav = (state && options.lossy) ? state.navigable : state;

	      if (!nav || nav.url === undefined || nav.url === null) {
	        return null;
	      }
	      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {
	        absolute: options.absolute
	      });
	    };

	    /**
	     * @ngdoc function
	     * @name ui.router.state.$state#get
	     * @methodOf ui.router.state.$state
	     *
	     * @description
	     * Returns the state configuration object for any specific state or all states.
	     *
	     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
	     * the requested state. If not provided, returns an array of ALL state configs.
	     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
	     * @returns {Object|Array} State configuration object or array of all objects.
	     */
	    $state.get = function (stateOrName, context) {
	      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });
	      var state = findState(stateOrName, context || $state.$current);
	      return (state && state.self) ? state.self : null;
	    };

	    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
	      // Make a restricted $stateParams with only the parameters that apply to this state if
	      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
	      // we also need $stateParams to be available for any $injector calls we make during the
	      // dependency resolution process.
	      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
	      var locals = { $stateParams: $stateParams };

	      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
	      // We're also including $stateParams in this; that way the parameters are restricted
	      // to the set that should be visible to the state, and are independent of when we update
	      // the global $state and $stateParams values.
	      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
	      var promises = [dst.resolve.then(function (globals) {
	        dst.globals = globals;
	      })];
	      if (inherited) promises.push(inherited);

	      function resolveViews() {
	        var viewsPromises = [];

	        // Resolve template and dependencies for all views.
	        forEach(state.views, function (view, name) {
	          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
	          injectables.$template = [ function () {
	            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';
	          }];

	          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
	            // References to the controller (only instantiated at link time)
	            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
	              var injectLocals = angular.extend({}, injectables, dst.globals);
	              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
	            } else {
	              result.$$controller = view.controller;
	            }
	            // Provide access to the state itself for internal use
	            result.$$state = state;
	            result.$$controllerAs = view.controllerAs;
	            dst[name] = result;
	          }));
	        });

	        return $q.all(viewsPromises).then(function(){
	          return dst.globals;
	        });
	      }

	      // Wait for all the promises and then return the activation object
	      return $q.all(promises).then(resolveViews).then(function (values) {
	        return dst;
	      });
	    }

	    return $state;
	  }

	  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
	    // Return true if there are no differences in non-search (path/object) params, false if there are differences
	    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
	      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.
	      function notSearchParam(key) {
	        return fromAndToState.params[key].location != "search";
	      }
	      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
	      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
	      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
	      return nonQueryParamSet.$$equals(fromParams, toParams);
	    }

	    // If reload was not explicitly requested
	    // and we're transitioning to the same state we're already in
	    // and    the locals didn't change
	    //     or they changed in a way that doesn't merit reloading
	    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)
	    // Then return true.
	    if (!options.reload && to === from &&
	      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
	      return true;
	    }
	  }
	}

	angular.module('ui.router.state')
	  .factory('$stateParams', function () { return {}; })
	  .provider('$state', $StateProvider);


	$ViewProvider.$inject = [];
	function $ViewProvider() {

	  this.$get = $get;
	  /**
	   * @ngdoc object
	   * @name ui.router.state.$view
	   *
	   * @requires ui.router.util.$templateFactory
	   * @requires $rootScope
	   *
	   * @description
	   *
	   */
	  $get.$inject = ['$rootScope', '$templateFactory'];
	  function $get(   $rootScope,   $templateFactory) {
	    return {
	      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
	      /**
	       * @ngdoc function
	       * @name ui.router.state.$view#load
	       * @methodOf ui.router.state.$view
	       *
	       * @description
	       *
	       * @param {string} name name
	       * @param {object} options option object.
	       */
	      load: function load(name, options) {
	        var result, defaults = {
	          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
	        };
	        options = extend(defaults, options);

	        if (options.view) {
	          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
	        }
	        return result;
	      }
	    };
	  }
	}

	angular.module('ui.router.state').provider('$view', $ViewProvider);

	/**
	 * @ngdoc object
	 * @name ui.router.state.$uiViewScrollProvider
	 *
	 * @description
	 * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
	 */
	function $ViewScrollProvider() {

	  var useAnchorScroll = false;

	  /**
	   * @ngdoc function
	   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
	   * @methodOf ui.router.state.$uiViewScrollProvider
	   *
	   * @description
	   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
	   * scrolling based on the url anchor.
	   */
	  this.useAnchorScroll = function () {
	    useAnchorScroll = true;
	  };

	  /**
	   * @ngdoc object
	   * @name ui.router.state.$uiViewScroll
	   *
	   * @requires $anchorScroll
	   * @requires $timeout
	   *
	   * @description
	   * When called with a jqLite element, it scrolls the element into view (after a
	   * `$timeout` so the DOM has time to refresh).
	   *
	   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
	   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
	   */
	  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
	    if (useAnchorScroll) {
	      return $anchorScroll;
	    }

	    return function ($element) {
	      return $timeout(function () {
	        $element[0].scrollIntoView();
	      }, 0, false);
	    };
	  }];
	}

	angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

	var ngMajorVer = angular.version.major;
	var ngMinorVer = angular.version.minor;
	/**
	 * @ngdoc directive
	 * @name ui.router.state.directive:ui-view
	 *
	 * @requires ui.router.state.$state
	 * @requires $compile
	 * @requires $controller
	 * @requires $injector
	 * @requires ui.router.state.$uiViewScroll
	 * @requires $document
	 *
	 * @restrict ECA
	 *
	 * @description
	 * The ui-view directive tells $state where to place your templates.
	 *
	 * @param {string=} name A view name. The name should be unique amongst the other views in the
	 * same state. You can have views of the same name that live in different states.
	 *
	 * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
	 * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
	 * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
	 * scroll ui-view elements into view when they are populated during a state activation.
	 *
	 * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations
	 * will be applied to the ui-view)
	 *
	 * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
	 * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
	 *
	 * @param {string=} onload Expression to evaluate whenever the view updates.
	 * 
	 * @example
	 * A view can be unnamed or named. 
	 * <pre>
	 * <!-- Unnamed -->
	 * <div ui-view></div> 
	 * 
	 * <!-- Named -->
	 * <div ui-view="viewName"></div>
	 * </pre>
	 *
	 * You can only have one unnamed view within any template (or root html). If you are only using a 
	 * single view and it is unnamed then you can populate it like so:
	 * <pre>
	 * <div ui-view></div> 
	 * $stateProvider.state("home", {
	 *   template: "<h1>HELLO!</h1>"
	 * })
	 * </pre>
	 * 
	 * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}
	 * config property, by name, in this case an empty name:
	 * <pre>
	 * $stateProvider.state("home", {
	 *   views: {
	 *     "": {
	 *       template: "<h1>HELLO!</h1>"
	 *     }
	 *   }    
	 * })
	 * </pre>
	 * 
	 * But typically you'll only use the views property if you name your view or have more than one view 
	 * in the same template. There's not really a compelling reason to name a view if its the only one, 
	 * but you could if you wanted, like so:
	 * <pre>
	 * <div ui-view="main"></div>
	 * </pre> 
	 * <pre>
	 * $stateProvider.state("home", {
	 *   views: {
	 *     "main": {
	 *       template: "<h1>HELLO!</h1>"
	 *     }
	 *   }    
	 * })
	 * </pre>
	 * 
	 * Really though, you'll use views to set up multiple views:
	 * <pre>
	 * <div ui-view></div>
	 * <div ui-view="chart"></div> 
	 * <div ui-view="data"></div> 
	 * </pre>
	 * 
	 * <pre>
	 * $stateProvider.state("home", {
	 *   views: {
	 *     "": {
	 *       template: "<h1>HELLO!</h1>"
	 *     },
	 *     "chart": {
	 *       template: "<chart_thing/>"
	 *     },
	 *     "data": {
	 *       template: "<data_thing/>"
	 *     }
	 *   }    
	 * })
	 * </pre>
	 *
	 * Examples for `autoscroll`:
	 *
	 * <pre>
	 * <!-- If autoscroll present with no expression,
	 *      then scroll ui-view into view -->
	 * <ui-view autoscroll/>
	 *
	 * <!-- If autoscroll present with valid expression,
	 *      then scroll ui-view into view if expression evaluates to true -->
	 * <ui-view autoscroll='true'/>
	 * <ui-view autoscroll='false'/>
	 * <ui-view autoscroll='scopeVariable'/>
	 * </pre>
	 */
	$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
	function $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {

	  function getService() {
	    return ($injector.has) ? function(service) {
	      return $injector.has(service) ? $injector.get(service) : null;
	    } : function(service) {
	      try {
	        return $injector.get(service);
	      } catch (e) {
	        return null;
	      }
	    };
	  }

	  var service = getService(),
	      $animator = service('$animator'),
	      $animate = service('$animate');

	  // Returns a set of DOM manipulation functions based on which Angular version
	  // it should use
	  function getRenderer(attrs, scope) {
	    var statics = {
	      enter: function (element, target, cb) { target.after(element); cb(); },
	      leave: function (element, cb) { element.remove(); cb(); }
	    };

	    if (!!attrs.noanimation) return statics;

	    function animEnabled(element) {
	      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);
	      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();
	      return (!!$animator);
	    }

	    // ng 1.2+
	    if ($animate) {
	      return {
	        enter: function(element, target, cb) {
	          if (!animEnabled(element)) {
	            statics.enter(element, target, cb);
	          } else if (angular.version.minor > 2) {
	            $animate.enter(element, null, target).then(cb);
	          } else {
	            $animate.enter(element, null, target, cb);
	          }
	        },
	        leave: function(element, cb) {
	          if (!animEnabled(element)) {
	            statics.leave(element, cb);
	          } else if (angular.version.minor > 2) {
	            $animate.leave(element).then(cb);
	          } else {
	            $animate.leave(element, cb);
	          }
	        }
	      };
	    }

	    // ng 1.1.5
	    if ($animator) {
	      var animate = $animator && $animator(scope, attrs);

	      return {
	        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },
	        leave: function(element, cb) { animate.leave(element); cb(); }
	      };
	    }

	    return statics;
	  }

	  var directive = {
	    restrict: 'ECA',
	    terminal: true,
	    priority: 400,
	    transclude: 'element',
	    compile: function (tElement, tAttrs, $transclude) {
	      return function (scope, $element, attrs) {
	        var previousEl, currentEl, currentScope, latestLocals,
	            onloadExp     = attrs.onload || '',
	            autoScrollExp = attrs.autoscroll,
	            renderer      = getRenderer(attrs, scope);

	        scope.$on('$stateChangeSuccess', function() {
	          updateView(false);
	        });

	        updateView(true);

	        function cleanupLastView() {
	          var _previousEl = previousEl;
	          var _currentScope = currentScope;

	          if (_currentScope) {
	            _currentScope._willBeDestroyed = true;
	          }

	          function cleanOld() {
	            if (_previousEl) {
	              _previousEl.remove();
	            }

	            if (_currentScope) {
	              _currentScope.$destroy();
	            }
	          }

	          if (currentEl) {
	            renderer.leave(currentEl, function() {
	              cleanOld();
	              previousEl = null;
	            });

	            previousEl = currentEl;
	          } else {
	            cleanOld();
	            previousEl = null;
	          }

	          currentEl = null;
	          currentScope = null;
	        }

	        function updateView(firstTime) {
	          var newScope,
	              name            = getUiViewName(scope, attrs, $element, $interpolate),
	              previousLocals  = name && $state.$current && $state.$current.locals[name];

	          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do
	          newScope = scope.$new();
	          latestLocals = $state.$current.locals[name];

	          /**
	           * @ngdoc event
	           * @name ui.router.state.directive:ui-view#$viewContentLoading
	           * @eventOf ui.router.state.directive:ui-view
	           * @eventType emits on ui-view directive scope
	           * @description
	           *
	           * Fired once the view **begins loading**, *before* the DOM is rendered.
	           *
	           * @param {Object} event Event object.
	           * @param {string} viewName Name of the view.
	           */
	          newScope.$emit('$viewContentLoading', name);

	          var clone = $transclude(newScope, function(clone) {
	            renderer.enter(clone, $element, function onUiViewEnter() {
	              if(currentScope) {
	                currentScope.$emit('$viewContentAnimationEnded');
	              }

	              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
	                $uiViewScroll(clone);
	              }
	            });
	            cleanupLastView();
	          });

	          currentEl = clone;
	          currentScope = newScope;
	          /**
	           * @ngdoc event
	           * @name ui.router.state.directive:ui-view#$viewContentLoaded
	           * @eventOf ui.router.state.directive:ui-view
	           * @eventType emits on ui-view directive scope
	           * @description
	           * Fired once the view is **loaded**, *after* the DOM is rendered.
	           *
	           * @param {Object} event Event object.
	           * @param {string} viewName Name of the view.
	           */
	          currentScope.$emit('$viewContentLoaded', name);
	          currentScope.$eval(onloadExp);
	        }
	      };
	    }
	  };

	  return directive;
	}

	$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
	function $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {
	  return {
	    restrict: 'ECA',
	    priority: -400,
	    compile: function (tElement) {
	      var initial = tElement.html();
	      return function (scope, $element, attrs) {
	        var current = $state.$current,
	            name = getUiViewName(scope, attrs, $element, $interpolate),
	            locals  = current && current.locals[name];

	        if (! locals) {
	          return;
	        }

	        $element.data('$uiView', { name: name, state: locals.$$state });
	        $element.html(locals.$template ? locals.$template : initial);

	        var link = $compile($element.contents());

	        if (locals.$$controller) {
	          locals.$scope = scope;
	          locals.$element = $element;
	          var controller = $controller(locals.$$controller, locals);
	          if (locals.$$controllerAs) {
	            scope[locals.$$controllerAs] = controller;
	          }
	          $element.data('$ngControllerController', controller);
	          $element.children().data('$ngControllerController', controller);
	        }

	        link(scope);
	      };
	    }
	  };
	}

	/**
	 * Shared ui-view code for both directives:
	 * Given scope, element, and its attributes, return the view's name
	 */
	function getUiViewName(scope, attrs, element, $interpolate) {
	  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
	  var inherited = element.inheritedData('$uiView');
	  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));
	}

	angular.module('ui.router.state').directive('uiView', $ViewDirective);
	angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

	function parseStateRef(ref, current) {
	  var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
	  if (preparsed) ref = current + '(' + preparsed[1] + ')';
	  parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
	  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
	  return { state: parsed[1], paramExpr: parsed[3] || null };
	}

	function stateContext(el) {
	  var stateData = el.parent().inheritedData('$uiView');

	  if (stateData && stateData.state && stateData.state.name) {
	    return stateData.state;
	  }
	}

	function getTypeInfo(el) {
	  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
	  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
	  var isForm = el[0].nodeName === "FORM";

	  return {
	    attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
	    isAnchor: el.prop("tagName").toUpperCase() === "A",
	    clickable: !isForm
	  };
	}

	function clickHook(el, $state, $timeout, type, current) {
	  return function(e) {
	    var button = e.which || e.button, target = current();

	    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
	      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
	      var transition = $timeout(function() {
	        $state.go(target.state, target.params, target.options);
	      });
	      e.preventDefault();

	      // if the state has no URL, ignore one preventDefault from the <a> directive.
	      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;

	      e.preventDefault = function() {
	        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
	      };
	    }
	  };
	}

	function defaultOpts(el, $state) {
	  return { relative: stateContext(el) || $state.$current, inherit: true };
	}

	/**
	 * @ngdoc directive
	 * @name ui.router.state.directive:ui-sref
	 *
	 * @requires ui.router.state.$state
	 * @requires $timeout
	 *
	 * @restrict A
	 *
	 * @description
	 * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
	 * URL, the directive will automatically generate & update the `href` attribute via
	 * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
	 * the link will trigger a state transition with optional parameters.
	 *
	 * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
	 * handled natively by the browser.
	 *
	 * You can also use relative state paths within ui-sref, just like the relative
	 * paths passed to `$state.go()`. You just need to be aware that the path is relative
	 * to the state that the link lives in, in other words the state that loaded the
	 * template containing the link.
	 *
	 * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}
	 * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
	 * and `reload`.
	 *
	 * @example
	 * Here's an example of how you'd use ui-sref and how it would compile. If you have the
	 * following template:
	 * <pre>
	 * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
	 *
	 * <ul>
	 *     <li ng-repeat="contact in contacts">
	 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
	 *     </li>
	 * </ul>
	 * </pre>
	 *
	 * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
	 * <pre>
	 * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
	 *
	 * <ul>
	 *     <li ng-repeat="contact in contacts">
	 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
	 *     </li>
	 *     <li ng-repeat="contact in contacts">
	 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
	 *     </li>
	 *     <li ng-repeat="contact in contacts">
	 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
	 *     </li>
	 * </ul>
	 *
	 * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
	 * </pre>
	 *
	 * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
	 * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}
	 */
	$StateRefDirective.$inject = ['$state', '$timeout'];
	function $StateRefDirective($state, $timeout) {
	  return {
	    restrict: 'A',
	    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
	    link: function(scope, element, attrs, uiSrefActive) {
	      var ref    = parseStateRef(attrs.uiSref, $state.current.name);
	      var def    = { state: ref.state, href: null, params: null };
	      var type   = getTypeInfo(element);
	      var active = uiSrefActive[1] || uiSrefActive[0];

	      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});

	      var update = function(val) {
	        if (val) def.params = angular.copy(val);
	        def.href = $state.href(ref.state, def.params, def.options);

	        if (active) active.$$addStateInfo(ref.state, def.params);
	        if (def.href !== null) attrs.$set(type.attr, def.href);
	      };

	      if (ref.paramExpr) {
	        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);
	        def.params = angular.copy(scope.$eval(ref.paramExpr));
	      }
	      update();

	      if (!type.clickable) return;
	      element.bind("click", clickHook(element, $state, $timeout, type, function() { return def; }));
	    }
	  };
	}

	/**
	 * @ngdoc directive
	 * @name ui.router.state.directive:ui-state
	 *
	 * @requires ui.router.state.uiSref
	 *
	 * @restrict A
	 *
	 * @description
	 * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,
	 * params and override options.
	 *
	 * @param {string} ui-state 'stateName' can be any valid absolute or relative state
	 * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}
	 * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}
	 */
	$StateRefDynamicDirective.$inject = ['$state', '$timeout'];
	function $StateRefDynamicDirective($state, $timeout) {
	  return {
	    restrict: 'A',
	    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
	    link: function(scope, element, attrs, uiSrefActive) {
	      var type   = getTypeInfo(element);
	      var active = uiSrefActive[1] || uiSrefActive[0];
	      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
	      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';
	      var def    = { state: null, params: null, options: null, href: null };

	      function runStateRefLink (group) {
	        def.state = group[0]; def.params = group[1]; def.options = group[2];
	        def.href = $state.href(def.state, def.params, def.options);

	        if (active) active.$$addStateInfo(def.state, def.params);
	        if (def.href) attrs.$set(type.attr, def.href);
	      }

	      scope.$watch(watch, runStateRefLink, true);
	      runStateRefLink(scope.$eval(watch));

	      if (!type.clickable) return;
	      element.bind("click", clickHook(element, $state, $timeout, type, function() { return def; }));
	    }
	  };
	}


	/**
	 * @ngdoc directive
	 * @name ui.router.state.directive:ui-sref-active
	 *
	 * @requires ui.router.state.$state
	 * @requires ui.router.state.$stateParams
	 * @requires $interpolate
	 *
	 * @restrict A
	 *
	 * @description
	 * A directive working alongside ui-sref to add classes to an element when the
	 * related ui-sref directive's state is active, and removing them when it is inactive.
	 * The primary use-case is to simplify the special appearance of navigation menus
	 * relying on `ui-sref`, by having the "active" state's menu button appear different,
	 * distinguishing it from the inactive menu items.
	 *
	 * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
	 * ui-sref-active found at the same level or above the ui-sref will be used.
	 *
	 * Will activate when the ui-sref's target state or any child state is active. If you
	 * need to activate only when the ui-sref target state is active and *not* any of
	 * it's children, then you will use
	 * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}
	 *
	 * @example
	 * Given the following template:
	 * <pre>
	 * <ul>
	 *   <li ui-sref-active="active" class="item">
	 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
	 *   </li>
	 * </ul>
	 * </pre>
	 *
	 *
	 * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
	 * the resulting HTML will appear as (note the 'active' class):
	 * <pre>
	 * <ul>
	 *   <li ui-sref-active="active" class="item active">
	 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
	 *   </li>
	 * </ul>
	 * </pre>
	 *
	 * The class name is interpolated **once** during the directives link time (any further changes to the
	 * interpolated value are ignored).
	 *
	 * Multiple classes may be specified in a space-separated format:
	 * <pre>
	 * <ul>
	 *   <li ui-sref-active='class1 class2 class3'>
	 *     <a ui-sref="app.user">link</a>
	 *   </li>
	 * </ul>
	 * </pre>
	 *
	 * It is also possible to pass ui-sref-active an expression that evaluates
	 * to an object hash, whose keys represent active class names and whose
	 * values represent the respective state names/globs.
	 * ui-sref-active will match if the current active state **includes** any of
	 * the specified state names/globs, even the abstract ones.
	 *
	 * @Example
	 * Given the following template, with "admin" being an abstract state:
	 * <pre>
	 * <div ui-sref-active="{'active': 'admin.*'}">
	 *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
	 * </div>
	 * </pre>
	 *
	 * When the current state is "admin.roles" the "active" class will be applied
	 * to both the <div> and <a> elements. It is important to note that the state
	 * names/globs passed to ui-sref-active shadow the state provided by ui-sref.
	 */

	/**
	 * @ngdoc directive
	 * @name ui.router.state.directive:ui-sref-active-eq
	 *
	 * @requires ui.router.state.$state
	 * @requires ui.router.state.$stateParams
	 * @requires $interpolate
	 *
	 * @restrict A
	 *
	 * @description
	 * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate
	 * when the exact target state used in the `ui-sref` is active; no child states.
	 *
	 */
	$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
	function $StateRefActiveDirective($state, $stateParams, $interpolate) {
	  return  {
	    restrict: "A",
	    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {
	      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;

	      // There probably isn't much point in $observing this
	      // uiSrefActive and uiSrefActiveEq share the same directive object with some
	      // slight difference in logic routing
	      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);

	      try {
	        uiSrefActive = $scope.$eval($attrs.uiSrefActive);
	      } catch (e) {
	        // Do nothing. uiSrefActive is not a valid expression.
	        // Fall back to using $interpolate below
	      }
	      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
	      if (isObject(uiSrefActive)) {
	        forEach(uiSrefActive, function(stateOrName, activeClass) {
	          if (isString(stateOrName)) {
	            var ref = parseStateRef(stateOrName, $state.current.name);
	            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
	          }
	        });
	      }

	      // Allow uiSref to communicate with uiSrefActive[Equals]
	      this.$$addStateInfo = function (newState, newParams) {
	        // we already got an explicit state provided by ui-sref-active, so we
	        // shadow the one that comes from ui-sref
	        if (isObject(uiSrefActive) && states.length > 0) {
	          return;
	        }
	        addState(newState, newParams, uiSrefActive);
	        update();
	      };

	      $scope.$on('$stateChangeSuccess', update);

	      function addState(stateName, stateParams, activeClass) {
	        var state = $state.get(stateName, stateContext($element));
	        var stateHash = createStateHash(stateName, stateParams);

	        states.push({
	          state: state || { name: stateName },
	          params: stateParams,
	          hash: stateHash
	        });

	        activeClasses[stateHash] = activeClass;
	      }

	      /**
	       * @param {string} state
	       * @param {Object|string} [params]
	       * @return {string}
	       */
	      function createStateHash(state, params) {
	        if (!isString(state)) {
	          throw new Error('state should be a string');
	        }
	        if (isObject(params)) {
	          return state + toJson(params);
	        }
	        params = $scope.$eval(params);
	        if (isObject(params)) {
	          return state + toJson(params);
	        }
	        return state;
	      }

	      // Update route state
	      function update() {
	        for (var i = 0; i < states.length; i++) {
	          if (anyMatch(states[i].state, states[i].params)) {
	            addClass($element, activeClasses[states[i].hash]);
	          } else {
	            removeClass($element, activeClasses[states[i].hash]);
	          }

	          if (exactMatch(states[i].state, states[i].params)) {
	            addClass($element, activeEqClass);
	          } else {
	            removeClass($element, activeEqClass);
	          }
	        }
	      }

	      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }
	      function removeClass(el, className) { el.removeClass(className); }
	      function anyMatch(state, params) { return $state.includes(state.name, params); }
	      function exactMatch(state, params) { return $state.is(state.name, params); }

	      update();
	    }]
	  };
	}

	angular.module('ui.router.state')
	  .directive('uiSref', $StateRefDirective)
	  .directive('uiSrefActive', $StateRefActiveDirective)
	  .directive('uiSrefActiveEq', $StateRefActiveDirective)
	  .directive('uiState', $StateRefDynamicDirective);

	/**
	 * @ngdoc filter
	 * @name ui.router.state.filter:isState
	 *
	 * @requires ui.router.state.$state
	 *
	 * @description
	 * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
	 */
	$IsStateFilter.$inject = ['$state'];
	function $IsStateFilter($state) {
	  var isFilter = function (state, params) {
	    return $state.is(state, params);
	  };
	  isFilter.$stateful = true;
	  return isFilter;
	}

	/**
	 * @ngdoc filter
	 * @name ui.router.state.filter:includedByState
	 *
	 * @requires ui.router.state.$state
	 *
	 * @description
	 * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
	 */
	$IncludedByStateFilter.$inject = ['$state'];
	function $IncludedByStateFilter($state) {
	  var includesFilter = function (state, params, options) {
	    return $state.includes(state, params, options);
	  };
	  includesFilter.$stateful = true;
	  return  includesFilter;
	}

	angular.module('ui.router.state')
	  .filter('isState', $IsStateFilter)
	  .filter('includedByState', $IncludedByStateFilter);
	})(window, window.angular);

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ViewListView = __webpack_require__(6);

	var _ViewListView2 = _interopRequireDefault(_ViewListView);

	var Collection = (function (_ListView) {
	    _inherits(Collection, _ListView);

	    function Collection() {
	        _classCallCheck(this, Collection);

	        _get(Object.getPrototypeOf(Collection.prototype), 'constructor', this).apply(this, arguments);
	    }

	    _createClass(Collection, [{
	        key: 'setEntity',
	        value: function setEntity(entity) {
	            this.entity = entity;
	            if (!this._name) {
	                this._name = entity.name();
	            }
	            return this;
	        }
	    }]);

	    return Collection;
	})(_ViewListView2['default']);

	exports['default'] = Collection;
	module.exports = exports['default'];
	//# sourceMappingURL=Collection.js.map

/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Dashboard = (function () {
	    function Dashboard() {
	        _classCallCheck(this, Dashboard);

	        this._collections = {};
	        this._template = null;
	    }

	    _createClass(Dashboard, [{
	        key: "addCollection",
	        value: function addCollection(collection) {
	            this._collections[collection.name()] = collection;
	            return this;
	        }
	    }, {
	        key: "collections",
	        value: function collections(_collections) {
	            if (arguments.length) {
	                this._collections = _collections;
	                return this;
	            }
	            return this._collections;
	        }
	    }, {
	        key: "hasCollections",
	        value: function hasCollections() {
	            return Object.keys(this._collections).length > 0;
	        }
	    }, {
	        key: "template",
	        value: function template(_template) {
	            if (arguments.length) {
	                this._template = _template;
	                return this;
	            }
	            return this._template;
	        }
	    }]);

	    return Dashboard;
	})();

	exports["default"] = Dashboard;
	module.exports = exports["default"];
	//# sourceMappingURL=Dashboard.js.map

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var DataStore = (function () {
	    function DataStore() {
	        _classCallCheck(this, DataStore);

	        this._entries = {};
	    }

	    _createClass(DataStore, [{
	        key: 'setEntries',
	        value: function setEntries(name, entries) {
	            this._entries[name] = entries;

	            return this;
	        }
	    }, {
	        key: 'addEntry',
	        value: function addEntry(name, entry) {
	            if (!(name in this._entries)) {
	                this._entries[name] = [];
	            }

	            this._entries[name].push(entry);
	        }
	    }, {
	        key: 'getEntries',
	        value: function getEntries(name) {
	            return this._entries[name] || [];
	        }

	        /**
	         * Get first entry satisfying a filter function
	         *
	         * @example datastore.getEntry('books', book => book.title === 'War and Peace');
	         */
	    }, {
	        key: 'getFirstEntry',
	        value: function getFirstEntry(name) {
	            var filter = arguments.length <= 1 || arguments[1] === undefined ? function () {
	                return true;
	            } : arguments[1];

	            return this.getEntries(name).filter(filter).shift();
	        }
	    }, {
	        key: 'getChoices',
	        value: function getChoices(field) {
	            var identifier = field.targetEntity().identifier().name();
	            var name = field.targetField().name();

	            return this.getEntries(field.targetEntity().uniqueId + '_choices').map(function (entry) {
	                return {
	                    value: entry.values[identifier],
	                    label: entry.values[name]
	                };
	            });
	        }
	    }, {
	        key: 'fillReferencesValuesFromCollection',
	        value: function fillReferencesValuesFromCollection(collection, referencedValues, fillSimpleReference) {
	            fillSimpleReference = typeof fillSimpleReference === 'undefined' ? false : fillSimpleReference;

	            for (var i = 0, l = collection.length; i < l; i++) {
	                collection[i] = this.fillReferencesValuesFromEntry(collection[i], referencedValues, fillSimpleReference);
	            }

	            return collection;
	        }
	    }, {
	        key: 'fillReferencesValuesFromEntry',
	        value: function fillReferencesValuesFromEntry(entry, referencedValues, fillSimpleReference) {
	            for (var referenceField in referencedValues) {
	                var reference = referencedValues[referenceField],
	                    choices = this.getReferenceChoicesById(reference),
	                    entries = [],
	                    identifier = reference.getMappedValue(entry.values[referenceField], entry.values);

	                if (reference.type() === 'reference_many') {
	                    for (var i in identifier) {
	                        var id = identifier[i];
	                        entries.push(choices[id]);
	                    }

	                    entry.listValues[referenceField] = entries;
	                } else if (fillSimpleReference && identifier != null && identifier in choices) {
	                    entry.listValues[referenceField] = reference.getMappedValue(choices[identifier], entry.values);
	                }
	            }

	            return entry;
	        }
	    }, {
	        key: 'getReferenceChoicesById',
	        value: function getReferenceChoicesById(field) {
	            var result = {},
	                targetField = field.targetField().name(),
	                targetIdentifier = field.targetEntity().identifier().name(),
	                entries = this.getEntries(field.targetEntity().uniqueId + '_values');

	            for (var i = 0, l = entries.length; i < l; i++) {
	                var entry = entries[i];
	                result[entry.values[targetIdentifier]] = entry.values[targetField];
	            }

	            return result;
	        }
	    }]);

	    return DataStore;
	})();

	exports['default'] = DataStore;
	module.exports = exports['default'];
	//# sourceMappingURL=DataStore.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var DateField = (function (_Field) {
	    _inherits(DateField, _Field);

	    function DateField(name) {
	        _classCallCheck(this, DateField);

	        _get(Object.getPrototypeOf(DateField.prototype), "constructor", this).call(this, name);

	        this._format = null;
	        this._parse = function (date) {
	            if (date instanceof Date) {
	                // the datepicker returns a JS Date object, with hours, minutes and timezone
	                // in order to convert it back to date, we must remove the timezone, then
	                // remove hours and minutes
	                date.setMinutes(date.getMinutes() - date.getTimezoneOffset());

	                var dateString = date.toJSON();
	                return dateString ? dateString.substr(0, 10) : null;
	            }
	            return date;
	        };
	        this._type = "date";
	    }

	    _createClass(DateField, [{
	        key: "format",
	        value: function format(value) {
	            if (!arguments.length) return this._format;
	            this._format = value;
	            return this;
	        }
	    }, {
	        key: "parse",
	        value: function parse(value) {
	            if (!arguments.length) return this._parse;
	            this._parse = value;
	            return this;
	        }
	    }]);

	    return DateField;
	})(_Field3["default"]);

	exports["default"] = DateField;
	module.exports = exports["default"];
	//# sourceMappingURL=DateField.js.map

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var NumberField = (function (_Field) {
	    _inherits(NumberField, _Field);

	    function NumberField(name) {
	        _classCallCheck(this, NumberField);

	        _get(Object.getPrototypeOf(NumberField.prototype), "constructor", this).call(this, name);
	        this._type = "number";
	        this._format = undefined;
	    }

	    /**
	     * Specify format pattern for number to string conversion. 
	     *
	     * Based on NumeralJs, which uses a syntax similar to Excel.
	     *
	     * {@link} http://numeraljs.com/
	     * {@link} https://github.com/baumandm/angular-numeraljs
	     * {@example}
	     *
	     *     nga.field('height', 'number').format('$0,0.00');
	     */

	    _createClass(NumberField, [{
	        key: "format",
	        value: function format(value) {
	            if (!arguments.length) return this._format;
	            this._format = value;
	            return this;
	        }
	    }, {
	        key: "fractionSize",
	        value: function fractionSize(decimals) {
	            console.warn('NumberField.fractionSize() is deprecated, use NumberField.format() instead');
	            this.format('0.' + '0'.repeat(decimals));
	            return this;
	        }
	    }]);

	    return NumberField;
	})(_Field3["default"]);

	exports["default"] = NumberField;
	module.exports = exports["default"];
	//# sourceMappingURL=NumberField.js.map

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _EntityEntity = __webpack_require__(7);

	var _EntityEntity2 = _interopRequireDefault(_EntityEntity);

	function alwaysFalse() {
	    return false;
	}

	var uuid = 0;
	var _autoClose = true;

	var Menu = (function () {
	    function Menu() {
	        _classCallCheck(this, Menu);

	        this._link = null;
	        this._activeFunc = alwaysFalse;
	        this._title = null;
	        this._icon = false;
	        this._children = [];
	        this._template = false;
	        this._autoClose = true;
	        this.uuid = uuid++;
	    }

	    _createClass(Menu, [{
	        key: 'title',
	        value: function title() {
	            if (arguments.length) {
	                this._title = arguments[0];
	                return this;
	            }
	            return this._title;
	        }
	    }, {
	        key: 'isLink',
	        value: function isLink() {
	            return !!this._link;
	        }
	    }, {
	        key: 'link',
	        value: function link() {
	            var _this = this;

	            if (arguments.length) {
	                this._link = arguments[0];
	                if (this._activeFunc == alwaysFalse) {
	                    this._activeFunc = function (url) {
	                        return url.indexOf(_this._link) === 0;
	                    };
	                }
	                return this;
	            }
	            return this._link;
	        }
	    }, {
	        key: 'autoClose',
	        value: function autoClose() {
	            if (arguments.length) {
	                _autoClose = arguments[0];
	                return this;
	            }
	            return _autoClose;
	        }
	    }, {
	        key: 'active',
	        value: function active(activeFunc) {
	            if (arguments.length) {
	                this._activeFunc = arguments[0];
	                return this;
	            }
	            return this._activeFunc;
	        }
	    }, {
	        key: 'isActive',
	        value: function isActive(url) {
	            return this._activeFunc(url);
	        }
	    }, {
	        key: 'isChildActive',
	        value: function isChildActive(url) {
	            return this.isActive(url) || this.children().filter(function (menu) {
	                return menu.isChildActive(url);
	            }).length > 0;
	        }
	    }, {
	        key: 'addChild',
	        value: function addChild(child) {
	            if (!(child instanceof Menu)) {
	                throw new Error('Only Menu instances are accepted as children of a Menu');
	            }
	            this._children.push(child);
	            return this;
	        }
	    }, {
	        key: 'hasChild',
	        value: function hasChild() {
	            return this._children.length > 0;
	        }
	    }, {
	        key: 'getChildByTitle',
	        value: function getChildByTitle(title) {
	            return this.children().filter(function (child) {
	                return child.title() == title;
	            }).pop();
	        }
	    }, {
	        key: 'children',
	        value: function children() {
	            if (arguments.length) {
	                this._children = arguments[0];
	                return this;
	            }
	            return this._children;
	        }
	    }, {
	        key: 'icon',
	        value: function icon() {
	            if (arguments.length) {
	                this._icon = arguments[0];
	                return this;
	            }
	            return this._icon;
	        }
	    }, {
	        key: 'template',
	        value: function template() {
	            if (arguments.length) {
	                this._template = arguments[0];
	                return this;
	            }
	            return this._template;
	        }
	    }, {
	        key: 'populateFromEntity',
	        value: function populateFromEntity(entity) {
	            if (!(entity instanceof _EntityEntity2['default'])) {
	                throw new Error('populateFromEntity() only accepts an Entity parameter');
	            }
	            this.title(entity.label());
	            this.active(function (path) {
	                return path.indexOf('/' + entity.name() + '/') === 0;
	            });
	            this.link('/' + entity.name() + '/list');
	            // deprecated
	            this.icon(entity.menuView().icon());
	            return this;
	        }
	    }]);

	    return Menu;
	})();

	exports['default'] = Menu;
	module.exports = exports['default'];
	//# sourceMappingURL=Menu.js.map

/***/ },
/* 20 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Queries = function Queries(RestWrapper, PromisesResolver, Application) {
	    _classCallCheck(this, Queries);

	    this._restWrapper = RestWrapper;
	    this._promisesResolver = PromisesResolver;
	    this._application = Application;
	};

	exports["default"] = Queries;
	module.exports = exports["default"];
	//# sourceMappingURL=Queries.js.map

/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	exports.clone = clone;
	exports.cloneAndFlatten = cloneAndFlatten;
	exports.cloneAndNest = cloneAndNest;
	function isObject(value) {
	    if (value === null) return false;
	    if (typeof value !== 'object') return false;
	    if (Array.isArray(value)) return false;
	    if (Object.prototype.toString.call(value) === '[object Date]') return false;
	    return true;
	}

	function clone(object) {
	    return Object.keys(object).reduce(function (values, name) {
	        if (object.hasOwnProperty(name)) {
	            values[name] = object[name];
	        }
	        return values;
	    }, {});
	}

	/*
	 * Flatten nested object into a single level object with 'foo.bar' property names
	 *
	 * The parameter object is left unchanged. All values in the returned object are scalar.
	 *
	 *     cloneAndFlatten({ a: 1, b: { c: 2 }, d: { e: 3, f: { g: 4, h: 5 } }, i: { j: 6 } }, ['i'])
	 *     // { a: 1, 'b.c': 2, 'd.e': 3, 'd.f.g': 4, 'd.f.h': 5, i: { j: 6 } } }
	 *
	 * @param {Object} object
	 * @param {String[]} excludedProperties
	 * @return {Object}
	 */

	function cloneAndFlatten(object) {
	    var excludedProperties = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

	    if (typeof object !== 'object') {
	        throw new Error('Expecting an object parameter');
	    }
	    return Object.keys(object).reduce(function (values, name) {
	        if (!object.hasOwnProperty(name)) return values;
	        if (isObject(object[name])) {
	            if (excludedProperties.indexOf(name) === -1) {
	                (function () {
	                    var flatObject = cloneAndFlatten(object[name]);
	                    Object.keys(flatObject).forEach(function (flatObjectKey) {
	                        if (!flatObject.hasOwnProperty(flatObjectKey)) return;
	                        values[name + '.' + flatObjectKey] = flatObject[flatObjectKey];
	                    });
	                })();
	            } else {
	                values[name] = clone(object[name]);
	            }
	        } else {
	            values[name] = object[name];
	        }
	        return values;
	    }, {});
	}

	;

	/*
	 * Clone flattened object into a nested object
	 *
	 * The parameter object is left unchanged.
	 *
	 *     cloneAndNest({ a: 1, 'b.c': 2, 'd.e': 3, 'd.f.g': 4, 'd.f.h': 5 } )
	 *     // { a: 1, b: { c: 2 }, d: { e: 3, f: { g: 4, h: 5 } } }
	 *
	 * @param {Object} object
	 * @return {Object}
	 */

	function cloneAndNest(object) {
	    if (typeof object !== 'object') {
	        throw new Error('Expecting an object parameter');
	    }
	    return Object.keys(object).reduce(function (values, name) {
	        if (!object.hasOwnProperty(name)) return values;
	        name.split('.').reduce(function (previous, current, index, list) {
	            if (previous != null) {
	                if (typeof previous[current] === 'undefined') previous[current] = {};
	                if (index < list.length - 1) {
	                    return previous[current];
	                };
	                previous[current] = object[name];
	            }
	        }, values);
	        return values;
	    }, {});
	}
	//# sourceMappingURL=objectProperties.js.map

/***/ },
/* 22 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports["default"] = {
	    order: function order(input) {
	        var results = [],
	            objectKey;

	        for (objectKey in input) {
	            results.push(input[objectKey]);
	        }

	        return results.sort(function (e1, e2) {
	            return e1.order() - e2.order();
	        });
	    }
	};
	module.exports = exports["default"];
	//# sourceMappingURL=orderElement.js.map

/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	exports['default'] = {
	    /**
	     * @see http://stackoverflow.com/questions/10425287/convert-string-to-camelcase-with-regular-expression
	     * @see http://phpjs.org/functions/ucfirst/
	     */
	    camelCase: function camelCase(text) {
	        if (!text) {
	            return text;
	        }

	        var f = text.charAt(0).toUpperCase();
	        text = f + text.substr(1);

	        return text.replace(/[-_.\s](.)/g, function (match, group1) {
	            return ' ' + group1.toUpperCase();
	        });
	    }
	};
	module.exports = exports['default'];
	//# sourceMappingURL=stringUtils.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * numeral.js
	 * version : 1.5.3
	 * author : Adam Draper
	 * license : MIT
	 * http://adamwdraper.github.com/Numeral-js/
	 */

	(function () {

	    /************************************
	        Constants
	    ************************************/

	    var numeral,
	        VERSION = '1.5.3',
	        // internal storage for language config files
	        languages = {},
	        currentLanguage = 'en',
	        zeroFormat = null,
	        defaultFormat = '0,0',
	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module.exports);


	    /************************************
	        Constructors
	    ************************************/


	    // Numeral prototype object
	    function Numeral (number) {
	        this._value = number;
	    }

	    /**
	     * Implementation of toFixed() that treats floats more like decimals
	     *
	     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
	     * problems for accounting- and finance-related software.
	     */
	    function toFixed (value, precision, roundingFunction, optionals) {
	        var power = Math.pow(10, precision),
	            optionalsRegExp,
	            output;
	            
	        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
	        // Multiply up by precision, round accurately, then divide and use native toFixed():
	        output = (roundingFunction(value * power) / power).toFixed(precision);

	        if (optionals) {
	            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
	            output = output.replace(optionalsRegExp, '');
	        }

	        return output;
	    }

	    /************************************
	        Formatting
	    ************************************/

	    // determine what type of formatting we need to do
	    function formatNumeral (n, format, roundingFunction) {
	        var output;

	        // figure out what kind of format we are dealing with
	        if (format.indexOf('$') > -1) { // currency!!!!!
	            output = formatCurrency(n, format, roundingFunction);
	        } else if (format.indexOf('%') > -1) { // percentage
	            output = formatPercentage(n, format, roundingFunction);
	        } else if (format.indexOf(':') > -1) { // time
	            output = formatTime(n, format);
	        } else { // plain ol' numbers or bytes
	            output = formatNumber(n._value, format, roundingFunction);
	        }

	        // return string
	        return output;
	    }

	    // revert to number
	    function unformatNumeral (n, string) {
	        var stringOriginal = string,
	            thousandRegExp,
	            millionRegExp,
	            billionRegExp,
	            trillionRegExp,
	            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	            bytesMultiplier = false,
	            power;

	        if (string.indexOf(':') > -1) {
	            n._value = unformatTime(string);
	        } else {
	            if (string === zeroFormat) {
	                n._value = 0;
	            } else {
	                if (languages[currentLanguage].delimiters.decimal !== '.') {
	                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
	                }

	                // see if abbreviations are there so that we can multiply to the correct number
	                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

	                // see if bytes are there so that we can multiply to the correct number
	                for (power = 0; power <= suffixes.length; power++) {
	                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

	                    if (bytesMultiplier) {
	                        break;
	                    }
	                }

	                // do some math to create our number
	                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

	                // round if we are talking about bytes
	                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
	            }
	        }
	        return n._value;
	    }

	    function formatCurrency (n, format, roundingFunction) {
	        var symbolIndex = format.indexOf('$'),
	            openParenIndex = format.indexOf('('),
	            minusSignIndex = format.indexOf('-'),
	            space = '',
	            spliceIndex,
	            output;

	        // check for space before or after currency
	        if (format.indexOf(' $') > -1) {
	            space = ' ';
	            format = format.replace(' $', '');
	        } else if (format.indexOf('$ ') > -1) {
	            space = ' ';
	            format = format.replace('$ ', '');
	        } else {
	            format = format.replace('$', '');
	        }

	        // format the number
	        output = formatNumber(n._value, format, roundingFunction);

	        // position the symbol
	        if (symbolIndex <= 1) {
	            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
	                output = output.split('');
	                spliceIndex = 1;
	                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
	                    // the symbol appears before the "(" or "-"
	                    spliceIndex = 0;
	                }
	                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
	                output = output.join('');
	            } else {
	                output = languages[currentLanguage].currency.symbol + space + output;
	            }
	        } else {
	            if (output.indexOf(')') > -1) {
	                output = output.split('');
	                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
	                output = output.join('');
	            } else {
	                output = output + space + languages[currentLanguage].currency.symbol;
	            }
	        }

	        return output;
	    }

	    function formatPercentage (n, format, roundingFunction) {
	        var space = '',
	            output,
	            value = n._value * 100;

	        // check for space before %
	        if (format.indexOf(' %') > -1) {
	            space = ' ';
	            format = format.replace(' %', '');
	        } else {
	            format = format.replace('%', '');
	        }

	        output = formatNumber(value, format, roundingFunction);
	        
	        if (output.indexOf(')') > -1 ) {
	            output = output.split('');
	            output.splice(-1, 0, space + '%');
	            output = output.join('');
	        } else {
	            output = output + space + '%';
	        }

	        return output;
	    }

	    function formatTime (n) {
	        var hours = Math.floor(n._value/60/60),
	            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
	            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
	        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
	    }

	    function unformatTime (string) {
	        var timeArray = string.split(':'),
	            seconds = 0;
	        // turn hours and minutes into seconds and add them all up
	        if (timeArray.length === 3) {
	            // hours
	            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
	            // minutes
	            seconds = seconds + (Number(timeArray[1]) * 60);
	            // seconds
	            seconds = seconds + Number(timeArray[2]);
	        } else if (timeArray.length === 2) {
	            // minutes
	            seconds = seconds + (Number(timeArray[0]) * 60);
	            // seconds
	            seconds = seconds + Number(timeArray[1]);
	        }
	        return Number(seconds);
	    }

	    function formatNumber (value, format, roundingFunction) {
	        var negP = false,
	            signed = false,
	            optDec = false,
	            abbr = '',
	            abbrK = false, // force abbreviation to thousands
	            abbrM = false, // force abbreviation to millions
	            abbrB = false, // force abbreviation to billions
	            abbrT = false, // force abbreviation to trillions
	            abbrForce = false, // force abbreviation
	            bytes = '',
	            ord = '',
	            abs = Math.abs(value),
	            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	            min,
	            max,
	            power,
	            w,
	            precision,
	            thousands,
	            d = '',
	            neg = false;

	        // check if number is zero and a custom zero format has been set
	        if (value === 0 && zeroFormat !== null) {
	            return zeroFormat;
	        } else {
	            // see if we should use parentheses for negative number or if we should prefix with a sign
	            // if both are present we default to parentheses
	            if (format.indexOf('(') > -1) {
	                negP = true;
	                format = format.slice(1, -1);
	            } else if (format.indexOf('+') > -1) {
	                signed = true;
	                format = format.replace(/\+/g, '');
	            }

	            // see if abbreviation is wanted
	            if (format.indexOf('a') > -1) {
	                // check if abbreviation is specified
	                abbrK = format.indexOf('aK') >= 0;
	                abbrM = format.indexOf('aM') >= 0;
	                abbrB = format.indexOf('aB') >= 0;
	                abbrT = format.indexOf('aT') >= 0;
	                abbrForce = abbrK || abbrM || abbrB || abbrT;

	                // check for space before abbreviation
	                if (format.indexOf(' a') > -1) {
	                    abbr = ' ';
	                    format = format.replace(' a', '');
	                } else {
	                    format = format.replace('a', '');
	                }

	                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
	                    // trillion
	                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
	                    value = value / Math.pow(10, 12);
	                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
	                    // billion
	                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
	                    value = value / Math.pow(10, 9);
	                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
	                    // million
	                    abbr = abbr + languages[currentLanguage].abbreviations.million;
	                    value = value / Math.pow(10, 6);
	                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
	                    // thousand
	                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
	                    value = value / Math.pow(10, 3);
	                }
	            }

	            // see if we are formatting bytes
	            if (format.indexOf('b') > -1) {
	                // check for space before
	                if (format.indexOf(' b') > -1) {
	                    bytes = ' ';
	                    format = format.replace(' b', '');
	                } else {
	                    format = format.replace('b', '');
	                }

	                for (power = 0; power <= suffixes.length; power++) {
	                    min = Math.pow(1024, power);
	                    max = Math.pow(1024, power+1);

	                    if (value >= min && value < max) {
	                        bytes = bytes + suffixes[power];
	                        if (min > 0) {
	                            value = value / min;
	                        }
	                        break;
	                    }
	                }
	            }

	            // see if ordinal is wanted
	            if (format.indexOf('o') > -1) {
	                // check for space before
	                if (format.indexOf(' o') > -1) {
	                    ord = ' ';
	                    format = format.replace(' o', '');
	                } else {
	                    format = format.replace('o', '');
	                }

	                ord = ord + languages[currentLanguage].ordinal(value);
	            }

	            if (format.indexOf('[.]') > -1) {
	                optDec = true;
	                format = format.replace('[.]', '.');
	            }

	            w = value.toString().split('.')[0];
	            precision = format.split('.')[1];
	            thousands = format.indexOf(',');

	            if (precision) {
	                if (precision.indexOf('[') > -1) {
	                    precision = precision.replace(']', '');
	                    precision = precision.split('[');
	                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
	                } else {
	                    d = toFixed(value, precision.length, roundingFunction);
	                }

	                w = d.split('.')[0];

	                if (d.split('.')[1].length) {
	                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
	                } else {
	                    d = '';
	                }

	                if (optDec && Number(d.slice(1)) === 0) {
	                    d = '';
	                }
	            } else {
	                w = toFixed(value, null, roundingFunction);
	            }

	            // format number
	            if (w.indexOf('-') > -1) {
	                w = w.slice(1);
	                neg = true;
	            }

	            if (thousands > -1) {
	                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
	            }

	            if (format.indexOf('.') === 0) {
	                w = '';
	            }

	            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
	        }
	    }

	    /************************************
	        Top Level Functions
	    ************************************/

	    numeral = function (input) {
	        if (numeral.isNumeral(input)) {
	            input = input.value();
	        } else if (input === 0 || typeof input === 'undefined') {
	            input = 0;
	        } else if (!Number(input)) {
	            input = numeral.fn.unformat(input);
	        }

	        return new Numeral(Number(input));
	    };

	    // version number
	    numeral.version = VERSION;

	    // compare numeral object
	    numeral.isNumeral = function (obj) {
	        return obj instanceof Numeral;
	    };

	    // This function will load languages and then set the global language.  If
	    // no arguments are passed in, it will simply return the current global
	    // language key.
	    numeral.language = function (key, values) {
	        if (!key) {
	            return currentLanguage;
	        }

	        if (key && !values) {
	            if(!languages[key]) {
	                throw new Error('Unknown language : ' + key);
	            }
	            currentLanguage = key;
	        }

	        if (values || !languages[key]) {
	            loadLanguage(key, values);
	        }

	        return numeral;
	    };
	    
	    // This function provides access to the loaded language data.  If
	    // no arguments are passed in, it will simply return the current
	    // global language object.
	    numeral.languageData = function (key) {
	        if (!key) {
	            return languages[currentLanguage];
	        }
	        
	        if (!languages[key]) {
	            throw new Error('Unknown language : ' + key);
	        }
	        
	        return languages[key];
	    };

	    numeral.language('en', {
	        delimiters: {
	            thousands: ',',
	            decimal: '.'
	        },
	        abbreviations: {
	            thousand: 'k',
	            million: 'm',
	            billion: 'b',
	            trillion: 't'
	        },
	        ordinal: function (number) {
	            var b = number % 10;
	            return (~~ (number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	        },
	        currency: {
	            symbol: '$'
	        }
	    });

	    numeral.zeroFormat = function (format) {
	        zeroFormat = typeof(format) === 'string' ? format : null;
	    };

	    numeral.defaultFormat = function (format) {
	        defaultFormat = typeof(format) === 'string' ? format : '0.0';
	    };

	    /************************************
	        Helpers
	    ************************************/

	    function loadLanguage(key, values) {
	        languages[key] = values;
	    }

	    /************************************
	        Floating-point helpers
	    ************************************/

	    // The floating-point helper functions and implementation
	    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

	    /**
	     * Array.prototype.reduce for browsers that don't support it
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
	     */
	    if ('function' !== typeof Array.prototype.reduce) {
	        Array.prototype.reduce = function (callback, opt_initialValue) {
	            'use strict';
	            
	            if (null === this || 'undefined' === typeof this) {
	                // At the moment all modern browsers, that support strict mode, have
	                // native implementation of Array.prototype.reduce. For instance, IE8
	                // does not support strict mode, so this check is actually useless.
	                throw new TypeError('Array.prototype.reduce called on null or undefined');
	            }
	            
	            if ('function' !== typeof callback) {
	                throw new TypeError(callback + ' is not a function');
	            }

	            var index,
	                value,
	                length = this.length >>> 0,
	                isValueSet = false;

	            if (1 < arguments.length) {
	                value = opt_initialValue;
	                isValueSet = true;
	            }

	            for (index = 0; length > index; ++index) {
	                if (this.hasOwnProperty(index)) {
	                    if (isValueSet) {
	                        value = callback(value, this[index], index, this);
	                    } else {
	                        value = this[index];
	                        isValueSet = true;
	                    }
	                }
	            }

	            if (!isValueSet) {
	                throw new TypeError('Reduce of empty array with no initial value');
	            }

	            return value;
	        };
	    }

	    
	    /**
	     * Computes the multiplier necessary to make x >= 1,
	     * effectively eliminating miscalculations caused by
	     * finite precision.
	     */
	    function multiplier(x) {
	        var parts = x.toString().split('.');
	        if (parts.length < 2) {
	            return 1;
	        }
	        return Math.pow(10, parts[1].length);
	    }

	    /**
	     * Given a variable number of arguments, returns the maximum
	     * multiplier that must be used to normalize an operation involving
	     * all of them.
	     */
	    function correctionFactor() {
	        var args = Array.prototype.slice.call(arguments);
	        return args.reduce(function (prev, next) {
	            var mp = multiplier(prev),
	                mn = multiplier(next);
	        return mp > mn ? mp : mn;
	        }, -Infinity);
	    }        


	    /************************************
	        Numeral Prototype
	    ************************************/


	    numeral.fn = Numeral.prototype = {

	        clone : function () {
	            return numeral(this);
	        },

	        format : function (inputString, roundingFunction) {
	            return formatNumeral(this, 
	                  inputString ? inputString : defaultFormat, 
	                  (roundingFunction !== undefined) ? roundingFunction : Math.round
	              );
	        },

	        unformat : function (inputString) {
	            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
	                return inputString; 
	            }
	            return unformatNumeral(this, inputString ? inputString : defaultFormat);
	        },

	        value : function () {
	            return this._value;
	        },

	        valueOf : function () {
	            return this._value;
	        },

	        set : function (value) {
	            this._value = Number(value);
	            return this;
	        },

	        add : function (value) {
	            var corrFactor = correctionFactor.call(null, this._value, value);
	            function cback(accum, curr, currI, O) {
	                return accum + corrFactor * curr;
	            }
	            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
	            return this;
	        },

	        subtract : function (value) {
	            var corrFactor = correctionFactor.call(null, this._value, value);
	            function cback(accum, curr, currI, O) {
	                return accum - corrFactor * curr;
	            }
	            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
	            return this;
	        },

	        multiply : function (value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = correctionFactor(accum, curr);
	                return (accum * corrFactor) * (curr * corrFactor) /
	                    (corrFactor * corrFactor);
	            }
	            this._value = [this._value, value].reduce(cback, 1);
	            return this;
	        },

	        divide : function (value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = correctionFactor(accum, curr);
	                return (accum * corrFactor) / (curr * corrFactor);
	            }
	            this._value = [this._value, value].reduce(cback);            
	            return this;
	        },

	        difference : function (value) {
	            return Math.abs(numeral(this._value).subtract(value).value());
	        }

	    };

	    /************************************
	        Exposing Numeral
	    ************************************/

	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = numeral;
	    }

	    /*global ender:false */
	    if (typeof ender === 'undefined') {
	        // here, `this` means `window` in the browser, or `global` on the server
	        // add `numeral` as a global object via a string identifier,
	        // for Closure Compiler 'advanced' mode
	        this['numeral'] = numeral;
	    }

	    /*global define:false */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return numeral;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	}).call(this);


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Rangy, a cross-browser JavaScript range and selection library
	 * https://github.com/timdown/rangy
	 *
	 * Copyright 2015, Tim Down
	 * Licensed under the MIT license.
	 * Version: 1.3.0
	 * Build date: 10 May 2015
	 */

	(function(factory, root) {
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module != "undefined" && typeof exports == "object") {
	        // Node/CommonJS style
	        module.exports = factory();
	    } else {
	        // No AMD or CommonJS support so we place Rangy in (probably) the global variable
	        root.rangy = factory();
	    }
	})(function() {

	    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";

	    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START
	    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.
	    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
	        "commonAncestorContainer"];

	    // Minimal set of methods required for DOM Level 2 Range compliance
	    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",
	        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",
	        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];

	    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];

	    // Subset of TextRange's full set of methods that we're interested in
	    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",
	        "setEndPoint", "getBoundingClientRect"];

	    /*----------------------------------------------------------------------------------------------------------------*/

	    // Trio of functions taken from Peter Michaux's article:
	    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
	    function isHostMethod(o, p) {
	        var t = typeof o[p];
	        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";
	    }

	    function isHostObject(o, p) {
	        return !!(typeof o[p] == OBJECT && o[p]);
	    }

	    function isHostProperty(o, p) {
	        return typeof o[p] != UNDEFINED;
	    }

	    // Creates a convenience function to save verbose repeated calls to tests functions
	    function createMultiplePropertyTest(testFunc) {
	        return function(o, props) {
	            var i = props.length;
	            while (i--) {
	                if (!testFunc(o, props[i])) {
	                    return false;
	                }
	            }
	            return true;
	        };
	    }

	    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions
	    var areHostMethods = createMultiplePropertyTest(isHostMethod);
	    var areHostObjects = createMultiplePropertyTest(isHostObject);
	    var areHostProperties = createMultiplePropertyTest(isHostProperty);

	    function isTextRange(range) {
	        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
	    }

	    function getBody(doc) {
	        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
	    }

	    var forEach = [].forEach ?
	        function(arr, func) {
	            arr.forEach(func);
	        } :
	        function(arr, func) {
	            for (var i = 0, len = arr.length; i < len; ++i) {
	                func(arr[i], i);
	            }
	        };

	    var modules = {};

	    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);

	    var util = {
	        isHostMethod: isHostMethod,
	        isHostObject: isHostObject,
	        isHostProperty: isHostProperty,
	        areHostMethods: areHostMethods,
	        areHostObjects: areHostObjects,
	        areHostProperties: areHostProperties,
	        isTextRange: isTextRange,
	        getBody: getBody,
	        forEach: forEach
	    };

	    var api = {
	        version: "1.3.0",
	        initialized: false,
	        isBrowser: isBrowser,
	        supported: true,
	        util: util,
	        features: {},
	        modules: modules,
	        config: {
	            alertOnFail: false,
	            alertOnWarn: false,
	            preferTextRange: false,
	            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize
	        }
	    };

	    function consoleLog(msg) {
	        if (typeof console != UNDEFINED && isHostMethod(console, "log")) {
	            console.log(msg);
	        }
	    }

	    function alertOrLog(msg, shouldAlert) {
	        if (isBrowser && shouldAlert) {
	            alert(msg);
	        } else  {
	            consoleLog(msg);
	        }
	    }

	    function fail(reason) {
	        api.initialized = true;
	        api.supported = false;
	        alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);
	    }

	    api.fail = fail;

	    function warn(msg) {
	        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
	    }

	    api.warn = warn;

	    // Add utility extend() method
	    var extend;
	    if ({}.hasOwnProperty) {
	        util.extend = extend = function(obj, props, deep) {
	            var o, p;
	            for (var i in props) {
	                if (props.hasOwnProperty(i)) {
	                    o = obj[i];
	                    p = props[i];
	                    if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {
	                        extend(o, p, true);
	                    }
	                    obj[i] = p;
	                }
	            }
	            // Special case for toString, which does not show up in for...in loops in IE <= 8
	            if (props.hasOwnProperty("toString")) {
	                obj.toString = props.toString;
	            }
	            return obj;
	        };

	        util.createOptions = function(optionsParam, defaults) {
	            var options = {};
	            extend(options, defaults);
	            if (optionsParam) {
	                extend(options, optionsParam);
	            }
	            return options;
	        };
	    } else {
	        fail("hasOwnProperty not supported");
	    }

	    // Test whether we're in a browser and bail out if not
	    if (!isBrowser) {
	        fail("Rangy can only run in a browser");
	    }

	    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not
	    (function() {
	        var toArray;

	        if (isBrowser) {
	            var el = document.createElement("div");
	            el.appendChild(document.createElement("span"));
	            var slice = [].slice;
	            try {
	                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
	                    toArray = function(arrayLike) {
	                        return slice.call(arrayLike, 0);
	                    };
	                }
	            } catch (e) {}
	        }

	        if (!toArray) {
	            toArray = function(arrayLike) {
	                var arr = [];
	                for (var i = 0, len = arrayLike.length; i < len; ++i) {
	                    arr[i] = arrayLike[i];
	                }
	                return arr;
	            };
	        }

	        util.toArray = toArray;
	    })();

	    // Very simple event handler wrapper function that doesn't attempt to solve issues such as "this" handling or
	    // normalization of event properties
	    var addListener;
	    if (isBrowser) {
	        if (isHostMethod(document, "addEventListener")) {
	            addListener = function(obj, eventType, listener) {
	                obj.addEventListener(eventType, listener, false);
	            };
	        } else if (isHostMethod(document, "attachEvent")) {
	            addListener = function(obj, eventType, listener) {
	                obj.attachEvent("on" + eventType, listener);
	            };
	        } else {
	            fail("Document does not have required addEventListener or attachEvent method");
	        }

	        util.addListener = addListener;
	    }

	    var initListeners = [];

	    function getErrorDesc(ex) {
	        return ex.message || ex.description || String(ex);
	    }

	    // Initialization
	    function init() {
	        if (!isBrowser || api.initialized) {
	            return;
	        }
	        var testRange;
	        var implementsDomRange = false, implementsTextRange = false;

	        // First, perform basic feature tests

	        if (isHostMethod(document, "createRange")) {
	            testRange = document.createRange();
	            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
	                implementsDomRange = true;
	            }
	        }

	        var body = getBody(document);
	        if (!body || body.nodeName.toLowerCase() != "body") {
	            fail("No body element found");
	            return;
	        }

	        if (body && isHostMethod(body, "createTextRange")) {
	            testRange = body.createTextRange();
	            if (isTextRange(testRange)) {
	                implementsTextRange = true;
	            }
	        }

	        if (!implementsDomRange && !implementsTextRange) {
	            fail("Neither Range nor TextRange are available");
	            return;
	        }

	        api.initialized = true;
	        api.features = {
	            implementsDomRange: implementsDomRange,
	            implementsTextRange: implementsTextRange
	        };

	        // Initialize modules
	        var module, errorMessage;
	        for (var moduleName in modules) {
	            if ( (module = modules[moduleName]) instanceof Module ) {
	                module.init(module, api);
	            }
	        }

	        // Call init listeners
	        for (var i = 0, len = initListeners.length; i < len; ++i) {
	            try {
	                initListeners[i](api);
	            } catch (ex) {
	                errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
	                consoleLog(errorMessage);
	            }
	        }
	    }

	    function deprecationNotice(deprecated, replacement, module) {
	        if (module) {
	            deprecated += " in module " + module.name;
	        }
	        api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " +
	        replacement + " instead.");
	    }

	    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {
	        owner[deprecated] = function() {
	            deprecationNotice(deprecated, replacement, module);
	            return owner[replacement].apply(owner, util.toArray(arguments));
	        };
	    }

	    util.deprecationNotice = deprecationNotice;
	    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;

	    // Allow external scripts to initialize this library in case it's loaded after the document has loaded
	    api.init = init;

	    // Execute listener immediately if already initialized
	    api.addInitListener = function(listener) {
	        if (api.initialized) {
	            listener(api);
	        } else {
	            initListeners.push(listener);
	        }
	    };

	    var shimListeners = [];

	    api.addShimListener = function(listener) {
	        shimListeners.push(listener);
	    };

	    function shim(win) {
	        win = win || window;
	        init();

	        // Notify listeners
	        for (var i = 0, len = shimListeners.length; i < len; ++i) {
	            shimListeners[i](win);
	        }
	    }

	    if (isBrowser) {
	        api.shim = api.createMissingNativeApi = shim;
	        createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");
	    }

	    function Module(name, dependencies, initializer) {
	        this.name = name;
	        this.dependencies = dependencies;
	        this.initialized = false;
	        this.supported = false;
	        this.initializer = initializer;
	    }

	    Module.prototype = {
	        init: function() {
	            var requiredModuleNames = this.dependencies || [];
	            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
	                moduleName = requiredModuleNames[i];

	                requiredModule = modules[moduleName];
	                if (!requiredModule || !(requiredModule instanceof Module)) {
	                    throw new Error("required module '" + moduleName + "' not found");
	                }

	                requiredModule.init();

	                if (!requiredModule.supported) {
	                    throw new Error("required module '" + moduleName + "' not supported");
	                }
	            }

	            // Now run initializer
	            this.initializer(this);
	        },

	        fail: function(reason) {
	            this.initialized = true;
	            this.supported = false;
	            throw new Error(reason);
	        },

	        warn: function(msg) {
	            api.warn("Module " + this.name + ": " + msg);
	        },

	        deprecationNotice: function(deprecated, replacement) {
	            api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " +
	                replacement + " instead");
	        },

	        createError: function(msg) {
	            return new Error("Error in Rangy " + this.name + " module: " + msg);
	        }
	    };

	    function createModule(name, dependencies, initFunc) {
	        var newModule = new Module(name, dependencies, function(module) {
	            if (!module.initialized) {
	                module.initialized = true;
	                try {
	                    initFunc(api, module);
	                    module.supported = true;
	                } catch (ex) {
	                    var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
	                    consoleLog(errorMessage);
	                    if (ex.stack) {
	                        consoleLog(ex.stack);
	                    }
	                }
	            }
	        });
	        modules[name] = newModule;
	        return newModule;
	    }

	    api.createModule = function(name) {
	        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)
	        var initFunc, dependencies;
	        if (arguments.length == 2) {
	            initFunc = arguments[1];
	            dependencies = [];
	        } else {
	            initFunc = arguments[2];
	            dependencies = arguments[1];
	        }

	        var module = createModule(name, dependencies, initFunc);

	        // Initialize the module immediately if the core is already initialized
	        if (api.initialized && api.supported) {
	            module.init();
	        }
	    };

	    api.createCoreModule = function(name, dependencies, initFunc) {
	        createModule(name, dependencies, initFunc);
	    };

	    /*----------------------------------------------------------------------------------------------------------------*/

	    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately

	    function RangePrototype() {}
	    api.RangePrototype = RangePrototype;
	    api.rangePrototype = new RangePrototype();

	    function SelectionPrototype() {}
	    api.selectionPrototype = new SelectionPrototype();

	    /*----------------------------------------------------------------------------------------------------------------*/

	    // DOM utility methods used by Rangy
	    api.createCoreModule("DomUtil", [], function(api, module) {
	        var UNDEF = "undefined";
	        var util = api.util;
	        var getBody = util.getBody;

	        // Perform feature tests
	        if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
	            module.fail("document missing a Node creation method");
	        }

	        if (!util.isHostMethod(document, "getElementsByTagName")) {
	            module.fail("document missing getElementsByTagName method");
	        }

	        var el = document.createElement("div");
	        if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||
	                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {
	            module.fail("Incomplete Element implementation");
	        }

	        // innerHTML is required for Range's createContextualFragment method
	        if (!util.isHostProperty(el, "innerHTML")) {
	            module.fail("Element is missing innerHTML property");
	        }

	        var textNode = document.createTextNode("test");
	        if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||
	                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||
	                !util.areHostProperties(textNode, ["data"]))) {
	            module.fail("Incomplete Text Node implementation");
	        }

	        /*----------------------------------------------------------------------------------------------------------------*/

	        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been
	        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that
	        // contains just the document as a single element and the value searched for is the document.
	        var arrayContains = /*Array.prototype.indexOf ?
	            function(arr, val) {
	                return arr.indexOf(val) > -1;
	            }:*/

	            function(arr, val) {
	                var i = arr.length;
	                while (i--) {
	                    if (arr[i] === val) {
	                        return true;
	                    }
	                }
	                return false;
	            };

	        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI
	        function isHtmlNamespace(node) {
	            var ns;
	            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
	        }

	        function parentElement(node) {
	            var parent = node.parentNode;
	            return (parent.nodeType == 1) ? parent : null;
	        }

	        function getNodeIndex(node) {
	            var i = 0;
	            while( (node = node.previousSibling) ) {
	                ++i;
	            }
	            return i;
	        }

	        function getNodeLength(node) {
	            switch (node.nodeType) {
	                case 7:
	                case 10:
	                    return 0;
	                case 3:
	                case 8:
	                    return node.length;
	                default:
	                    return node.childNodes.length;
	            }
	        }

	        function getCommonAncestor(node1, node2) {
	            var ancestors = [], n;
	            for (n = node1; n; n = n.parentNode) {
	                ancestors.push(n);
	            }

	            for (n = node2; n; n = n.parentNode) {
	                if (arrayContains(ancestors, n)) {
	                    return n;
	                }
	            }

	            return null;
	        }

	        function isAncestorOf(ancestor, descendant, selfIsAncestor) {
	            var n = selfIsAncestor ? descendant : descendant.parentNode;
	            while (n) {
	                if (n === ancestor) {
	                    return true;
	                } else {
	                    n = n.parentNode;
	                }
	            }
	            return false;
	        }

	        function isOrIsAncestorOf(ancestor, descendant) {
	            return isAncestorOf(ancestor, descendant, true);
	        }

	        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
	            var p, n = selfIsAncestor ? node : node.parentNode;
	            while (n) {
	                p = n.parentNode;
	                if (p === ancestor) {
	                    return n;
	                }
	                n = p;
	            }
	            return null;
	        }

	        function isCharacterDataNode(node) {
	            var t = node.nodeType;
	            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment
	        }

	        function isTextOrCommentNode(node) {
	            if (!node) {
	                return false;
	            }
	            var t = node.nodeType;
	            return t == 3 || t == 8 ; // Text or Comment
	        }

	        function insertAfter(node, precedingNode) {
	            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
	            if (nextNode) {
	                parent.insertBefore(node, nextNode);
	            } else {
	                parent.appendChild(node);
	            }
	            return node;
	        }

	        // Note that we cannot use splitText() because it is bugridden in IE 9.
	        function splitDataNode(node, index, positionsToPreserve) {
	            var newNode = node.cloneNode(false);
	            newNode.deleteData(0, index);
	            node.deleteData(index, node.length - index);
	            insertAfter(newNode, node);

	            // Preserve positions
	            if (positionsToPreserve) {
	                for (var i = 0, position; position = positionsToPreserve[i++]; ) {
	                    // Handle case where position was inside the portion of node after the split point
	                    if (position.node == node && position.offset > index) {
	                        position.node = newNode;
	                        position.offset -= index;
	                    }
	                    // Handle the case where the position is a node offset within node's parent
	                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {
	                        ++position.offset;
	                    }
	                }
	            }
	            return newNode;
	        }

	        function getDocument(node) {
	            if (node.nodeType == 9) {
	                return node;
	            } else if (typeof node.ownerDocument != UNDEF) {
	                return node.ownerDocument;
	            } else if (typeof node.document != UNDEF) {
	                return node.document;
	            } else if (node.parentNode) {
	                return getDocument(node.parentNode);
	            } else {
	                throw module.createError("getDocument: no document found for node");
	            }
	        }

	        function getWindow(node) {
	            var doc = getDocument(node);
	            if (typeof doc.defaultView != UNDEF) {
	                return doc.defaultView;
	            } else if (typeof doc.parentWindow != UNDEF) {
	                return doc.parentWindow;
	            } else {
	                throw module.createError("Cannot get a window object for node");
	            }
	        }

	        function getIframeDocument(iframeEl) {
	            if (typeof iframeEl.contentDocument != UNDEF) {
	                return iframeEl.contentDocument;
	            } else if (typeof iframeEl.contentWindow != UNDEF) {
	                return iframeEl.contentWindow.document;
	            } else {
	                throw module.createError("getIframeDocument: No Document object found for iframe element");
	            }
	        }

	        function getIframeWindow(iframeEl) {
	            if (typeof iframeEl.contentWindow != UNDEF) {
	                return iframeEl.contentWindow;
	            } else if (typeof iframeEl.contentDocument != UNDEF) {
	                return iframeEl.contentDocument.defaultView;
	            } else {
	                throw module.createError("getIframeWindow: No Window object found for iframe element");
	            }
	        }

	        // This looks bad. Is it worth it?
	        function isWindow(obj) {
	            return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");
	        }

	        function getContentDocument(obj, module, methodName) {
	            var doc;

	            if (!obj) {
	                doc = document;
	            }

	            // Test if a DOM node has been passed and obtain a document object for it if so
	            else if (util.isHostProperty(obj, "nodeType")) {
	                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?
	                    getIframeDocument(obj) : getDocument(obj);
	            }

	            // Test if the doc parameter appears to be a Window object
	            else if (isWindow(obj)) {
	                doc = obj.document;
	            }

	            if (!doc) {
	                throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");
	            }

	            return doc;
	        }

	        function getRootContainer(node) {
	            var parent;
	            while ( (parent = node.parentNode) ) {
	                node = parent;
	            }
	            return node;
	        }

	        function comparePoints(nodeA, offsetA, nodeB, offsetB) {
	            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing
	            var nodeC, root, childA, childB, n;
	            if (nodeA == nodeB) {
	                // Case 1: nodes are the same
	                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;
	            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {
	                // Case 2: node C (container B or an ancestor) is a child node of A
	                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
	            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {
	                // Case 3: node C (container A or an ancestor) is a child node of B
	                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;
	            } else {
	                root = getCommonAncestor(nodeA, nodeB);
	                if (!root) {
	                    throw new Error("comparePoints error: nodes have no common ancestor");
	                }

	                // Case 4: containers are siblings or descendants of siblings
	                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);
	                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);

	                if (childA === childB) {
	                    // This shouldn't be possible
	                    throw module.createError("comparePoints got to case 4 and childA and childB are the same!");
	                } else {
	                    n = root.firstChild;
	                    while (n) {
	                        if (n === childA) {
	                            return -1;
	                        } else if (n === childB) {
	                            return 1;
	                        }
	                        n = n.nextSibling;
	                    }
	                }
	            }
	        }

	        /*----------------------------------------------------------------------------------------------------------------*/

	        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried
	        var crashyTextNodes = false;

	        function isBrokenNode(node) {
	            var n;
	            try {
	                n = node.parentNode;
	                return false;
	            } catch (e) {
	                return true;
	            }
	        }

	        (function() {
	            var el = document.createElement("b");
	            el.innerHTML = "1";
	            var textNode = el.firstChild;
	            el.innerHTML = "<br />";
	            crashyTextNodes = isBrokenNode(textNode);

	            api.features.crashyTextNodes = crashyTextNodes;
	        })();

	        /*----------------------------------------------------------------------------------------------------------------*/

	        function inspectNode(node) {
	            if (!node) {
	                return "[No node]";
	            }
	            if (crashyTextNodes && isBrokenNode(node)) {
	                return "[Broken node]";
	            }
	            if (isCharacterDataNode(node)) {
	                return '"' + node.data + '"';
	            }
	            if (node.nodeType == 1) {
	                var idAttr = node.id ? ' id="' + node.id + '"' : "";
	                return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
	            }
	            return node.nodeName;
	        }

	        function fragmentFromNodeChildren(node) {
	            var fragment = getDocument(node).createDocumentFragment(), child;
	            while ( (child = node.firstChild) ) {
	                fragment.appendChild(child);
	            }
	            return fragment;
	        }

	        var getComputedStyleProperty;
	        if (typeof window.getComputedStyle != UNDEF) {
	            getComputedStyleProperty = function(el, propName) {
	                return getWindow(el).getComputedStyle(el, null)[propName];
	            };
	        } else if (typeof document.documentElement.currentStyle != UNDEF) {
	            getComputedStyleProperty = function(el, propName) {
	                return el.currentStyle ? el.currentStyle[propName] : "";
	            };
	        } else {
	            module.fail("No means of obtaining computed style properties found");
	        }

	        function createTestElement(doc, html, contentEditable) {
	            var body = getBody(doc);
	            var el = doc.createElement("div");
	            el.contentEditable = "" + !!contentEditable;
	            if (html) {
	                el.innerHTML = html;
	            }

	            // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)
	            var bodyFirstChild = body.firstChild;
	            if (bodyFirstChild) {
	                body.insertBefore(el, bodyFirstChild);
	            } else {
	                body.appendChild(el);
	            }

	            return el;
	        }

	        function removeNode(node) {
	            return node.parentNode.removeChild(node);
	        }

	        function NodeIterator(root) {
	            this.root = root;
	            this._next = root;
	        }

	        NodeIterator.prototype = {
	            _current: null,

	            hasNext: function() {
	                return !!this._next;
	            },

	            next: function() {
	                var n = this._current = this._next;
	                var child, next;
	                if (this._current) {
	                    child = n.firstChild;
	                    if (child) {
	                        this._next = child;
	                    } else {
	                        next = null;
	                        while ((n !== this.root) && !(next = n.nextSibling)) {
	                            n = n.parentNode;
	                        }
	                        this._next = next;
	                    }
	                }
	                return this._current;
	            },

	            detach: function() {
	                this._current = this._next = this.root = null;
	            }
	        };

	        function createIterator(root) {
	            return new NodeIterator(root);
	        }

	        function DomPosition(node, offset) {
	            this.node = node;
	            this.offset = offset;
	        }

	        DomPosition.prototype = {
	            equals: function(pos) {
	                return !!pos && this.node === pos.node && this.offset == pos.offset;
	            },

	            inspect: function() {
	                return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
	            },

	            toString: function() {
	                return this.inspect();
	            }
	        };

	        function DOMException(codeName) {
	            this.code = this[codeName];
	            this.codeName = codeName;
	            this.message = "DOMException: " + this.codeName;
	        }

	        DOMException.prototype = {
	            INDEX_SIZE_ERR: 1,
	            HIERARCHY_REQUEST_ERR: 3,
	            WRONG_DOCUMENT_ERR: 4,
	            NO_MODIFICATION_ALLOWED_ERR: 7,
	            NOT_FOUND_ERR: 8,
	            NOT_SUPPORTED_ERR: 9,
	            INVALID_STATE_ERR: 11,
	            INVALID_NODE_TYPE_ERR: 24
	        };

	        DOMException.prototype.toString = function() {
	            return this.message;
	        };

	        api.dom = {
	            arrayContains: arrayContains,
	            isHtmlNamespace: isHtmlNamespace,
	            parentElement: parentElement,
	            getNodeIndex: getNodeIndex,
	            getNodeLength: getNodeLength,
	            getCommonAncestor: getCommonAncestor,
	            isAncestorOf: isAncestorOf,
	            isOrIsAncestorOf: isOrIsAncestorOf,
	            getClosestAncestorIn: getClosestAncestorIn,
	            isCharacterDataNode: isCharacterDataNode,
	            isTextOrCommentNode: isTextOrCommentNode,
	            insertAfter: insertAfter,
	            splitDataNode: splitDataNode,
	            getDocument: getDocument,
	            getWindow: getWindow,
	            getIframeWindow: getIframeWindow,
	            getIframeDocument: getIframeDocument,
	            getBody: getBody,
	            isWindow: isWindow,
	            getContentDocument: getContentDocument,
	            getRootContainer: getRootContainer,
	            comparePoints: comparePoints,
	            isBrokenNode: isBrokenNode,
	            inspectNode: inspectNode,
	            getComputedStyleProperty: getComputedStyleProperty,
	            createTestElement: createTestElement,
	            removeNode: removeNode,
	            fragmentFromNodeChildren: fragmentFromNodeChildren,
	            createIterator: createIterator,
	            DomPosition: DomPosition
	        };

	        api.DOMException = DOMException;
	    });

	    /*----------------------------------------------------------------------------------------------------------------*/

	    // Pure JavaScript implementation of DOM Range
	    api.createCoreModule("DomRange", ["DomUtil"], function(api, module) {
	        var dom = api.dom;
	        var util = api.util;
	        var DomPosition = dom.DomPosition;
	        var DOMException = api.DOMException;

	        var isCharacterDataNode = dom.isCharacterDataNode;
	        var getNodeIndex = dom.getNodeIndex;
	        var isOrIsAncestorOf = dom.isOrIsAncestorOf;
	        var getDocument = dom.getDocument;
	        var comparePoints = dom.comparePoints;
	        var splitDataNode = dom.splitDataNode;
	        var getClosestAncestorIn = dom.getClosestAncestorIn;
	        var getNodeLength = dom.getNodeLength;
	        var arrayContains = dom.arrayContains;
	        var getRootContainer = dom.getRootContainer;
	        var crashyTextNodes = api.features.crashyTextNodes;

	        var removeNode = dom.removeNode;

	        /*----------------------------------------------------------------------------------------------------------------*/

	        // Utility functions

	        function isNonTextPartiallySelected(node, range) {
	            return (node.nodeType != 3) &&
	                   (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));
	        }

	        function getRangeDocument(range) {
	            return range.document || getDocument(range.startContainer);
	        }

	        function getRangeRoot(range) {
	            return getRootContainer(range.startContainer);
	        }

	        function getBoundaryBeforeNode(node) {
	            return new DomPosition(node.parentNode, getNodeIndex(node));
	        }

	        function getBoundaryAfterNode(node) {
	            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);
	        }

	        function insertNodeAtPosition(node, n, o) {
	            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
	            if (isCharacterDataNode(n)) {
	                if (o == n.length) {
	                    dom.insertAfter(node, n);
	                } else {
	                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));
	                }
	            } else if (o >= n.childNodes.length) {
	                n.appendChild(node);
	            } else {
	                n.insertBefore(node, n.childNodes[o]);
	            }
	            return firstNodeInserted;
	        }

	        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
	            assertRangeValid(rangeA);
	            assertRangeValid(rangeB);

	            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
	                throw new DOMException("WRONG_DOCUMENT_ERR");
	            }

	            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),
	                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);

	            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
	        }

	        function cloneSubtree(iterator) {
	            var partiallySelected;
	            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
	                partiallySelected = iterator.isPartiallySelectedSubtree();
	                node = node.cloneNode(!partiallySelected);
	                if (partiallySelected) {
	                    subIterator = iterator.getSubtreeIterator();
	                    node.appendChild(cloneSubtree(subIterator));
	                    subIterator.detach();
	                }

	                if (node.nodeType == 10) { // DocumentType
	                    throw new DOMException("HIERARCHY_REQUEST_ERR");
	                }
	                frag.appendChild(node);
	            }
	            return frag;
	        }

	        function iterateSubtree(rangeIterator, func, iteratorState) {
	            var it, n;
	            iteratorState = iteratorState || { stop: false };
	            for (var node, subRangeIterator; node = rangeIterator.next(); ) {
	                if (rangeIterator.isPartiallySelectedSubtree()) {
	                    if (func(node) === false) {
	                        iteratorState.stop = true;
	                        return;
	                    } else {
	                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of
	                        // the node selected by the Range.
	                        subRangeIterator = rangeIterator.getSubtreeIterator();
	                        iterateSubtree(subRangeIterator, func, iteratorState);
	                        subRangeIterator.detach();
	                        if (iteratorState.stop) {
	                            return;
	                        }
	                    }
	                } else {
	                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its
	                    // descendants
	                    it = dom.createIterator(node);
	                    while ( (n = it.next()) ) {
	                        if (func(n) === false) {
	                            iteratorState.stop = true;
	                            return;
	                        }
	                    }
	                }
	            }
	        }

	        function deleteSubtree(iterator) {
	            var subIterator;
	            while (iterator.next()) {
	                if (iterator.isPartiallySelectedSubtree()) {
	                    subIterator = iterator.getSubtreeIterator();
	                    deleteSubtree(subIterator);
	                    subIterator.detach();
	                } else {
	                    iterator.remove();
	                }
	            }
	        }

	        function extractSubtree(iterator) {
	            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {

	                if (iterator.isPartiallySelectedSubtree()) {
	                    node = node.cloneNode(false);
	                    subIterator = iterator.getSubtreeIterator();
	                    node.appendChild(extractSubtree(subIterator));
	                    subIterator.detach();
	                } else {
	                    iterator.remove();
	                }
	                if (node.nodeType == 10) { // DocumentType
	                    throw new DOMException("HIERARCHY_REQUEST_ERR");
	                }
	                frag.appendChild(node);
	            }
	            return frag;
	        }

	        function getNodesInRange(range, nodeTypes, filter) {
	            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
	            var filterExists = !!filter;
	            if (filterNodeTypes) {
	                regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
	            }

	            var nodes = [];
	            iterateSubtree(new RangeIterator(range, false), function(node) {
	                if (filterNodeTypes && !regex.test(node.nodeType)) {
	                    return;
	                }
	                if (filterExists && !filter(node)) {
	                    return;
	                }
	                // Don't include a boundary container if it is a character data node and the range does not contain any
	                // of its character data. See issue 190.
	                var sc = range.startContainer;
	                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
	                    return;
	                }

	                var ec = range.endContainer;
	                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
	                    return;
	                }

	                nodes.push(node);
	            });
	            return nodes;
	        }

	        function inspect(range) {
	            var name = (typeof range.getName == "undefined") ? "Range" : range.getName();
	            return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +
	                    dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
	        }

	        /*----------------------------------------------------------------------------------------------------------------*/

	        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)

	        function RangeIterator(range, clonePartiallySelectedTextNodes) {
	            this.range = range;
	            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;


	            if (!range.collapsed) {
	                this.sc = range.startContainer;
	                this.so = range.startOffset;
	                this.ec = range.endContainer;
	                this.eo = range.endOffset;
	                var root = range.commonAncestorContainer;

	                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
	                    this.isSingleCharacterDataNode = true;
	                    this._first = this._last = this._next = this.sc;
	                } else {
	                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?
	                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
	                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?
	                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
	                }
	            }
	        }

	        RangeIterator.prototype = {
	            _current: null,
	            _next: null,
	            _first: null,
	            _last: null,
	            isSingleCharacterDataNode: false,

	            reset: function() {
	                this._current = null;
	                this._next = this._first;
	            },

	            hasNext: function() {
	                return !!this._next;
	            },

	            next: function() {
	                // Move to next node
	                var current = this._current = this._next;
	                if (current) {
	                    this._next = (current !== this._last) ? current.nextSibling : null;

	                    // Check for partially selected text nodes
	                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
	                        if (current === this.ec) {
	                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
	                        }
	                        if (this._current === this.sc) {
	                            (current = current.cloneNode(true)).deleteData(0, this.so);
	                        }
	                    }
	                }

	                return current;
	            },

	            remove: function() {
	                var current = this._current, start, end;

	                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
	                    start = (current === this.sc) ? this.so : 0;
	                    end = (current === this.ec) ? this.eo : current.length;
	                    if (start != end) {
	                        current.deleteData(start, end - start);
	                    }
	                } else {
	                    if (current.parentNode) {
	                        removeNode(current);
	                    } else {
	                    }
	                }
	            },

	            // Checks if the current node is partially selected
	            isPartiallySelectedSubtree: function() {
	                var current = this._current;
	                return isNonTextPartiallySelected(current, this.range);
	            },

	            getSubtreeIterator: function() {
	                var subRange;
	                if (this.isSingleCharacterDataNode) {
	                    subRange = this.range.cloneRange();
	                    subRange.collapse(false);
	                } else {
	                    subRange = new Range(getRangeDocument(this.range));
	                    var current = this._current;
	                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);

	                    if (isOrIsAncestorOf(current, this.sc)) {
	                        startContainer = this.sc;
	                        startOffset = this.so;
	                    }
	                    if (isOrIsAncestorOf(current, this.ec)) {
	                        endContainer = this.ec;
	                        endOffset = this.eo;
	                    }

	                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
	                }
	                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
	            },

	            detach: function() {
	                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
	            }
	        };

	        /*----------------------------------------------------------------------------------------------------------------*/

	        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
	        var rootContainerNodeTypes = [2, 9, 11];
	        var readonlyNodeTypes = [5, 6, 10, 12];
	        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
	        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];

	        function createAncestorFinder(nodeTypes) {
	            return function(node, selfIsAncestor) {
	                var t, n = selfIsAncestor ? node : node.parentNode;
	                while (n) {
	                    t = n.nodeType;
	                    if (arrayContains(nodeTypes, t)) {
	                        return n;
	                    }
	                    n = n.parentNode;
	                }
	                return null;
	            };
	        }

	        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );
	        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
	        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );

	        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
	            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
	                throw new DOMException("INVALID_NODE_TYPE_ERR");
	            }
	        }

	        function assertValidNodeType(node, invalidTypes) {
	            if (!arrayContains(invalidTypes, node.nodeType)) {
	                throw new DOMException("INVALID_NODE_TYPE_ERR");
	            }
	        }

	        function assertValidOffset(node, offset) {
	            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
	                throw new DOMException("INDEX_SIZE_ERR");
	            }
	        }

	        function assertSameDocumentOrFragment(node1, node2) {
	            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
	                throw new DOMException("WRONG_DOCUMENT_ERR");
	            }
	        }

	        function assertNodeNotReadOnly(node) {
	            if (getReadonlyAncestor(node, true)) {
	                throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");
	            }
	        }

	        function assertNode(node, codeName) {
	            if (!node) {
	                throw new DOMException(codeName);
	            }
	        }

	        function isValidOffset(node, offset) {
	            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
	        }

	        function isRangeValid(range) {
	            return (!!range.startContainer && !!range.endContainer &&
	                    !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&
	                    getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&
	                    isValidOffset(range.startContainer, range.startOffset) &&
	                    isValidOffset(range.endContainer, range.endOffset));
	        }

	        function assertRangeValid(range) {
	            if (!isRangeValid(range)) {
	                throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");
	            }
	        }

	        /*----------------------------------------------------------------------------------------------------------------*/

	        // Test the browser's innerHTML support to decide how to implement createContextualFragment
	        var styleEl = document.createElement("style");
	        var htmlParsingConforms = false;
	        try {
	            styleEl.innerHTML = "<b>x</b>";
	            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node
	        } catch (e) {
	            // IE 6 and 7 throw
	        }

	        api.features.htmlParsingConforms = htmlParsingConforms;

	        var createContextualFragment = htmlParsingConforms ?

	            // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See
	            // discussion and base code for this implementation at issue 67.
	            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface
	            // Thanks to Aleks Williams.
	            function(fragmentStr) {
	                // "Let node the context object's start's node."
	                var node = this.startContainer;
	                var doc = getDocument(node);

	                // "If the context object's start's node is null, raise an INVALID_STATE_ERR
	                // exception and abort these steps."
	                if (!node) {
	                    throw new DOMException("INVALID_STATE_ERR");
	                }

	                // "Let element be as follows, depending on node's interface:"
	                // Document, Document Fragment: null
	                var el = null;

	                // "Element: node"
	                if (node.nodeType == 1) {
	                    el = node;

	                // "Text, Comment: node's parentElement"
	                } else if (isCharacterDataNode(node)) {
	                    el = dom.parentElement(node);
	                }

	                // "If either element is null or element's ownerDocument is an HTML document
	                // and element's local name is "html" and element's namespace is the HTML
	                // namespace"
	                if (el === null || (
	                    el.nodeName == "HTML" &&
	                    dom.isHtmlNamespace(getDocument(el).documentElement) &&
	                    dom.isHtmlNamespace(el)
	                )) {

	                // "let element be a new Element with "body" as its local name and the HTML
	                // namespace as its namespace.""
	                    el = doc.createElement("body");
	                } else {
	                    el = el.cloneNode(false);
	                }

	                // "If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm."
	                // "If the node's document is an XML document: Invoke the XML fragment parsing algorithm."
	                // "In either case, the algorithm must be invoked with fragment as the input
	                // and element as the context element."
	                el.innerHTML = fragmentStr;

	                // "If this raises an exception, then abort these steps. Otherwise, let new
	                // children be the nodes returned."

	                // "Let fragment be a new DocumentFragment."
	                // "Append all new children to fragment."
	                // "Return fragment."
	                return dom.fragmentFromNodeChildren(el);
	            } :

	            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that
	            // previous versions of Rangy used (with the exception of using a body element rather than a div)
	            function(fragmentStr) {
	                var doc = getRangeDocument(this);
	                var el = doc.createElement("body");
	                el.innerHTML = fragmentStr;

	                return dom.fragmentFromNodeChildren(el);
	            };

	        function splitRangeBoundaries(range, positionsToPreserve) {
	            assertRangeValid(range);

	            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
	            var startEndSame = (sc === ec);

	            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
	                splitDataNode(ec, eo, positionsToPreserve);
	            }

	            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
	                sc = splitDataNode(sc, so, positionsToPreserve);
	                if (startEndSame) {
	                    eo -= so;
	                    ec = sc;
	                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
	                    eo++;
	                }
	                so = 0;
	            }
	            range.setStartAndEnd(sc, so, ec, eo);
	        }

	        function rangeToHtml(range) {
	            assertRangeValid(range);
	            var container = range.commonAncestorContainer.parentNode.cloneNode(false);
	            container.appendChild( range.cloneContents() );
	            return container.innerHTML;
	        }

	        /*----------------------------------------------------------------------------------------------------------------*/

	        var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
	            "commonAncestorContainer"];

	        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
	        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;

	        util.extend(api.rangePrototype, {
	            compareBoundaryPoints: function(how, range) {
	                assertRangeValid(this);
	                assertSameDocumentOrFragment(this.startContainer, range.startContainer);

	                var nodeA, offsetA, nodeB, offsetB;
	                var prefixA = (how == e2s || how == s2s) ? "start" : "end";
	                var prefixB = (how == s2e || how == s2s) ? "start" : "end";
	                nodeA = this[prefixA + "Container"];
	                offsetA = this[prefixA + "Offset"];
	                nodeB = range[prefixB + "Container"];
	                offsetB = range[prefixB + "Offset"];
	                return comparePoints(nodeA, offsetA, nodeB, offsetB);
	            },

	            insertNode: function(node) {
	                assertRangeValid(this);
	                assertValidNodeType(node, insertableNodeTypes);
	                assertNodeNotReadOnly(this.startContainer);

	                if (isOrIsAncestorOf(node, this.startContainer)) {
	                    throw new DOMException("HIERARCHY_REQUEST_ERR");
	                }

	                // No check for whether the container of the start of the Range is of a type that does not allow
	                // children of the type of node: the browser's DOM implementation should do this for us when we attempt
	                // to add the node

	                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
	                this.setStartBefore(firstNodeInserted);
	            },

	            cloneContents: function() {
	                assertRangeValid(this);

	                var clone, frag;
	                if (this.collapsed) {
	                    return getRangeDocument(this).createDocumentFragment();
	                } else {
	                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
	                        clone = this.startContainer.cloneNode(true);
	                        clone.data = clone.data.slice(this.startOffset, this.endOffset);
	                        frag = getRangeDocument(this).createDocumentFragment();
	                        frag.appendChild(clone);
	                        return frag;
	                    } else {
	                        var iterator = new RangeIterator(this, true);
	                        clone = cloneSubtree(iterator);
	                        iterator.detach();
	                    }
	                    return clone;
	                }
	            },

	            canSurroundContents: function() {
	                assertRangeValid(this);
	                assertNodeNotReadOnly(this.startContainer);
	                assertNodeNotReadOnly(this.endContainer);

	                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
	                // no non-text nodes.
	                var iterator = new RangeIterator(this, true);
	                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
	                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
	                iterator.detach();
	                return !boundariesInvalid;
	            },

	            surroundContents: function(node) {
	                assertValidNodeType(node, surroundNodeTypes);

	                if (!this.canSurroundContents()) {
	                    throw new DOMException("INVALID_STATE_ERR");
	                }

	                // Extract the contents
	                var content = this.extractContents();

	                // Clear the children of the node
	                if (node.hasChildNodes()) {
	                    while (node.lastChild) {
	                        node.removeChild(node.lastChild);
	                    }
	                }

	                // Insert the new node and add the extracted contents
	                insertNodeAtPosition(node, this.startContainer, this.startOffset);
	                node.appendChild(content);

	                this.selectNode(node);
	            },

	            cloneRange: function() {
	                assertRangeValid(this);
	                var range = new Range(getRangeDocument(this));
	                var i = rangeProperties.length, prop;
	                while (i--) {
	                    prop = rangeProperties[i];
	                    range[prop] = this[prop];
	                }
	                return range;
	            },

	            toString: function() {
	                assertRangeValid(this);
	                var sc = this.startContainer;
	                if (sc === this.endContainer && isCharacterDataNode(sc)) {
	                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";
	                } else {
	                    var textParts = [], iterator = new RangeIterator(this, true);
	                    iterateSubtree(iterator, function(node) {
	                        // Accept only text or CDATA nodes, not comments
	                        if (node.nodeType == 3 || node.nodeType == 4) {
	                            textParts.push(node.data);
	                        }
	                    });
	                    iterator.detach();
	                    return textParts.join("");
	                }
	            },

	            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since
	            // been removed from Mozilla.

	            compareNode: function(node) {
	                assertRangeValid(this);

	                var parent = node.parentNode;
	                var nodeIndex = getNodeIndex(node);

	                if (!parent) {
	                    throw new DOMException("NOT_FOUND_ERR");
	                }

	                var startComparison = this.comparePoint(parent, nodeIndex),
	                    endComparison = this.comparePoint(parent, nodeIndex + 1);

	                if (startComparison < 0) { // Node starts before
	                    return (endComparison > 0) ? n_b_a : n_b;
	                } else {
	                    return (endComparison > 0) ? n_a : n_i;
	                }
	            },

	            comparePoint: function(node, offset) {
	                assertRangeValid(this);
	                assertNode(node, "HIERARCHY_REQUEST_ERR");
	                assertSameDocumentOrFragment(node, this.startContainer);

	                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
	                    return -1;
	                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
	                    return 1;
	                }
	                return 0;
	            },

	            createContextualFragment: createContextualFragment,

	            toHtml: function() {
	                return rangeToHtml(this);
	            },

	            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects
	            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)
	            intersectsNode: function(node, touchingIsIntersecting) {
	                assertRangeValid(this);
	                if (getRootContainer(node) != getRangeRoot(this)) {
	                    return false;
	                }

	                var parent = node.parentNode, offset = getNodeIndex(node);
	                if (!parent) {
	                    return true;
	                }

	                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),
	                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);

	                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
	            },

	            isPointInRange: function(node, offset) {
	                assertRangeValid(this);
	                assertNode(node, "HIERARCHY_REQUEST_ERR");
	                assertSameDocumentOrFragment(node, this.startContainer);

	                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&
	                       (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);
	            },

	            // The methods below are non-standard and invented by me.

	            // Sharing a boundary start-to-end or end-to-start does not count as intersection.
	            intersectsRange: function(range) {
	                return rangesIntersect(this, range, false);
	            },

	            // Sharing a boundary start-to-end or end-to-start does count as intersection.
	            intersectsOrTouchesRange: function(range) {
	                return rangesIntersect(this, range, true);
	            },

	            intersection: function(range) {
	                if (this.intersectsRange(range)) {
	                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),
	                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);

	                    var intersectionRange = this.cloneRange();
	                    if (startComparison == -1) {
	                        intersectionRange.setStart(range.startContainer, range.startOffset);
	                    }
	                    if (endComparison == 1) {
	                        intersectionRange.setEnd(range.endContainer, range.endOffset);
	                    }
	                    return intersectionRange;
	                }
	                return null;
	            },

	            union: function(range) {
	                if (this.intersectsOrTouchesRange(range)) {
	                    var unionRange = this.cloneRange();
	                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
	                        unionRange.setStart(range.startContainer, range.startOffset);
	                    }
	                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
	                        unionRange.setEnd(range.endContainer, range.endOffset);
	                    }
	                    return unionRange;
	                } else {
	                    throw new DOMException("Ranges do not intersect");
	                }
	            },

	            containsNode: function(node, allowPartial) {
	                if (allowPartial) {
	                    return this.intersectsNode(node, false);
	                } else {
	                    return this.compareNode(node) == n_i;
	                }
	            },

	            containsNodeContents: function(node) {
	                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
	            },

	            containsRange: function(range) {
	                var intersection = this.intersection(range);
	                return intersection !== null && range.equals(intersection);
	            },

	            containsNodeText: function(node) {
	                var nodeRange = this.cloneRange();
	                nodeRange.selectNode(node);
	                var textNodes = nodeRange.getNodes([3]);
	                if (textNodes.length > 0) {
	                    nodeRange.setStart(textNodes[0], 0);
	                    var lastTextNode = textNodes.pop();
	                    nodeRange.setEnd(lastTextNode, lastTextNode.length);
	                    return this.containsRange(nodeRange);
	                } else {
	                    return this.containsNodeContents(node);
	                }
	            },

	            getNodes: function(nodeTypes, filter) {
	                assertRangeValid(this);
	                return getNodesInRange(this, nodeTypes, filter);
	            },

	            getDocument: function() {
	                return getRangeDocument(this);
	            },

	            collapseBefore: function(node) {
	                this.setEndBefore(node);
	                this.collapse(false);
	            },

	            collapseAfter: function(node) {
	                this.setStartAfter(node);
	                this.collapse(true);
	            },

	            getBookmark: function(containerNode) {
	                var doc = getRangeDocument(this);
	                var preSelectionRange = api.createRange(doc);
	                containerNode = containerNode || dom.getBody(doc);
	                preSelectionRange.selectNodeContents(containerNode);
	                var range = this.intersection(preSelectionRange);
	                var start = 0, end = 0;
	                if (range) {
	                    preSelectionRange.setEnd(range.startContainer, range.startOffset);
	                    start = preSelectionRange.toString().length;
	                    end = start + range.toString().length;
	                }

	                return {
	                    start: start,
	                    end: end,
	                    containerNode: containerNode
	                };
	            },

	            moveToBookmark: function(bookmark) {
	                var containerNode = bookmark.containerNode;
	                var charIndex = 0;
	                this.setStart(containerNode, 0);
	                this.collapse(true);
	                var nodeStack = [containerNode], node, foundStart = false, stop = false;
	                var nextCharIndex, i, childNodes;

	                while (!stop && (node = nodeStack.pop())) {
	                    if (node.nodeType == 3) {
	                        nextCharIndex = charIndex + node.length;
	                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
	                            this.setStart(node, bookmark.start - charIndex);
	                            foundStart = true;
	                        }
	                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
	                            this.setEnd(node, bookmark.end - charIndex);
	                            stop = true;
	                        }
	                        charIndex = nextCharIndex;
	                    } else {
	                        childNodes = node.childNodes;
	                        i = childNodes.length;
	                        while (i--) {
	                            nodeStack.push(childNodes[i]);
	                        }
	                    }
	                }
	            },

	            getName: function() {
	                return "DomRange";
	            },

	            equals: function(range) {
	                return Range.rangesEqual(this, range);
	            },

	            isValid: function() {
	                return isRangeValid(this);
	            },

	            inspect: function() {
	                return inspect(this);
	            },

	            detach: function() {
	                // In DOM4, detach() is now a no-op.
	            }
	        });

	        function copyComparisonConstantsToObject(obj) {
	            obj.START_TO_START = s2s;
	            obj.START_TO_END = s2e;
	            obj.END_TO_END = e2e;
	            obj.END_TO_START = e2s;

	            obj.NODE_BEFORE = n_b;
	            obj.NODE_AFTER = n_a;
	            obj.NODE_BEFORE_AND_AFTER = n_b_a;
	            obj.NODE_INSIDE = n_i;
	        }

	        function copyComparisonConstants(constructor) {
	            copyComparisonConstantsToObject(constructor);
	            copyComparisonConstantsToObject(constructor.prototype);
	        }

	        function createRangeContentRemover(remover, boundaryUpdater) {
	            return function() {
	                assertRangeValid(this);

	                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;

	                var iterator = new RangeIterator(this, true);

	                // Work out where to position the range after content removal
	                var node, boundary;
	                if (sc !== root) {
	                    node = getClosestAncestorIn(sc, root, true);
	                    boundary = getBoundaryAfterNode(node);
	                    sc = boundary.node;
	                    so = boundary.offset;
	                }

	                // Check none of the range is read-only
	                iterateSubtree(iterator, assertNodeNotReadOnly);

	                iterator.reset();

	                // Remove the content
	                var returnValue = remover(iterator);
	                iterator.detach();

	                // Move to the new position
	                boundaryUpdater(this, sc, so, sc, so);

	                return returnValue;
	            };
	        }

	        function createPrototypeRange(constructor, boundaryUpdater) {
	            function createBeforeAfterNodeSetter(isBefore, isStart) {
	                return function(node) {
	                    assertValidNodeType(node, beforeAfterNodeTypes);
	                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);

	                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
	                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
	                };
	            }

	            function setRangeStart(range, node, offset) {
	                var ec = range.endContainer, eo = range.endOffset;
	                if (node !== range.startContainer || offset !== range.startOffset) {
	                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
	                    // is after the current end. In either case, collapse the range to the new position
	                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
	                        ec = node;
	                        eo = offset;
	                    }
	                    boundaryUpdater(range, node, offset, ec, eo);
	                }
	            }

	            function setRangeEnd(range, node, offset) {
	                var sc = range.startContainer, so = range.startOffset;
	                if (node !== range.endContainer || offset !== range.endOffset) {
	                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
	                    // is after the current end. In either case, collapse the range to the new position
	                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
	                        sc = node;
	                        so = offset;
	                    }
	                    boundaryUpdater(range, sc, so, node, offset);
	                }
	            }

	            // Set up inheritance
	            var F = function() {};
	            F.prototype = api.rangePrototype;
	            constructor.prototype = new F();

	            util.extend(constructor.prototype, {
	                setStart: function(node, offset) {
	                    assertNoDocTypeNotationEntityAncestor(node, true);
	                    assertValidOffset(node, offset);

	                    setRangeStart(this, node, offset);
	                },

	                setEnd: function(node, offset) {
	                    assertNoDocTypeNotationEntityAncestor(node, true);
	                    assertValidOffset(node, offset);

	                    setRangeEnd(this, node, offset);
	                },

	                /**
	                 * Convenience method to set a range's start and end boundaries. Overloaded as follows:
	                 * - Two parameters (node, offset) creates a collapsed range at that position
	                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at
	                 *   startOffset and ending at endOffset
	                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in
	                 *   startNode and ending at endOffset in endNode
	                 */
	                setStartAndEnd: function() {
	                    var args = arguments;
	                    var sc = args[0], so = args[1], ec = sc, eo = so;

	                    switch (args.length) {
	                        case 3:
	                            eo = args[2];
	                            break;
	                        case 4:
	                            ec = args[2];
	                            eo = args[3];
	                            break;
	                    }

	                    boundaryUpdater(this, sc, so, ec, eo);
	                },

	                setBoundary: function(node, offset, isStart) {
	                    this["set" + (isStart ? "Start" : "End")](node, offset);
	                },

	                setStartBefore: createBeforeAfterNodeSetter(true, true),
	                setStartAfter: createBeforeAfterNodeSetter(false, true),
	                setEndBefore: createBeforeAfterNodeSetter(true, false),
	                setEndAfter: createBeforeAfterNodeSetter(false, false),

	                collapse: function(isStart) {
	                    assertRangeValid(this);
	                    if (isStart) {
	                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
	                    } else {
	                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
	                    }
	                },

	                selectNodeContents: function(node) {
	                    assertNoDocTypeNotationEntityAncestor(node, true);

	                    boundaryUpdater(this, node, 0, node, getNodeLength(node));
	                },

	                selectNode: function(node) {
	                    assertNoDocTypeNotationEntityAncestor(node, false);
	                    assertValidNodeType(node, beforeAfterNodeTypes);

	                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
	                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
	                },

	                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),

	                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),

	                canSurroundContents: function() {
	                    assertRangeValid(this);
	                    assertNodeNotReadOnly(this.startContainer);
	                    assertNodeNotReadOnly(this.endContainer);

	                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
	                    // no non-text nodes.
	                    var iterator = new RangeIterator(this, true);
	                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||
	                            (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
	                    iterator.detach();
	                    return !boundariesInvalid;
	                },

	                splitBoundaries: function() {
	                    splitRangeBoundaries(this);
	                },

	                splitBoundariesPreservingPositions: function(positionsToPreserve) {
	                    splitRangeBoundaries(this, positionsToPreserve);
	                },

	                normalizeBoundaries: function() {
	                    assertRangeValid(this);

	                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;

	                    var mergeForward = function(node) {
	                        var sibling = node.nextSibling;
	                        if (sibling && sibling.nodeType == node.nodeType) {
	                            ec = node;
	                            eo = node.length;
	                            node.appendData(sibling.data);
	                            removeNode(sibling);
	                        }
	                    };

	                    var mergeBackward = function(node) {
	                        var sibling = node.previousSibling;
	                        if (sibling && sibling.nodeType == node.nodeType) {
	                            sc = node;
	                            var nodeLength = node.length;
	                            so = sibling.length;
	                            node.insertData(0, sibling.data);
	                            removeNode(sibling);
	                            if (sc == ec) {
	                                eo += so;
	                                ec = sc;
	                            } else if (ec == node.parentNode) {
	                                var nodeIndex = getNodeIndex(node);
	                                if (eo == nodeIndex) {
	                                    ec = node;
	                                    eo = nodeLength;
	                                } else if (eo > nodeIndex) {
	                                    eo--;
	                                }
	                            }
	                        }
	                    };

	                    var normalizeStart = true;
	                    var sibling;

	                    if (isCharacterDataNode(ec)) {
	                        if (eo == ec.length) {
	                            mergeForward(ec);
	                        } else if (eo == 0) {
	                            sibling = ec.previousSibling;
	                            if (sibling && sibling.nodeType == ec.nodeType) {
	                                eo = sibling.length;
	                                if (sc == ec) {
	                                    normalizeStart = false;
	                                }
	                                sibling.appendData(ec.data);
	                                removeNode(ec);
	                                ec = sibling;
	                            }
	                        }
	                    } else {
	                        if (eo > 0) {
	                            var endNode = ec.childNodes[eo - 1];
	                            if (endNode && isCharacterDataNode(endNode)) {
	                                mergeForward(endNode);
	                            }
	                        }
	                        normalizeStart = !this.collapsed;
	                    }

	                    if (normalizeStart) {
	                        if (isCharacterDataNode(sc)) {
	                            if (so == 0) {
	                                mergeBackward(sc);
	                            } else if (so == sc.length) {
	                                sibling = sc.nextSibling;
	                                if (sibling && sibling.nodeType == sc.nodeType) {
	                                    if (ec == sibling) {
	                                        ec = sc;
	                                        eo += sc.length;
	                                    }
	                                    sc.appendData(sibling.data);
	                                    removeNode(sibling);
	                                }
	                            }
	                        } else {
	                            if (so < sc.childNodes.length) {
	                                var startNode = sc.childNodes[so];
	                                if (startNode && isCharacterDataNode(startNode)) {
	                                    mergeBackward(startNode);
	                                }
	                            }
	                        }
	                    } else {
	                        sc = ec;
	                        so = eo;
	                    }

	                    boundaryUpdater(this, sc, so, ec, eo);
	                },

	                collapseToPoint: function(node, offset) {
	                    assertNoDocTypeNotationEntityAncestor(node, true);
	                    assertValidOffset(node, offset);
	                    this.setStartAndEnd(node, offset);
	                }
	            });

	            copyComparisonConstants(constructor);
	        }

	        /*----------------------------------------------------------------------------------------------------------------*/

	        // Updates commonAncestorContainer and collapsed after boundary change
	        function updateCollapsedAndCommonAncestor(range) {
	            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
	            range.commonAncestorContainer = range.collapsed ?
	                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
	        }

	        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
	            range.startContainer = startContainer;
	            range.startOffset = startOffset;
	            range.endContainer = endContainer;
	            range.endOffset = endOffset;
	            range.document = dom.getDocument(startContainer);

	            updateCollapsedAndCommonAncestor(range);
	        }

	        function Range(doc) {
	            this.startContainer = doc;
	            this.startOffset = 0;
	            this.endContainer = doc;
	            this.endOffset = 0;
	            this.document = doc;
	            updateCollapsedAndCommonAncestor(this);
	        }

	        createPrototypeRange(Range, updateBoundaries);

	        util.extend(Range, {
	            rangeProperties: rangeProperties,
	            RangeIterator: RangeIterator,
	            copyComparisonConstants: copyComparisonConstants,
	            createPrototypeRange: createPrototypeRange,
	            inspect: inspect,
	            toHtml: rangeToHtml,
	            getRangeDocument: getRangeDocument,
	            rangesEqual: function(r1, r2) {
	                return r1.startContainer === r2.startContainer &&
	                    r1.startOffset === r2.startOffset &&
	                    r1.endContainer === r2.endContainer &&
	                    r1.endOffset === r2.endOffset;
	            }
	        });

	        api.DomRange = Range;
	    });

	    /*----------------------------------------------------------------------------------------------------------------*/

	    // Wrappers for the browser's native DOM Range and/or TextRange implementation
	    api.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {
	        var WrappedRange, WrappedTextRange;
	        var dom = api.dom;
	        var util = api.util;
	        var DomPosition = dom.DomPosition;
	        var DomRange = api.DomRange;
	        var getBody = dom.getBody;
	        var getContentDocument = dom.getContentDocument;
	        var isCharacterDataNode = dom.isCharacterDataNode;


	        /*----------------------------------------------------------------------------------------------------------------*/

	        if (api.features.implementsDomRange) {
	            // This is a wrapper around the browser's native DOM Range. It has two aims:
	            // - Provide workarounds for specific browser bugs
	            // - provide convenient extensions, which are inherited from Rangy's DomRange

	            (function() {
	                var rangeProto;
	                var rangeProperties = DomRange.rangeProperties;

	                function updateRangeProperties(range) {
	                    var i = rangeProperties.length, prop;
	                    while (i--) {
	                        prop = rangeProperties[i];
	                        range[prop] = range.nativeRange[prop];
	                    }
	                    // Fix for broken collapsed property in IE 9.
	                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
	                }

	                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {
	                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);
	                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);
	                    var nativeRangeDifferent = !range.equals(range.nativeRange);

	                    // Always set both boundaries for the benefit of IE9 (see issue 35)
	                    if (startMoved || endMoved || nativeRangeDifferent) {
	                        range.setEnd(endContainer, endOffset);
	                        range.setStart(startContainer, startOffset);
	                    }
	                }

	                var createBeforeAfterNodeSetter;

	                WrappedRange = function(range) {
	                    if (!range) {
	                        throw module.createError("WrappedRange: Range must be specified");
	                    }
	                    this.nativeRange = range;
	                    updateRangeProperties(this);
	                };

	                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);

	                rangeProto = WrappedRange.prototype;

	                rangeProto.selectNode = function(node) {
	                    this.nativeRange.selectNode(node);
	                    updateRangeProperties(this);
	                };

	                rangeProto.cloneContents = function() {
	                    return this.nativeRange.cloneContents();
	                };

	                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,
	                // insertNode() is never delegated to the native range.

	                rangeProto.surroundContents = function(node) {
	                    this.nativeRange.surroundContents(node);
	                    updateRangeProperties(this);
	                };

	                rangeProto.collapse = function(isStart) {
	                    this.nativeRange.collapse(isStart);
	                    updateRangeProperties(this);
	                };

	                rangeProto.cloneRange = function() {
	                    return new WrappedRange(this.nativeRange.cloneRange());
	                };

	                rangeProto.refresh = function() {
	                    updateRangeProperties(this);
	                };

	                rangeProto.toString = function() {
	                    return this.nativeRange.toString();
	                };

	                // Create test range and node for feature detection

	                var testTextNode = document.createTextNode("test");
	                getBody(document).appendChild(testTextNode);
	                var range = document.createRange();

	                /*--------------------------------------------------------------------------------------------------------*/

	                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and
	                // correct for it

	                range.setStart(testTextNode, 0);
	                range.setEnd(testTextNode, 0);

	                try {
	                    range.setStart(testTextNode, 1);

	                    rangeProto.setStart = function(node, offset) {
	                        this.nativeRange.setStart(node, offset);
	                        updateRangeProperties(this);
	                    };

	                    rangeProto.setEnd = function(node, offset) {
	                        this.nativeRange.setEnd(node, offset);
	                        updateRangeProperties(this);
	                    };

	                    createBeforeAfterNodeSetter = function(name) {
	                        return function(node) {
	                            this.nativeRange[name](node);
	                            updateRangeProperties(this);
	                        };
	                    };

	                } catch(ex) {

	                    rangeProto.setStart = function(node, offset) {
	                        try {
	                            this.nativeRange.setStart(node, offset);
	                        } catch (ex) {
	                            this.nativeRange.setEnd(node, offset);
	                            this.nativeRange.setStart(node, offset);
	                        }
	                        updateRangeProperties(this);
	                    };

	                    rangeProto.setEnd = function(node, offset) {
	                        try {
	                            this.nativeRange.setEnd(node, offset);
	                        } catch (ex) {
	                            this.nativeRange.setStart(node, offset);
	                            this.nativeRange.setEnd(node, offset);
	                        }
	                        updateRangeProperties(this);
	                    };

	                    createBeforeAfterNodeSetter = function(name, oppositeName) {
	                        return function(node) {
	                            try {
	                                this.nativeRange[name](node);
	                            } catch (ex) {
	                                this.nativeRange[oppositeName](node);
	                                this.nativeRange[name](node);
	                            }
	                            updateRangeProperties(this);
	                        };
	                    };
	                }

	                rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
	                rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
	                rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
	                rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");

	                /*--------------------------------------------------------------------------------------------------------*/

	                // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing
	                // whether the native implementation can be trusted
	                rangeProto.selectNodeContents = function(node) {
	                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));
	                };

	                /*--------------------------------------------------------------------------------------------------------*/

	                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for
	                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738

	                range.selectNodeContents(testTextNode);
	                range.setEnd(testTextNode, 3);

	                var range2 = document.createRange();
	                range2.selectNodeContents(testTextNode);
	                range2.setEnd(testTextNode, 4);
	                range2.setStart(testTextNode, 2);

	                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&
	                        range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
	                    // This is the wrong way round, so correct for it

	                    rangeProto.compareBoundaryPoints = function(type, range) {
	                        range = range.nativeRange || range;
	                        if (type == range.START_TO_END) {
	                            type = range.END_TO_START;
	                        } else if (type == range.END_TO_START) {
	                            type = range.START_TO_END;
	                        }
	                        return this.nativeRange.compareBoundaryPoints(type, range);
	                    };
	                } else {
	                    rangeProto.compareBoundaryPoints = function(type, range) {
	                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
	                    };
	                }

	                /*--------------------------------------------------------------------------------------------------------*/

	                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.

	                var el = document.createElement("div");
	                el.innerHTML = "123";
	                var textNode = el.firstChild;
	                var body = getBody(document);
	                body.appendChild(el);

	                range.setStart(textNode, 1);
	                range.setEnd(textNode, 2);
	                range.deleteContents();

	                if (textNode.data == "13") {
	                    // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and
	                    // extractContents()
	                    rangeProto.deleteContents = function() {
	                        this.nativeRange.deleteContents();
	                        updateRangeProperties(this);
	                    };

	                    rangeProto.extractContents = function() {
	                        var frag = this.nativeRange.extractContents();
	                        updateRangeProperties(this);
	                        return frag;
	                    };
	                } else {
	                }

	                body.removeChild(el);
	                body = null;

	                /*--------------------------------------------------------------------------------------------------------*/

	                // Test for existence of createContextualFragment and delegate to it if it exists
	                if (util.isHostMethod(range, "createContextualFragment")) {
	                    rangeProto.createContextualFragment = function(fragmentStr) {
	                        return this.nativeRange.createContextualFragment(fragmentStr);
	                    };
	                }

	                /*--------------------------------------------------------------------------------------------------------*/

	                // Clean up
	                getBody(document).removeChild(testTextNode);

	                rangeProto.getName = function() {
	                    return "WrappedRange";
	                };

	                api.WrappedRange = WrappedRange;

	                api.createNativeRange = function(doc) {
	                    doc = getContentDocument(doc, module, "createNativeRange");
	                    return doc.createRange();
	                };
	            })();
	        }

	        if (api.features.implementsTextRange) {
	            /*
	            This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()
	            method. For example, in the following (where pipes denote the selection boundaries):

	            <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>

	            var range = document.selection.createRange();
	            alert(range.parentElement().id); // Should alert "ul" but alerts "b"

	            This method returns the common ancestor node of the following:
	            - the parentElement() of the textRange
	            - the parentElement() of the textRange after calling collapse(true)
	            - the parentElement() of the textRange after calling collapse(false)
	            */
	            var getTextRangeContainerElement = function(textRange) {
	                var parentEl = textRange.parentElement();
	                var range = textRange.duplicate();
	                range.collapse(true);
	                var startEl = range.parentElement();
	                range = textRange.duplicate();
	                range.collapse(false);
	                var endEl = range.parentElement();
	                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);

	                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
	            };

	            var textRangeIsCollapsed = function(textRange) {
	                return textRange.compareEndPoints("StartToEnd", textRange) == 0;
	            };

	            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started
	            // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)
	            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange
	            // bugs, handling for inputs and images, plus optimizations.
	            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
	                var workingRange = textRange.duplicate();
	                workingRange.collapse(isStart);
	                var containerElement = workingRange.parentElement();

	                // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so
	                // check for that
	                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
	                    containerElement = wholeRangeContainerElement;
	                }


	                // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and
	                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx
	                if (!containerElement.canHaveHTML) {
	                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
	                    return {
	                        boundaryPosition: pos,
	                        nodeInfo: {
	                            nodeIndex: pos.offset,
	                            containerElement: pos.node
	                        }
	                    };
	                }

	                var workingNode = dom.getDocument(containerElement).createElement("span");

	                // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5
	                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64
	                if (workingNode.parentNode) {
	                    dom.removeNode(workingNode);
	                }

	                var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
	                var previousNode, nextNode, boundaryPosition, boundaryNode;
	                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;
	                var childNodeCount = containerElement.childNodes.length;
	                var end = childNodeCount;

	                // Check end first. Code within the loop assumes that the endth child node of the container is definitely
	                // after the range boundary.
	                var nodeIndex = end;

	                while (true) {
	                    if (nodeIndex == childNodeCount) {
	                        containerElement.appendChild(workingNode);
	                    } else {
	                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
	                    }
	                    workingRange.moveToElementText(workingNode);
	                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
	                    if (comparison == 0 || start == end) {
	                        break;
	                    } else if (comparison == -1) {
	                        if (end == start + 1) {
	                            // We know the endth child node is after the range boundary, so we must be done.
	                            break;
	                        } else {
	                            start = nodeIndex;
	                        }
	                    } else {
	                        end = (end == start + 1) ? start : nodeIndex;
	                    }
	                    nodeIndex = Math.floor((start + end) / 2);
	                    containerElement.removeChild(workingNode);
	                }


	                // We've now reached or gone past the boundary of the text range we're interested in
	                // so have identified the node we want
	                boundaryNode = workingNode.nextSibling;

	                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
	                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of
	                    // the node containing the text range's boundary, so we move the end of the working range to the
	                    // boundary point and measure the length of its text to get the boundary's offset within the node.
	                    workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);

	                    var offset;

	                    if (/[\r\n]/.test(boundaryNode.data)) {
	                        /*
	                        For the particular case of a boundary within a text node containing rendered line breaks (within a
	                        <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in
	                        IE. The facts:

	                        - Each line break is represented as \r in the text node's data/nodeValue properties
	                        - Each line break is represented as \r\n in the TextRange's 'text' property
	                        - The 'text' property of the TextRange does not contain trailing line breaks

	                        To get round the problem presented by the final fact above, we can use the fact that TextRange's
	                        moveStart() and moveEnd() methods return the actual number of characters moved, which is not
	                        necessarily the same as the number of characters it was instructed to move. The simplest approach is
	                        to use this to store the characters moved when moving both the start and end of the range to the
	                        start of the document body and subtracting the start offset from the end offset (the
	                        "move-negative-gazillion" method). However, this is extremely slow when the document is large and
	                        the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to
	                        the end of the document) has the same problem.

	                        Another approach that works is to use moveStart() to move the start boundary of the range up to the
	                        end boundary one character at a time and incrementing a counter with the value returned by the
	                        moveStart() call. However, the check for whether the start boundary has reached the end boundary is
	                        expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected
	                        by the location of the range within the document).

	                        The approach used below is a hybrid of the two methods above. It uses the fact that a string
	                        containing the TextRange's 'text' property with each \r\n converted to a single \r character cannot
	                        be longer than the text of the TextRange, so the start of the range is moved that length initially
	                        and then a character at a time to make up for any trailing line breaks not contained in the 'text'
	                        property. This has good performance in most situations compared to the previous two methods.
	                        */
	                        var tempRange = workingRange.duplicate();
	                        var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;

	                        offset = tempRange.moveStart("character", rangeLength);
	                        while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
	                            offset++;
	                            tempRange.moveStart("character", 1);
	                        }
	                    } else {
	                        offset = workingRange.text.length;
	                    }
	                    boundaryPosition = new DomPosition(boundaryNode, offset);
	                } else {

	                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour
	                    // a position within that, and likewise for a start boundary preceding a character data node
	                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
	                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
	                    if (nextNode && isCharacterDataNode(nextNode)) {
	                        boundaryPosition = new DomPosition(nextNode, 0);
	                    } else if (previousNode && isCharacterDataNode(previousNode)) {
	                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
	                    } else {
	                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
	                    }
	                }

	                // Clean up
	                dom.removeNode(workingNode);

	                return {
	                    boundaryPosition: boundaryPosition,
	                    nodeInfo: {
	                        nodeIndex: nodeIndex,
	                        containerElement: containerElement
	                    }
	                };
	            };

	            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that
	            // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange
	            // (http://code.google.com/p/ierange/)
	            var createBoundaryTextRange = function(boundaryPosition, isStart) {
	                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
	                var doc = dom.getDocument(boundaryPosition.node);
	                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();
	                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);

	                if (nodeIsDataNode) {
	                    boundaryNode = boundaryPosition.node;
	                    boundaryParent = boundaryNode.parentNode;
	                } else {
	                    childNodes = boundaryPosition.node.childNodes;
	                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;
	                    boundaryParent = boundaryPosition.node;
	                }

	                // Position the range immediately before the node containing the boundary
	                workingNode = doc.createElement("span");

	                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within
	                // the element rather than immediately before or after it
	                workingNode.innerHTML = "&#feff;";

	                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report
	                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12
	                if (boundaryNode) {
	                    boundaryParent.insertBefore(workingNode, boundaryNode);
	                } else {
	                    boundaryParent.appendChild(workingNode);
	                }

	                workingRange.moveToElementText(workingNode);
	                workingRange.collapse(!isStart);

	                // Clean up
	                boundaryParent.removeChild(workingNode);

	                // Move the working range to the text offset, if required
	                if (nodeIsDataNode) {
	                    workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
	                }

	                return workingRange;
	            };

	            /*------------------------------------------------------------------------------------------------------------*/

	            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a
	            // prototype

	            WrappedTextRange = function(textRange) {
	                this.textRange = textRange;
	                this.refresh();
	            };

	            WrappedTextRange.prototype = new DomRange(document);

	            WrappedTextRange.prototype.refresh = function() {
	                var start, end, startBoundary;

	                // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.
	                var rangeContainerElement = getTextRangeContainerElement(this.textRange);

	                if (textRangeIsCollapsed(this.textRange)) {
	                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,
	                        true).boundaryPosition;
	                } else {
	                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
	                    start = startBoundary.boundaryPosition;

	                    // An optimization used here is that if the start and end boundaries have the same parent element, the
	                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes
	                    // the start boundary
	                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,
	                        startBoundary.nodeInfo).boundaryPosition;
	                }

	                this.setStart(start.node, start.offset);
	                this.setEnd(end.node, end.offset);
	            };

	            WrappedTextRange.prototype.getName = function() {
	                return "WrappedTextRange";
	            };

	            DomRange.copyComparisonConstants(WrappedTextRange);

	            var rangeToTextRange = function(range) {
	                if (range.collapsed) {
	                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
	                } else {
	                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
	                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
	                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();
	                    textRange.setEndPoint("StartToStart", startRange);
	                    textRange.setEndPoint("EndToEnd", endRange);
	                    return textRange;
	                }
	            };

	            WrappedTextRange.rangeToTextRange = rangeToTextRange;

	            WrappedTextRange.prototype.toTextRange = function() {
	                return rangeToTextRange(this);
	            };

	            api.WrappedTextRange = WrappedTextRange;

	            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which
	            // implementation to use by default.
	            if (!api.features.implementsDomRange || api.config.preferTextRange) {
	                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work
	                var globalObj = (function(f) { return f("return this;")(); })(Function);
	                if (typeof globalObj.Range == "undefined") {
	                    globalObj.Range = WrappedTextRange;
	                }

	                api.createNativeRange = function(doc) {
	                    doc = getContentDocument(doc, module, "createNativeRange");
	                    return getBody(doc).createTextRange();
	                };

	                api.WrappedRange = WrappedTextRange;
	            }
	        }

	        api.createRange = function(doc) {
	            doc = getContentDocument(doc, module, "createRange");
	            return new api.WrappedRange(api.createNativeRange(doc));
	        };

	        api.createRangyRange = function(doc) {
	            doc = getContentDocument(doc, module, "createRangyRange");
	            return new DomRange(doc);
	        };

	        util.createAliasForDeprecatedMethod(api, "createIframeRange", "createRange");
	        util.createAliasForDeprecatedMethod(api, "createIframeRangyRange", "createRangyRange");

	        api.addShimListener(function(win) {
	            var doc = win.document;
	            if (typeof doc.createRange == "undefined") {
	                doc.createRange = function() {
	                    return api.createRange(doc);
	                };
	            }
	            doc = win = null;
	        });
	    });

	    /*----------------------------------------------------------------------------------------------------------------*/

	    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification
	    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)
	    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {
	        api.config.checkSelectionRanges = true;

	        var BOOLEAN = "boolean";
	        var NUMBER = "number";
	        var dom = api.dom;
	        var util = api.util;
	        var isHostMethod = util.isHostMethod;
	        var DomRange = api.DomRange;
	        var WrappedRange = api.WrappedRange;
	        var DOMException = api.DOMException;
	        var DomPosition = dom.DomPosition;
	        var getNativeSelection;
	        var selectionIsCollapsed;
	        var features = api.features;
	        var CONTROL = "Control";
	        var getDocument = dom.getDocument;
	        var getBody = dom.getBody;
	        var rangesEqual = DomRange.rangesEqual;


	        // Utility function to support direction parameters in the API that may be a string ("backward", "backwards",
	        // "forward" or "forwards") or a Boolean (true for backwards).
	        function isDirectionBackward(dir) {
	            return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;
	        }

	        function getWindow(win, methodName) {
	            if (!win) {
	                return window;
	            } else if (dom.isWindow(win)) {
	                return win;
	            } else if (win instanceof WrappedSelection) {
	                return win.win;
	            } else {
	                var doc = dom.getContentDocument(win, module, methodName);
	                return dom.getWindow(doc);
	            }
	        }

	        function getWinSelection(winParam) {
	            return getWindow(winParam, "getWinSelection").getSelection();
	        }

	        function getDocSelection(winParam) {
	            return getWindow(winParam, "getDocSelection").document.selection;
	        }

	        function winSelectionIsBackward(sel) {
	            var backward = false;
	            if (sel.anchorNode) {
	                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);
	            }
	            return backward;
	        }

	        // Test for the Range/TextRange and Selection features required
	        // Test for ability to retrieve selection
	        var implementsWinGetSelection = isHostMethod(window, "getSelection"),
	            implementsDocSelection = util.isHostObject(document, "selection");

	        features.implementsWinGetSelection = implementsWinGetSelection;
	        features.implementsDocSelection = implementsDocSelection;

	        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);

	        if (useDocumentSelection) {
	            getNativeSelection = getDocSelection;
	            api.isSelectionValid = function(winParam) {
	                var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;

	                // Check whether the selection TextRange is actually contained within the correct document
	                return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);
	            };
	        } else if (implementsWinGetSelection) {
	            getNativeSelection = getWinSelection;
	            api.isSelectionValid = function() {
	                return true;
	            };
	        } else {
	            module.fail("Neither document.selection or window.getSelection() detected.");
	            return false;
	        }

	        api.getNativeSelection = getNativeSelection;

	        var testSelection = getNativeSelection();

	        // In Firefox, the selection is null in an iframe with display: none. See issue #138.
	        if (!testSelection) {
	            module.fail("Native selection was null (possibly issue 138?)");
	            return false;
	        }

	        var testRange = api.createNativeRange(document);
	        var body = getBody(document);

	        // Obtaining a range from a selection
	        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,
	            ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);

	        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;

	        // Test for existence of native selection extend() method
	        var selectionHasExtend = isHostMethod(testSelection, "extend");
	        features.selectionHasExtend = selectionHasExtend;

	        // Test if rangeCount exists
	        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);
	        features.selectionHasRangeCount = selectionHasRangeCount;

	        var selectionSupportsMultipleRanges = false;
	        var collapsedNonEditableSelectionsSupported = true;

	        var addRangeBackwardToNative = selectionHasExtend ?
	            function(nativeSelection, range) {
	                var doc = DomRange.getRangeDocument(range);
	                var endRange = api.createRange(doc);
	                endRange.collapseToPoint(range.endContainer, range.endOffset);
	                nativeSelection.addRange(getNativeRange(endRange));
	                nativeSelection.extend(range.startContainer, range.startOffset);
	            } : null;

	        if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&
	                typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {

	            (function() {
	                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are
	                // performed on the current document's selection. See issue 109.

	                // Note also that if a selection previously existed, it is wiped and later restored by these tests. This
	                // will result in the selection direction begin reversed if the original selection was backwards and the
	                // browser does not support setting backwards selections (Internet Explorer, I'm looking at you).
	                var sel = window.getSelection();
	                if (sel) {
	                    // Store the current selection
	                    var originalSelectionRangeCount = sel.rangeCount;
	                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);
	                    var originalSelectionRanges = [];
	                    var originalSelectionBackward = winSelectionIsBackward(sel);
	                    for (var i = 0; i < originalSelectionRangeCount; ++i) {
	                        originalSelectionRanges[i] = sel.getRangeAt(i);
	                    }

	                    // Create some test elements
	                    var testEl = dom.createTestElement(document, "", false);
	                    var textNode = testEl.appendChild( document.createTextNode("\u00a0\u00a0\u00a0") );

	                    // Test whether the native selection will allow a collapsed selection within a non-editable element
	                    var r1 = document.createRange();

	                    r1.setStart(textNode, 1);
	                    r1.collapse(true);
	                    sel.removeAllRanges();
	                    sel.addRange(r1);
	                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);
	                    sel.removeAllRanges();

	                    // Test whether the native selection is capable of supporting multiple ranges.
	                    if (!selectionHasMultipleRanges) {
	                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a
	                        // console error of "Discontiguous selection is not supported." that cannot be suppressed. There's
	                        // nothing we can do about this while retaining the feature test so we have to resort to a browser
	                        // sniff. I'm not happy about it. See
	                        // https://code.google.com/p/chromium/issues/detail?id=399791
	                        var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
	                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
	                            selectionSupportsMultipleRanges = false;
	                        } else {
	                            var r2 = r1.cloneRange();
	                            r1.setStart(textNode, 0);
	                            r2.setEnd(textNode, 3);
	                            r2.setStart(textNode, 2);
	                            sel.addRange(r1);
	                            sel.addRange(r2);
	                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);
	                        }
	                    }

	                    // Clean up
	                    dom.removeNode(testEl);
	                    sel.removeAllRanges();

	                    for (i = 0; i < originalSelectionRangeCount; ++i) {
	                        if (i == 0 && originalSelectionBackward) {
	                            if (addRangeBackwardToNative) {
	                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);
	                            } else {
	                                api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
	                                sel.addRange(originalSelectionRanges[i]);
	                            }
	                        } else {
	                            sel.addRange(originalSelectionRanges[i]);
	                        }
	                    }
	                }
	            })();
	        }

	        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
	        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;

	        // ControlRanges
	        var implementsControlRange = false, testControlRange;

	        if (body && isHostMethod(body, "createControlRange")) {
	            testControlRange = body.createControlRange();
	            if (util.areHostProperties(testControlRange, ["item", "add"])) {
	                implementsControlRange = true;
	            }
	        }
	        features.implementsControlRange = implementsControlRange;

	        // Selection collapsedness
	        if (selectionHasAnchorAndFocus) {
	            selectionIsCollapsed = function(sel) {
	                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
	            };
	        } else {
	            selectionIsCollapsed = function(sel) {
	                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
	            };
	        }

	        function updateAnchorAndFocusFromRange(sel, range, backward) {
	            var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
	            sel.anchorNode = range[anchorPrefix + "Container"];
	            sel.anchorOffset = range[anchorPrefix + "Offset"];
	            sel.focusNode = range[focusPrefix + "Container"];
	            sel.focusOffset = range[focusPrefix + "Offset"];
	        }

	        function updateAnchorAndFocusFromNativeSelection(sel) {
	            var nativeSel = sel.nativeSelection;
	            sel.anchorNode = nativeSel.anchorNode;
	            sel.anchorOffset = nativeSel.anchorOffset;
	            sel.focusNode = nativeSel.focusNode;
	            sel.focusOffset = nativeSel.focusOffset;
	        }

	        function updateEmptySelection(sel) {
	            sel.anchorNode = sel.focusNode = null;
	            sel.anchorOffset = sel.focusOffset = 0;
	            sel.rangeCount = 0;
	            sel.isCollapsed = true;
	            sel._ranges.length = 0;
	        }

	        function getNativeRange(range) {
	            var nativeRange;
	            if (range instanceof DomRange) {
	                nativeRange = api.createNativeRange(range.getDocument());
	                nativeRange.setEnd(range.endContainer, range.endOffset);
	                nativeRange.setStart(range.startContainer, range.startOffset);
	            } else if (range instanceof WrappedRange) {
	                nativeRange = range.nativeRange;
	            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {
	                nativeRange = range;
	            }
	            return nativeRange;
	        }

	        function rangeContainsSingleElement(rangeNodes) {
	            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
	                return false;
	            }
	            for (var i = 1, len = rangeNodes.length; i < len; ++i) {
	                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
	                    return false;
	                }
	            }
	            return true;
	        }

	        function getSingleElementFromRange(range) {
	            var nodes = range.getNodes();
	            if (!rangeContainsSingleElement(nodes)) {
	                throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
	            }
	            return nodes[0];
	        }

	        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange
	        function isTextRange(range) {
	            return !!range && typeof range.text != "undefined";
	        }

	        function updateFromTextRange(sel, range) {
	            // Create a Range from the selected TextRange
	            var wrappedRange = new WrappedRange(range);
	            sel._ranges = [wrappedRange];

	            updateAnchorAndFocusFromRange(sel, wrappedRange, false);
	            sel.rangeCount = 1;
	            sel.isCollapsed = wrappedRange.collapsed;
	        }

	        function updateControlSelection(sel) {
	            // Update the wrapped selection based on what's now in the native selection
	            sel._ranges.length = 0;
	            if (sel.docSelection.type == "None") {
	                updateEmptySelection(sel);
	            } else {
	                var controlRange = sel.docSelection.createRange();
	                if (isTextRange(controlRange)) {
	                    // This case (where the selection type is "Control" and calling createRange() on the selection returns
	                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected
	                    // ControlRange have been removed from the ControlRange and removed from the document.
	                    updateFromTextRange(sel, controlRange);
	                } else {
	                    sel.rangeCount = controlRange.length;
	                    var range, doc = getDocument(controlRange.item(0));
	                    for (var i = 0; i < sel.rangeCount; ++i) {
	                        range = api.createRange(doc);
	                        range.selectNode(controlRange.item(i));
	                        sel._ranges.push(range);
	                    }
	                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
	                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
	                }
	            }
	        }

	        function addRangeToControlSelection(sel, range) {
	            var controlRange = sel.docSelection.createRange();
	            var rangeElement = getSingleElementFromRange(range);

	            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element
	            // contained by the supplied range
	            var doc = getDocument(controlRange.item(0));
	            var newControlRange = getBody(doc).createControlRange();
	            for (var i = 0, len = controlRange.length; i < len; ++i) {
	                newControlRange.add(controlRange.item(i));
	            }
	            try {
	                newControlRange.add(rangeElement);
	            } catch (ex) {
	                throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
	            }
	            newControlRange.select();

	            // Update the wrapped selection based on what's now in the native selection
	            updateControlSelection(sel);
	        }

	        var getSelectionRangeAt;

	        if (isHostMethod(testSelection, "getRangeAt")) {
	            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.
	            // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a
	            // lesson to us all, especially me.
	            getSelectionRangeAt = function(sel, index) {
	                try {
	                    return sel.getRangeAt(index);
	                } catch (ex) {
	                    return null;
	                }
	            };
	        } else if (selectionHasAnchorAndFocus) {
	            getSelectionRangeAt = function(sel) {
	                var doc = getDocument(sel.anchorNode);
	                var range = api.createRange(doc);
	                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);

	                // Handle the case when the selection was selected backwards (from the end to the start in the
	                // document)
	                if (range.collapsed !== this.isCollapsed) {
	                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
	                }

	                return range;
	            };
	        }

	        function WrappedSelection(selection, docSelection, win) {
	            this.nativeSelection = selection;
	            this.docSelection = docSelection;
	            this._ranges = [];
	            this.win = win;
	            this.refresh();
	        }

	        WrappedSelection.prototype = api.selectionPrototype;

	        function deleteProperties(sel) {
	            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
	            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
	            sel.detached = true;
	        }

	        var cachedRangySelections = [];

	        function actOnCachedSelection(win, action) {
	            var i = cachedRangySelections.length, cached, sel;
	            while (i--) {
	                cached = cachedRangySelections[i];
	                sel = cached.selection;
	                if (action == "deleteAll") {
	                    deleteProperties(sel);
	                } else if (cached.win == win) {
	                    if (action == "delete") {
	                        cachedRangySelections.splice(i, 1);
	                        return true;
	                    } else {
	                        return sel;
	                    }
	                }
	            }
	            if (action == "deleteAll") {
	                cachedRangySelections.length = 0;
	            }
	            return null;
	        }

	        var getSelection = function(win) {
	            // Check if the parameter is a Rangy Selection object
	            if (win && win instanceof WrappedSelection) {
	                win.refresh();
	                return win;
	            }

	            win = getWindow(win, "getNativeSelection");

	            var sel = actOnCachedSelection(win);
	            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
	            if (sel) {
	                sel.nativeSelection = nativeSel;
	                sel.docSelection = docSel;
	                sel.refresh();
	            } else {
	                sel = new WrappedSelection(nativeSel, docSel, win);
	                cachedRangySelections.push( { win: win, selection: sel } );
	            }
	            return sel;
	        };

	        api.getSelection = getSelection;

	        util.createAliasForDeprecatedMethod(api, "getIframeSelection", "getSelection");

	        var selProto = WrappedSelection.prototype;

	        function createControlSelection(sel, ranges) {
	            // Ensure that the selection becomes of type "Control"
	            var doc = getDocument(ranges[0].startContainer);
	            var controlRange = getBody(doc).createControlRange();
	            for (var i = 0, el, len = ranges.length; i < len; ++i) {
	                el = getSingleElementFromRange(ranges[i]);
	                try {
	                    controlRange.add(el);
	                } catch (ex) {
	                    throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
	                }
	            }
	            controlRange.select();

	            // Update the wrapped selection based on what's now in the native selection
	            updateControlSelection(sel);
	        }

	        // Selecting a range
	        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
	            selProto.removeAllRanges = function() {
	                this.nativeSelection.removeAllRanges();
	                updateEmptySelection(this);
	            };

	            var addRangeBackward = function(sel, range) {
	                addRangeBackwardToNative(sel.nativeSelection, range);
	                sel.refresh();
	            };

	            if (selectionHasRangeCount) {
	                selProto.addRange = function(range, direction) {
	                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
	                        addRangeToControlSelection(this, range);
	                    } else {
	                        if (isDirectionBackward(direction) && selectionHasExtend) {
	                            addRangeBackward(this, range);
	                        } else {
	                            var previousRangeCount;
	                            if (selectionSupportsMultipleRanges) {
	                                previousRangeCount = this.rangeCount;
	                            } else {
	                                this.removeAllRanges();
	                                previousRangeCount = 0;
	                            }
	                            // Clone the native range so that changing the selected range does not affect the selection.
	                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See
	                            // issue 80.
	                            var clonedNativeRange = getNativeRange(range).cloneRange();
	                            try {
	                                this.nativeSelection.addRange(clonedNativeRange);
	                            } catch (ex) {
	                            }

	                            // Check whether adding the range was successful
	                            this.rangeCount = this.nativeSelection.rangeCount;

	                            if (this.rangeCount == previousRangeCount + 1) {
	                                // The range was added successfully

	                                // Check whether the range that we added to the selection is reflected in the last range extracted from
	                                // the selection
	                                if (api.config.checkSelectionRanges) {
	                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
	                                    if (nativeRange && !rangesEqual(nativeRange, range)) {
	                                        // Happens in WebKit with, for example, a selection placed at the start of a text node
	                                        range = new WrappedRange(nativeRange);
	                                    }
	                                }
	                                this._ranges[this.rangeCount - 1] = range;
	                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
	                                this.isCollapsed = selectionIsCollapsed(this);
	                            } else {
	                                // The range was not added successfully. The simplest thing is to refresh
	                                this.refresh();
	                            }
	                        }
	                    }
	                };
	            } else {
	                selProto.addRange = function(range, direction) {
	                    if (isDirectionBackward(direction) && selectionHasExtend) {
	                        addRangeBackward(this, range);
	                    } else {
	                        this.nativeSelection.addRange(getNativeRange(range));
	                        this.refresh();
	                    }
	                };
	            }

	            selProto.setRanges = function(ranges) {
	                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
	                    createControlSelection(this, ranges);
	                } else {
	                    this.removeAllRanges();
	                    for (var i = 0, len = ranges.length; i < len; ++i) {
	                        this.addRange(ranges[i]);
	                    }
	                }
	            };
	        } else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&
	                   implementsControlRange && useDocumentSelection) {

	            selProto.removeAllRanges = function() {
	                // Added try/catch as fix for issue #21
	                try {
	                    this.docSelection.empty();

	                    // Check for empty() not working (issue #24)
	                    if (this.docSelection.type != "None") {
	                        // Work around failure to empty a control selection by instead selecting a TextRange and then
	                        // calling empty()
	                        var doc;
	                        if (this.anchorNode) {
	                            doc = getDocument(this.anchorNode);
	                        } else if (this.docSelection.type == CONTROL) {
	                            var controlRange = this.docSelection.createRange();
	                            if (controlRange.length) {
	                                doc = getDocument( controlRange.item(0) );
	                            }
	                        }
	                        if (doc) {
	                            var textRange = getBody(doc).createTextRange();
	                            textRange.select();
	                            this.docSelection.empty();
	                        }
	                    }
	                } catch(ex) {}
	                updateEmptySelection(this);
	            };

	            selProto.addRange = function(range) {
	                if (this.docSelection.type == CONTROL) {
	                    addRangeToControlSelection(this, range);
	                } else {
	                    api.WrappedTextRange.rangeToTextRange(range).select();
	                    this._ranges[0] = range;
	                    this.rangeCount = 1;
	                    this.isCollapsed = this._ranges[0].collapsed;
	                    updateAnchorAndFocusFromRange(this, range, false);
	                }
	            };

	            selProto.setRanges = function(ranges) {
	                this.removeAllRanges();
	                var rangeCount = ranges.length;
	                if (rangeCount > 1) {
	                    createControlSelection(this, ranges);
	                } else if (rangeCount) {
	                    this.addRange(ranges[0]);
	                }
	            };
	        } else {
	            module.fail("No means of selecting a Range or TextRange was found");
	            return false;
	        }

	        selProto.getRangeAt = function(index) {
	            if (index < 0 || index >= this.rangeCount) {
	                throw new DOMException("INDEX_SIZE_ERR");
	            } else {
	                // Clone the range to preserve selection-range independence. See issue 80.
	                return this._ranges[index].cloneRange();
	            }
	        };

	        var refreshSelection;

	        if (useDocumentSelection) {
	            refreshSelection = function(sel) {
	                var range;
	                if (api.isSelectionValid(sel.win)) {
	                    range = sel.docSelection.createRange();
	                } else {
	                    range = getBody(sel.win.document).createTextRange();
	                    range.collapse(true);
	                }

	                if (sel.docSelection.type == CONTROL) {
	                    updateControlSelection(sel);
	                } else if (isTextRange(range)) {
	                    updateFromTextRange(sel, range);
	                } else {
	                    updateEmptySelection(sel);
	                }
	            };
	        } else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
	            refreshSelection = function(sel) {
	                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
	                    updateControlSelection(sel);
	                } else {
	                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
	                    if (sel.rangeCount) {
	                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
	                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
	                        }
	                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
	                        sel.isCollapsed = selectionIsCollapsed(sel);
	                    } else {
	                        updateEmptySelection(sel);
	                    }
	                }
	            };
	        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
	            refreshSelection = function(sel) {
	                var range, nativeSel = sel.nativeSelection;
	                if (nativeSel.anchorNode) {
	                    range = getSelectionRangeAt(nativeSel, 0);
	                    sel._ranges = [range];
	                    sel.rangeCount = 1;
	                    updateAnchorAndFocusFromNativeSelection(sel);
	                    sel.isCollapsed = selectionIsCollapsed(sel);
	                } else {
	                    updateEmptySelection(sel);
	                }
	            };
	        } else {
	            module.fail("No means of obtaining a Range or TextRange from the user's selection was found");
	            return false;
	        }

	        selProto.refresh = function(checkForChanges) {
	            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
	            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;

	            refreshSelection(this);
	            if (checkForChanges) {
	                // Check the range count first
	                var i = oldRanges.length;
	                if (i != this._ranges.length) {
	                    return true;
	                }

	                // Now check the direction. Checking the anchor position is the same is enough since we're checking all the
	                // ranges after this
	                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
	                    return true;
	                }

	                // Finally, compare each range in turn
	                while (i--) {
	                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {
	                        return true;
	                    }
	                }
	                return false;
	            }
	        };

	        // Removal of a single range
	        var removeRangeManually = function(sel, range) {
	            var ranges = sel.getAllRanges();
	            sel.removeAllRanges();
	            for (var i = 0, len = ranges.length; i < len; ++i) {
	                if (!rangesEqual(range, ranges[i])) {
	                    sel.addRange(ranges[i]);
	                }
	            }
	            if (!sel.rangeCount) {
	                updateEmptySelection(sel);
	            }
	        };

	        if (implementsControlRange && implementsDocSelection) {
	            selProto.removeRange = function(range) {
	                if (this.docSelection.type == CONTROL) {
	                    var controlRange = this.docSelection.createRange();
	                    var rangeElement = getSingleElementFromRange(range);

	                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the
	                    // element contained by the supplied range
	                    var doc = getDocument(controlRange.item(0));
	                    var newControlRange = getBody(doc).createControlRange();
	                    var el, removed = false;
	                    for (var i = 0, len = controlRange.length; i < len; ++i) {
	                        el = controlRange.item(i);
	                        if (el !== rangeElement || removed) {
	                            newControlRange.add(controlRange.item(i));
	                        } else {
	                            removed = true;
	                        }
	                    }
	                    newControlRange.select();

	                    // Update the wrapped selection based on what's now in the native selection
	                    updateControlSelection(this);
	                } else {
	                    removeRangeManually(this, range);
	                }
	            };
	        } else {
	            selProto.removeRange = function(range) {
	                removeRangeManually(this, range);
	            };
	        }

	        // Detecting if a selection is backward
	        var selectionIsBackward;
	        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
	            selectionIsBackward = winSelectionIsBackward;

	            selProto.isBackward = function() {
	                return selectionIsBackward(this);
	            };
	        } else {
	            selectionIsBackward = selProto.isBackward = function() {
	                return false;
	            };
	        }

	        // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"
	        selProto.isBackwards = selProto.isBackward;

	        // Selection stringifier
	        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.
	        // The current spec does not yet define this method.
	        selProto.toString = function() {
	            var rangeTexts = [];
	            for (var i = 0, len = this.rangeCount; i < len; ++i) {
	                rangeTexts[i] = "" + this._ranges[i];
	            }
	            return rangeTexts.join("");
	        };

	        function assertNodeInSameDocument(sel, node) {
	            if (sel.win.document != getDocument(node)) {
	                throw new DOMException("WRONG_DOCUMENT_ERR");
	            }
	        }

	        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used
	        selProto.collapse = function(node, offset) {
	            assertNodeInSameDocument(this, node);
	            var range = api.createRange(node);
	            range.collapseToPoint(node, offset);
	            this.setSingleRange(range);
	            this.isCollapsed = true;
	        };

	        selProto.collapseToStart = function() {
	            if (this.rangeCount) {
	                var range = this._ranges[0];
	                this.collapse(range.startContainer, range.startOffset);
	            } else {
	                throw new DOMException("INVALID_STATE_ERR");
	            }
	        };

	        selProto.collapseToEnd = function() {
	            if (this.rangeCount) {
	                var range = this._ranges[this.rangeCount - 1];
	                this.collapse(range.endContainer, range.endOffset);
	            } else {
	                throw new DOMException("INVALID_STATE_ERR");
	            }
	        };

	        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as
	        // specified so the native implementation is never used by Rangy.
	        selProto.selectAllChildren = function(node) {
	            assertNodeInSameDocument(this, node);
	            var range = api.createRange(node);
	            range.selectNodeContents(node);
	            this.setSingleRange(range);
	        };

	        selProto.deleteFromDocument = function() {
	            // Sepcial behaviour required for IE's control selections
	            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
	                var controlRange = this.docSelection.createRange();
	                var element;
	                while (controlRange.length) {
	                    element = controlRange.item(0);
	                    controlRange.remove(element);
	                    dom.removeNode(element);
	                }
	                this.refresh();
	            } else if (this.rangeCount) {
	                var ranges = this.getAllRanges();
	                if (ranges.length) {
	                    this.removeAllRanges();
	                    for (var i = 0, len = ranges.length; i < len; ++i) {
	                        ranges[i].deleteContents();
	                    }
	                    // The spec says nothing about what the selection should contain after calling deleteContents on each
	                    // range. Firefox moves the selection to where the final selected range was, so we emulate that
	                    this.addRange(ranges[len - 1]);
	                }
	            }
	        };

	        // The following are non-standard extensions
	        selProto.eachRange = function(func, returnValue) {
	            for (var i = 0, len = this._ranges.length; i < len; ++i) {
	                if ( func( this.getRangeAt(i) ) ) {
	                    return returnValue;
	                }
	            }
	        };

	        selProto.getAllRanges = function() {
	            var ranges = [];
	            this.eachRange(function(range) {
	                ranges.push(range);
	            });
	            return ranges;
	        };

	        selProto.setSingleRange = function(range, direction) {
	            this.removeAllRanges();
	            this.addRange(range, direction);
	        };

	        selProto.callMethodOnEachRange = function(methodName, params) {
	            var results = [];
	            this.eachRange( function(range) {
	                results.push( range[methodName].apply(range, params || []) );
	            } );
	            return results;
	        };

	        function createStartOrEndSetter(isStart) {
	            return function(node, offset) {
	                var range;
	                if (this.rangeCount) {
	                    range = this.getRangeAt(0);
	                    range["set" + (isStart ? "Start" : "End")](node, offset);
	                } else {
	                    range = api.createRange(this.win.document);
	                    range.setStartAndEnd(node, offset);
	                }
	                this.setSingleRange(range, this.isBackward());
	            };
	        }

	        selProto.setStart = createStartOrEndSetter(true);
	        selProto.setEnd = createStartOrEndSetter(false);

	        // Add select() method to Range prototype. Any existing selection will be removed.
	        api.rangePrototype.select = function(direction) {
	            getSelection( this.getDocument() ).setSingleRange(this, direction);
	        };

	        selProto.changeEachRange = function(func) {
	            var ranges = [];
	            var backward = this.isBackward();

	            this.eachRange(function(range) {
	                func(range);
	                ranges.push(range);
	            });

	            this.removeAllRanges();
	            if (backward && ranges.length == 1) {
	                this.addRange(ranges[0], "backward");
	            } else {
	                this.setRanges(ranges);
	            }
	        };

	        selProto.containsNode = function(node, allowPartial) {
	            return this.eachRange( function(range) {
	                return range.containsNode(node, allowPartial);
	            }, true ) || false;
	        };

	        selProto.getBookmark = function(containerNode) {
	            return {
	                backward: this.isBackward(),
	                rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
	            };
	        };

	        selProto.moveToBookmark = function(bookmark) {
	            var selRanges = [];
	            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {
	                range = api.createRange(this.win);
	                range.moveToBookmark(rangeBookmark);
	                selRanges.push(range);
	            }
	            if (bookmark.backward) {
	                this.setSingleRange(selRanges[0], "backward");
	            } else {
	                this.setRanges(selRanges);
	            }
	        };

	        selProto.saveRanges = function() {
	            return {
	                backward: this.isBackward(),
	                ranges: this.callMethodOnEachRange("cloneRange")
	            };
	        };

	        selProto.restoreRanges = function(selRanges) {
	            this.removeAllRanges();
	            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {
	                this.addRange(range, (selRanges.backward && i == 0));
	            }
	        };

	        selProto.toHtml = function() {
	            var rangeHtmls = [];
	            this.eachRange(function(range) {
	                rangeHtmls.push( DomRange.toHtml(range) );
	            });
	            return rangeHtmls.join("");
	        };

	        if (features.implementsTextRange) {
	            selProto.getNativeTextRange = function() {
	                var sel, textRange;
	                if ( (sel = this.docSelection) ) {
	                    var range = sel.createRange();
	                    if (isTextRange(range)) {
	                        return range;
	                    } else {
	                        throw module.createError("getNativeTextRange: selection is a control selection");
	                    }
	                } else if (this.rangeCount > 0) {
	                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );
	                } else {
	                    throw module.createError("getNativeTextRange: selection contains no range");
	                }
	            };
	        }

	        function inspect(sel) {
	            var rangeInspects = [];
	            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
	            var focus = new DomPosition(sel.focusNode, sel.focusOffset);
	            var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";

	            if (typeof sel.rangeCount != "undefined") {
	                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
	                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
	                }
	            }
	            return "[" + name + "(Ranges: " + rangeInspects.join(", ") +
	                    ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
	        }

	        selProto.getName = function() {
	            return "WrappedSelection";
	        };

	        selProto.inspect = function() {
	            return inspect(this);
	        };

	        selProto.detach = function() {
	            actOnCachedSelection(this.win, "delete");
	            deleteProperties(this);
	        };

	        WrappedSelection.detachAll = function() {
	            actOnCachedSelection(null, "deleteAll");
	        };

	        WrappedSelection.inspect = inspect;
	        WrappedSelection.isDirectionBackward = isDirectionBackward;

	        api.Selection = WrappedSelection;

	        api.selectionPrototype = selProto;

	        api.addShimListener(function(win) {
	            if (typeof win.getSelection == "undefined") {
	                win.getSelection = function() {
	                    return getSelection(win);
	                };
	            }
	            win = null;
	        });
	    });
	    

	    /*----------------------------------------------------------------------------------------------------------------*/

	    // Wait for document to load before initializing
	    var docReady = false;

	    var loadHandler = function(e) {
	        if (!docReady) {
	            docReady = true;
	            if (!api.initialized && api.config.autoInitialize) {
	                init();
	            }
	        }
	    };

	    if (isBrowser) {
	        // Test whether the document has already been loaded and initialize immediately if so
	        if (document.readyState == "complete") {
	            loadHandler();
	        } else {
	            if (isHostMethod(document, "addEventListener")) {
	                document.addEventListener("DOMContentLoaded", loadHandler, false);
	            }

	            // Add a fallback in case the DOMContentLoaded event isn't supported
	            addListener(window, "load", loadHandler);
	        }
	    }

	    return api;
	}, this);

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * AngularJS filter for Numeral.js: number formatting as a filter
	 * @version v1.2.0 - 2016-01-16
	 * @link https://github.com/baumandm/angular-numeraljs
	 * @author Dave Bauman <baumandm@gmail.com>
	 * @license MIT License, http://www.opensource.org/licenses/MIT
	 */
	'use strict';

	(function (root, factory) {
	  if (true) {
	    // CommonJS
	    module.exports = factory(__webpack_require__(24));
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['numeral'], function (numeral) {
	      return (root.ngNumeraljs = factory(numeral));
	    });
	  } else {
	    // Global Variables
	    root.ngNumeraljs = factory(root.numeral);
	  }
	}(this, function (numeral) {
	  return angular.module('ngNumeraljs', [])
	    .provider('$numeraljsConfig', function () {
	        var formats = {};

	        this.setFormat = function (name, format) {
	            formats[name] = format;
	        };

	        this.setDefaultFormat = function (format) {
	            numeral.defaultFormat(format);
	        };

	        this.setLanguage = function (lang, def) {
	            numeral.language(lang, def);
	        };

	        this.setCurrentLanguage = function (lang) {
	            numeral.language(lang);
	        };

	        this.$get = function () {
	            return {
	                customFormat: function (name) {
	                    return formats[name] || name;
	                },

	                setCurrentLanguage: this.setCurrentLanguage,

	                setDefaultFormat: this.setDefaultFormat,

	                setFormat: this.setFormat,

	                setLanguage: this.setLanguage,
	            };
	        };
	    })
	    .filter('numeraljs', ['$numeraljsConfig', function ($numeraljsConfig) {
	        return function (input, format) {
	            if (input == null) {
	                return input;
	            }

	            format = $numeraljsConfig.customFormat(format);

	            return numeral(input).format(format);
	        };
	    }]);
	}));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * angular-translate - v2.12.1 - 2016-09-15
	 * 
	 * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT
	 */
	(function (root, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return (factory());
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    factory();
	  }
	}(this, function () {

	/**
	 * @ngdoc overview
	 * @name pascalprecht.translate
	 *
	 * @description
	 * The main module which holds everything together.
	 */
	runTranslate.$inject = ['$translate'];
	$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];
	$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];
	translateDirective.$inject = ['$translate', '$interpolate', '$compile', '$parse', '$rootScope'];
	translateAttrDirective.$inject = ['$translate', '$rootScope'];
	translateCloakDirective.$inject = ['$translate', '$rootScope'];
	translateFilterFactory.$inject = ['$parse', '$translate'];
	$translationCache.$inject = ['$cacheFactory'];
	angular.module('pascalprecht.translate', ['ng'])
	  .run(runTranslate);

	function runTranslate($translate) {

	  'use strict';

	  var key = $translate.storageKey(),
	    storage = $translate.storage();

	  var fallbackFromIncorrectStorageValue = function () {
	    var preferred = $translate.preferredLanguage();
	    if (angular.isString(preferred)) {
	      $translate.use(preferred);
	      // $translate.use() will also remember the language.
	      // So, we don't need to call storage.put() here.
	    } else {
	      storage.put(key, $translate.use());
	    }
	  };

	  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';

	  if (storage) {
	    if (!storage.get(key)) {
	      fallbackFromIncorrectStorageValue();
	    } else {
	      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);
	    }
	  } else if (angular.isString($translate.preferredLanguage())) {
	    $translate.use($translate.preferredLanguage());
	  }
	}

	runTranslate.displayName = 'runTranslate';

	/**
	 * @ngdoc object
	 * @name pascalprecht.translate.$translateSanitizationProvider
	 *
	 * @description
	 *
	 * Configurations for $translateSanitization
	 */
	angular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);

	function $translateSanitizationProvider () {

	  'use strict';

	  var $sanitize,
	      $sce,
	      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.
	      hasConfiguredStrategy = false,
	      hasShownNoStrategyConfiguredWarning = false,
	      strategies;

	  /**
	   * Definition of a sanitization strategy function
	   * @callback StrategyFunction
	   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)
	   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params
	   * @return {string|object}
	   */

	  /**
	   * @ngdoc property
	   * @name strategies
	   * @propertyOf pascalprecht.translate.$translateSanitizationProvider
	   *
	   * @description
	   * Following strategies are built-in:
	   * <dl>
	   *   <dt>sanitize</dt>
	   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>
	   *   <dt>escape</dt>
	   *   <dd>Escapes HTML in the translation</dd>
	   *   <dt>sanitizeParameters</dt>
	   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>
	   *   <dt>escapeParameters</dt>
	   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>
	   *   <dt>escaped</dt>
	   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>
	   * </dl>
	   *
	   */

	  strategies = {
	    sanitize: function (value, mode/*, context*/) {
	      if (mode === 'text') {
	        value = htmlSanitizeValue(value);
	      }
	      return value;
	    },
	    escape: function (value, mode/*, context*/) {
	      if (mode === 'text') {
	        value = htmlEscapeValue(value);
	      }
	      return value;
	    },
	    sanitizeParameters: function (value, mode/*, context*/) {
	      if (mode === 'params') {
	        value = mapInterpolationParameters(value, htmlSanitizeValue);
	      }
	      return value;
	    },
	    escapeParameters: function (value, mode/*, context*/) {
	      if (mode === 'params') {
	        value = mapInterpolationParameters(value, htmlEscapeValue);
	      }
	      return value;
	    },
	    sce: function (value, mode, context) {
	      if (mode === 'text') {
	        value = htmlTrustValue(value);
	      } else if (mode === 'params') {
	        if (context !== 'filter') {
	          // do html escape in filter context #1101
	          value = mapInterpolationParameters(value, htmlEscapeValue);
	        }
	      }
	      return value;
	    },
	    sceParameters: function (value, mode/*, context*/) {
	      if (mode === 'params') {
	        value = mapInterpolationParameters(value, htmlTrustValue);
	      }
	      return value;
	    }
	  };
	  // Support legacy strategy name 'escaped' for backwards compatibility.
	  // TODO should be removed in 3.0
	  strategies.escaped = strategies.escapeParameters;

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy
	   * @methodOf pascalprecht.translate.$translateSanitizationProvider
	   *
	   * @description
	   * Adds a sanitization strategy to the list of known strategies.
	   *
	   * @param {string} strategyName - unique key for a strategy
	   * @param {StrategyFunction} strategyFunction - strategy function
	   * @returns {object} this
	   */
	  this.addStrategy = function (strategyName, strategyFunction) {
	    strategies[strategyName] = strategyFunction;
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy
	   * @methodOf pascalprecht.translate.$translateSanitizationProvider
	   *
	   * @description
	   * Removes a sanitization strategy from the list of known strategies.
	   *
	   * @param {string} strategyName - unique key for a strategy
	   * @returns {object} this
	   */
	  this.removeStrategy = function (strategyName) {
	    delete strategies[strategyName];
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy
	   * @methodOf pascalprecht.translate.$translateSanitizationProvider
	   *
	   * @description
	   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.
	   *
	   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.
	   * @returns {object} this
	   */
	  this.useStrategy = function (strategy) {
	    hasConfiguredStrategy = true;
	    currentStrategy = strategy;
	    return this;
	  };

	  /**
	   * @ngdoc object
	   * @name pascalprecht.translate.$translateSanitization
	   * @requires $injector
	   * @requires $log
	   *
	   * @description
	   * Sanitizes interpolation parameters and translated texts.
	   *
	   */
	  this.$get = ['$injector', '$log', function ($injector, $log) {

	    var cachedStrategyMap = {};

	    var applyStrategies = function (value, mode, context, selectedStrategies) {
	      angular.forEach(selectedStrategies, function (selectedStrategy) {
	        if (angular.isFunction(selectedStrategy)) {
	          value = selectedStrategy(value, mode, context);
	        } else if (angular.isFunction(strategies[selectedStrategy])) {
	          value = strategies[selectedStrategy](value, mode, context);
	        } else if (angular.isString(strategies[selectedStrategy])) {
	          if (!cachedStrategyMap[strategies[selectedStrategy]]) {
	            try {
	              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);
	            } catch (e) {
	              cachedStrategyMap[strategies[selectedStrategy]] = function() {};
	              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \'' + selectedStrategy + '\'');
	            }
	          }
	          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode, context);
	        } else {
	          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \'' + selectedStrategy + '\'');
	        }
	      });
	      return value;
	    };

	    // TODO: should be removed in 3.0
	    var showNoStrategyConfiguredWarning = function () {
	      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {
	        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');
	        hasShownNoStrategyConfiguredWarning = true;
	      }
	    };

	    if ($injector.has('$sanitize')) {
	      $sanitize = $injector.get('$sanitize');
	    }
	    if ($injector.has('$sce')) {
	      $sce = $injector.get('$sce');
	    }

	    return {
	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translateSanitization#useStrategy
	       * @methodOf pascalprecht.translate.$translateSanitization
	       *
	       * @description
	       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.
	       *
	       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.
	       */
	      useStrategy: (function (self) {
	        return function (strategy) {
	          self.useStrategy(strategy);
	        };
	      })(this),

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translateSanitization#sanitize
	       * @methodOf pascalprecht.translate.$translateSanitization
	       *
	       * @description
	       * Sanitizes a value.
	       *
	       * @param {string|object} value The value which should be sanitized.
	       * @param {string} mode The current sanitization mode, either 'params' or 'text'.
	       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.
	       * @param {string} [context] The context of this call: filter, service. Default is service
	       * @returns {string|object} sanitized value
	       */
	      sanitize: function (value, mode, strategy, context) {
	        if (!currentStrategy) {
	          showNoStrategyConfiguredWarning();
	        }

	        if (!strategy && strategy !== null) {
	          strategy = currentStrategy;
	        }

	        if (!strategy) {
	          return value;
	        }

	        if (!context) {
	          context = 'service';
	        }

	        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];
	        return applyStrategies(value, mode, context, selectedStrategies);
	      }
	    };
	  }];

	  var htmlEscapeValue = function (value) {
	    var element = angular.element('<div></div>');
	    element.text(value); // not chainable, see #1044
	    return element.html();
	  };

	  var htmlSanitizeValue = function (value) {
	    if (!$sanitize) {
	      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \'escape\'.');
	    }
	    return $sanitize(value);
	  };

	  var htmlTrustValue = function (value) {
	    if (!$sce) {
	      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sce service.');
	    }
	    return $sce.trustAsHtml(value);
	  };

	  var mapInterpolationParameters = function (value, iteratee, stack) {
	    if (angular.isDate(value)) {
	      return value;
	    } else if (angular.isObject(value)) {
	      var result = angular.isArray(value) ? [] : {};

	      if (!stack) {
	        stack = [];
	      } else {
	        if (stack.indexOf(value) > -1) {
	          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');
	        }
	      }

	      stack.push(value);
	      angular.forEach(value, function (propertyValue, propertyKey) {

	        /* Skipping function properties. */
	        if (angular.isFunction(propertyValue)) {
	          return;
	        }

	        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);
	      });
	      stack.splice(-1, 1); // remove last

	      return result;
	    } else if (angular.isNumber(value)) {
	      return value;
	    } else {
	      return iteratee(value);
	    }
	  };
	}

	/**
	 * @ngdoc object
	 * @name pascalprecht.translate.$translateProvider
	 * @description
	 *
	 * $translateProvider allows developers to register translation-tables, asynchronous loaders
	 * and similar to configure translation behavior directly inside of a module.
	 *
	 */
	angular.module('pascalprecht.translate')
	.constant('pascalprechtTranslateOverrider', {})
	.provider('$translate', $translate);

	function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {

	  'use strict';

	  var $translationTable = {},
	      $preferredLanguage,
	      $availableLanguageKeys = [],
	      $languageKeyAliases,
	      $fallbackLanguage,
	      $fallbackWasString,
	      $uses,
	      $nextLang,
	      $storageFactory,
	      $storageKey = $STORAGE_KEY,
	      $storagePrefix,
	      $missingTranslationHandlerFactory,
	      $interpolationFactory,
	      $interpolatorFactories = [],
	      $loaderFactory,
	      $cloakClassName = 'translate-cloak',
	      $loaderOptions,
	      $notFoundIndicatorLeft,
	      $notFoundIndicatorRight,
	      $postCompilingEnabled = false,
	      $forceAsyncReloadEnabled = false,
	      $nestedObjectDelimeter = '.',
	      $isReady = false,
	      $keepContent = false,
	      loaderCache,
	      directivePriority = 0,
	      statefulFilter = true,
	      postProcessFn,
	      uniformLanguageTagResolver = 'default',
	      languageTagResolver = {
	        'default': function (tag) {
	          return (tag || '').split('-').join('_');
	        },
	        java: function (tag) {
	          var temp = (tag || '').split('-').join('_');
	          var parts = temp.split('_');
	          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;
	        },
	        bcp47: function (tag) {
	          var temp = (tag || '').split('_').join('-');
	          var parts = temp.split('-');
	          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;
	        },
	        'iso639-1': function (tag) {
	          var temp = (tag || '').split('_').join('-');
	          var parts = temp.split('-');
	          return parts[0].toLowerCase();
	        }
	      };

	  var version = '2.12.1';

	  // tries to determine the browsers language
	  var getFirstBrowserLanguage = function () {

	    // internal purpose only
	    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {
	      return pascalprechtTranslateOverrider.getLocale();
	    }

	    var nav = $windowProvider.$get().navigator,
	        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],
	        i,
	        language;

	    // support for HTML 5.1 "navigator.languages"
	    if (angular.isArray(nav.languages)) {
	      for (i = 0; i < nav.languages.length; i++) {
	        language = nav.languages[i];
	        if (language && language.length) {
	          return language;
	        }
	      }
	    }

	    // support for other well known properties in browsers
	    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
	      language = nav[browserLanguagePropertyKeys[i]];
	      if (language && language.length) {
	        return language;
	      }
	    }

	    return null;
	  };
	  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';

	  // tries to determine the browsers locale
	  var getLocale = function () {
	    var locale = getFirstBrowserLanguage() || '';
	    if (languageTagResolver[uniformLanguageTagResolver]) {
	      locale = languageTagResolver[uniformLanguageTagResolver](locale);
	    }
	    return locale;
	  };
	  getLocale.displayName = 'angular-translate/service: getLocale';

	  /**
	   * @name indexOf
	   * @private
	   *
	   * @description
	   * indexOf polyfill. Kinda sorta.
	   *
	   * @param {array} array Array to search in.
	   * @param {string} searchElement Element to search for.
	   *
	   * @returns {int} Index of search element.
	   */
	  var indexOf = function(array, searchElement) {
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (array[i] === searchElement) {
	        return i;
	      }
	    }
	    return -1;
	  };

	  /**
	   * @name trim
	   * @private
	   *
	   * @description
	   * trim polyfill
	   *
	   * @returns {string} The string stripped of whitespace from both ends
	   */
	  var trim = function() {
	    return this.toString().replace(/^\s+|\s+$/g, '');
	  };

	  var negotiateLocale = function (preferred) {
	    if(!preferred) {
	      return;
	    }

	    var avail = [],
	        locale = angular.lowercase(preferred),
	        i = 0,
	        n = $availableLanguageKeys.length;

	    for (; i < n; i++) {
	      avail.push(angular.lowercase($availableLanguageKeys[i]));
	    }

	    // Check for an exact match in our list of available keys
	    if (indexOf(avail, locale) > -1) {
	      return preferred;
	    }

	    if ($languageKeyAliases) {
	      var alias;
	      for (var langKeyAlias in $languageKeyAliases) {
	        if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {
	          var hasWildcardKey = false;
	          var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&
	            angular.lowercase(langKeyAlias) === angular.lowercase(preferred);

	          if (langKeyAlias.slice(-1) === '*') {
	            hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length - 1);
	          }
	          if (hasExactKey || hasWildcardKey) {
	            alias = $languageKeyAliases[langKeyAlias];
	            if (indexOf(avail, angular.lowercase(alias)) > -1) {
	              return alias;
	            }
	          }
	        }
	      }
	    }

	    // Check for a language code without region
	    var parts = preferred.split('_');

	    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {
	      return parts[0];
	    }

	    // If everything fails, return undefined.
	    return;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#translations
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Registers a new translation table for specific language key.
	   *
	   * To register a translation table for specific language, pass a defined language
	   * key as first parameter.
	   *
	   * <pre>
	   *  // register translation table for language: 'de_DE'
	   *  $translateProvider.translations('de_DE', {
	   *    'GREETING': 'Hallo Welt!'
	   *  });
	   *
	   *  // register another one
	   *  $translateProvider.translations('en_US', {
	   *    'GREETING': 'Hello world!'
	   *  });
	   * </pre>
	   *
	   * When registering multiple translation tables for for the same language key,
	   * the actual translation table gets extended. This allows you to define module
	   * specific translation which only get added, once a specific module is loaded in
	   * your app.
	   *
	   * Invoking this method with no arguments returns the translation table which was
	   * registered with no language key. Invoking it with a language key returns the
	   * related translation table.
	   *
	   * @param {string} langKey A language key.
	   * @param {object} translationTable A plain old JavaScript object that represents a translation table.
	   *
	   */
	  var translations = function (langKey, translationTable) {

	    if (!langKey && !translationTable) {
	      return $translationTable;
	    }

	    if (langKey && !translationTable) {
	      if (angular.isString(langKey)) {
	        return $translationTable[langKey];
	      }
	    } else {
	      if (!angular.isObject($translationTable[langKey])) {
	        $translationTable[langKey] = {};
	      }
	      angular.extend($translationTable[langKey], flatObject(translationTable));
	    }
	    return this;
	  };

	  this.translations = translations;

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#cloakClassName
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   *
	   * Let's you change the class name for `translate-cloak` directive.
	   * Default class name is `translate-cloak`.
	   *
	   * @param {string} name translate-cloak class name
	   */
	  this.cloakClassName = function (name) {
	    if (!name) {
	      return $cloakClassName;
	    }
	    $cloakClassName = name;
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   *
	   * Let's you change the delimiter for namespaced translations.
	   * Default delimiter is `.`.
	   *
	   * @param {string} delimiter namespace separator
	   */
	  this.nestedObjectDelimeter = function (delimiter) {
	    if (!delimiter) {
	      return $nestedObjectDelimeter;
	    }
	    $nestedObjectDelimeter = delimiter;
	    return this;
	  };

	  /**
	   * @name flatObject
	   * @private
	   *
	   * @description
	   * Flats an object. This function is used to flatten given translation data with
	   * namespaces, so they are later accessible via dot notation.
	   */
	  var flatObject = function (data, path, result, prevKey) {
	    var key, keyWithPath, keyWithShortPath, val;

	    if (!path) {
	      path = [];
	    }
	    if (!result) {
	      result = {};
	    }
	    for (key in data) {
	      if (!Object.prototype.hasOwnProperty.call(data, key)) {
	        continue;
	      }
	      val = data[key];
	      if (angular.isObject(val)) {
	        flatObject(val, path.concat(key), result, key);
	      } else {
	        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;
	        if(path.length && key === prevKey){
	          // Create shortcut path (foo.bar == foo.bar.bar)
	          keyWithShortPath = '' + path.join($nestedObjectDelimeter);
	          // Link it to original path
	          result[keyWithShortPath] = '@:' + keyWithPath;
	        }
	        result[keyWithPath] = val;
	      }
	    }
	    return result;
	  };
	  flatObject.displayName = 'flatObject';

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#addInterpolation
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Adds interpolation services to angular-translate, so it can manage them.
	   *
	   * @param {object} factory Interpolation service factory
	   */
	  this.addInterpolation = function (factory) {
	    $interpolatorFactories.push(factory);
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use interpolation functionality of messageformat.js.
	   * This is useful when having high level pluralization and gender selection.
	   */
	  this.useMessageFormatInterpolation = function () {
	    return this.useInterpolation('$translateMessageFormatInterpolation');
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useInterpolation
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate which interpolation style to use as default, application-wide.
	   * Simply pass a factory/service name. The interpolation service has to implement
	   * the correct interface.
	   *
	   * @param {string} factory Interpolation service name.
	   */
	  this.useInterpolation = function (factory) {
	    $interpolationFactory = factory;
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Simply sets a sanitation strategy type.
	   *
	   * @param {string} value Strategy type.
	   */
	  this.useSanitizeValueStrategy = function (value) {
	    $translateSanitizationProvider.useStrategy(value);
	    return this;
	  };

	 /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#preferredLanguage
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells the module which of the registered translation tables to use for translation
	   * at initial startup by passing a language key. Similar to `$translateProvider#use`
	   * only that it says which language to **prefer**.
	   *
	   * @param {string} langKey A language key.
	   */
	  this.preferredLanguage = function(langKey) {
	    if (langKey) {
	      setupPreferredLanguage(langKey);
	      return this;
	    }
	    return $preferredLanguage;
	  };
	  var setupPreferredLanguage = function (langKey) {
	    if (langKey) {
	      $preferredLanguage = langKey;
	    }
	    return $preferredLanguage;
	  };
	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Sets an indicator which is used when a translation isn't found. E.g. when
	   * setting the indicator as 'X' and one tries to translate a translation id
	   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.
	   *
	   * Internally this methods sets a left indicator and a right indicator using
	   * `$translateProvider.translationNotFoundIndicatorLeft()` and
	   * `$translateProvider.translationNotFoundIndicatorRight()`.
	   *
	   * **Note**: These methods automatically add a whitespace between the indicators
	   * and the translation id.
	   *
	   * @param {string} indicator An indicator, could be any string.
	   */
	  this.translationNotFoundIndicator = function (indicator) {
	    this.translationNotFoundIndicatorLeft(indicator);
	    this.translationNotFoundIndicatorRight(indicator);
	    return this;
	  };

	  /**
	   * ngdoc function
	   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Sets an indicator which is used when a translation isn't found left to the
	   * translation id.
	   *
	   * @param {string} indicator An indicator.
	   */
	  this.translationNotFoundIndicatorLeft = function (indicator) {
	    if (!indicator) {
	      return $notFoundIndicatorLeft;
	    }
	    $notFoundIndicatorLeft = indicator;
	    return this;
	  };

	  /**
	   * ngdoc function
	   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Sets an indicator which is used when a translation isn't found right to the
	   * translation id.
	   *
	   * @param {string} indicator An indicator.
	   */
	  this.translationNotFoundIndicatorRight = function (indicator) {
	    if (!indicator) {
	      return $notFoundIndicatorRight;
	    }
	    $notFoundIndicatorRight = indicator;
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#fallbackLanguage
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells the module which of the registered translation tables to use when missing translations
	   * at initial startup by passing a language key. Similar to `$translateProvider#use`
	   * only that it says which language to **fallback**.
	   *
	   * @param {string||array} langKey A language key.
	   *
	   */
	  this.fallbackLanguage = function (langKey) {
	    fallbackStack(langKey);
	    return this;
	  };

	  var fallbackStack = function (langKey) {
	    if (langKey) {
	      if (angular.isString(langKey)) {
	        $fallbackWasString = true;
	        $fallbackLanguage = [ langKey ];
	      } else if (angular.isArray(langKey)) {
	        $fallbackWasString = false;
	        $fallbackLanguage = langKey;
	      }
	      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {
	        $fallbackLanguage.push($preferredLanguage);
	      }

	      return this;
	    } else {
	      if ($fallbackWasString) {
	        return $fallbackLanguage[0];
	      } else {
	        return $fallbackLanguage;
	      }
	    }
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#use
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Set which translation table to use for translation by given language key. When
	   * trying to 'use' a language which isn't provided, it'll throw an error.
	   *
	   * You actually don't have to use this method since `$translateProvider#preferredLanguage`
	   * does the job too.
	   *
	   * @param {string} langKey A language key.
	   */
	  this.use = function (langKey) {
	    if (langKey) {
	      if (!$translationTable[langKey] && (!$loaderFactory)) {
	        // only throw an error, when not loading translation data asynchronously
	        throw new Error('$translateProvider couldn\'t find translationTable for langKey: \'' + langKey + '\'');
	      }
	      $uses = langKey;
	      return this;
	    }
	    return $uses;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#resolveClientLocale
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * This returns the current browser/client's language key. The result is processed with the configured uniform tag resolver.
	   *
	   * @returns {string} the current client/browser language key
	   */
	  this.resolveClientLocale = function () {
	    return getLocale();
	  };

	 /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#storageKey
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells the module which key must represent the choosed language by a user in the storage.
	   *
	   * @param {string} key A key for the storage.
	   */
	  var storageKey = function(key) {
	    if (!key) {
	      if ($storagePrefix) {
	        return $storagePrefix + $storageKey;
	      }
	      return $storageKey;
	    }
	    $storageKey = key;
	    return this;
	  };

	  this.storageKey = storageKey;

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useUrlLoader
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.
	   *
	   * @param {string} url Url
	   * @param {Object=} options Optional configuration object
	   */
	  this.useUrlLoader = function (url, options) {
	    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.
	   *
	   * @param {Object=} options Optional configuration object
	   */
	  this.useStaticFilesLoader = function (options) {
	    return this.useLoader('$translateStaticFilesLoader', options);
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useLoader
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use any other service as loader.
	   *
	   * @param {string} loaderFactory Factory name to use
	   * @param {Object=} options Optional configuration object
	   */
	  this.useLoader = function (loaderFactory, options) {
	    $loaderFactory = loaderFactory;
	    $loaderOptions = options || {};
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useLocalStorage
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.
	   *
	   */
	  this.useLocalStorage = function () {
	    return this.useStorage('$translateLocalStorage');
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useCookieStorage
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.
	   */
	  this.useCookieStorage = function () {
	    return this.useStorage('$translateCookieStorage');
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useStorage
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use custom service as storage layer.
	   */
	  this.useStorage = function (storageFactory) {
	    $storageFactory = storageFactory;
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#storagePrefix
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Sets prefix for storage key.
	   *
	   * @param {string} prefix Storage key prefix
	   */
	  this.storagePrefix = function (prefix) {
	    if (!prefix) {
	      return prefix;
	    }
	    $storagePrefix = prefix;
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to use built-in log handler when trying to translate
	   * a translation Id which doesn't exist.
	   *
	   * This is actually a shortcut method for `useMissingTranslationHandler()`.
	   *
	   */
	  this.useMissingTranslationHandlerLog = function () {
	    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Expects a factory name which later gets instantiated with `$injector`.
	   * This method can be used to tell angular-translate to use a custom
	   * missingTranslationHandler. Just build a factory which returns a function
	   * and expects a translation id as argument.
	   *
	   * Example:
	   * <pre>
	   *  app.config(function ($translateProvider) {
	   *    $translateProvider.useMissingTranslationHandler('customHandler');
	   *  });
	   *
	   *  app.factory('customHandler', function (dep1, dep2) {
	   *    return function (translationId) {
	   *      // something with translationId and dep1 and dep2
	   *    };
	   *  });
	   * </pre>
	   *
	   * @param {string} factory Factory name
	   */
	  this.useMissingTranslationHandler = function (factory) {
	    $missingTranslationHandlerFactory = factory;
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#usePostCompiling
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * If post compiling is enabled, all translated values will be processed
	   * again with AngularJS' $compile.
	   *
	   * Example:
	   * <pre>
	   *  app.config(function ($translateProvider) {
	   *    $translateProvider.usePostCompiling(true);
	   *  });
	   * </pre>
	   *
	   * @param {string} factory Factory name
	   */
	  this.usePostCompiling = function (value) {
	    $postCompilingEnabled = !(!value);
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#forceAsyncReload
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * If force async reload is enabled, async loader will always be called
	   * even if $translationTable already contains the language key, adding
	   * possible new entries to the $translationTable.
	   *
	   * Example:
	   * <pre>
	   *  app.config(function ($translateProvider) {
	   *    $translateProvider.forceAsyncReload(true);
	   *  });
	   * </pre>
	   *
	   * @param {boolean} value - valid values are true or false
	   */
	  this.forceAsyncReload = function (value) {
	    $forceAsyncReloadEnabled = !(!value);
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate which language tag should be used as a result when determining
	   * the current browser language.
	   *
	   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.
	   *
	   * <pre>
	   * $translateProvider
	   *   .uniformLanguageTag('bcp47')
	   *   .determinePreferredLanguage()
	   * </pre>
	   *
	   * The resolver currently supports:
	   * * default
	   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)
	   *     en-US => en_US
	   *     en_US => en_US
	   *     en-us => en_us
	   * * java
	   *     like default, but the second part will be always in uppercase
	   *     en-US => en_US
	   *     en_US => en_US
	   *     en-us => en_US
	   * * BCP 47 (RFC 4646 & 4647)
	   *     en-US => en-US
	   *     en_US => en-US
	   *     en-us => en-US
	   *
	   * See also:
	   * * http://en.wikipedia.org/wiki/IETF_language_tag
	   * * http://www.w3.org/International/core/langtags/
	   * * http://tools.ietf.org/html/bcp47
	   *
	   * @param {string|object} options - options (or standard)
	   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'
	   */
	  this.uniformLanguageTag = function (options) {

	    if (!options) {
	      options = {};
	    } else if (angular.isString(options)) {
	      options = {
	        standard: options
	      };
	    }

	    uniformLanguageTagResolver = options.standard;

	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Tells angular-translate to try to determine on its own which language key
	   * to set as preferred language. When `fn` is given, angular-translate uses it
	   * to determine a language key, otherwise it uses the built-in `getLocale()`
	   * method.
	   *
	   * The `getLocale()` returns a language key in the format `[lang]_[country]` or
	   * `[lang]` depending on what the browser provides.
	   *
	   * Use this method at your own risk, since not all browsers return a valid
	   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).
	   *
	   * @param {Function=} fn Function to determine a browser's locale
	   */
	  this.determinePreferredLanguage = function (fn) {

	    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();

	    if (!$availableLanguageKeys.length) {
	      $preferredLanguage = locale;
	    } else {
	      $preferredLanguage = negotiateLocale(locale) || locale;
	    }

	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Registers a set of language keys the app will work with. Use this method in
	   * combination with
	   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.
	   * When available languages keys are registered, angular-translate
	   * tries to find the best fitting language key depending on the browsers locale,
	   * considering your language key convention.
	   *
	   * @param {object} languageKeys Array of language keys the your app will use
	   * @param {object=} aliases Alias map.
	   */
	  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {
	    if (languageKeys) {
	      $availableLanguageKeys = languageKeys;
	      if (aliases) {
	        $languageKeyAliases = aliases;
	      }
	      return this;
	    }
	    return $availableLanguageKeys;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#useLoaderCache
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Registers a cache for internal $http based loaders.
	   * {@link pascalprecht.translate.$translationCache $translationCache}.
	   * When false the cache will be disabled (default). When true or undefined
	   * the cache will be a default (see $cacheFactory). When an object it will
	   * be treat as a cache object itself: the usage is $http({cache: cache})
	   *
	   * @param {object} cache boolean, string or cache-object
	   */
	  this.useLoaderCache = function (cache) {
	    if (cache === false) {
	      // disable cache
	      loaderCache = undefined;
	    } else if (cache === true) {
	      // enable cache using AJS defaults
	      loaderCache = true;
	    } else if (typeof(cache) === 'undefined') {
	      // enable cache using default
	      loaderCache = '$translationCache';
	    } else if (cache) {
	      // enable cache using given one (see $cacheFactory)
	      loaderCache = cache;
	    }
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#directivePriority
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Sets the default priority of the translate directive. The standard value is `0`.
	   * Calling this function without an argument will return the current value.
	   *
	   * @param {number} priority for the translate-directive
	   */
	  this.directivePriority = function (priority) {
	    if (priority === undefined) {
	      // getter
	      return directivePriority;
	    } else {
	      // setter with chaining
	      directivePriority = priority;
	      return this;
	    }
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#statefulFilter
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)
	   * have to explicit define this behavior.
	   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`
	   * meaning being stateful.
	   * Calling this function without an argument will return the current value.
	   *
	   * @param {boolean} state - defines the state of the filter
	   */
	  this.statefulFilter = function (state) {
	    if (state === undefined) {
	      // getter
	      return statefulFilter;
	    } else {
	      // setter with chaining
	      statefulFilter = state;
	      return this;
	    }
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#postProcess
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * The post processor will be intercept right after the translation result. It can modify the result.
	   *
	   * @param {object} fn Function or service name (string) to be called after the translation value has been set / resolved. The function itself will enrich every value being processed and then continue the normal resolver process
	   */
	  this.postProcess = function (fn) {
	    if (fn) {
	      postProcessFn = fn;
	    } else {
	      postProcessFn = undefined;
	    }
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateProvider#keepContent
	   * @methodOf pascalprecht.translate.$translateProvider
	   *
	   * @description
	   * If keepContent is set to true than translate directive will always use innerHTML
	   * as a default translation
	   *
	   * Example:
	   * <pre>
	   *  app.config(function ($translateProvider) {
	   *    $translateProvider.keepContent(true);
	   *  });
	   * </pre>
	   *
	   * @param {boolean} value - valid values are true or false
	   */
	  this.keepContent = function (value) {
	    $keepContent = !(!value);
	    return this;
	  };

	  /**
	   * @ngdoc object
	   * @name pascalprecht.translate.$translate
	   * @requires $interpolate
	   * @requires $log
	   * @requires $rootScope
	   * @requires $q
	   *
	   * @description
	   * The `$translate` service is the actual core of angular-translate. It expects a translation id
	   * and optional interpolate parameters to translate contents.
	   *
	   * <pre>
	   *  $translate('HEADLINE_TEXT').then(function (translation) {
	   *    $scope.translatedText = translation;
	   *  });
	   * </pre>
	   *
	   * @param {string|array} translationId A token which represents a translation id
	   *                                     This can be optionally an array of translation ids which
	   *                                     results that the function returns an object where each key
	   *                                     is the translation id and the value the translation.
	   * @param {object=} interpolateParams An object hash for dynamic values
	   * @param {string} interpolationId The id of the interpolation to use
	   * @param {string} defaultTranslationText the optional default translation text that is written as
	   *                                        as default text in case it is not found in any configured language
	   * @param {string} forceLanguage A language to be used instead of the current language
	   * @returns {object} promise
	   */
	  this.$get = [
	    '$log',
	    '$injector',
	    '$rootScope',
	    '$q',
	    function ($log, $injector, $rootScope, $q) {

	      var Storage,
	          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),
	          pendingLoader = false,
	          interpolatorHashMap = {},
	          langPromises = {},
	          fallbackIndex,
	          startFallbackIteration;

	      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {
	        if (!$uses && $preferredLanguage) {
	          $uses = $preferredLanguage;
	        }
	        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses
	              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;

	        // Check forceLanguage is present
	        if (forceLanguage) {
	          loadTranslationsIfMissing(forceLanguage);
	        }

	        // Duck detection: If the first argument is an array, a bunch of translations was requested.
	        // The result is an object.
	        if (angular.isArray(translationId)) {
	          // Inspired by Q.allSettled by Kris Kowal
	          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563
	          // This transforms all promises regardless resolved or rejected
	          var translateAll = function (translationIds) {
	            var results = {}; // storing the actual results
	            var promises = []; // promises to wait for
	            // Wraps the promise a) being always resolved and b) storing the link id->value
	            var translate = function (translationId) {
	              var deferred = $q.defer();
	              var regardless = function (value) {
	                results[translationId] = value;
	                deferred.resolve([translationId, value]);
	              };
	              // we don't care whether the promise was resolved or rejected; just store the values
	              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);
	              return deferred.promise;
	            };
	            for (var i = 0, c = translationIds.length; i < c; i++) {
	              promises.push(translate(translationIds[i]));
	            }
	            // wait for all (including storing to results)
	            return $q.all(promises).then(function () {
	              // return the results
	              return results;
	            });
	          };
	          return translateAll(translationId);
	        }

	        var deferred = $q.defer();

	        // trim off any whitespace
	        if (translationId) {
	          translationId = trim.apply(translationId);
	        }

	        var promiseToWaitFor = (function () {
	          var promise = $preferredLanguage ?
	            langPromises[$preferredLanguage] :
	            langPromises[uses];

	          fallbackIndex = 0;

	          if ($storageFactory && !promise) {
	            // looks like there's no pending promise for $preferredLanguage or
	            // $uses. Maybe there's one pending for a language that comes from
	            // storage.
	            var langKey = Storage.get($storageKey);
	            promise = langPromises[langKey];

	            if ($fallbackLanguage && $fallbackLanguage.length) {
	                var index = indexOf($fallbackLanguage, langKey);
	                // maybe the language from storage is also defined as fallback language
	                // we increase the fallback language index to not search in that language
	                // as fallback, since it's probably the first used language
	                // in that case the index starts after the first element
	                fallbackIndex = (index === 0) ? 1 : 0;

	                // but we can make sure to ALWAYS fallback to preferred language at least
	                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
	                  $fallbackLanguage.push($preferredLanguage);
	                }
	            }
	          }
	          return promise;
	        }());

	        if (!promiseToWaitFor) {
	          // no promise to wait for? okay. Then there's no loader registered
	          // nor is a one pending for language that comes from storage.
	          // We can just translate.
	          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);
	        } else {
	          var promiseResolved = function () {
	            // $uses may have changed while waiting
	            if (!forceLanguage) {
	              uses = $uses;
	            }
	            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);
	          };
	          promiseResolved.displayName = 'promiseResolved';

	          promiseToWaitFor['finally'](promiseResolved);
	        }
	        return deferred.promise;
	      };

	      /**
	       * @name applyNotFoundIndicators
	       * @private
	       *
	       * @description
	       * Applies not fount indicators to given translation id, if needed.
	       * This function gets only executed, if a translation id doesn't exist,
	       * which is why a translation id is expected as argument.
	       *
	       * @param {string} translationId Translation id.
	       * @returns {string} Same as given translation id but applied with not found
	       * indicators.
	       */
	      var applyNotFoundIndicators = function (translationId) {
	        // applying notFoundIndicators
	        if ($notFoundIndicatorLeft) {
	          translationId = [$notFoundIndicatorLeft, translationId].join(' ');
	        }
	        if ($notFoundIndicatorRight) {
	          translationId = [translationId, $notFoundIndicatorRight].join(' ');
	        }
	        return translationId;
	      };

	      /**
	       * @name useLanguage
	       * @private
	       *
	       * @description
	       * Makes actual use of a language by setting a given language key as used
	       * language and informs registered interpolators to also use the given
	       * key as locale.
	       *
	       * @param {string} key Locale key.
	       */
	      var useLanguage = function (key) {
	        $uses = key;

	        // make sure to store new language key before triggering success event
	        if ($storageFactory) {
	          Storage.put($translate.storageKey(), $uses);
	        }

	        $rootScope.$emit('$translateChangeSuccess', {language: key});

	        // inform default interpolator
	        defaultInterpolator.setLocale($uses);

	        var eachInterpolator = function (interpolator, id) {
	          interpolatorHashMap[id].setLocale($uses);
	        };
	        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';

	        // inform all others too!
	        angular.forEach(interpolatorHashMap, eachInterpolator);
	        $rootScope.$emit('$translateChangeEnd', {language: key});
	      };

	      /**
	       * @name loadAsync
	       * @private
	       *
	       * @description
	       * Kicks of registered async loader using `$injector` and applies existing
	       * loader options. When resolved, it updates translation tables accordingly
	       * or rejects with given language key.
	       *
	       * @param {string} key Language key.
	       * @return {Promise} A promise.
	       */
	      var loadAsync = function (key) {
	        if (!key) {
	          throw 'No language key specified for loading.';
	        }

	        var deferred = $q.defer();

	        $rootScope.$emit('$translateLoadingStart', {language: key});
	        pendingLoader = true;

	        var cache = loaderCache;
	        if (typeof(cache) === 'string') {
	          // getting on-demand instance of loader
	          cache = $injector.get(cache);
	        }

	        var loaderOptions = angular.extend({}, $loaderOptions, {
	          key: key,
	          $http: angular.extend({}, {
	            cache: cache
	          }, $loaderOptions.$http)
	        });

	        var onLoaderSuccess = function (data) {
	          var translationTable = {};
	          $rootScope.$emit('$translateLoadingSuccess', {language: key});

	          if (angular.isArray(data)) {
	            angular.forEach(data, function (table) {
	              angular.extend(translationTable, flatObject(table));
	            });
	          } else {
	            angular.extend(translationTable, flatObject(data));
	          }
	          pendingLoader = false;
	          deferred.resolve({
	            key: key,
	            table: translationTable
	          });
	          $rootScope.$emit('$translateLoadingEnd', {language: key});
	        };
	        onLoaderSuccess.displayName = 'onLoaderSuccess';

	        var onLoaderError = function (key) {
	          $rootScope.$emit('$translateLoadingError', {language: key});
	          deferred.reject(key);
	          $rootScope.$emit('$translateLoadingEnd', {language: key});
	        };
	        onLoaderError.displayName = 'onLoaderError';

	        $injector.get($loaderFactory)(loaderOptions)
	          .then(onLoaderSuccess, onLoaderError);

	        return deferred.promise;
	      };

	      if ($storageFactory) {
	        Storage = $injector.get($storageFactory);

	        if (!Storage.get || !Storage.put) {
	          throw new Error('Couldn\'t use storage \'' + $storageFactory + '\', missing get() or put() method!');
	        }
	      }

	      // if we have additional interpolations that were added via
	      // $translateProvider.addInterpolation(), we have to map'em
	      if ($interpolatorFactories.length) {
	        var eachInterpolationFactory = function (interpolatorFactory) {
	          var interpolator = $injector.get(interpolatorFactory);
	          // setting initial locale for each interpolation service
	          interpolator.setLocale($preferredLanguage || $uses);
	          // make'em recognizable through id
	          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
	        };
	        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';

	        angular.forEach($interpolatorFactories, eachInterpolationFactory);
	      }

	      /**
	       * @name getTranslationTable
	       * @private
	       *
	       * @description
	       * Returns a promise that resolves to the translation table
	       * or is rejected if an error occurred.
	       *
	       * @param langKey
	       * @returns {Q.promise}
	       */
	      var getTranslationTable = function (langKey) {
	        var deferred = $q.defer();
	        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
	          deferred.resolve($translationTable[langKey]);
	        } else if (langPromises[langKey]) {
	          var onResolve = function (data) {
	            translations(data.key, data.table);
	            deferred.resolve(data.table);
	          };
	          onResolve.displayName = 'translationTableResolver';
	          langPromises[langKey].then(onResolve, deferred.reject);
	        } else {
	          deferred.reject();
	        }
	        return deferred.promise;
	      };

	      /**
	       * @name getFallbackTranslation
	       * @private
	       *
	       * @description
	       * Returns a promise that will resolve to the translation
	       * or be rejected if no translation was found for the language.
	       * This function is currently only used for fallback language translation.
	       *
	       * @param langKey The language to translate to.
	       * @param translationId
	       * @param interpolateParams
	       * @param Interpolator
	       * @returns {Q.promise}
	       */
	      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {
	        var deferred = $q.defer();

	        var onResolve = function (translationTable) {
	          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
	            Interpolator.setLocale(langKey);
	            var translation = translationTable[translationId];
	            if (translation.substr(0, 2) === '@:') {
	              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)
	                .then(deferred.resolve, deferred.reject);
	            } else {
	              var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams, 'service');
	              interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey);

	              deferred.resolve(interpolatedValue);

	            }
	            Interpolator.setLocale($uses);
	          } else {
	            deferred.reject();
	          }
	        };
	        onResolve.displayName = 'fallbackTranslationResolver';

	        getTranslationTable(langKey).then(onResolve, deferred.reject);

	        return deferred.promise;
	      };

	      /**
	       * @name getFallbackTranslationInstant
	       * @private
	       *
	       * @description
	       * Returns a translation
	       * This function is currently only used for fallback language translation.
	       *
	       * @param langKey The language to translate to.
	       * @param translationId
	       * @param interpolateParams
	       * @param Interpolator
	       * @returns {string} translation
	       */
	      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {
	        var result, translationTable = $translationTable[langKey];

	        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
	          Interpolator.setLocale(langKey);
	          result = Interpolator.interpolate(translationTable[translationId], interpolateParams, 'filter');
	          result = applyPostProcessing(translationId, translationTable[translationId], result, interpolateParams, langKey);
	          if (result.substr(0, 2) === '@:') {
	            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);
	          }
	          Interpolator.setLocale($uses);
	        }

	        return result;
	      };


	      /**
	       * @name translateByHandler
	       * @private
	       *
	       * Translate by missing translation handler.
	       *
	       * @param translationId
	       * @param interpolateParams
	       * @param defaultTranslationText
	       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is
	       * absent
	       */
	      var translateByHandler = function (translationId, interpolateParams, defaultTranslationText) {
	        // If we have a handler factory - we might also call it here to determine if it provides
	        // a default text for a translationid that can't be found anywhere in our tables
	        if ($missingTranslationHandlerFactory) {
	          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText);
	          if (resultString !== undefined) {
	            return resultString;
	          } else {
	            return translationId;
	          }
	        } else {
	          return translationId;
	        }
	      };

	      /**
	       * @name resolveForFallbackLanguage
	       * @private
	       *
	       * Recursive helper function for fallbackTranslation that will sequentially look
	       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.
	       *
	       * @param fallbackLanguageIndex
	       * @param translationId
	       * @param interpolateParams
	       * @param Interpolator
	       * @returns {Q.promise} Promise that will resolve to the translation.
	       */
	      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {
	        var deferred = $q.defer();

	        if (fallbackLanguageIndex < $fallbackLanguage.length) {
	          var langKey = $fallbackLanguage[fallbackLanguageIndex];
	          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(
	            function (data) {
	                deferred.resolve(data);
	            },
	            function () {
	              // Look in the next fallback language for a translation.
	              // It delays the resolving by passing another promise to resolve.
	              return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve, deferred.reject);
	            }
	          );
	        } else {
	          // No translation found in any fallback language
	          // if a default translation text is set in the directive, then return this as a result
	          if (defaultTranslationText) {
	            deferred.resolve(defaultTranslationText);
	          } else {
	            // if no default translation is set and an error handler is defined, send it to the handler
	            // and then return the result
	            if ($missingTranslationHandlerFactory) {
	              deferred.resolve(translateByHandler(translationId, interpolateParams));
	            } else {
	              deferred.reject(translateByHandler(translationId, interpolateParams));
	            }

	          }
	        }
	        return deferred.promise;
	      };

	      /**
	       * @name resolveForFallbackLanguageInstant
	       * @private
	       *
	       * Recursive helper function for fallbackTranslation that will sequentially look
	       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.
	       *
	       * @param fallbackLanguageIndex
	       * @param translationId
	       * @param interpolateParams
	       * @param Interpolator
	       * @returns {string} translation
	       */
	      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {
	        var result;

	        if (fallbackLanguageIndex < $fallbackLanguage.length) {
	          var langKey = $fallbackLanguage[fallbackLanguageIndex];
	          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);
	          if (!result) {
	            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);
	          }
	        }
	        return result;
	      };

	      /**
	       * Translates with the usage of the fallback languages.
	       *
	       * @param translationId
	       * @param interpolateParams
	       * @param Interpolator
	       * @returns {Q.promise} Promise, that resolves to the translation.
	       */
	      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {
	        // Start with the fallbackLanguage with index 0
	        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);
	      };

	      /**
	       * Translates with the usage of the fallback languages.
	       *
	       * @param translationId
	       * @param interpolateParams
	       * @param Interpolator
	       * @returns {String} translation
	       */
	      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {
	        // Start with the fallbackLanguage with index 0
	        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);
	      };

	      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {

	        var deferred = $q.defer();

	        var table = uses ? $translationTable[uses] : $translationTable,
	            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;

	        // if the translation id exists, we can just interpolate it
	        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
	          var translation = table[translationId];

	          // If using link, rerun $translate with linked translationId and return it
	          if (translation.substr(0, 2) === '@:') {

	            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)
	              .then(deferred.resolve, deferred.reject);
	          } else {
	            //
	            var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams, 'service');
	            resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses);
	            deferred.resolve(resolvedTranslation);
	          }
	        } else {
	          var missingTranslationHandlerTranslation;
	          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise
	          if ($missingTranslationHandlerFactory && !pendingLoader) {
	            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
	          }

	          // since we couldn't translate the inital requested translation id,
	          // we try it now with one or more fallback languages, if fallback language(s) is
	          // configured.
	          if (uses && $fallbackLanguage && $fallbackLanguage.length) {
	            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)
	                .then(function (translation) {
	                  deferred.resolve(translation);
	                }, function (_translationId) {
	                  deferred.reject(applyNotFoundIndicators(_translationId));
	                });
	          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
	            // looks like the requested translation id doesn't exists.
	            // Now, if there is a registered handler for missing translations and no
	            // asyncLoader is pending, we execute the handler
	            if (defaultTranslationText) {
	              deferred.resolve(defaultTranslationText);
	              } else {
	                deferred.resolve(missingTranslationHandlerTranslation);
	              }
	          } else {
	            if (defaultTranslationText) {
	              deferred.resolve(defaultTranslationText);
	            } else {
	              deferred.reject(applyNotFoundIndicators(translationId));
	            }
	          }
	        }
	        return deferred.promise;
	      };

	      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {

	        var result, table = uses ? $translationTable[uses] : $translationTable,
	            Interpolator = defaultInterpolator;

	        // if the interpolation id exists use custom interpolator
	        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {
	          Interpolator = interpolatorHashMap[interpolationId];
	        }

	        // if the translation id exists, we can just interpolate it
	        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
	          var translation = table[translationId];

	          // If using link, rerun $translate with linked translationId and return it
	          if (translation.substr(0, 2) === '@:') {
	            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);
	          } else {
	            result = Interpolator.interpolate(translation, interpolateParams, 'filter');
	            result = applyPostProcessing(translationId, translation, result, interpolateParams, uses);
	          }
	        } else {
	          var missingTranslationHandlerTranslation;
	          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise
	          if ($missingTranslationHandlerFactory && !pendingLoader) {
	            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);
	          }

	          // since we couldn't translate the inital requested translation id,
	          // we try it now with one or more fallback languages, if fallback language(s) is
	          // configured.
	          if (uses && $fallbackLanguage && $fallbackLanguage.length) {
	            fallbackIndex = 0;
	            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);
	          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
	            // looks like the requested translation id doesn't exists.
	            // Now, if there is a registered handler for missing translations and no
	            // asyncLoader is pending, we execute the handler
	            result = missingTranslationHandlerTranslation;
	          } else {
	            result = applyNotFoundIndicators(translationId);
	          }
	        }

	        return result;
	      };

	      var clearNextLangAndPromise = function(key) {
	        if ($nextLang === key) {
	          $nextLang = undefined;
	        }
	        langPromises[key] = undefined;
	      };

	      var applyPostProcessing = function (translationId, translation, resolvedTranslation, interpolateParams, uses) {
	        var fn = postProcessFn;

	        if (fn) {

	          if (typeof(fn) === 'string') {
	            // getting on-demand instance
	            fn = $injector.get(fn);
	          }
	          if (fn) {
	            return fn(translationId, translation, resolvedTranslation, interpolateParams, uses);
	          }
	        }

	        return resolvedTranslation;
	      };

	      var loadTranslationsIfMissing = function (key) {
	        if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {
	          langPromises[key] = loadAsync(key).then(function (translation) {
	            translations(translation.key, translation.table);
	            return translation;
	          });
	        }
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#preferredLanguage
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the language key for the preferred language.
	       *
	       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)
	       *
	       * @return {string} preferred language key
	       */
	      $translate.preferredLanguage = function (langKey) {
	        if(langKey) {
	          setupPreferredLanguage(langKey);
	        }
	        return $preferredLanguage;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#cloakClassName
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the configured class name for `translate-cloak` directive.
	       *
	       * @return {string} cloakClassName
	       */
	      $translate.cloakClassName = function () {
	        return $cloakClassName;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#nestedObjectDelimeter
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the configured delimiter for nested namespaces.
	       *
	       * @return {string} nestedObjectDelimeter
	       */
	      $translate.nestedObjectDelimeter = function () {
	        return $nestedObjectDelimeter;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#fallbackLanguage
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the language key for the fallback languages or sets a new fallback stack.
	       *
	       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)
	       *
	       * @return {string||array} fallback language key
	       */
	      $translate.fallbackLanguage = function (langKey) {
	        if (langKey !== undefined && langKey !== null) {
	          fallbackStack(langKey);

	          // as we might have an async loader initiated and a new translation language might have been defined
	          // we need to add the promise to the stack also. So - iterate.
	          if ($loaderFactory) {
	            if ($fallbackLanguage && $fallbackLanguage.length) {
	              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
	                if (!langPromises[$fallbackLanguage[i]]) {
	                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);
	                }
	              }
	            }
	          }
	          $translate.use($translate.use());
	        }
	        if ($fallbackWasString) {
	          return $fallbackLanguage[0];
	        } else {
	          return $fallbackLanguage;
	        }

	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#useFallbackLanguage
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Sets the first key of the fallback language stack to be used for translation.
	       * Therefore all languages in the fallback array BEFORE this key will be skipped!
	       *
	       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to
	       * get back to the whole stack
	       */
	      $translate.useFallbackLanguage = function (langKey) {
	        if (langKey !== undefined && langKey !== null) {
	          if (!langKey) {
	            startFallbackIteration = 0;
	          } else {
	            var langKeyPosition = indexOf($fallbackLanguage, langKey);
	            if (langKeyPosition > -1) {
	              startFallbackIteration = langKeyPosition;
	            }
	          }

	        }

	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#proposedLanguage
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the language key of language that is currently loaded asynchronously.
	       *
	       * @return {string} language key
	       */
	      $translate.proposedLanguage = function () {
	        return $nextLang;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#storage
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns registered storage.
	       *
	       * @return {object} Storage
	       */
	      $translate.storage = function () {
	        return Storage;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#negotiateLocale
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns a language key based on available languages and language aliases. If a
	       * language key cannot be resolved, returns undefined.
	       *
	       * If no or a falsy key is given, returns undefined.
	       *
	       * @param {string} [key] Language key
	       * @return {string|undefined} Language key or undefined if no language key is found.
	       */
	      $translate.negotiateLocale = negotiateLocale;

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#use
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Tells angular-translate which language to use by given language key. This method is
	       * used to change language at runtime. It also takes care of storing the language
	       * key in a configured store to let your app remember the choosed language.
	       *
	       * When trying to 'use' a language which isn't available it tries to load it
	       * asynchronously with registered loaders.
	       *
	       * Returns promise object with loaded language file data or string of the currently used language.
	       *
	       * If no or a falsy key is given it returns the currently used language key.
	       * The returned string will be ```undefined``` if setting up $translate hasn't finished.
	       * @example
	       * $translate.use("en_US").then(function(data){
	       *   $scope.text = $translate("HELLO");
	       * });
	       *
	       * @param {string} [key] Language key
	       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.
	       */
	      $translate.use = function (key) {
	        if (!key) {
	          return $uses;
	        }

	        var deferred = $q.defer();

	        $rootScope.$emit('$translateChangeStart', {language: key});

	        // Try to get the aliased language key
	        var aliasedKey = negotiateLocale(key);
	        // Ensure only registered language keys will be loaded
	        if ($availableLanguageKeys.length > 0 && !aliasedKey) {
	          return $q.reject(key);
	        }

	        if (aliasedKey) {
	          key = aliasedKey;
	        }

	        // if there isn't a translation table for the language we've requested,
	        // we load it asynchronously
	        $nextLang = key;
	        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {
	          langPromises[key] = loadAsync(key).then(function (translation) {
	            translations(translation.key, translation.table);
	            deferred.resolve(translation.key);
	            if ($nextLang === key) {
	              useLanguage(translation.key);
	            }
	            return translation;
	          }, function (key) {
	            $rootScope.$emit('$translateChangeError', {language: key});
	            deferred.reject(key);
	            $rootScope.$emit('$translateChangeEnd', {language: key});
	            return $q.reject(key);
	          });
	          langPromises[key]['finally'](function () {
	            clearNextLangAndPromise(key);
	          });
	        } else if (langPromises[key]) {
	          // we are already loading this asynchronously
	          // resolve our new deferred when the old langPromise is resolved
	          langPromises[key].then(function (translation) {
	            if ($nextLang === translation.key) {
	              useLanguage(translation.key);
	            }
	            deferred.resolve(translation.key);
	            return translation;
	          }, function (key) {
	            // find first available fallback language if that request has failed
	            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0 && $fallbackLanguage[0] !== key) {
	              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);
	            } else {
	              return deferred.reject(key);
	            }
	          });
	        } else {
	          deferred.resolve(key);
	          useLanguage(key);
	        }

	        return deferred.promise;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#resolveClientLocale
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * This returns the current browser/client's language key. The result is processed with the configured uniform tag resolver.
	       *
	       * @returns {string} the current client/browser language key
	       */
	      $translate.resolveClientLocale = function () {
	        return getLocale();
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#storageKey
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the key for the storage.
	       *
	       * @return {string} storage key
	       */
	      $translate.storageKey = function () {
	        return storageKey();
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#isPostCompilingEnabled
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns whether post compiling is enabled or not
	       *
	       * @return {bool} storage key
	       */
	      $translate.isPostCompilingEnabled = function () {
	        return $postCompilingEnabled;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns whether force async reload is enabled or not
	       *
	       * @return {boolean} forceAsyncReload value
	       */
	      $translate.isForceAsyncReloadEnabled = function () {
	        return $forceAsyncReloadEnabled;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#isKeepContent
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns whether keepContent or not
	       *
	       * @return {boolean} keepContent value
	       */
	      $translate.isKeepContent = function () {
	        return $keepContent;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#refresh
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,
	       * the module will drop all existent translation tables and load new version of those which
	       * are currently in use.
	       *
	       * Refresh means that the module will drop target translation table and try to load it again.
	       *
	       * In case there are no loaders registered the refresh() method will throw an Error.
	       *
	       * If the module is able to refresh translation tables refresh() method will broadcast
	       * $translateRefreshStart and $translateRefreshEnd events.
	       *
	       * @example
	       * // this will drop all currently existent translation tables and reload those which are
	       * // currently in use
	       * $translate.refresh();
	       * // this will refresh a translation table for the en_US language
	       * $translate.refresh('en_US');
	       *
	       * @param {string} langKey A language key of the table, which has to be refreshed
	       *
	       * @return {promise} Promise, which will be resolved in case a translation tables refreshing
	       * process is finished successfully, and reject if not.
	       */
	      $translate.refresh = function (langKey) {
	        if (!$loaderFactory) {
	          throw new Error('Couldn\'t refresh translation table, no loader registered!');
	        }

	        var deferred = $q.defer();

	        function resolve() {
	          deferred.resolve();
	          $rootScope.$emit('$translateRefreshEnd', {language: langKey});
	        }

	        function reject() {
	          deferred.reject();
	          $rootScope.$emit('$translateRefreshEnd', {language: langKey});
	        }

	        $rootScope.$emit('$translateRefreshStart', {language: langKey});

	        if (!langKey) {
	          // if there's no language key specified we refresh ALL THE THINGS!
	          var tables = [], loadingKeys = {};

	          // reload registered fallback languages
	          if ($fallbackLanguage && $fallbackLanguage.length) {
	            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
	              tables.push(loadAsync($fallbackLanguage[i]));
	              loadingKeys[$fallbackLanguage[i]] = true;
	            }
	          }

	          // reload currently used language
	          if ($uses && !loadingKeys[$uses]) {
	            tables.push(loadAsync($uses));
	          }

	          var allTranslationsLoaded = function (tableData) {
	            $translationTable = {};
	            angular.forEach(tableData, function (data) {
	              translations(data.key, data.table);
	            });
	            if ($uses) {
	              useLanguage($uses);
	            }
	            resolve();
	          };
	          allTranslationsLoaded.displayName = 'refreshPostProcessor';

	          $q.all(tables).then(allTranslationsLoaded, reject);

	        } else if ($translationTable[langKey]) {

	          var oneTranslationsLoaded = function (data) {
	            translations(data.key, data.table);
	            if (langKey === $uses) {
	              useLanguage($uses);
	            }
	            resolve();
	            return data;
	          };
	          oneTranslationsLoaded.displayName = 'refreshPostProcessor';

	          loadAsync(langKey).then(oneTranslationsLoaded, reject);

	        } else {
	          reject();
	        }
	        return deferred.promise;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#instant
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns a translation instantly from the internal state of loaded translation. All rules
	       * regarding the current language, the preferred language of even fallback languages will be
	       * used except any promise handling. If a language was not found, an asynchronous loading
	       * will be invoked in the background.
	       *
	       * @param {string|array} translationId A token which represents a translation id
	       *                                     This can be optionally an array of translation ids which
	       *                                     results that the function's promise returns an object where
	       *                                     each key is the translation id and the value the translation.
	       * @param {object} interpolateParams Params
	       * @param {string} interpolationId The id of the interpolation to use
	       * @param {string} forceLanguage A language to be used instead of the current language
	       *
	       * @return {string|object} translation
	       */
	      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {

	        // we don't want to re-negotiate $uses
	        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses
	              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;

	        // Detect undefined and null values to shorten the execution and prevent exceptions
	        if (translationId === null || angular.isUndefined(translationId)) {
	          return translationId;
	        }

	        // Check forceLanguage is present
	        if (forceLanguage) {
	          loadTranslationsIfMissing(forceLanguage);
	        }

	        // Duck detection: If the first argument is an array, a bunch of translations was requested.
	        // The result is an object.
	        if (angular.isArray(translationId)) {
	          var results = {};
	          for (var i = 0, c = translationId.length; i < c; i++) {
	            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);
	          }
	          return results;
	        }

	        // We discarded unacceptable values. So we just need to verify if translationId is empty String
	        if (angular.isString(translationId) && translationId.length < 1) {
	          return translationId;
	        }

	        // trim off any whitespace
	        if (translationId) {
	          translationId = trim.apply(translationId);
	        }

	        var result, possibleLangKeys = [];
	        if ($preferredLanguage) {
	          possibleLangKeys.push($preferredLanguage);
	        }
	        if (uses) {
	          possibleLangKeys.push(uses);
	        }
	        if ($fallbackLanguage && $fallbackLanguage.length) {
	          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
	        }
	        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
	          var possibleLangKey = possibleLangKeys[j];
	          if ($translationTable[possibleLangKey]) {
	            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {
	              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);
	            }
	          }
	          if (typeof result !== 'undefined') {
	            break;
	          }
	        }

	        if (!result && result !== '') {
	          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
	            result = applyNotFoundIndicators(translationId);
	          } else {
	            // Return translation of default interpolator if not found anything.
	            result = defaultInterpolator.interpolate(translationId, interpolateParams, 'filter');
	            if ($missingTranslationHandlerFactory && !pendingLoader) {
	              result = translateByHandler(translationId, interpolateParams);
	            }
	          }
	        }

	        return result;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#versionInfo
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the current version information for the angular-translate library
	       *
	       * @return {string} angular-translate version
	       */
	      $translate.versionInfo = function () {
	        return version;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#loaderCache
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns the defined loaderCache.
	       *
	       * @return {boolean|string|object} current value of loaderCache
	       */
	      $translate.loaderCache = function () {
	        return loaderCache;
	      };

	      // internal purpose only
	      $translate.directivePriority = function () {
	        return directivePriority;
	      };

	      // internal purpose only
	      $translate.statefulFilter = function () {
	        return statefulFilter;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#isReady
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns whether the service is "ready" to translate (i.e. loading 1st language).
	       *
	       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.
	       *
	       * @return {boolean} current value of ready
	       */
	      $translate.isReady = function () {
	        return $isReady;
	      };

	      var $onReadyDeferred = $q.defer();
	      $onReadyDeferred.promise.then(function () {
	        $isReady = true;
	      });

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#onReady
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * Returns whether the service is "ready" to translate (i.e. loading 1st language).
	       *
	       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.
	       *
	       * @param {Function=} fn Function to invoke when service is ready
	       * @return {object} Promise resolved when service is ready
	       */
	      $translate.onReady = function (fn) {
	        var deferred = $q.defer();
	        if (angular.isFunction(fn)) {
	          deferred.promise.then(fn);
	        }
	        if ($isReady) {
	          deferred.resolve();
	        } else {
	          $onReadyDeferred.promise.then(deferred.resolve);
	        }
	        return deferred.promise;
	      };

	      /**
	       * @ngdoc function
	       * @name pascalprecht.translate.$translate#getAvailableLanguageKeys
	       * @methodOf pascalprecht.translate.$translate
	       *
	       * @description
	       * This function simply returns the registered language keys being defined before in the config phase
	       * With this, an application can use the array to provide a language selection dropdown or similar
	       * without any additional effort
	       *
	       * @returns {object} returns the list of possibly registered language keys and mapping or null if not defined
	       */
	      $translate.getAvailableLanguageKeys = function () {
	        if ($availableLanguageKeys.length > 0) {
	          return $availableLanguageKeys;
	        }
	        return null;
	      };

	      // Whenever $translateReady is being fired, this will ensure the state of $isReady
	      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {
	        $onReadyDeferred.resolve();
	        globalOnReadyListener(); // one time only
	        globalOnReadyListener = null;
	      });
	      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {
	        $onReadyDeferred.resolve();
	        globalOnChangeListener(); // one time only
	        globalOnChangeListener = null;
	      });

	      if ($loaderFactory) {

	        // If at least one async loader is defined and there are no
	        // (default) translations available we should try to load them.
	        if (angular.equals($translationTable, {})) {
	          if ($translate.use()) {
	            $translate.use($translate.use());
	          }
	        }

	        // Also, if there are any fallback language registered, we start
	        // loading them asynchronously as soon as we can.
	        if ($fallbackLanguage && $fallbackLanguage.length) {
	          var processAsyncResult = function (translation) {
	            translations(translation.key, translation.table);
	            $rootScope.$emit('$translateChangeEnd', { language: translation.key });
	            return translation;
	          };
	          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
	            var fallbackLanguageId = $fallbackLanguage[i];
	            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {
	              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);
	            }
	          }
	        }
	      } else {
	        $rootScope.$emit('$translateReady', { language: $translate.use() });
	      }

	      return $translate;
	    }
	  ];
	}

	$translate.displayName = 'displayName';

	/**
	 * @ngdoc object
	 * @name pascalprecht.translate.$translateDefaultInterpolation
	 * @requires $interpolate
	 *
	 * @description
	 * Uses angular's `$interpolate` services to interpolate strings against some values.
	 *
	 * Be aware to configure a proper sanitization strategy.
	 *
	 * See also:
	 * * {@link pascalprecht.translate.$translateSanitization}
	 *
	 * @return {object} $translateDefaultInterpolation Interpolator service
	 */
	angular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);

	function $translateDefaultInterpolation ($interpolate, $translateSanitization) {

	  'use strict';

	  var $translateInterpolator = {},
	      $locale,
	      $identifier = 'default';

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale
	   * @methodOf pascalprecht.translate.$translateDefaultInterpolation
	   *
	   * @description
	   * Sets current locale (this is currently not use in this interpolation).
	   *
	   * @param {string} locale Language key or locale.
	   */
	  $translateInterpolator.setLocale = function (locale) {
	    $locale = locale;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier
	   * @methodOf pascalprecht.translate.$translateDefaultInterpolation
	   *
	   * @description
	   * Returns an identifier for this interpolation service.
	   *
	   * @returns {string} $identifier
	   */
	  $translateInterpolator.getInterpolationIdentifier = function () {
	    return $identifier;
	  };

	  /**
	   * @deprecated will be removed in 3.0
	   * @see {@link pascalprecht.translate.$translateSanitization}
	   */
	  $translateInterpolator.useSanitizeValueStrategy = function (value) {
	    $translateSanitization.useStrategy(value);
	    return this;
	  };

	  /**
	   * @ngdoc function
	   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate
	   * @methodOf pascalprecht.translate.$translateDefaultInterpolation
	   *
	   * @description
	   * Interpolates given value agains given interpolate params using angulars
	   * `$interpolate` service.
	   *
	   * Since AngularJS 1.5, `value` must not be a string but can be anything input.
	   *
	   * @returns {string} interpolated string.
	   */
	  $translateInterpolator.interpolate = function (value, interpolationParams, context) {
	    interpolationParams = interpolationParams || {};
	    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params', undefined, context);

	    var interpolatedText;
	    if (angular.isNumber(value)) {
	      // numbers are safe
	      interpolatedText = '' + value;
	    } else if (angular.isString(value)) {
	      // strings must be interpolated (that's the job here)
	      interpolatedText = $interpolate(value)(interpolationParams);
	      interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text', undefined, context);
	    } else {
	      // neither a number or a string, cant interpolate => empty string
	      interpolatedText = '';
	    }

	    return interpolatedText;
	  };

	  return $translateInterpolator;
	}

	$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';

	angular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');

	angular.module('pascalprecht.translate')
	/**
	 * @ngdoc directive
	 * @name pascalprecht.translate.directive:translate
	 * @requires $interpolate, 
	 * @requires $compile, 
	 * @requires $parse, 
	 * @requires $rootScope
	 * @restrict AE
	 *
	 * @description
	 * Translates given translation id either through attribute or DOM content.
	 * Internally it uses $translate service to translate the translation id. It possible to
	 * pass an optional `translate-values` object literal as string into translation id.
	 *
	 * @param {string=} translate Translation id which could be either string or interpolated string.
	 * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.
	 * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.
	 * @param {string=} translate-default will be used unless translation was successful
	 * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}
	 * @param {boolean=} translate-keep-content (default true if present) defines that in case a KEY could not be translated, that the existing content is left in the innerHTML}
	 *
	 * @example
	   <example module="ngView">
	    <file name="index.html">
	      <div ng-controller="TranslateCtrl">

	        <pre translate="TRANSLATION_ID"></pre>
	        <pre translate>TRANSLATION_ID</pre>
	        <pre translate translate-attr-title="TRANSLATION_ID"></pre>
	        <pre translate="{{translationId}}"></pre>
	        <pre translate>{{translationId}}</pre>
	        <pre translate="WITH_VALUES" translate-values="{value: 5}"></pre>
	        <pre translate translate-values="{value: 5}">WITH_VALUES</pre>
	        <pre translate="WITH_VALUES" translate-values="{{values}}"></pre>
	        <pre translate translate-values="{{values}}">WITH_VALUES</pre>
	        <pre translate translate-attr-title="WITH_VALUES" translate-values="{{values}}"></pre>
	        <pre translate="WITH_CAMEL_CASE_KEY" translate-value-camel-case-key="Hi"></pre>

	      </div>
	    </file>
	    <file name="script.js">
	      angular.module('ngView', ['pascalprecht.translate'])

	      .config(function ($translateProvider) {

	        $translateProvider.translations('en',{
	          'TRANSLATION_ID': 'Hello there!',
	          'WITH_VALUES': 'The following value is dynamic: {{value}}',
	          'WITH_CAMEL_CASE_KEY': 'The interpolation key is camel cased: {{camelCaseKey}}'
	        }).preferredLanguage('en');

	      });

	      angular.module('ngView').controller('TranslateCtrl', function ($scope) {
	        $scope.translationId = 'TRANSLATION_ID';

	        $scope.values = {
	          value: 78
	        };
	      });
	    </file>
	    <file name="scenario.js">
	      it('should translate', function () {
	        inject(function ($rootScope, $compile) {
	          $rootScope.translationId = 'TRANSLATION_ID';

	          element = $compile('<p translate="TRANSLATION_ID"></p>')($rootScope);
	          $rootScope.$digest();
	          expect(element.text()).toBe('Hello there!');

	          element = $compile('<p translate="{{translationId}}"></p>')($rootScope);
	          $rootScope.$digest();
	          expect(element.text()).toBe('Hello there!');

	          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);
	          $rootScope.$digest();
	          expect(element.text()).toBe('Hello there!');

	          element = $compile('<p translate>{{translationId}}</p>')($rootScope);
	          $rootScope.$digest();
	          expect(element.text()).toBe('Hello there!');

	          element = $compile('<p translate translate-attr-title="TRANSLATION_ID"></p>')($rootScope);
	          $rootScope.$digest();
	          expect(element.attr('title')).toBe('Hello there!');

	          element = $compile('<p translate="WITH_CAMEL_CASE_KEY" translate-value-camel-case-key="Hello"></p>')($rootScope);
	          $rootScope.$digest();
	          expect(element.text()).toBe('The interpolation key is camel cased: Hello');
	        });
	      });
	    </file>
	   </example>
	 */
	.directive('translate', translateDirective);
	function translateDirective($translate, $interpolate, $compile, $parse, $rootScope) {

	  'use strict';

	  /**
	   * @name trim
	   * @private
	   *
	   * @description
	   * trim polyfill
	   *
	   * @returns {string} The string stripped of whitespace from both ends
	   */
	  var trim = function() {
	    return this.toString().replace(/^\s+|\s+$/g, '');
	  };

	  return {
	    restrict: 'AE',
	    scope: true,
	    priority: $translate.directivePriority(),
	    compile: function (tElement, tAttr) {

	      var translateValuesExist = (tAttr.translateValues) ?
	        tAttr.translateValues : undefined;

	      var translateInterpolation = (tAttr.translateInterpolation) ?
	        tAttr.translateInterpolation : undefined;

	      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);

	      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',
	          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';

	      return function linkFn(scope, iElement, iAttr) {

	        scope.interpolateParams = {};
	        scope.preText = '';
	        scope.postText = '';
	        scope.translateNamespace = getTranslateNamespace(scope);
	        var translationIds = {};

	        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {
	          // initial setup
	          if (iAttr.translateValues) {
	            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));
	          }
	          // initially fetch all attributes if existing and fill the params
	          if (translateValueExist) {
	            for (var attr in tAttr) {
	              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
	                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);
	                interpolateParams[attributeName] = tAttr[attr];
	              }
	            }
	          }
	        };

	        // Ensures any change of the attribute "translate" containing the id will
	        // be re-stored to the scope's "translationId".
	        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.
	        var observeElementTranslation = function (translationId) {

	          // Remove any old watcher
	          if (angular.isFunction(observeElementTranslation._unwatchOld)) {
	            observeElementTranslation._unwatchOld();
	            observeElementTranslation._unwatchOld = undefined;
	          }

	          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {
	            var iElementText = trim.apply(iElement.text());

	            // Resolve translation id by inner html if required
	            var interpolateMatches = iElementText.match(interpolateRegExp);
	            // Interpolate translation id if required
	            if (angular.isArray(interpolateMatches)) {
	              scope.preText = interpolateMatches[1];
	              scope.postText = interpolateMatches[3];
	              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
	              var watcherMatches = iElementText.match(watcherRegExp);
	              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
	                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {
	                  translationIds.translate = newValue;
	                  updateTranslations();
	                });
	              }
	            } else {
	              // do not assigne the translation id if it is empty.
	              translationIds.translate = !iElementText ? undefined : iElementText;
	            }
	          } else {
	            translationIds.translate = translationId;
	          }
	          updateTranslations();
	        };

	        var observeAttributeTranslation = function (translateAttr) {
	          iAttr.$observe(translateAttr, function (translationId) {
	            translationIds[translateAttr] = translationId;
	            updateTranslations();
	          });
	        };

	        // initial setup with values
	        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);

	        var firstAttributeChangedEvent = true;
	        iAttr.$observe('translate', function (translationId) {
	          if (typeof translationId === 'undefined') {
	            // case of element "<translate>xyz</translate>"
	            observeElementTranslation('');
	          } else {
	            // case of regular attribute
	            if (translationId !== '' || !firstAttributeChangedEvent) {
	              translationIds.translate = translationId;
	              updateTranslations();
	            }
	          }
	          firstAttributeChangedEvent = false;
	        });

	        for (var translateAttr in iAttr) {
	          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr' && translateAttr.length > 13) {
	            observeAttributeTranslation(translateAttr);
	          }
	        }

	        iAttr.$observe('translateDefault', function (value) {
	          scope.defaultText = value;
	          updateTranslations();
	        });

	        if (translateValuesExist) {
	          iAttr.$observe('translateValues', function (interpolateParams) {
	            if (interpolateParams) {
	              scope.$parent.$watch(function () {
	                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
	              });
	            }
	          });
	        }

	        if (translateValueExist) {
	          var observeValueAttribute = function (attrName) {
	            iAttr.$observe(attrName, function (value) {
	              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);
	              scope.interpolateParams[attributeName] = value;
	            });
	          };
	          for (var attr in iAttr) {
	            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
	              observeValueAttribute(attr);
	            }
	          }
	        }

	        // Master update function
	        var updateTranslations = function () {
	          for (var key in translationIds) {
	            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {
	              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);
	            }
	          }
	        };

	        // Put translation processing function outside loop
	        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {
	          if (translationId) {
	            // if translation id starts with '.' and translateNamespace given, prepend namespace
	            if (translateNamespace && translationId.charAt(0) === '.') {
	              translationId = translateNamespace + translationId;
	            }

	            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)
	              .then(function (translation) {
	                applyTranslation(translation, scope, true, translateAttr);
	              }, function (translationId) {
	                applyTranslation(translationId, scope, false, translateAttr);
	              });
	          } else {
	            // as an empty string cannot be translated, we can solve this using successful=false
	            applyTranslation(translationId, scope, false, translateAttr);
	          }
	        };

	        var applyTranslation = function (value, scope, successful, translateAttr) {
	          if (!successful) {
	            if (typeof scope.defaultText !== 'undefined') {
	              value = scope.defaultText;
	            }
	          }
	          if (translateAttr === 'translate') {
	            // default translate into innerHTML
	            if (successful || (!successful && !$translate.isKeepContent() && typeof iAttr.translateKeepContent === 'undefined')) {
	              iElement.empty().append(scope.preText + value + scope.postText);
	            }
	            var globallyEnabled = $translate.isPostCompilingEnabled();
	            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';
	            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';
	            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {
	              $compile(iElement.contents())(scope);
	            }
	          } else {
	            // translate attribute
	            var attributeName = iAttr.$attr[translateAttr];
	            if (attributeName.substr(0, 5) === 'data-') {
	              // ensure html5 data prefix is stripped
	              attributeName = attributeName.substr(5);
	            }
	            attributeName = attributeName.substr(15);
	            iElement.attr(attributeName, value);
	          }
	        };

	        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {
	          scope.$watch('interpolateParams', updateTranslations, true);
	        }

	        // Replaced watcher on translateLanguage with event listener
	        scope.$on('translateLanguageChanged', updateTranslations);

	        // Ensures the text will be refreshed after the current language was changed
	        // w/ $translate.use(...)
	        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);

	        // ensure translation will be looked up at least one
	        if (iElement.text().length) {
	          if (iAttr.translate) {
	            observeElementTranslation(iAttr.translate);
	          } else {
	            observeElementTranslation('');
	          }
	        } else if (iAttr.translate) {
	          // ensure attribute will be not skipped
	          observeElementTranslation(iAttr.translate);
	        }
	        updateTranslations();
	        scope.$on('$destroy', unbind);
	      };
	    }
	  };
	}

	/**
	 * Returns the scope's namespace.
	 * @private
	 * @param scope
	 * @returns {string}
	 */
	function getTranslateNamespace(scope) {
	  'use strict';
	  if (scope.translateNamespace) {
	    return scope.translateNamespace;
	  }
	  if (scope.$parent) {
	    return getTranslateNamespace(scope.$parent);
	  }
	}

	translateDirective.displayName = 'translateDirective';

	angular.module('pascalprecht.translate')
	/**
	 * @ngdoc directive
	 * @name pascalprecht.translate.directive:translate-attr
	 * @restrict A
	 *
	 * @description
	 * Translates attributes like translate-attr-ATTR, but with an object like ng-class.
	 * Internally it uses `translate` service to translate translation id. It possible to
	 * pass an optional `translate-values` object literal as string into translation id.
	 *
	 * @param {string=} translate-attr Object literal mapping attributes to translation ids.
	 * @param {string=} translate-values Values to pass into the translation ids. Can be passed as object literal string.
	 *
	 * @example
	   <example module="ngView">
	    <file name="index.html">
	      <div ng-controller="TranslateCtrl">

	        <input translate-attr="{ placeholder: translationId, title: 'WITH_VALUES' }" translate-values="{value: 5}" />

	      </div>
	    </file>
	    <file name="script.js">
	      angular.module('ngView', ['pascalprecht.translate'])

	      .config(function ($translateProvider) {

	        $translateProvider.translations('en',{
	          'TRANSLATION_ID': 'Hello there!',
	          'WITH_VALUES': 'The following value is dynamic: {{value}}',
	        }).preferredLanguage('en');

	      });

	      angular.module('ngView').controller('TranslateCtrl', function ($scope) {
	        $scope.translationId = 'TRANSLATION_ID';

	        $scope.values = {
	          value: 78
	        };
	      });
	    </file>
	    <file name="scenario.js">
	      it('should translate', function () {
	        inject(function ($rootScope, $compile) {
	          $rootScope.translationId = 'TRANSLATION_ID';

	          element = $compile('<input translate-attr="{ placeholder: translationId, title: 'WITH_VALUES' }" translate-values="{ value: 5 }" />')($rootScope);
	          $rootScope.$digest();
	          expect(element.attr('placeholder)).toBe('Hello there!');
	          expect(element.attr('title)).toBe('The following value is dynamic: 5');
	        });
	      });
	    </file>
	   </example>
	 */
	.directive('translateAttr', translateAttrDirective);
	function translateAttrDirective($translate, $rootScope) {

	  'use strict';

	  return {
	    restrict: 'A',
	    priority: $translate.directivePriority(),
	    link: function linkFn(scope, element, attr) {

	      var translateAttr,
	          translateValues,
	          previousAttributes = {};

	      // Main update translations function
	      var updateTranslations = function () {
	        angular.forEach(translateAttr, function (translationId, attributeName) {
	          if (!translationId) {
	            return;
	          }
	          previousAttributes[attributeName] = true;

	          // if translation id starts with '.' and translateNamespace given, prepend namespace
	          if (scope.translateNamespace && translationId.charAt(0) === '.') {
	            translationId = scope.translateNamespace + translationId;
	          }
	          $translate(translationId, translateValues, attr.translateInterpolation, undefined, scope.translateLanguage)
	            .then(function (translation) {
	              element.attr(attributeName, translation);
	            }, function (translationId) {
	              element.attr(attributeName, translationId);
	            });
	        });

	        // Removing unused attributes that were previously used
	        angular.forEach(previousAttributes, function (flag, attributeName) {
	          if (!translateAttr[attributeName]) {
	            element.removeAttr(attributeName);
	            delete previousAttributes[attributeName];
	          }
	        });
	      };

	      // Watch for attribute changes
	      watchAttribute(
	        scope,
	        attr.translateAttr,
	        function (newValue) { translateAttr = newValue; },
	        updateTranslations
	      );
	      // Watch for value changes
	      watchAttribute(
	        scope,
	        attr.translateValues,
	        function (newValue) { translateValues = newValue; },
	        updateTranslations
	      );

	      if (attr.translateValues) {
	        scope.$watch(attr.translateValues, updateTranslations, true);
	      }

	      // Replaced watcher on translateLanguage with event listener
	      scope.$on('translateLanguageChanged', updateTranslations);

	      // Ensures the text will be refreshed after the current language was changed
	      // w/ $translate.use(...)
	      var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);

	      updateTranslations();
	      scope.$on('$destroy', unbind);
	    }
	  };
	}

	function watchAttribute(scope, attribute, valueCallback, changeCallback) {
	  'use strict';
	  if (!attribute) {
	    return;
	  }
	  if (attribute.substr(0, 2) === '::') {
	    attribute = attribute.substr(2);
	  } else {
	    scope.$watch(attribute, function(newValue) {
	      valueCallback(newValue);
	      changeCallback();
	    }, true);
	  }
	  valueCallback(scope.$eval(attribute));
	}

	translateAttrDirective.displayName = 'translateAttrDirective';

	angular.module('pascalprecht.translate')
	/**
	 * @ngdoc directive
	 * @name pascalprecht.translate.directive:translateCloak
	 * @requires $rootScope
	 * @requires $translate
	 * @restrict A
	 *
	 * $description
	 * Adds a `translate-cloak` class name to the given element where this directive
	 * is applied initially and removes it, once a loader has finished loading.
	 *
	 * This directive can be used to prevent initial flickering when loading translation
	 * data asynchronously.
	 *
	 * The class name is defined in
	 * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.
	 *
	 * @param {string=} translate-cloak If a translationId is provided, it will be used for showing
	 *                                  or hiding the cloak. Basically it relies on the translation
	 *                                  resolve.
	 */
	.directive('translateCloak', translateCloakDirective);

	function translateCloakDirective($translate, $rootScope) {

	  'use strict';

	  return {
	    compile: function (tElement) {
	      var applyCloak = function () {
	        tElement.addClass($translate.cloakClassName());
	      },
	      removeCloak = function () {
	        tElement.removeClass($translate.cloakClassName());
	      };
	      $translate.onReady(function () {
	        removeCloak();
	      });
	      applyCloak();

	      return function linkFn(scope, iElement, iAttr) {
	        if (iAttr.translateCloak && iAttr.translateCloak.length) {
	          // Register a watcher for the defined translation allowing a fine tuned cloak
	          iAttr.$observe('translateCloak', function (translationId) {
	            $translate(translationId).then(removeCloak, applyCloak);
	          });
	          // Register for change events as this is being another indicicator revalidating the cloak)
	          $rootScope.$on('$translateChangeSuccess', function () {
	            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);
	          });
	        }
	      };
	    }
	  };
	}

	translateCloakDirective.displayName = 'translateCloakDirective';

	angular.module('pascalprecht.translate')
	/**
	 * @ngdoc directive
	 * @name pascalprecht.translate.directive:translateNamespace
	 * @restrict A
	 *
	 * @description
	 * Translates given translation id either through attribute or DOM content.
	 * Internally it uses `translate` filter to translate translation id. It possible to
	 * pass an optional `translate-values` object literal as string into translation id.
	 *
	 * @param {string=} translate namespace name which could be either string or interpolated string.
	 *
	 * @example
	   <example module="ngView">
	    <file name="index.html">
	      <div translate-namespace="CONTENT">

	        <div>
	            <h1 translate>.HEADERS.TITLE</h1>
	            <h1 translate>.HEADERS.WELCOME</h1>
	        </div>

	        <div translate-namespace=".HEADERS">
	            <h1 translate>.TITLE</h1>
	            <h1 translate>.WELCOME</h1>
	        </div>

	      </div>
	    </file>
	    <file name="script.js">
	      angular.module('ngView', ['pascalprecht.translate'])

	      .config(function ($translateProvider) {

	        $translateProvider.translations('en',{
	          'TRANSLATION_ID': 'Hello there!',
	          'CONTENT': {
	            'HEADERS': {
	                TITLE: 'Title'
	            }
	          },
	          'CONTENT.HEADERS.WELCOME': 'Welcome'
	        }).preferredLanguage('en');

	      });

	    </file>
	   </example>
	 */
	.directive('translateNamespace', translateNamespaceDirective);

	function translateNamespaceDirective() {

	  'use strict';

	  return {
	    restrict: 'A',
	    scope: true,
	    compile: function () {
	      return {
	        pre: function (scope, iElement, iAttrs) {
	          scope.translateNamespace = getTranslateNamespace(scope);

	          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {
	            scope.translateNamespace += iAttrs.translateNamespace;
	          } else {
	            scope.translateNamespace = iAttrs.translateNamespace;
	          }
	        }
	      };
	    }
	  };
	}

	/**
	 * Returns the scope's namespace.
	 * @private
	 * @param scope
	 * @returns {string}
	 */
	function getTranslateNamespace(scope) {
	  'use strict';
	  if (scope.translateNamespace) {
	    return scope.translateNamespace;
	  }
	  if (scope.$parent) {
	    return getTranslateNamespace(scope.$parent);
	  }
	}

	translateNamespaceDirective.displayName = 'translateNamespaceDirective';

	angular.module('pascalprecht.translate')
	/**
	 * @ngdoc directive
	 * @name pascalprecht.translate.directive:translateLanguage
	 * @restrict A
	 *
	 * @description
	 * Forces the language to the directives in the underlying scope.
	 *
	 * @param {string=} translate language that will be negotiated.
	 *
	 * @example
	   <example module="ngView">
	    <file name="index.html">
	      <div>

	        <div>
	            <h1 translate>HELLO</h1>
	        </div>

	        <div translate-language="de">
	            <h1 translate>HELLO</h1>
	        </div>

	      </div>
	    </file>
	    <file name="script.js">
	      angular.module('ngView', ['pascalprecht.translate'])

	      .config(function ($translateProvider) {

	        $translateProvider
	          .translations('en',{
	            'HELLO': 'Hello world!'
	          })
	          .translations('de',{
	            'HELLO': 'Hallo Welt!'
	          })
	          .preferredLanguage('en');

	      });

	    </file>
	   </example>
	 */
	.directive('translateLanguage', translateLanguageDirective);

	function translateLanguageDirective() {

	  'use strict';

	  return {
	    restrict: 'A',
	    scope: true,
	    compile: function () {
	      return function linkFn(scope, iElement, iAttrs) {

	        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {
	          scope.translateLanguage = newTranslateLanguage;
	        });

	        scope.$watch('translateLanguage', function(){
	          scope.$broadcast('translateLanguageChanged');
	        });
	      };
	    }
	  };
	}

	translateLanguageDirective.displayName = 'translateLanguageDirective';

	angular.module('pascalprecht.translate')
	/**
	 * @ngdoc filter
	 * @name pascalprecht.translate.filter:translate
	 * @requires $parse
	 * @requires pascalprecht.translate.$translate
	 * @function
	 *
	 * @description
	 * Uses `$translate` service to translate contents. Accepts interpolate parameters
	 * to pass dynamized values though translation.
	 *
	 * @param {string} translationId A translation id to be translated.
	 * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.
	 *
	 * @returns {string} Translated text.
	 *
	 * @example
	   <example module="ngView">
	    <file name="index.html">
	      <div ng-controller="TranslateCtrl">

	        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>
	        <pre>{{ translationId | translate }}</pre>
	        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>
	        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>

	      </div>
	    </file>
	    <file name="script.js">
	      angular.module('ngView', ['pascalprecht.translate'])

	      .config(function ($translateProvider) {

	        $translateProvider.translations('en', {
	          'TRANSLATION_ID': 'Hello there!',
	          'WITH_VALUES': 'The following value is dynamic: {{value}}'
	        });
	        $translateProvider.preferredLanguage('en');

	      });

	      angular.module('ngView').controller('TranslateCtrl', function ($scope) {
	        $scope.translationId = 'TRANSLATION_ID';

	        $scope.values = {
	          value: 78
	        };
	      });
	    </file>
	   </example>
	 */
	.filter('translate', translateFilterFactory);

	function translateFilterFactory($parse, $translate) {

	  'use strict';

	  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {
	    if (!angular.isObject(interpolateParams)) {
	      interpolateParams = $parse(interpolateParams)(this);
	    }

	    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);
	  };

	  if ($translate.statefulFilter()) {
	    translateFilter.$stateful = true;
	  }

	  return translateFilter;
	}

	translateFilterFactory.displayName = 'translateFilterFactory';

	angular.module('pascalprecht.translate')

	/**
	 * @ngdoc object
	 * @name pascalprecht.translate.$translationCache
	 * @requires $cacheFactory
	 *
	 * @description
	 * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You
	 * can load translation tables directly into the cache by consuming the
	 * `$translationCache` service directly.
	 *
	 * @return {object} $cacheFactory object.
	 */
	  .factory('$translationCache', $translationCache);

	function $translationCache($cacheFactory) {

	  'use strict';

	  return $cacheFactory('translations');
	}

	$translationCache.displayName = '$translationCache';
	return 'pascalprecht.translate';

	}));


/***/ },
/* 28 */
/***/ function(module, exports) {

	/*
	 * angular-ui-bootstrap
	 * http://angular-ui.github.io/bootstrap/

	 * Version: 1.2.5 - 2016-03-20
	 * License: MIT
	 */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.isClass","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.debounce","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.paging","ui.bootstrap.pager","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
	angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html","uib/template/accordion/accordion.html","uib/template/alert/alert.html","uib/template/carousel/carousel.html","uib/template/carousel/slide.html","uib/template/datepicker/datepicker.html","uib/template/datepicker/day.html","uib/template/datepicker/month.html","uib/template/datepicker/popup.html","uib/template/datepicker/year.html","uib/template/modal/backdrop.html","uib/template/modal/window.html","uib/template/pager/pager.html","uib/template/pagination/pagination.html","uib/template/tooltip/tooltip-html-popup.html","uib/template/tooltip/tooltip-popup.html","uib/template/tooltip/tooltip-template-popup.html","uib/template/popover/popover-html.html","uib/template/popover/popover-template.html","uib/template/popover/popover.html","uib/template/progressbar/bar.html","uib/template/progressbar/progress.html","uib/template/progressbar/progressbar.html","uib/template/rating/rating.html","uib/template/tabs/tab.html","uib/template/tabs/tabset.html","uib/template/timepicker/timepicker.html","uib/template/typeahead/typeahead-match.html","uib/template/typeahead/typeahead-popup.html"]);
	angular.module('ui.bootstrap.collapse', [])

	  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
	    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
	    return {
	      link: function(scope, element, attrs) {
	        var expandingExpr = $parse(attrs.expanding),
	            expandedExpr = $parse(attrs.expanded),
	            collapsingExpr = $parse(attrs.collapsing),
	            collapsedExpr = $parse(attrs.collapsed);

	        if (!scope.$eval(attrs.uibCollapse)) {
	          element.addClass('in')
	            .addClass('collapse')
	            .attr('aria-expanded', true)
	            .attr('aria-hidden', false)
	            .css({height: 'auto'});
	        }

	        function expand() {
	          if (element.hasClass('collapse') && element.hasClass('in')) {
	            return;
	          }

	          $q.resolve(expandingExpr(scope))
	            .then(function() {
	              element.removeClass('collapse')
	                .addClass('collapsing')
	                .attr('aria-expanded', true)
	                .attr('aria-hidden', false);

	              if ($animateCss) {
	                $animateCss(element, {
	                  addClass: 'in',
	                  easing: 'ease',
	                  to: { height: element[0].scrollHeight + 'px' }
	                }).start()['finally'](expandDone);
	              } else {
	                $animate.addClass(element, 'in', {
	                  to: { height: element[0].scrollHeight + 'px' }
	                }).then(expandDone);
	              }
	            });
	        }

	        function expandDone() {
	          element.removeClass('collapsing')
	            .addClass('collapse')
	            .css({height: 'auto'});
	          expandedExpr(scope);
	        }

	        function collapse() {
	          if (!element.hasClass('collapse') && !element.hasClass('in')) {
	            return collapseDone();
	          }

	          $q.resolve(collapsingExpr(scope))
	            .then(function() {
	              element
	                // IMPORTANT: The height must be set before adding "collapsing" class.
	                // Otherwise, the browser attempts to animate from height 0 (in
	                // collapsing class) to the given height here.
	                .css({height: element[0].scrollHeight + 'px'})
	                // initially all panel collapse have the collapse class, this removal
	                // prevents the animation from jumping to collapsed state
	                .removeClass('collapse')
	                .addClass('collapsing')
	                .attr('aria-expanded', false)
	                .attr('aria-hidden', true);

	              if ($animateCss) {
	                $animateCss(element, {
	                  removeClass: 'in',
	                  to: {height: '0'}
	                }).start()['finally'](collapseDone);
	              } else {
	                $animate.removeClass(element, 'in', {
	                  to: {height: '0'}
	                }).then(collapseDone);
	              }
	            });
	        }

	        function collapseDone() {
	          element.css({height: '0'}); // Required so that collapse works when animation is disabled
	          element.removeClass('collapsing')
	            .addClass('collapse');
	          collapsedExpr(scope);
	        }

	        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
	          if (shouldCollapse) {
	            collapse();
	          } else {
	            expand();
	          }
	        });
	      }
	    };
	  }]);

	angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

	.constant('uibAccordionConfig', {
	  closeOthers: true
	})

	.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
	  // This array keeps track of the accordion groups
	  this.groups = [];

	  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
	  this.closeOthers = function(openGroup) {
	    var closeOthers = angular.isDefined($attrs.closeOthers) ?
	      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	    if (closeOthers) {
	      angular.forEach(this.groups, function(group) {
	        if (group !== openGroup) {
	          group.isOpen = false;
	        }
	      });
	    }
	  };

	  // This is called from the accordion-group directive to add itself to the accordion
	  this.addGroup = function(groupScope) {
	    var that = this;
	    this.groups.push(groupScope);

	    groupScope.$on('$destroy', function(event) {
	      that.removeGroup(groupScope);
	    });
	  };

	  // This is called from the accordion-group directive when to remove itself
	  this.removeGroup = function(group) {
	    var index = this.groups.indexOf(group);
	    if (index !== -1) {
	      this.groups.splice(index, 1);
	    }
	  };
	}])

	// The accordion directive simply sets up the directive controller
	// and adds an accordion CSS class to itself element.
	.directive('uibAccordion', function() {
	  return {
	    controller: 'UibAccordionController',
	    controllerAs: 'accordion',
	    transclude: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/accordion/accordion.html';
	    }
	  };
	})

	// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
	.directive('uibAccordionGroup', function() {
	  return {
	    require: '^uibAccordion',         // We need this directive to be inside an accordion
	    transclude: true,              // It transcludes the contents of the directive into the template
	    replace: true,                // The element containing the directive will be replaced with the template
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
	    },
	    scope: {
	      heading: '@',               // Interpolate the heading attribute onto this scope
	      panelClass: '@?',           // Ditto with panelClass
	      isOpen: '=?',
	      isDisabled: '=?'
	    },
	    controller: function() {
	      this.setHeading = function(element) {
	        this.heading = element;
	      };
	    },
	    link: function(scope, element, attrs, accordionCtrl) {
	      accordionCtrl.addGroup(scope);

	      scope.openClass = attrs.openClass || 'panel-open';
	      scope.panelClass = attrs.panelClass || 'panel-default';
	      scope.$watch('isOpen', function(value) {
	        element.toggleClass(scope.openClass, !!value);
	        if (value) {
	          accordionCtrl.closeOthers(scope);
	        }
	      });

	      scope.toggleOpen = function($event) {
	        if (!scope.isDisabled) {
	          if (!$event || $event.which === 32) {
	            scope.isOpen = !scope.isOpen;
	          }
	        }
	      };

	      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	      scope.headingId = id + '-tab';
	      scope.panelId = id + '-panel';
	    }
	  };
	})

	// Use accordion-heading below an accordion-group to provide a heading containing HTML
	.directive('uibAccordionHeading', function() {
	  return {
	    transclude: true,   // Grab the contents to be used as the heading
	    template: '',       // In effect remove this element!
	    replace: true,
	    require: '^uibAccordionGroup',
	    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
	      // Pass the heading to the accordion-group controller
	      // so that it can be transcluded into the right place in the template
	      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
	    }
	  };
	})

	// Use in the accordion-group template to indicate where you want the heading to be transcluded
	// You must provide the property on the accordion-group controller that will hold the transcluded element
	.directive('uibAccordionTransclude', function() {
	  return {
	    require: '^uibAccordionGroup',
	    link: function(scope, element, attrs, controller) {
	      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
	        if (heading) {
	          var elem = angular.element(element[0].querySelector('[uib-accordion-header]'));
	          elem.html('');
	          elem.append(heading);
	        }
	      });
	    }
	  };
	});

	angular.module('ui.bootstrap.alert', [])

	.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
	  $scope.closeable = !!$attrs.close;

	  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
	    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

	  if (dismissOnTimeout) {
	    $timeout(function() {
	      $scope.close();
	    }, parseInt(dismissOnTimeout, 10));
	  }
	}])

	.directive('uibAlert', function() {
	  return {
	    controller: 'UibAlertController',
	    controllerAs: 'alert',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/alert/alert.html';
	    },
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@',
	      close: '&'
	    }
	  };
	});

	angular.module('ui.bootstrap.buttons', [])

	.constant('uibButtonConfig', {
	  activeClass: 'active',
	  toggleEvent: 'click'
	})

	.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
	  this.activeClass = buttonConfig.activeClass || 'active';
	  this.toggleEvent = buttonConfig.toggleEvent || 'click';
	}])

	.directive('uibBtnRadio', ['$parse', function($parse) {
	  return {
	    require: ['uibBtnRadio', 'ngModel'],
	    controller: 'UibButtonsController',
	    controllerAs: 'buttons',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	      var uncheckableExpr = $parse(attrs.uibUncheckable);

	      element.find('input').css({display: 'none'});

	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
	      };

	      //ui->model
	      element.on(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }

	        var isActive = element.hasClass(buttonsCtrl.activeClass);

	        if (!isActive || angular.isDefined(attrs.uncheckable)) {
	          scope.$apply(function() {
	            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
	            ngModelCtrl.$render();
	          });
	        }
	      });

	      if (attrs.uibUncheckable) {
	        scope.$watch(uncheckableExpr, function(uncheckable) {
	          attrs.$set('uncheckable', uncheckable ? '' : undefined);
	        });
	      }
	    }
	  };
	}])

	.directive('uibBtnCheckbox', function() {
	  return {
	    require: ['uibBtnCheckbox', 'ngModel'],
	    controller: 'UibButtonsController',
	    controllerAs: 'button',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	      element.find('input').css({display: 'none'});

	      function getTrueValue() {
	        return getCheckboxValue(attrs.btnCheckboxTrue, true);
	      }

	      function getFalseValue() {
	        return getCheckboxValue(attrs.btnCheckboxFalse, false);
	      }

	      function getCheckboxValue(attribute, defaultValue) {
	        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
	      }

	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	      };

	      //ui->model
	      element.on(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }

	        scope.$apply(function() {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	    }
	  };
	});

	angular.module('ui.bootstrap.carousel', [])

	.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
	  var self = this,
	    slides = self.slides = $scope.slides = [],
	    SLIDE_DIRECTION = 'uib-slideDirection',
	    currentIndex = $scope.active,
	    currentInterval, isPlaying, bufferedTransitions = [];

	  var destroyed = false;

	  self.addSlide = function(slide, element) {
	    slides.push({
	      slide: slide,
	      element: element
	    });
	    slides.sort(function(a, b) {
	      return +a.slide.index > +b.slide.index;
	    });
	    //if this is the first slide or the slide is set to active, select it
	    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
	      if ($scope.$currentTransition) {
	        $scope.$currentTransition = null;
	      }

	      currentIndex = slide.index;
	      $scope.active = slide.index;
	      setActive(currentIndex);
	      self.select(slides[findSlideIndex(slide)]);
	      if (slides.length === 1) {
	        $scope.play();
	      }
	    }
	  };

	  self.getCurrentIndex = function() {
	    for (var i = 0; i < slides.length; i++) {
	      if (slides[i].slide.index === currentIndex) {
	        return i;
	      }
	    }
	  };

	  self.next = $scope.next = function() {
	    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

	    if (newIndex === 0 && $scope.noWrap()) {
	      $scope.pause();
	      return;
	    }

	    return self.select(slides[newIndex], 'next');
	  };

	  self.prev = $scope.prev = function() {
	    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

	    if ($scope.noWrap() && newIndex === slides.length - 1) {
	      $scope.pause();
	      return;
	    }

	    return self.select(slides[newIndex], 'prev');
	  };

	  self.removeSlide = function(slide) {
	    var index = findSlideIndex(slide);

	    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
	    if (bufferedIndex !== -1) {
	      bufferedTransitions.splice(bufferedIndex, 1);
	    }

	    //get the index of the slide inside the carousel
	    slides.splice(index, 1);
	    if (slides.length > 0 && currentIndex === index) {
	      if (index >= slides.length) {
	        currentIndex = slides.length - 1;
	        $scope.active = currentIndex;
	        setActive(currentIndex);
	        self.select(slides[slides.length - 1]);
	      } else {
	        currentIndex = index;
	        $scope.active = currentIndex;
	        setActive(currentIndex);
	        self.select(slides[index]);
	      }
	    } else if (currentIndex > index) {
	      currentIndex--;
	      $scope.active = currentIndex;
	    }

	    //clean the active value when no more slide
	    if (slides.length === 0) {
	      currentIndex = null;
	      $scope.active = null;
	      clearBufferedTransitions();
	    }
	  };

	  /* direction: "prev" or "next" */
	  self.select = $scope.select = function(nextSlide, direction) {
	    var nextIndex = findSlideIndex(nextSlide.slide);
	    //Decide direction if it's not given
	    if (direction === undefined) {
	      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
	    }
	    //Prevent this user-triggered transition from occurring if there is already one in progress
	    if (nextSlide.slide.index !== currentIndex &&
	      !$scope.$currentTransition) {
	      goNext(nextSlide.slide, nextIndex, direction);
	    } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
	      bufferedTransitions.push(slides[nextIndex]);
	    }
	  };

	  /* Allow outside people to call indexOf on slides array */
	  $scope.indexOfSlide = function(slide) {
	    return +slide.slide.index;
	  };

	  $scope.isActive = function(slide) {
	    return $scope.active === slide.slide.index;
	  };

	  $scope.pause = function() {
	    if (!$scope.noPause) {
	      isPlaying = false;
	      resetTimer();
	    }
	  };

	  $scope.play = function() {
	    if (!isPlaying) {
	      isPlaying = true;
	      restartTimer();
	    }
	  };

	  $scope.$on('$destroy', function() {
	    destroyed = true;
	    resetTimer();
	  });

	  $scope.$watch('noTransition', function(noTransition) {
	    $animate.enabled($element, !noTransition);
	  });

	  $scope.$watch('interval', restartTimer);

	  $scope.$watchCollection('slides', resetTransition);

	  $scope.$watch('active', function(index) {
	    if (angular.isNumber(index) && currentIndex !== index) {
	      for (var i = 0; i < slides.length; i++) {
	        if (slides[i].slide.index === index) {
	          index = i;
	          break;
	        }
	      }

	      var slide = slides[index];
	      if (slide) {
	        currentIndex = index;
	        setActive(index);
	        self.select(slides[index]);
	      }
	    }
	  });

	  function clearBufferedTransitions() {
	    while (bufferedTransitions.length) {
	      bufferedTransitions.shift();
	    }
	  }

	  function getSlideByIndex(index) {
	    for (var i = 0, l = slides.length; i < l; ++i) {
	      if (slides[i].index === index) {
	        return slides[i];
	      }
	    }
	  }

	  function setActive(index) {
	    for (var i = 0; i < slides.length; i++) {
	      slides[i].slide.active = i === index;
	    }
	  }

	  function goNext(slide, index, direction) {
	    if (destroyed) {
	      return;
	    }

	    angular.extend(slide, {direction: direction});
	    angular.extend(slides[currentIndex].slide || {}, {direction: direction});
	    if ($animate.enabled($element) && !$scope.$currentTransition &&
	      slides[index].element && self.slides.length > 1) {
	      slides[index].element.data(SLIDE_DIRECTION, slide.direction);
	      var currentIdx = self.getCurrentIndex();

	      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
	        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
	      }

	      $scope.$currentTransition = true;
	      $animate.on('addClass', slides[index].element, function(element, phase) {
	        if (phase === 'close') {
	          $scope.$currentTransition = null;
	          $animate.off('addClass', element);
	          if (bufferedTransitions.length) {
	            var nextSlide = bufferedTransitions.pop().slide;
	            var nextIndex = nextSlide.index;
	            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
	            clearBufferedTransitions();

	            goNext(nextSlide, nextIndex, nextDirection);
	          }
	        }
	      });
	    }

	    $scope.active = slide.index;
	    currentIndex = slide.index;
	    setActive(index);

	    //every time you change slides, reset the timer
	    restartTimer();
	  }

	  function findSlideIndex(slide) {
	    for (var i = 0; i < slides.length; i++) {
	      if (slides[i].slide === slide) {
	        return i;
	      }
	    }
	  }

	  function resetTimer() {
	    if (currentInterval) {
	      $interval.cancel(currentInterval);
	      currentInterval = null;
	    }
	  }

	  function resetTransition(slides) {
	    if (!slides.length) {
	      $scope.$currentTransition = null;
	      clearBufferedTransitions();
	    }
	  }

	  function restartTimer() {
	    resetTimer();
	    var interval = +$scope.interval;
	    if (!isNaN(interval) && interval > 0) {
	      currentInterval = $interval(timerFn, interval);
	    }
	  }

	  function timerFn() {
	    var interval = +$scope.interval;
	    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
	      $scope.next();
	    } else {
	      $scope.pause();
	    }
	  }
	}])

	.directive('uibCarousel', function() {
	  return {
	    transclude: true,
	    replace: true,
	    controller: 'UibCarouselController',
	    controllerAs: 'carousel',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/carousel/carousel.html';
	    },
	    scope: {
	      active: '=',
	      interval: '=',
	      noTransition: '=',
	      noPause: '=',
	      noWrap: '&'
	    }
	  };
	})

	.directive('uibSlide', function() {
	  return {
	    require: '^uibCarousel',
	    transclude: true,
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/carousel/slide.html';
	    },
	    scope: {
	      actual: '=?',
	      index: '=?'
	    },
	    link: function (scope, element, attrs, carouselCtrl) {
	      carouselCtrl.addSlide(scope, element);
	      //when the scope is destroyed then remove the slide from the current slides array
	      scope.$on('$destroy', function() {
	        carouselCtrl.removeSlide(scope);
	      });
	    }
	  };
	})

	.animation('.item', ['$animateCss',
	function($animateCss) {
	  var SLIDE_DIRECTION = 'uib-slideDirection';

	  function removeClass(element, className, callback) {
	    element.removeClass(className);
	    if (callback) {
	      callback();
	    }
	  }

	  return {
	    beforeAddClass: function(element, className, done) {
	      if (className === 'active') {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction === 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element,
	          directionClass + ' ' + direction, done);
	        element.addClass(direction);

	        $animateCss(element, {addClass: directionClass})
	          .start()
	          .done(removeClassFn);

	        return function() {
	          stopped = true;
	        };
	      }
	      done();
	    },
	    beforeRemoveClass: function (element, className, done) {
	      if (className === 'active') {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction === 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element, directionClass, done);

	        $animateCss(element, {addClass: directionClass})
	          .start()
	          .done(removeClassFn);

	        return function() {
	          stopped = true;
	        };
	      }
	      done();
	    }
	  };
	}]);

	angular.module('ui.bootstrap.dateparser', [])

	.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
	  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
	  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

	  var localeId;
	  var formatCodeToRegex;

	  this.init = function() {
	    localeId = $locale.id;

	    this.parsers = {};
	    this.formatters = {};

	    formatCodeToRegex = [
	      {
	        key: 'yyyy',
	        regex: '\\d{4}',
	        apply: function(value) { this.year = +value; },
	        formatter: function(date) {
	          var _date = new Date();
	          _date.setFullYear(Math.abs(date.getFullYear()));
	          return dateFilter(_date, 'yyyy');
	        }
	      },
	      {
	        key: 'yy',
	        regex: '\\d{2}',
	        apply: function(value) { this.year = +value + 2000; },
	        formatter: function(date) {
	          var _date = new Date();
	          _date.setFullYear(Math.abs(date.getFullYear()));
	          return dateFilter(_date, 'yy');
	        }
	      },
	      {
	        key: 'y',
	        regex: '\\d{1,4}',
	        apply: function(value) { this.year = +value; },
	        formatter: function(date) {
	          var _date = new Date();
	          _date.setFullYear(Math.abs(date.getFullYear()));
	          return dateFilter(_date, 'y');
	        }
	      },
	      {
	        key: 'M!',
	        regex: '0?[1-9]|1[0-2]',
	        apply: function(value) { this.month = value - 1; },
	        formatter: function(date) {
	          var value = date.getMonth();
	          if (/^[0-9]$/.test(value)) {
	            return dateFilter(date, 'MM');
	          }

	          return dateFilter(date, 'M');
	        }
	      },
	      {
	        key: 'MMMM',
	        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
	        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
	        formatter: function(date) { return dateFilter(date, 'MMMM'); }
	      },
	      {
	        key: 'MMM',
	        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
	        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
	        formatter: function(date) { return dateFilter(date, 'MMM'); }
	      },
	      {
	        key: 'MM',
	        regex: '0[1-9]|1[0-2]',
	        apply: function(value) { this.month = value - 1; },
	        formatter: function(date) { return dateFilter(date, 'MM'); }
	      },
	      {
	        key: 'M',
	        regex: '[1-9]|1[0-2]',
	        apply: function(value) { this.month = value - 1; },
	        formatter: function(date) { return dateFilter(date, 'M'); }
	      },
	      {
	        key: 'd!',
	        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
	        apply: function(value) { this.date = +value; },
	        formatter: function(date) {
	          var value = date.getDate();
	          if (/^[1-9]$/.test(value)) {
	            return dateFilter(date, 'dd');
	          }

	          return dateFilter(date, 'd');
	        }
	      },
	      {
	        key: 'dd',
	        regex: '[0-2][0-9]{1}|3[0-1]{1}',
	        apply: function(value) { this.date = +value; },
	        formatter: function(date) { return dateFilter(date, 'dd'); }
	      },
	      {
	        key: 'd',
	        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
	        apply: function(value) { this.date = +value; },
	        formatter: function(date) { return dateFilter(date, 'd'); }
	      },
	      {
	        key: 'EEEE',
	        regex: $locale.DATETIME_FORMATS.DAY.join('|'),
	        formatter: function(date) { return dateFilter(date, 'EEEE'); }
	      },
	      {
	        key: 'EEE',
	        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
	        formatter: function(date) { return dateFilter(date, 'EEE'); }
	      },
	      {
	        key: 'HH',
	        regex: '(?:0|1)[0-9]|2[0-3]',
	        apply: function(value) { this.hours = +value; },
	        formatter: function(date) { return dateFilter(date, 'HH'); }
	      },
	      {
	        key: 'hh',
	        regex: '0[0-9]|1[0-2]',
	        apply: function(value) { this.hours = +value; },
	        formatter: function(date) { return dateFilter(date, 'hh'); }
	      },
	      {
	        key: 'H',
	        regex: '1?[0-9]|2[0-3]',
	        apply: function(value) { this.hours = +value; },
	        formatter: function(date) { return dateFilter(date, 'H'); }
	      },
	      {
	        key: 'h',
	        regex: '[0-9]|1[0-2]',
	        apply: function(value) { this.hours = +value; },
	        formatter: function(date) { return dateFilter(date, 'h'); }
	      },
	      {
	        key: 'mm',
	        regex: '[0-5][0-9]',
	        apply: function(value) { this.minutes = +value; },
	        formatter: function(date) { return dateFilter(date, 'mm'); }
	      },
	      {
	        key: 'm',
	        regex: '[0-9]|[1-5][0-9]',
	        apply: function(value) { this.minutes = +value; },
	        formatter: function(date) { return dateFilter(date, 'm'); }
	      },
	      {
	        key: 'sss',
	        regex: '[0-9][0-9][0-9]',
	        apply: function(value) { this.milliseconds = +value; },
	        formatter: function(date) { return dateFilter(date, 'sss'); }
	      },
	      {
	        key: 'ss',
	        regex: '[0-5][0-9]',
	        apply: function(value) { this.seconds = +value; },
	        formatter: function(date) { return dateFilter(date, 'ss'); }
	      },
	      {
	        key: 's',
	        regex: '[0-9]|[1-5][0-9]',
	        apply: function(value) { this.seconds = +value; },
	        formatter: function(date) { return dateFilter(date, 's'); }
	      },
	      {
	        key: 'a',
	        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
	        apply: function(value) {
	          if (this.hours === 12) {
	            this.hours = 0;
	          }

	          if (value === 'PM') {
	            this.hours += 12;
	          }
	        },
	        formatter: function(date) { return dateFilter(date, 'a'); }
	      },
	      {
	        key: 'Z',
	        regex: '[+-]\\d{4}',
	        apply: function(value) {
	          var matches = value.match(/([+-])(\d{2})(\d{2})/),
	            sign = matches[1],
	            hours = matches[2],
	            minutes = matches[3];
	          this.hours += toInt(sign + hours);
	          this.minutes += toInt(sign + minutes);
	        },
	        formatter: function(date) {
	          return dateFilter(date, 'Z');
	        }
	      },
	      {
	        key: 'ww',
	        regex: '[0-4][0-9]|5[0-3]',
	        formatter: function(date) { return dateFilter(date, 'ww'); }
	      },
	      {
	        key: 'w',
	        regex: '[0-9]|[1-4][0-9]|5[0-3]',
	        formatter: function(date) { return dateFilter(date, 'w'); }
	      },
	      {
	        key: 'GGGG',
	        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
	        formatter: function(date) { return dateFilter(date, 'GGGG'); }
	      },
	      {
	        key: 'GGG',
	        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
	        formatter: function(date) { return dateFilter(date, 'GGG'); }
	      },
	      {
	        key: 'GG',
	        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
	        formatter: function(date) { return dateFilter(date, 'GG'); }
	      },
	      {
	        key: 'G',
	        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
	        formatter: function(date) { return dateFilter(date, 'G'); }
	      }
	    ];
	  };

	  this.init();

	  function createParser(format, func) {
	    var map = [], regex = format.split('');

	    // check for literal values
	    var quoteIndex = format.indexOf('\'');
	    if (quoteIndex > -1) {
	      var inLiteral = false;
	      format = format.split('');
	      for (var i = quoteIndex; i < format.length; i++) {
	        if (inLiteral) {
	          if (format[i] === '\'') {
	            if (i + 1 < format.length && format[i+1] === '\'') { // escaped single quote
	              format[i+1] = '$';
	              regex[i+1] = '';
	            } else { // end of literal
	              regex[i] = '';
	              inLiteral = false;
	            }
	          }
	          format[i] = '$';
	        } else {
	          if (format[i] === '\'') { // start of literal
	            format[i] = '$';
	            regex[i] = '';
	            inLiteral = true;
	          }
	        }
	      }

	      format = format.join('');
	    }

	    angular.forEach(formatCodeToRegex, function(data) {
	      var index = format.indexOf(data.key);

	      if (index > -1) {
	        format = format.split('');

	        regex[index] = '(' + data.regex + ')';
	        format[index] = '$'; // Custom symbol to define consumed part of format
	        for (var i = index + 1, n = index + data.key.length; i < n; i++) {
	          regex[i] = '';
	          format[i] = '$';
	        }
	        format = format.join('');

	        map.push({
	          index: index,
	          key: data.key,
	          apply: data[func],
	          matcher: data.regex
	        });
	      }
	    });

	    return {
	      regex: new RegExp('^' + regex.join('') + '$'),
	      map: orderByFilter(map, 'index')
	    };
	  }

	  this.filter = function(date, format) {
	    if (!angular.isDate(date) || isNaN(date) || !format) {
	      return '';
	    }

	    format = $locale.DATETIME_FORMATS[format] || format;

	    if ($locale.id !== localeId) {
	      this.init();
	    }

	    if (!this.formatters[format]) {
	      this.formatters[format] = createParser(format, 'formatter');
	    }

	    var parser = this.formatters[format],
	      map = parser.map;

	    var _format = format;

	    return map.reduce(function(str, mapper, i) {
	      var match = _format.match(new RegExp('(.*)' + mapper.key));
	      if (match && angular.isString(match[1])) {
	        str += match[1];
	        _format = _format.replace(match[1] + mapper.key, '');
	      }

	      var endStr = i === map.length - 1 ? _format : '';

	      if (mapper.apply) {
	        return str + mapper.apply.call(null, date) + endStr;
	      }

	      return str + endStr;
	    }, '');
	  };

	  this.parse = function(input, format, baseDate) {
	    if (!angular.isString(input) || !format) {
	      return input;
	    }

	    format = $locale.DATETIME_FORMATS[format] || format;
	    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

	    if ($locale.id !== localeId) {
	      this.init();
	    }

	    if (!this.parsers[format]) {
	      this.parsers[format] = createParser(format, 'apply');
	    }

	    var parser = this.parsers[format],
	        regex = parser.regex,
	        map = parser.map,
	        results = input.match(regex),
	        tzOffset = false;
	    if (results && results.length) {
	      var fields, dt;
	      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
	        fields = {
	          year: baseDate.getFullYear(),
	          month: baseDate.getMonth(),
	          date: baseDate.getDate(),
	          hours: baseDate.getHours(),
	          minutes: baseDate.getMinutes(),
	          seconds: baseDate.getSeconds(),
	          milliseconds: baseDate.getMilliseconds()
	        };
	      } else {
	        if (baseDate) {
	          $log.warn('dateparser:', 'baseDate is not a valid date');
	        }
	        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
	      }

	      for (var i = 1, n = results.length; i < n; i++) {
	        var mapper = map[i - 1];
	        if (mapper.matcher === 'Z') {
	          tzOffset = true;
	        }

	        if (mapper.apply) {
	          mapper.apply.call(fields, results[i]);
	        }
	      }

	      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
	        Date.prototype.setFullYear;
	      var timesetter = tzOffset ? Date.prototype.setUTCHours :
	        Date.prototype.setHours;

	      if (isValid(fields.year, fields.month, fields.date)) {
	        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
	          dt = new Date(baseDate);
	          datesetter.call(dt, fields.year, fields.month, fields.date);
	          timesetter.call(dt, fields.hours, fields.minutes,
	            fields.seconds, fields.milliseconds);
	        } else {
	          dt = new Date(0);
	          datesetter.call(dt, fields.year, fields.month, fields.date);
	          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
	            fields.seconds || 0, fields.milliseconds || 0);
	        }
	      }

	      return dt;
	    }
	  };

	  // Check if date is valid for specific month (and year for February).
	  // Month: 0 = Jan, 1 = Feb, etc
	  function isValid(year, month, date) {
	    if (date < 1) {
	      return false;
	    }

	    if (month === 1 && date > 28) {
	      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
	    }

	    if (month === 3 || month === 5 || month === 8 || month === 10) {
	      return date < 31;
	    }

	    return true;
	  }

	  function toInt(str) {
	    return parseInt(str, 10);
	  }

	  this.toTimezone = toTimezone;
	  this.fromTimezone = fromTimezone;
	  this.timezoneToOffset = timezoneToOffset;
	  this.addDateMinutes = addDateMinutes;
	  this.convertTimezoneToLocal = convertTimezoneToLocal;

	  function toTimezone(date, timezone) {
	    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
	  }

	  function fromTimezone(date, timezone) {
	    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
	  }

	  //https://github.com/angular/angular.js/blob/4daafd3dbe6a80d578f5a31df1bb99c77559543e/src/Angular.js#L1207
	  function timezoneToOffset(timezone, fallback) {
	    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
	    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
	  }

	  function addDateMinutes(date, minutes) {
	    date = new Date(date.getTime());
	    date.setMinutes(date.getMinutes() + minutes);
	    return date;
	  }

	  function convertTimezoneToLocal(date, timezone, reverse) {
	    reverse = reverse ? -1 : 1;
	    var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
	    return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
	  }
	}]);

	// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
	// at most one element.
	angular.module('ui.bootstrap.isClass', [])
	.directive('uibIsClass', [
	         '$animate',
	function ($animate) {
	  //                    11111111          22222222
	  var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
	  //                    11111111           22222222
	  var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

	  var dataPerTracked = {};

	  return {
	    restrict: 'A',
	    compile: function (tElement, tAttrs) {
	      var linkedScopes = [];
	      var instances = [];
	      var expToData = {};
	      var lastActivated = null;
	      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
	      var onExp = onExpMatches[2];
	      var expsStr = onExpMatches[1];
	      var exps = expsStr.split(',');

	      return linkFn;

	      function linkFn(scope, element, attrs) {
	        linkedScopes.push(scope);
	        instances.push({
	          scope: scope,
	          element: element
	        });

	        exps.forEach(function (exp, k) {
	          addForExp(exp, scope);
	        });

	        scope.$on('$destroy', removeScope);
	      }

	      function addForExp(exp, scope) {
	        var matches = exp.match(IS_REGEXP);
	        var clazz = scope.$eval(matches[1]);
	        var compareWithExp = matches[2];
	        var data = expToData[exp];
	        if (!data) {
	          var watchFn = function (compareWithVal) {
	            var newActivated = null;
	            instances.some(function (instance) {
	              var thisVal = instance.scope.$eval(onExp);
	              if (thisVal === compareWithVal) {
	                newActivated = instance;
	                return true;
	              }
	            });
	            if (data.lastActivated !== newActivated) {
	              if (data.lastActivated) {
	                $animate.removeClass(data.lastActivated.element, clazz);
	              }
	              if (newActivated) {
	                $animate.addClass(newActivated.element, clazz);
	              }
	              data.lastActivated = newActivated;
	            }
	          };
	          expToData[exp] = data = {
	            lastActivated: null,
	            scope: scope,
	            watchFn: watchFn,
	            compareWithExp: compareWithExp,
	            watcher: scope.$watch(compareWithExp, watchFn)
	          };
	        }
	        data.watchFn(scope.$eval(compareWithExp));
	      }

	      function removeScope(e) {
	        var removedScope = e.targetScope;
	        var index = linkedScopes.indexOf(removedScope);
	        linkedScopes.splice(index, 1);
	        instances.splice(index, 1);
	        if (linkedScopes.length) {
	          var newWatchScope = linkedScopes[0];
	          angular.forEach(expToData, function (data) {
	            if (data.scope === removedScope) {
	              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
	              data.scope = newWatchScope;
	            }
	          });
	        }
	        else {
	          expToData = {};
	        }
	      }
	    }
	  };
	}]);
	angular.module('ui.bootstrap.position', [])

	/**
	 * A set of utility methods for working with the DOM.
	 * It is meant to be used where we need to absolute-position elements in
	 * relation to another element (this is the case for tooltips, popovers,
	 * typeahead suggestions etc.).
	 */
	  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
	    /**
	     * Used by scrollbarWidth() function to cache scrollbar's width.
	     * Do not access this variable directly, use scrollbarWidth() instead.
	     */
	    var SCROLLBAR_WIDTH;
	    var OVERFLOW_REGEX = {
	      normal: /(auto|scroll)/,
	      hidden: /(auto|scroll|hidden)/
	    };
	    var PLACEMENT_REGEX = {
	      auto: /\s?auto?\s?/i,
	      primary: /^(top|bottom|left|right)$/,
	      secondary: /^(top|bottom|left|right|center)$/,
	      vertical: /^(top|bottom)$/
	    };

	    return {

	      /**
	       * Provides a raw DOM element from a jQuery/jQLite element.
	       *
	       * @param {element} elem - The element to convert.
	       *
	       * @returns {element} A HTML element.
	       */
	      getRawNode: function(elem) {
	        return elem.nodeName ? elem : elem[0] || elem;
	      },

	      /**
	       * Provides a parsed number for a style property.  Strips
	       * units and casts invalid numbers to 0.
	       *
	       * @param {string} value - The style value to parse.
	       *
	       * @returns {number} A valid number.
	       */
	      parseStyle: function(value) {
	        value = parseFloat(value);
	        return isFinite(value) ? value : 0;
	      },

	      /**
	       * Provides the closest positioned ancestor.
	       *
	       * @param {element} element - The element to get the offest parent for.
	       *
	       * @returns {element} The closest positioned ancestor.
	       */
	      offsetParent: function(elem) {
	        elem = this.getRawNode(elem);

	        var offsetParent = elem.offsetParent || $document[0].documentElement;

	        function isStaticPositioned(el) {
	          return ($window.getComputedStyle(el).position || 'static') === 'static';
	        }

	        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
	          offsetParent = offsetParent.offsetParent;
	        }

	        return offsetParent || $document[0].documentElement;
	      },

	      /**
	       * Provides the scrollbar width, concept from TWBS measureScrollbar()
	       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
	       *
	       * @returns {number} The width of the browser scollbar.
	       */
	      scrollbarWidth: function() {
	        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
	          var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
	          $document.find('body').append(scrollElem);
	          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
	          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
	          scrollElem.remove();
	        }

	        return SCROLLBAR_WIDTH;
	      },

	      /**
	       * Checks to see if the element is scrollable.
	       *
	       * @param {element} elem - The element to check.
	       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
	       *   default is false.
	       *
	       * @returns {boolean} Whether the element is scrollable.
	       */
	      isScrollable: function(elem, includeHidden) {
	        elem = this.getRawNode(elem);

	        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
	        var elemStyle = $window.getComputedStyle(elem);
	        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
	      },

	      /**
	       * Provides the closest scrollable ancestor.
	       * A port of the jQuery UI scrollParent method:
	       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
	       *
	       * @param {element} elem - The element to find the scroll parent of.
	       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
	       *   default is false.
	       *
	       * @returns {element} A HTML element.
	       */
	      scrollParent: function(elem, includeHidden) {
	        elem = this.getRawNode(elem);

	        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
	        var documentEl = $document[0].documentElement;
	        var elemStyle = $window.getComputedStyle(elem);
	        var excludeStatic = elemStyle.position === 'absolute';
	        var scrollParent = elem.parentElement || documentEl;

	        if (scrollParent === documentEl || elemStyle.position === 'fixed') {
	          return documentEl;
	        }

	        while (scrollParent.parentElement && scrollParent !== documentEl) {
	          var spStyle = $window.getComputedStyle(scrollParent);
	          if (excludeStatic && spStyle.position !== 'static') {
	            excludeStatic = false;
	          }

	          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
	            break;
	          }
	          scrollParent = scrollParent.parentElement;
	        }

	        return scrollParent;
	      },

	      /**
	       * Provides read-only equivalent of jQuery's position function:
	       * http://api.jquery.com/position/ - distance to closest positioned
	       * ancestor.  Does not account for margins by default like jQuery position.
	       *
	       * @param {element} elem - The element to caclulate the position on.
	       * @param {boolean=} [includeMargins=false] - Should margins be accounted
	       * for, default is false.
	       *
	       * @returns {object} An object with the following properties:
	       *   <ul>
	       *     <li>**width**: the width of the element</li>
	       *     <li>**height**: the height of the element</li>
	       *     <li>**top**: distance to top edge of offset parent</li>
	       *     <li>**left**: distance to left edge of offset parent</li>
	       *   </ul>
	       */
	      position: function(elem, includeMagins) {
	        elem = this.getRawNode(elem);

	        var elemOffset = this.offset(elem);
	        if (includeMagins) {
	          var elemStyle = $window.getComputedStyle(elem);
	          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
	          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
	        }
	        var parent = this.offsetParent(elem);
	        var parentOffset = {top: 0, left: 0};

	        if (parent !== $document[0].documentElement) {
	          parentOffset = this.offset(parent);
	          parentOffset.top += parent.clientTop - parent.scrollTop;
	          parentOffset.left += parent.clientLeft - parent.scrollLeft;
	        }

	        return {
	          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
	          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
	          top: Math.round(elemOffset.top - parentOffset.top),
	          left: Math.round(elemOffset.left - parentOffset.left)
	        };
	      },

	      /**
	       * Provides read-only equivalent of jQuery's offset function:
	       * http://api.jquery.com/offset/ - distance to viewport.  Does
	       * not account for borders, margins, or padding on the body
	       * element.
	       *
	       * @param {element} elem - The element to calculate the offset on.
	       *
	       * @returns {object} An object with the following properties:
	       *   <ul>
	       *     <li>**width**: the width of the element</li>
	       *     <li>**height**: the height of the element</li>
	       *     <li>**top**: distance to top edge of viewport</li>
	       *     <li>**right**: distance to bottom edge of viewport</li>
	       *   </ul>
	       */
	      offset: function(elem) {
	        elem = this.getRawNode(elem);

	        var elemBCR = elem.getBoundingClientRect();
	        return {
	          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
	          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
	          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
	          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
	        };
	      },

	      /**
	       * Provides offset distance to the closest scrollable ancestor
	       * or viewport.  Accounts for border and scrollbar width.
	       *
	       * Right and bottom dimensions represent the distance to the
	       * respective edge of the viewport element.  If the element
	       * edge extends beyond the viewport, a negative value will be
	       * reported.
	       *
	       * @param {element} elem - The element to get the viewport offset for.
	       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
	       * of the first scrollable element, default is false.
	       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
	       * be accounted for, default is true.
	       *
	       * @returns {object} An object with the following properties:
	       *   <ul>
	       *     <li>**top**: distance to the top content edge of viewport element</li>
	       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
	       *     <li>**left**: distance to the left content edge of viewport element</li>
	       *     <li>**right**: distance to the right content edge of viewport element</li>
	       *   </ul>
	       */
	      viewportOffset: function(elem, useDocument, includePadding) {
	        elem = this.getRawNode(elem);
	        includePadding = includePadding !== false ? true : false;

	        var elemBCR = elem.getBoundingClientRect();
	        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};

	        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
	        var offsetParentBCR = offsetParent.getBoundingClientRect();

	        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
	        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
	        if (offsetParent === $document[0].documentElement) {
	          offsetBCR.top += $window.pageYOffset;
	          offsetBCR.left += $window.pageXOffset;
	        }
	        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
	        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

	        if (includePadding) {
	          var offsetParentStyle = $window.getComputedStyle(offsetParent);
	          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
	          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
	          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
	          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
	        }

	        return {
	          top: Math.round(elemBCR.top - offsetBCR.top),
	          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
	          left: Math.round(elemBCR.left - offsetBCR.left),
	          right: Math.round(offsetBCR.right - elemBCR.right)
	        };
	      },

	      /**
	       * Provides an array of placement values parsed from a placement string.
	       * Along with the 'auto' indicator, supported placement strings are:
	       *   <ul>
	       *     <li>top: element on top, horizontally centered on host element.</li>
	       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
	       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
	       *     <li>bottom: element on bottom, horizontally centered on host element.</li>
	       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
	       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
	       *     <li>left: element on left, vertically centered on host element.</li>
	       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
	       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
	       *     <li>right: element on right, vertically centered on host element.</li>
	       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
	       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
	       *   </ul>
	       * A placement string with an 'auto' indicator is expected to be
	       * space separated from the placement, i.e: 'auto bottom-left'  If
	       * the primary and secondary placement values do not match 'top,
	       * bottom, left, right' then 'top' will be the primary placement and
	       * 'center' will be the secondary placement.  If 'auto' is passed, true
	       * will be returned as the 3rd value of the array.
	       *
	       * @param {string} placement - The placement string to parse.
	       *
	       * @returns {array} An array with the following values
	       * <ul>
	       *   <li>**[0]**: The primary placement.</li>
	       *   <li>**[1]**: The secondary placement.</li>
	       *   <li>**[2]**: If auto is passed: true, else undefined.</li>
	       * </ul>
	       */
	      parsePlacement: function(placement) {
	        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
	        if (autoPlace) {
	          placement = placement.replace(PLACEMENT_REGEX.auto, '');
	        }

	        placement = placement.split('-');

	        placement[0] = placement[0] || 'top';
	        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
	          placement[0] = 'top';
	        }

	        placement[1] = placement[1] || 'center';
	        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
	          placement[1] = 'center';
	        }

	        if (autoPlace) {
	          placement[2] = true;
	        } else {
	          placement[2] = false;
	        }

	        return placement;
	      },

	      /**
	       * Provides coordinates for an element to be positioned relative to
	       * another element.  Passing 'auto' as part of the placement parameter
	       * will enable smart placement - where the element fits. i.e:
	       * 'auto left-top' will check to see if there is enough space to the left
	       * of the hostElem to fit the targetElem, if not place right (same for secondary
	       * top placement).  Available space is calculated using the viewportOffset
	       * function.
	       *
	       * @param {element} hostElem - The element to position against.
	       * @param {element} targetElem - The element to position.
	       * @param {string=} [placement=top] - The placement for the targetElem,
	       *   default is 'top'. 'center' is assumed as secondary placement for
	       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
	       *   <ul>
	       *     <li>top</li>
	       *     <li>top-right</li>
	       *     <li>top-left</li>
	       *     <li>bottom</li>
	       *     <li>bottom-left</li>
	       *     <li>bottom-right</li>
	       *     <li>left</li>
	       *     <li>left-top</li>
	       *     <li>left-bottom</li>
	       *     <li>right</li>
	       *     <li>right-top</li>
	       *     <li>right-bottom</li>
	       *   </ul>
	       * @param {boolean=} [appendToBody=false] - Should the top and left values returned
	       *   be calculated from the body element, default is false.
	       *
	       * @returns {object} An object with the following properties:
	       *   <ul>
	       *     <li>**top**: Value for targetElem top.</li>
	       *     <li>**left**: Value for targetElem left.</li>
	       *     <li>**placement**: The resolved placement.</li>
	       *   </ul>
	       */
	      positionElements: function(hostElem, targetElem, placement, appendToBody) {
	        hostElem = this.getRawNode(hostElem);
	        targetElem = this.getRawNode(targetElem);

	        // need to read from prop to support tests.
	        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
	        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

	        placement = this.parsePlacement(placement);

	        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
	        var targetElemPos = {top: 0, left: 0, placement: ''};

	        if (placement[2]) {
	          var viewportOffset = this.viewportOffset(hostElem, appendToBody);

	          var targetElemStyle = $window.getComputedStyle(targetElem);
	          var adjustedSize = {
	            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
	            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
	          };

	          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
	                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
	                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
	                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
	                         placement[0];

	          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
	                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
	                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
	                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
	                         placement[1];

	          if (placement[1] === 'center') {
	            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
	              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
	              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
	                placement[1] = 'left';
	              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
	                placement[1] = 'right';
	              }
	            } else {
	              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
	              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
	                placement[1] = 'top';
	              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
	                placement[1] = 'bottom';
	              }
	            }
	          }
	        }

	        switch (placement[0]) {
	          case 'top':
	            targetElemPos.top = hostElemPos.top - targetHeight;
	            break;
	          case 'bottom':
	            targetElemPos.top = hostElemPos.top + hostElemPos.height;
	            break;
	          case 'left':
	            targetElemPos.left = hostElemPos.left - targetWidth;
	            break;
	          case 'right':
	            targetElemPos.left = hostElemPos.left + hostElemPos.width;
	            break;
	        }

	        switch (placement[1]) {
	          case 'top':
	            targetElemPos.top = hostElemPos.top;
	            break;
	          case 'bottom':
	            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
	            break;
	          case 'left':
	            targetElemPos.left = hostElemPos.left;
	            break;
	          case 'right':
	            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
	            break;
	          case 'center':
	            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
	              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
	            } else {
	              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
	            }
	            break;
	        }

	        targetElemPos.top = Math.round(targetElemPos.top);
	        targetElemPos.left = Math.round(targetElemPos.left);
	        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

	        return targetElemPos;
	      },

	      /**
	      * Provides a way for positioning tooltip & dropdown
	      * arrows when using placement options beyond the standard
	      * left, right, top, or bottom.
	      *
	      * @param {element} elem - The tooltip/dropdown element.
	      * @param {string} placement - The placement for the elem.
	      */
	      positionArrow: function(elem, placement) {
	        elem = this.getRawNode(elem);

	        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
	        if (!innerElem) {
	          return;
	        }

	        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

	        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
	        if (!arrowElem) {
	          return;
	        }

	        var arrowCss = {
	          top: '',
	          bottom: '',
	          left: '',
	          right: ''
	        };

	        placement = this.parsePlacement(placement);
	        if (placement[1] === 'center') {
	          // no adjustment necessary - just reset styles
	          angular.element(arrowElem).css(arrowCss);
	          return;
	        }

	        var borderProp = 'border-' + placement[0] + '-width';
	        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

	        var borderRadiusProp = 'border-';
	        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
	          borderRadiusProp += placement[0] + '-' + placement[1];
	        } else {
	          borderRadiusProp += placement[1] + '-' + placement[0];
	        }
	        borderRadiusProp += '-radius';
	        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

	        switch (placement[0]) {
	          case 'top':
	            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
	            break;
	          case 'bottom':
	            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
	            break;
	          case 'left':
	            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
	            break;
	          case 'right':
	            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
	            break;
	        }

	        arrowCss[placement[1]] = borderRadius;

	        angular.element(arrowElem).css(arrowCss);
	      }
	    };
	  }]);

	angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])

	.value('$datepickerSuppressError', false)
	.value('uibDatepickerAttributeWarning', true)

	.constant('uibDatepickerConfig', {
	  datepickerMode: 'day',
	  formatDay: 'dd',
	  formatMonth: 'MMMM',
	  formatYear: 'yyyy',
	  formatDayHeader: 'EEE',
	  formatDayTitle: 'MMMM yyyy',
	  formatMonthTitle: 'yyyy',
	  maxDate: null,
	  maxMode: 'year',
	  minDate: null,
	  minMode: 'day',
	  ngModelOptions: {},
	  shortcutPropagation: false,
	  showWeeks: true,
	  yearColumns: 5,
	  yearRows: 4
	})

	.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDatepickerAttributeWarning', 'uibDateParser',
	  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerSuppressError, datepickerAttributeWarning, dateParser) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;
	      ngModelOptions = {},
	      watchListeners = [],
	      optionsUsed = !!$attrs.datepickerOptions;

	  // Modes chain
	  this.modes = ['day', 'month', 'year'];

	  if (optionsUsed) {
	    [
	      'customClass',
	      'dateDisabled',
	      'datepickerMode',
	      'formatDay',
	      'formatDayHeader',
	      'formatDayTitle',
	      'formatMonth',
	      'formatMonthTitle',
	      'formatYear',
	      'initDate',
	      'maxDate',
	      'maxMode',
	      'minDate',
	      'minMode',
	      'showWeeks',
	      'shortcutPropagation',
	      'startingDay',
	      'yearColumns',
	      'yearRows'
	    ].forEach(function(key) {
	      switch (key) {
	        case 'customClass':
	        case 'dateDisabled':
	          $scope[key] = $scope.datepickerOptions[key] || angular.noop;
	          break;
	        case 'datepickerMode':
	          $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
	            $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
	          break;
	        case 'formatDay':
	        case 'formatDayHeader':
	        case 'formatDayTitle':
	        case 'formatMonth':
	        case 'formatMonthTitle':
	        case 'formatYear':
	          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
	            $interpolate($scope.datepickerOptions[key])($scope.$parent) :
	            datepickerConfig[key];
	          break;
	        case 'showWeeks':
	        case 'shortcutPropagation':
	        case 'yearColumns':
	        case 'yearRows':
	          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
	            $scope.datepickerOptions[key] : datepickerConfig[key];
	          break;
	        case 'startingDay':
	          if (angular.isDefined($scope.datepickerOptions.startingDay)) {
	            self.startingDay = $scope.datepickerOptions.startingDay;
	          } else if (angular.isNumber(datepickerConfig.startingDay)) {
	            self.startingDay = datepickerConfig.startingDay;
	          } else {
	            self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
	          }

	          break;
	        case 'maxDate':
	        case 'minDate':
	          if ($scope.datepickerOptions[key]) {
	            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {
	              if (value) {
	                if (angular.isDate(value)) {
	                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
	                } else {
	                  self[key] = new Date(dateFilter(value, 'medium'));
	                }
	              } else {
	                self[key] = null;
	              }

	              self.refreshView();
	            });
	          } else {
	            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
	          }

	          break;
	        case 'maxMode':
	        case 'minMode':
	          if ($scope.datepickerOptions[key]) {
	            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {
	              self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
	              if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
	                key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
	                $scope.datepickerMode = self[key];
	                $scope.datepickerOptions.datepickerMode = self[key];
	              }
	            });
	          } else {
	            self[key] = $scope[key] = datepickerConfig[key] || null;
	          }

	          break;
	        case 'initDate':
	          if ($scope.datepickerOptions.initDate) {
	            self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
	            $scope.$watch(function() { return $scope.datepickerOptions.initDate; }, function(initDate) {
	              if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
	                self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
	                self.refreshView();
	              }
	            });
	          } else {
	            self.activeDate = new Date();
	          }
	      }
	    });
	  } else {
	    // Interpolated configuration attributes
	    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function(key) {
	      self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];

	      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {
	        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');
	      }
	    });

	    // Evaled configuration attributes
	    angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], function(key) {
	      self[key] = angular.isDefined($attrs[key]) ?
	        $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];

	      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {
	        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');
	      }
	    });

	    angular.forEach(['dateDisabled', 'customClass'], function(key) {
	      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {
	        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');
	      }
	    });

	    if (angular.isDefined($attrs.startingDay)) {
	      if (datepickerAttributeWarning) {
	        $log.warn('uib-datepicker startingDay attribute usage is deprecated, use datepicker-options attribute instead');
	      }

	      self.startingDay = $scope.$parent.$eval($attrs.startingDay);
	    } else if (angular.isNumber(datepickerConfig.startingDay)) {
	      self.startingDay = datepickerConfig.startingDay;
	    } else {
	      self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
	    }

	    // Watchable date attributes
	    angular.forEach(['minDate', 'maxDate'], function(key) {
	      if ($attrs[key]) {
	        if (datepickerAttributeWarning) {
	          $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');
	        }

	        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {
	          if (value) {
	            if (angular.isDate(value)) {
	              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
	            } else {
	              self[key] = new Date(dateFilter(value, 'medium'));
	            }
	          } else {
	            self[key] = null;
	          }

	          self.refreshView();
	        }));
	      } else {
	        self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
	      }
	    });

	    angular.forEach(['minMode', 'maxMode'], function(key) {
	      if ($attrs[key]) {
	        if (datepickerAttributeWarning) {
	          $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');
	        }

	        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {
	          self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];
	          if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||
	            key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {
	            $scope.datepickerMode = self[key];
	          }
	        }));
	      } else {
	        self[key] = $scope[key] = datepickerConfig[key] || null;
	      }
	    });

	    if (angular.isDefined($attrs.initDate)) {
	      if (datepickerAttributeWarning) {
	        $log.warn('uib-datepicker initDate attribute usage is deprecated, use datepicker-options attribute instead');
	      }

	      var initDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone);
	      this.activeDate = !isNaN(initDate) ? initDate : new Date();
	      watchListeners.push($scope.$parent.$watch($attrs.initDate, function(initDate) {
	        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
	          initDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
	          self.activeDate = !isNaN(initDate) ? initDate : new Date();
	          self.refreshView();
	        }
	      }));
	    } else {
	      this.activeDate = new Date();
	    }

	    if ($attrs.datepickerMode && datepickerAttributeWarning) {
	      $log.warn('uib-datepicker datepickerMode attribute usage is deprecated, use datepicker-options attribute instead');
	    }

	    $scope.datepickerMode = $scope.datepickerMode ||
	      datepickerConfig.datepickerMode;
	  }

	  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

	  $scope.disabled = angular.isDefined($attrs.disabled) || false;
	  if (angular.isDefined($attrs.ngDisabled)) {
	    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
	      $scope.disabled = disabled;
	      self.refreshView();
	    }));
	  }

	  $scope.isActive = function(dateObject) {
	    if (self.compare(dateObject.date, self.activeDate) === 0) {
	      $scope.activeDateId = dateObject.uid;
	      return true;
	    }
	    return false;
	  };

	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;

	    this.activeDate = ngModelCtrl.$modelValue ?
	      dateParser.fromTimezone(new Date(ngModelCtrl.$modelValue), ngModelOptions.timezone) :
	      dateParser.fromTimezone(new Date(), ngModelOptions.timezone);

	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	  };

	  this.render = function() {
	    if (ngModelCtrl.$viewValue) {
	      var date = new Date(ngModelCtrl.$viewValue),
	          isValid = !isNaN(date);

	      if (isValid) {
	        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
	      } else if (!$datepickerSuppressError) {
	        $log.error('Datepicker directive: "ng-model" value must be a Date object');
	      }
	    }
	    this.refreshView();
	  };

	  this.refreshView = function() {
	    if (this.element) {
	      $scope.selectedDt = null;
	      this._refreshView();
	      if ($scope.activeDt) {
	        $scope.activeDateId = $scope.activeDt.uid;
	      }

	      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	      date = dateParser.fromTimezone(date, ngModelOptions.timezone);
	      ngModelCtrl.$setValidity('dateDisabled', !date ||
	        this.element && !this.isDisabled(date));
	    }
	  };

	  this.createDateObject = function(date, format) {
	    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	    model = dateParser.fromTimezone(model, ngModelOptions.timezone);
	    var today = new Date();
	    today = dateParser.fromTimezone(today, ngModelOptions.timezone);
	    var time = this.compare(date, today);
	    var dt = {
	      date: date,
	      label: dateParser.filter(date, format),
	      selected: model && this.compare(date, model) === 0,
	      disabled: this.isDisabled(date),
	      past: time < 0,
	      current: time === 0,
	      future: time > 0,
	      customClass: this.customClass(date) || null
	    };

	    if (model && this.compare(date, model) === 0) {
	      $scope.selectedDt = dt;
	    }

	    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
	      $scope.activeDt = dt;
	    }

	    return dt;
	  };

	  this.isDisabled = function(date) {
	    return $scope.disabled ||
	      this.minDate && this.compare(date, this.minDate) < 0 ||
	      this.maxDate && this.compare(date, this.maxDate) > 0 ||
	      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});
	  };

	  this.customClass = function(date) {
	    return $scope.customClass({date: date, mode: $scope.datepickerMode});
	  };

	  // Split array into smaller arrays
	  this.split = function(arr, size) {
	    var arrays = [];
	    while (arr.length > 0) {
	      arrays.push(arr.splice(0, size));
	    }
	    return arrays;
	  };

	  $scope.select = function(date) {
	    if ($scope.datepickerMode === self.minMode) {
	      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
	      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
	      ngModelCtrl.$setViewValue(dt);
	      ngModelCtrl.$render();
	    } else {
	      self.activeDate = date;
	      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

	      $scope.$emit('uib:datepicker.mode');
	    }
	  };

	  $scope.move = function(direction) {
	    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
	        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	    self.activeDate.setFullYear(year, month, 1);
	    self.refreshView();
	  };

	  $scope.toggleMode = function(direction) {
	    direction = direction || 1;

	    if ($scope.datepickerMode === self.maxMode && direction === 1 ||
	      $scope.datepickerMode === self.minMode && direction === -1) {
	      return;
	    }

	    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

	    $scope.$emit('uib:datepicker.mode');
	  };

	  // Key event mapper
	  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

	  var focusElement = function() {
	    self.element[0].focus();
	  };

	  // Listen for focus requests from popup directive
	  $scope.$on('uib:datepicker.focus', focusElement);

	  $scope.keydown = function(evt) {
	    var key = $scope.keys[evt.which];

	    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
	      return;
	    }

	    evt.preventDefault();
	    if (!self.shortcutPropagation) {
	      evt.stopPropagation();
	    }

	    if (key === 'enter' || key === 'space') {
	      if (self.isDisabled(self.activeDate)) {
	        return; // do nothing
	      }
	      $scope.select(self.activeDate);
	    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	      $scope.toggleMode(key === 'up' ? 1 : -1);
	    } else {
	      self.handleKeyDown(key, evt);
	      self.refreshView();
	    }
	  };

	  $scope.$on("$destroy", function() {
	    //Clear all watch listeners on destroy
	    while (watchListeners.length) {
	      watchListeners.shift()();
	    }
	  });

	  function setMode(mode) {
	    $scope.datepickerMode = mode;
	    if (optionsUsed) {
	      $scope.datepickerOptions.datepickerMode = mode;
	    }
	  }
	}])

	.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
	  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

	  this.step = { months: 1 };
	  this.element = $element;
	  function getDaysInMonth(year, month) {
	    return month === 1 && year % 4 === 0 &&
	      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
	  }

	  this.init = function(ctrl) {
	    angular.extend(ctrl, this);
	    scope.showWeeks = ctrl.showWeeks;
	    ctrl.refreshView();
	  };

	  this.getDates = function(startDate, n) {
	    var dates = new Array(n), current = new Date(startDate), i = 0, date;
	    while (i < n) {
	      date = new Date(current);
	      dates[i++] = date;
	      current.setDate(current.getDate() + 1);
	    }
	    return dates;
	  };

	  this._refreshView = function() {
	    var year = this.activeDate.getFullYear(),
	      month = this.activeDate.getMonth(),
	      firstDayOfMonth = new Date(this.activeDate);

	    firstDayOfMonth.setFullYear(year, month, 1);

	    var difference = this.startingDay - firstDayOfMonth.getDay(),
	      numDisplayedFromPreviousMonth = difference > 0 ?
	        7 - difference : - difference,
	      firstDate = new Date(firstDayOfMonth);

	    if (numDisplayedFromPreviousMonth > 0) {
	      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
	    }

	    // 42 is the number of days on a six-week calendar
	    var days = this.getDates(firstDate, 42);
	    for (var i = 0; i < 42; i ++) {
	      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
	        secondary: days[i].getMonth() !== month,
	        uid: scope.uniqueId + '-' + i
	      });
	    }

	    scope.labels = new Array(7);
	    for (var j = 0; j < 7; j++) {
	      scope.labels[j] = {
	        abbr: dateFilter(days[j].date, this.formatDayHeader),
	        full: dateFilter(days[j].date, 'EEEE')
	      };
	    }

	    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
	    scope.rows = this.split(days, 7);

	    if (scope.showWeeks) {
	      scope.weekNumbers = [];
	      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
	          numWeeks = scope.rows.length;
	      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
	        scope.weekNumbers.push(
	          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
	      }
	    }
	  };

	  this.compare = function(date1, date2) {
	    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
	    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
	    _date1.setFullYear(date1.getFullYear());
	    _date2.setFullYear(date2.getFullYear());
	    return _date1 - _date2;
	  };

	  function getISO8601WeekNumber(date) {
	    var checkDate = new Date(date);
	    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	    var time = checkDate.getTime();
	    checkDate.setMonth(0); // Compare with Jan 1
	    checkDate.setDate(1);
	    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	  }

	  this.handleKeyDown = function(key, evt) {
	    var date = this.activeDate.getDate();

	    if (key === 'left') {
	      date = date - 1;
	    } else if (key === 'up') {
	      date = date - 7;
	    } else if (key === 'right') {
	      date = date + 1;
	    } else if (key === 'down') {
	      date = date + 7;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
	      this.activeDate.setMonth(month, 1);
	      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
	    } else if (key === 'home') {
	      date = 1;
	    } else if (key === 'end') {
	      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
	    }
	    this.activeDate.setDate(date);
	  };
	}])

	.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
	  this.step = { years: 1 };
	  this.element = $element;

	  this.init = function(ctrl) {
	    angular.extend(ctrl, this);
	    ctrl.refreshView();
	  };

	  this._refreshView = function() {
	    var months = new Array(12),
	        year = this.activeDate.getFullYear(),
	        date;

	    for (var i = 0; i < 12; i++) {
	      date = new Date(this.activeDate);
	      date.setFullYear(year, i, 1);
	      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
	        uid: scope.uniqueId + '-' + i
	      });
	    }

	    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
	    scope.rows = this.split(months, 3);
	  };

	  this.compare = function(date1, date2) {
	    var _date1 = new Date(date1.getFullYear(), date1.getMonth());
	    var _date2 = new Date(date2.getFullYear(), date2.getMonth());
	    _date1.setFullYear(date1.getFullYear());
	    _date2.setFullYear(date2.getFullYear());
	    return _date1 - _date2;
	  };

	  this.handleKeyDown = function(key, evt) {
	    var date = this.activeDate.getMonth();

	    if (key === 'left') {
	      date = date - 1;
	    } else if (key === 'up') {
	      date = date - 3;
	    } else if (key === 'right') {
	      date = date + 1;
	    } else if (key === 'down') {
	      date = date + 3;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
	      this.activeDate.setFullYear(year);
	    } else if (key === 'home') {
	      date = 0;
	    } else if (key === 'end') {
	      date = 11;
	    }
	    this.activeDate.setMonth(date);
	  };
	}])

	.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
	  var columns, range;
	  this.element = $element;

	  function getStartingYear(year) {
	    return parseInt((year - 1) / range, 10) * range + 1;
	  }

	  this.yearpickerInit = function() {
	    columns = this.yearColumns;
	    range = this.yearRows * columns;
	    this.step = { years: range };
	  };

	  this._refreshView = function() {
	    var years = new Array(range), date;

	    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
	      date = new Date(this.activeDate);
	      date.setFullYear(start + i, 0, 1);
	      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
	        uid: scope.uniqueId + '-' + i
	      });
	    }

	    scope.title = [years[0].label, years[range - 1].label].join(' - ');
	    scope.rows = this.split(years, columns);
	    scope.columns = columns;
	  };

	  this.compare = function(date1, date2) {
	    return date1.getFullYear() - date2.getFullYear();
	  };

	  this.handleKeyDown = function(key, evt) {
	    var date = this.activeDate.getFullYear();

	    if (key === 'left') {
	      date = date - 1;
	    } else if (key === 'up') {
	      date = date - columns;
	    } else if (key === 'right') {
	      date = date + 1;
	    } else if (key === 'down') {
	      date = date + columns;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      date += (key === 'pageup' ? - 1 : 1) * range;
	    } else if (key === 'home') {
	      date = getStartingYear(this.activeDate.getFullYear());
	    } else if (key === 'end') {
	      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
	    }
	    this.activeDate.setFullYear(date);
	  };
	}])

	.directive('uibDatepicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
	    },
	    scope: {
	      datepickerMode: '=?',
	      datepickerOptions: '=?',
	      dateDisabled: '&',
	      customClass: '&',
	      shortcutPropagation: '&?'
	    },
	    require: ['uibDatepicker', '^ngModel'],
	    controller: 'UibDatepickerController',
	    controllerAs: 'datepicker',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	      datepickerCtrl.init(ngModelCtrl);
	    }
	  };
	})

	.directive('uibDaypicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/day.html';
	    },
	    require: ['^uibDatepicker', 'uibDaypicker'],
	    controller: 'UibDaypickerController',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0],
	        daypickerCtrl = ctrls[1];

	      daypickerCtrl.init(datepickerCtrl);
	    }
	  };
	})

	.directive('uibMonthpicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/month.html';
	    },
	    require: ['^uibDatepicker', 'uibMonthpicker'],
	    controller: 'UibMonthpickerController',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0],
	        monthpickerCtrl = ctrls[1];

	      monthpickerCtrl.init(datepickerCtrl);
	    }
	  };
	})

	.directive('uibYearpicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/year.html';
	    },
	    require: ['^uibDatepicker', 'uibYearpicker'],
	    controller: 'UibYearpickerController',
	    link: function(scope, element, attrs, ctrls) {
	      var ctrl = ctrls[0];
	      angular.extend(ctrl, ctrls[1]);
	      ctrl.yearpickerInit();

	      ctrl.refreshView();
	    }
	  };
	})

	.value('uibDatepickerPopupAttributeWarning', true)

	.constant('uibDatepickerPopupConfig', {
	  altInputFormats: [],
	  appendToBody: false,
	  clearText: 'Clear',
	  closeOnDateSelection: true,
	  closeText: 'Done',
	  currentText: 'Today',
	  datepickerPopup: 'yyyy-MM-dd',
	  datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html',
	  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
	  html5Types: {
	    date: 'yyyy-MM-dd',
	    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
	    'month': 'yyyy-MM'
	  },
	  onOpenFocus: true,
	  showButtonBar: true,
	  placement: 'auto bottom-left'
	})

	.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', 'uibDatepickerPopupAttributeWarning',
	function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, datepickerPopupAttributeWarning) {
	  var cache = {},
	    isHtml5DateInput = false;
	  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
	    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,
	    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];

	  $scope.watchData = {};

	  this.init = function(_ngModel_) {
	    ngModel = _ngModel_;
	    ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;
	    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
	      $scope.$parent.$eval($attrs.closeOnDateSelection) :
	      datepickerPopupConfig.closeOnDateSelection;
	    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
	      $scope.$parent.$eval($attrs.datepickerAppendToBody) :
	      datepickerPopupConfig.appendToBody;
	    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
	      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
	    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
	      $attrs.datepickerPopupTemplateUrl :
	      datepickerPopupConfig.datepickerPopupTemplateUrl;
	    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
	      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
	    altInputFormats = angular.isDefined($attrs.altInputFormats) ?
	      $scope.$parent.$eval($attrs.altInputFormats) :
	      datepickerPopupConfig.altInputFormats;

	    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
	      $scope.$parent.$eval($attrs.showButtonBar) :
	      datepickerPopupConfig.showButtonBar;

	    if (datepickerPopupConfig.html5Types[$attrs.type]) {
	      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
	      isHtml5DateInput = true;
	    } else {
	      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
	      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
	        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
	        // Invalidate the $modelValue to ensure that formatters re-run
	        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
	        if (newDateFormat !== dateFormat) {
	          dateFormat = newDateFormat;
	          ngModel.$modelValue = null;

	          if (!dateFormat) {
	            throw new Error('uibDatepickerPopup must have a date format specified.');
	          }
	        }
	      });
	    }

	    if (!dateFormat) {
	      throw new Error('uibDatepickerPopup must have a date format specified.');
	    }

	    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
	      throw new Error('HTML5 date input types do not support custom formats.');
	    }

	    // popup element used to display calendar
	    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
	    $scope.ngModelOptions = angular.copy(ngModelOptions);
	    $scope.ngModelOptions.timezone = null;
	    if ($scope.ngModelOptions.updateOnDefault === true) {
	      $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ?
	        $scope.ngModelOptions.updateOn + ' default' : 'default';
	    }

	    popupEl.attr({
	      'ng-model': 'date',
	      'ng-model-options': 'ngModelOptions',
	      'ng-change': 'dateSelection(date)',
	      'template-url': datepickerPopupTemplateUrl
	    });

	    // datepicker element
	    datepickerEl = angular.element(popupEl.children()[0]);
	    datepickerEl.attr('template-url', datepickerTemplateUrl);

	    if (isHtml5DateInput) {
	      if ($attrs.type === 'month') {
	        datepickerEl.attr('datepicker-mode', '"month"');
	        datepickerEl.attr('min-mode', 'month');
	      }
	    }

	    if ($scope.datepickerOptions) {
	      datepickerEl.attr('datepicker-options', 'datepickerOptions');
	    }

	    angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], function(key) {
	      if ($attrs[key]) {
	        if (datepickerPopupAttributeWarning) {
	          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');
	        }

	        var getAttribute = $parse($attrs[key]);
	        var propConfig = {
	          get: function() {
	            return getAttribute($scope.$parent);
	          }
	        };

	        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);

	        // Propagate changes from datepicker to outside
	        if (key === 'datepickerMode') {
	          var setAttribute = getAttribute.assign;
	          propConfig.set = function(v) {
	            setAttribute($scope.$parent, v);
	          };
	        }

	        Object.defineProperty($scope.watchData, key, propConfig);
	      }
	    });

	    angular.forEach(['minDate', 'maxDate', 'initDate'], function(key) {
	      if ($attrs[key]) {
	        if (datepickerPopupAttributeWarning) {
	          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');
	        }

	        var getAttribute = $parse($attrs[key]);

	        watchListeners.push($scope.$parent.$watch(getAttribute, function(value) {
	          if (key === 'minDate' || key === 'maxDate') {
	            if (value === null) {
	              cache[key] = null;
	            } else if (angular.isDate(value)) {
	              cache[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
	            } else {
	              cache[key] = new Date(dateFilter(value, 'medium'));
	            }

	            $scope.watchData[key] = value === null ? null : cache[key];
	          } else {
	            var date = value ? new Date(value) : new Date();
	            $scope.watchData[key] = dateParser.fromTimezone(date, ngModelOptions.timezone);
	          }
	        }));

	        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
	      }
	    });

	    if ($attrs.dateDisabled) {
	      if (datepickerPopupAttributeWarning) {
	        $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');
	      }

	      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
	    }

	    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function(key) {
	      if (angular.isDefined($attrs[key])) {
	        if (datepickerPopupAttributeWarning) {
	          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');
	        }

	        datepickerEl.attr(cameltoDash(key), $attrs[key]);
	      }
	    });

	    if ($attrs.customClass) {
	      if (datepickerPopupAttributeWarning) {
	        $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');
	      }

	      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
	    }

	    if (!isHtml5DateInput) {
	      // Internal API to maintain the correct ng-invalid-[key] class
	      ngModel.$$parserName = 'date';
	      ngModel.$validators.date = validator;
	      ngModel.$parsers.unshift(parseDate);
	      ngModel.$formatters.push(function(value) {
	        if (ngModel.$isEmpty(value)) {
	          $scope.date = value;
	          return value;
	        }

	        $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);

	        if (angular.isNumber($scope.date)) {
	          $scope.date = new Date($scope.date);
	        }

	        return dateParser.filter($scope.date, dateFormat);
	      });
	    } else {
	      ngModel.$formatters.push(function(value) {
	        $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
	        return value;
	      });
	    }

	    // Detect changes in the view from the text box
	    ngModel.$viewChangeListeners.push(function() {
	      $scope.date = parseDateString(ngModel.$viewValue);
	    });

	    $element.on('keydown', inputKeydownBind);

	    $popup = $compile(popupEl)($scope);
	    // Prevent jQuery cache memory leak (template is now redundant after linking)
	    popupEl.remove();

	    if (appendToBody) {
	      $document.find('body').append($popup);
	    } else {
	      $element.after($popup);
	    }

	    $scope.$on('$destroy', function() {
	      if ($scope.isOpen === true) {
	        if (!$rootScope.$$phase) {
	          $scope.$apply(function() {
	            $scope.isOpen = false;
	          });
	        }
	      }

	      $popup.remove();
	      $element.off('keydown', inputKeydownBind);
	      $document.off('click', documentClickBind);
	      if (scrollParentEl) {
	        scrollParentEl.off('scroll', positionPopup);
	      }
	      angular.element($window).off('resize', positionPopup);

	      //Clear all watch listeners on destroy
	      while (watchListeners.length) {
	        watchListeners.shift()();
	      }
	    });
	  };

	  $scope.getText = function(key) {
	    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
	  };

	  $scope.isDisabled = function(date) {
	    if (date === 'today') {
	      date = dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
	    }

	    if ($scope.datepickerOptions) {
	      return $scope.datepickerOptions &&
	        $scope.datepickerOptions.minDate && $scope.compare(date, $scope.datepickerOptions.minDate) < 0 ||
	        $scope.datepickerOptions.maxDate && $scope.compare(date, $scope.datepickerOptions.maxDate) > 0;
	    }

	    return $scope.watchData.minDate && $scope.compare(date, cache.minDate) < 0 ||
	      $scope.watchData.maxDate && $scope.compare(date, cache.maxDate) > 0;
	  };

	  $scope.compare = function(date1, date2) {
	    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
	  };

	  // Inner change
	  $scope.dateSelection = function(dt) {
	    if (angular.isDefined(dt)) {
	      $scope.date = dt;
	    }
	    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
	    $element.val(date);
	    ngModel.$setViewValue(date);

	    if (closeOnDateSelection) {
	      $scope.isOpen = false;
	      $element[0].focus();
	    }
	  };

	  $scope.keydown = function(evt) {
	    if (evt.which === 27) {
	      evt.stopPropagation();
	      $scope.isOpen = false;
	      $element[0].focus();
	    }
	  };

	  $scope.select = function(date, evt) {
	    evt.stopPropagation();

	    if (date === 'today') {
	      var today = new Date();
	      if (angular.isDate($scope.date)) {
	        date = new Date($scope.date);
	        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
	      } else {
	        date = new Date(today.setHours(0, 0, 0, 0));
	      }
	    }
	    $scope.dateSelection(date);
	  };

	  $scope.close = function(evt) {
	    evt.stopPropagation();

	    $scope.isOpen = false;
	    $element[0].focus();
	  };

	  $scope.disabled = angular.isDefined($attrs.disabled) || false;
	  if ($attrs.ngDisabled) {
	    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
	      $scope.disabled = disabled;
	    }));
	  }

	  $scope.$watch('isOpen', function(value) {
	    if (value) {
	      if (!$scope.disabled) {
	        $timeout(function() {
	          positionPopup();

	          if (onOpenFocus) {
	            $scope.$broadcast('uib:datepicker.focus');
	          }
	          $document.on('click', documentClickBind);

	          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
	          if (appendToBody || $position.parsePlacement(placement)[2]) {
	            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
	            if (scrollParentEl) {
	              scrollParentEl.on('scroll', positionPopup);
	            }
	          } else {
	            scrollParentEl = null;
	          }

	          angular.element($window).on('resize', positionPopup);
	        }, 0, false);
	      } else {
	        $scope.isOpen = false;
	      }
	    } else {
	      $document.off('click', documentClickBind);
	      if (scrollParentEl) {
	        scrollParentEl.off('scroll', positionPopup);
	      }
	      angular.element($window).off('resize', positionPopup);
	    }
	  });

	  function cameltoDash(string) {
	    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
	  }

	  function parseDateString(viewValue) {
	    var date = dateParser.parse(viewValue, dateFormat, $scope.date);
	    if (isNaN(date)) {
	      for (var i = 0; i < altInputFormats.length; i++) {
	        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
	        if (!isNaN(date)) {
	          return date;
	        }
	      }
	    }
	    return date;
	  }

	  function parseDate(viewValue) {
	    if (angular.isNumber(viewValue)) {
	      // presumably timestamp to date object
	      viewValue = new Date(viewValue);
	    }

	    if (!viewValue) {
	      return null;
	    }

	    if (angular.isDate(viewValue) && !isNaN(viewValue)) {
	      return viewValue;
	    }

	    if (angular.isString(viewValue)) {
	      var date = parseDateString(viewValue);
	      if (!isNaN(date)) {
	        return dateParser.toTimezone(date, ngModelOptions.timezone);
	      }
	    }

	    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
	  }

	  function validator(modelValue, viewValue) {
	    var value = modelValue || viewValue;

	    if (!$attrs.ngRequired && !value) {
	      return true;
	    }

	    if (angular.isNumber(value)) {
	      value = new Date(value);
	    }

	    if (!value) {
	      return true;
	    }

	    if (angular.isDate(value) && !isNaN(value)) {
	      return true;
	    }

	    if (angular.isString(value)) {
	      return !isNaN(parseDateString(viewValue));
	    }

	    return false;
	  }

	  function documentClickBind(event) {
	    if (!$scope.isOpen && $scope.disabled) {
	      return;
	    }

	    var popup = $popup[0];
	    var dpContainsTarget = $element[0].contains(event.target);
	    // The popup node may not be an element node
	    // In some browsers (IE) only element nodes have the 'contains' function
	    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
	    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
	      $scope.$apply(function() {
	        $scope.isOpen = false;
	      });
	    }
	  }

	  function inputKeydownBind(evt) {
	    if (evt.which === 27 && $scope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.$apply(function() {
	        $scope.isOpen = false;
	      });
	      $element[0].focus();
	    } else if (evt.which === 40 && !$scope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.$apply(function() {
	        $scope.isOpen = true;
	      });
	    }
	  }

	  function positionPopup() {
	    if ($scope.isOpen) {
	      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
	      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
	      var position = $position.positionElements($element, dpElement, placement, appendToBody);
	      dpElement.css({top: position.top + 'px', left: position.left + 'px'});
	      if (dpElement.hasClass('uib-position-measure')) {
	        dpElement.removeClass('uib-position-measure');
	      }
	    }
	  }

	  $scope.$on('uib:datepicker.mode', function() {
	    $timeout(positionPopup, 0, false);
	  });
	}])

	.directive('uibDatepickerPopup', function() {
	  return {
	    require: ['ngModel', 'uibDatepickerPopup'],
	    controller: 'UibDatepickerPopupController',
	    scope: {
	      datepickerOptions: '=?',
	      isOpen: '=?',
	      currentText: '@',
	      clearText: '@',
	      closeText: '@',
	      dateDisabled: '&',
	      customClass: '&'
	    },
	    link: function(scope, element, attrs, ctrls) {
	      var ngModel = ctrls[0],
	        ctrl = ctrls[1];

	      ctrl.init(ngModel);
	    }
	  };
	})

	.directive('uibDatepickerPopupWrap', function() {
	  return {
	    replace: true,
	    transclude: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/datepicker/popup.html';
	    }
	  };
	});

	angular.module('ui.bootstrap.debounce', [])
	/**
	 * A helper, internal service that debounces a function
	 */
	  .factory('$$debounce', ['$timeout', function($timeout) {
	    return function(callback, debounceTime) {
	      var timeoutPromise;

	      return function() {
	        var self = this;
	        var args = Array.prototype.slice.call(arguments);
	        if (timeoutPromise) {
	          $timeout.cancel(timeoutPromise);
	        }

	        timeoutPromise = $timeout(function() {
	          callback.apply(self, args);
	        }, debounceTime);
	      };
	    };
	  }]);

	angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

	.constant('uibDropdownConfig', {
	  appendToOpenClass: 'uib-dropdown-open',
	  openClass: 'open'
	})

	.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
	  var openScope = null;

	  this.open = function(dropdownScope) {
	    if (!openScope) {
	      $document.on('click', closeDropdown);
	      $document.on('keydown', keybindFilter);
	    }

	    if (openScope && openScope !== dropdownScope) {
	      openScope.isOpen = false;
	    }

	    openScope = dropdownScope;
	  };

	  this.close = function(dropdownScope) {
	    if (openScope === dropdownScope) {
	      openScope = null;
	      $document.off('click', closeDropdown);
	      $document.off('keydown', keybindFilter);
	    }
	  };

	  var closeDropdown = function(evt) {
	    // This method may still be called during the same mouse event that
	    // unbound this event handler. So check openScope before proceeding.
	    if (!openScope) { return; }

	    if (evt && openScope.getAutoClose() === 'disabled') { return; }

	    if (evt && evt.which === 3) { return; }

	    var toggleElement = openScope.getToggleElement();
	    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
	      return;
	    }

	    var dropdownElement = openScope.getDropdownElement();
	    if (evt && openScope.getAutoClose() === 'outsideClick' &&
	      dropdownElement && dropdownElement[0].contains(evt.target)) {
	      return;
	    }

	    openScope.isOpen = false;

	    if (!$rootScope.$$phase) {
	      openScope.$apply();
	    }
	  };

	  var keybindFilter = function(evt) {
	    if (evt.which === 27) {
	      openScope.focusToggleElement();
	      closeDropdown();
	    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      openScope.focusDropdownEntry(evt.which);
	    }
	  };
	}])

	.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
	  var self = this,
	    scope = $scope.$new(), // create a child scope so we are not polluting original one
	    templateScope,
	    appendToOpenClass = dropdownConfig.appendToOpenClass,
	    openClass = dropdownConfig.openClass,
	    getIsOpen,
	    setIsOpen = angular.noop,
	    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
	    appendToBody = false,
	    appendTo = null,
	    keynavEnabled = false,
	    selectedOption = null,
	    body = $document.find('body');

	  $element.addClass('dropdown');

	  this.init = function() {
	    if ($attrs.isOpen) {
	      getIsOpen = $parse($attrs.isOpen);
	      setIsOpen = getIsOpen.assign;

	      $scope.$watch(getIsOpen, function(value) {
	        scope.isOpen = !!value;
	      });
	    }

	    if (angular.isDefined($attrs.dropdownAppendTo)) {
	      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
	      if (appendToEl) {
	        appendTo = angular.element(appendToEl);
	      }
	    }

	    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
	    keynavEnabled = angular.isDefined($attrs.keyboardNav);

	    if (appendToBody && !appendTo) {
	      appendTo = body;
	    }

	    if (appendTo && self.dropdownMenu) {
	      appendTo.append(self.dropdownMenu);
	      $element.on('$destroy', function handleDestroyEvent() {
	        self.dropdownMenu.remove();
	      });
	    }
	  };

	  this.toggle = function(open) {
	    scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen(scope, scope.isOpen);
	    }

	    return scope.isOpen;
	  };

	  // Allow other directives to watch status
	  this.isOpen = function() {
	    return scope.isOpen;
	  };

	  scope.getToggleElement = function() {
	    return self.toggleElement;
	  };

	  scope.getAutoClose = function() {
	    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
	  };

	  scope.getElement = function() {
	    return $element;
	  };

	  scope.isKeynavEnabled = function() {
	    return keynavEnabled;
	  };

	  scope.focusDropdownEntry = function(keyCode) {
	    var elems = self.dropdownMenu ? //If append to body is used.
	      angular.element(self.dropdownMenu).find('a') :
	      $element.find('ul').eq(0).find('a');

	    switch (keyCode) {
	      case 40: {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = 0;
	        } else {
	          self.selectedOption = self.selectedOption === elems.length - 1 ?
	            self.selectedOption :
	            self.selectedOption + 1;
	        }
	        break;
	      }
	      case 38: {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = elems.length - 1;
	        } else {
	          self.selectedOption = self.selectedOption === 0 ?
	            0 : self.selectedOption - 1;
	        }
	        break;
	      }
	    }
	    elems[self.selectedOption].focus();
	  };

	  scope.getDropdownElement = function() {
	    return self.dropdownMenu;
	  };

	  scope.focusToggleElement = function() {
	    if (self.toggleElement) {
	      self.toggleElement[0].focus();
	    }
	  };

	  scope.$watch('isOpen', function(isOpen, wasOpen) {
	    if (appendTo && self.dropdownMenu) {
	      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
	        css,
	        rightalign;

	      css = {
	        top: pos.top + 'px',
	        display: isOpen ? 'block' : 'none'
	      };

	      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
	      if (!rightalign) {
	        css.left = pos.left + 'px';
	        css.right = 'auto';
	      } else {
	        css.left = 'auto';
	        css.right = window.innerWidth -
	          (pos.left + $element.prop('offsetWidth')) + 'px';
	      }

	      // Need to adjust our positioning to be relative to the appendTo container
	      // if it's not the body element
	      if (!appendToBody) {
	        var appendOffset = $position.offset(appendTo);

	        css.top = pos.top - appendOffset.top + 'px';

	        if (!rightalign) {
	          css.left = pos.left - appendOffset.left + 'px';
	        } else {
	          css.right = window.innerWidth -
	            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
	        }
	      }

	      self.dropdownMenu.css(css);
	    }

	    var openContainer = appendTo ? appendTo : $element;
	    var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);

	    if (hasOpenClass === !isOpen) {
	      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
	        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
	          toggleInvoker($scope, { open: !!isOpen });
	        }
	      });
	    }

	    if (isOpen) {
	      if (self.dropdownMenuTemplateUrl) {
	        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
	          templateScope = scope.$new();
	          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
	            var newEl = dropdownElement;
	            self.dropdownMenu.replaceWith(newEl);
	            self.dropdownMenu = newEl;
	          });
	        });
	      }

	      scope.focusToggleElement();
	      uibDropdownService.open(scope);
	    } else {
	      if (self.dropdownMenuTemplateUrl) {
	        if (templateScope) {
	          templateScope.$destroy();
	        }
	        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
	        self.dropdownMenu.replaceWith(newEl);
	        self.dropdownMenu = newEl;
	      }

	      uibDropdownService.close(scope);
	      self.selectedOption = null;
	    }

	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen($scope, isOpen);
	    }
	  });

	  $scope.$on('$locationChangeSuccess', function() {
	    if (scope.getAutoClose() !== 'disabled') {
	      scope.isOpen = false;
	    }
	  });
	}])

	.directive('uibDropdown', function() {
	  return {
	    controller: 'UibDropdownController',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      dropdownCtrl.init();
	    }
	  };
	})

	.directive('uibDropdownMenu', function() {
	  return {
	    restrict: 'A',
	    require: '?^uibDropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
	        return;
	      }

	      element.addClass('dropdown-menu');

	      var tplUrl = attrs.templateUrl;
	      if (tplUrl) {
	        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
	      }

	      if (!dropdownCtrl.dropdownMenu) {
	        dropdownCtrl.dropdownMenu = element;
	      }
	    }
	  };
	})

	.directive('uibDropdownToggle', function() {
	  return {
	    require: '?^uibDropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }

	      element.addClass('dropdown-toggle');

	      dropdownCtrl.toggleElement = element;

	      var toggleDropdown = function(event) {
	        event.preventDefault();

	        if (!element.hasClass('disabled') && !attrs.disabled) {
	          scope.$apply(function() {
	            dropdownCtrl.toggle();
	          });
	        }
	      };

	      element.bind('click', toggleDropdown);

	      // WAI-ARIA
	      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
	        element.attr('aria-expanded', !!isOpen);
	      });

	      scope.$on('$destroy', function() {
	        element.unbind('click', toggleDropdown);
	      });
	    }
	  };
	});

	angular.module('ui.bootstrap.stackedMap', [])
	/**
	 * A helper, internal data structure that acts as a map but also allows getting / removing
	 * elements in the LIFO order
	 */
	  .factory('$$stackedMap', function() {
	    return {
	      createNew: function() {
	        var stack = [];

	        return {
	          add: function(key, value) {
	            stack.push({
	              key: key,
	              value: value
	            });
	          },
	          get: function(key) {
	            for (var i = 0; i < stack.length; i++) {
	              if (key === stack[i].key) {
	                return stack[i];
	              }
	            }
	          },
	          keys: function() {
	            var keys = [];
	            for (var i = 0; i < stack.length; i++) {
	              keys.push(stack[i].key);
	            }
	            return keys;
	          },
	          top: function() {
	            return stack[stack.length - 1];
	          },
	          remove: function(key) {
	            var idx = -1;
	            for (var i = 0; i < stack.length; i++) {
	              if (key === stack[i].key) {
	                idx = i;
	                break;
	              }
	            }
	            return stack.splice(idx, 1)[0];
	          },
	          removeTop: function() {
	            return stack.splice(stack.length - 1, 1)[0];
	          },
	          length: function() {
	            return stack.length;
	          }
	        };
	      }
	    };
	  });
	angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])
	/**
	 * A helper, internal data structure that stores all references attached to key
	 */
	  .factory('$$multiMap', function() {
	    return {
	      createNew: function() {
	        var map = {};

	        return {
	          entries: function() {
	            return Object.keys(map).map(function(key) {
	              return {
	                key: key,
	                value: map[key]
	              };
	            });
	          },
	          get: function(key) {
	            return map[key];
	          },
	          hasKey: function(key) {
	            return !!map[key];
	          },
	          keys: function() {
	            return Object.keys(map);
	          },
	          put: function(key, value) {
	            if (!map[key]) {
	              map[key] = [];
	            }

	            map[key].push(value);
	          },
	          remove: function(key, value) {
	            var values = map[key];

	            if (!values) {
	              return;
	            }

	            var idx = values.indexOf(value);

	            if (idx !== -1) {
	              values.splice(idx, 1);
	            }

	            if (!values.length) {
	              delete map[key];
	            }
	          }
	        };
	      }
	    };
	  })

	/**
	 * Pluggable resolve mechanism for the modal resolve resolution
	 * Supports UI Router's $resolve service
	 */
	  .provider('$uibResolve', function() {
	    var resolve = this;
	    this.resolver = null;

	    this.setResolver = function(resolver) {
	      this.resolver = resolver;
	    };

	    this.$get = ['$injector', '$q', function($injector, $q) {
	      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
	      return {
	        resolve: function(invocables, locals, parent, self) {
	          if (resolver) {
	            return resolver.resolve(invocables, locals, parent, self);
	          }

	          var promises = [];

	          angular.forEach(invocables, function(value) {
	            if (angular.isFunction(value) || angular.isArray(value)) {
	              promises.push($q.resolve($injector.invoke(value)));
	            } else if (angular.isString(value)) {
	              promises.push($q.resolve($injector.get(value)));
	            } else {
	              promises.push($q.resolve(value));
	            }
	          });

	          return $q.all(promises).then(function(resolves) {
	            var resolveObj = {};
	            var resolveIter = 0;
	            angular.forEach(invocables, function(value, key) {
	              resolveObj[key] = resolves[resolveIter++];
	            });

	            return resolveObj;
	          });
	        }
	      };
	    }];
	  })

	/**
	 * A helper directive for the $modal service. It creates a backdrop element.
	 */
	  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
	  function($animate, $injector, $modalStack) {
	    return {
	      replace: true,
	      templateUrl: 'uib/template/modal/backdrop.html',
	      compile: function(tElement, tAttrs) {
	        tElement.addClass(tAttrs.backdropClass);
	        return linkFn;
	      }
	    };

	    function linkFn(scope, element, attrs) {
	      if (attrs.modalInClass) {
	        $animate.addClass(element, attrs.modalInClass);

	        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	          var done = setIsAsync();
	          if (scope.modalOptions.animation) {
	            $animate.removeClass(element, attrs.modalInClass).then(done);
	          } else {
	            done();
	          }
	        });
	      }
	    }
	  }])

	  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
	  function($modalStack, $q, $animateCss, $document) {
	    return {
	      scope: {
	        index: '@'
	      },
	      replace: true,
	      transclude: true,
	      templateUrl: function(tElement, tAttrs) {
	        return tAttrs.templateUrl || 'uib/template/modal/window.html';
	      },
	      link: function(scope, element, attrs) {
	        element.addClass(attrs.windowClass || '');
	        element.addClass(attrs.windowTopClass || '');
	        scope.size = attrs.size;

	        scope.close = function(evt) {
	          var modal = $modalStack.getTop();
	          if (modal && modal.value.backdrop &&
	            modal.value.backdrop !== 'static' &&
	            evt.target === evt.currentTarget) {
	            evt.preventDefault();
	            evt.stopPropagation();
	            $modalStack.dismiss(modal.key, 'backdrop click');
	          }
	        };

	        // moved from template to fix issue #2280
	        element.on('click', scope.close);

	        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
	        // We can detect that by using this property in the template associated with this directive and then use
	        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
	        scope.$isRendered = true;

	        // Deferred object that will be resolved when this modal is render.
	        var modalRenderDeferObj = $q.defer();
	        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
	        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
	        attrs.$observe('modalRender', function(value) {
	          if (value === 'true') {
	            modalRenderDeferObj.resolve();
	          }
	        });

	        modalRenderDeferObj.promise.then(function() {
	          var animationPromise = null;

	          if (attrs.modalInClass) {
	            animationPromise = $animateCss(element, {
	              addClass: attrs.modalInClass
	            }).start();

	            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	              var done = setIsAsync();
	              $animateCss(element, {
	                removeClass: attrs.modalInClass
	              }).start().then(done);
	            });
	          }


	          $q.when(animationPromise).then(function() {
	            // Notify {@link $modalStack} that modal is rendered.
	            var modal = $modalStack.getTop();
	            if (modal) {
	              $modalStack.modalRendered(modal.key);
	            }

	            /**
	             * If something within the freshly-opened modal already has focus (perhaps via a
	             * directive that causes focus). then no need to try and focus anything.
	             */
	            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
	              var inputWithAutofocus = element[0].querySelector('[autofocus]');
	              /**
	               * Auto-focusing of a freshly-opened modal element causes any child elements
	               * with the autofocus attribute to lose focus. This is an issue on touch
	               * based devices which will show and then hide the onscreen keyboard.
	               * Attempts to refocus the autofocus element via JavaScript will not reopen
	               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
	               * the modal element if the modal does not contain an autofocus element.
	               */
	              if (inputWithAutofocus) {
	                inputWithAutofocus.focus();
	              } else {
	                element[0].focus();
	              }
	            }
	          });
	        });
	      }
	    };
	  }])

	  .directive('uibModalAnimationClass', function() {
	    return {
	      compile: function(tElement, tAttrs) {
	        if (tAttrs.modalAnimation) {
	          tElement.addClass(tAttrs.uibModalAnimationClass);
	        }
	      }
	    };
	  })

	  .directive('uibModalTransclude', function() {
	    return {
	      link: function(scope, element, attrs, controller, transclude) {
	        transclude(scope.$parent, function(clone) {
	          element.empty();
	          element.append(clone);
	        });
	      }
	    };
	  })

	  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
	    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',
	    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {
	      var OPENED_MODAL_CLASS = 'modal-open';

	      var backdropDomEl, backdropScope;
	      var openedWindows = $$stackedMap.createNew();
	      var openedClasses = $$multiMap.createNew();
	      var $modalStack = {
	        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
	      };

	      //Modal focus behavior
	      var tabableSelector = 'a[href], area[href], input:not([disabled]), ' +
	        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
	        'iframe, object, embed, *[tabindex], *[contenteditable=true]';

	      function isVisible(element) {
	        return !!(element.offsetWidth ||
	          element.offsetHeight ||
	          element.getClientRects().length);
	      }

	      function backdropIndex() {
	        var topBackdropIndex = -1;
	        var opened = openedWindows.keys();
	        for (var i = 0; i < opened.length; i++) {
	          if (openedWindows.get(opened[i]).value.backdrop) {
	            topBackdropIndex = i;
	          }
	        }
	        return topBackdropIndex;
	      }

	      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
	        if (backdropScope) {
	          backdropScope.index = newBackdropIndex;
	        }
	      });

	      function removeModalWindow(modalInstance, elementToReceiveFocus) {
	        var modalWindow = openedWindows.get(modalInstance).value;
	        var appendToElement = modalWindow.appendTo;

	        //clean up the stack
	        openedWindows.remove(modalInstance);

	        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
	          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
	          openedClasses.remove(modalBodyClass, modalInstance);
	          appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
	          toggleTopWindowClass(true);
	        }, modalWindow.closedDeferred);
	        checkRemoveBackdrop();

	        //move focus to specified element if available, or else to body
	        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
	          elementToReceiveFocus.focus();
	        } else if (appendToElement.focus) {
	          appendToElement.focus();
	        }
	      }

	      // Add or remove "windowTopClass" from the top window in the stack
	      function toggleTopWindowClass(toggleSwitch) {
	        var modalWindow;

	        if (openedWindows.length() > 0) {
	          modalWindow = openedWindows.top().value;
	          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
	        }
	      }

	      function checkRemoveBackdrop() {
	        //remove backdrop if no longer needed
	        if (backdropDomEl && backdropIndex() === -1) {
	          var backdropScopeRef = backdropScope;
	          removeAfterAnimate(backdropDomEl, backdropScope, function() {
	            backdropScopeRef = null;
	          });
	          backdropDomEl = undefined;
	          backdropScope = undefined;
	        }
	      }

	      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
	        var asyncDeferred;
	        var asyncPromise = null;
	        var setIsAsync = function() {
	          if (!asyncDeferred) {
	            asyncDeferred = $q.defer();
	            asyncPromise = asyncDeferred.promise;
	          }

	          return function asyncDone() {
	            asyncDeferred.resolve();
	          };
	        };
	        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

	        // Note that it's intentional that asyncPromise might be null.
	        // That's when setIsAsync has not been called during the
	        // NOW_CLOSING_EVENT broadcast.
	        return $q.when(asyncPromise).then(afterAnimating);

	        function afterAnimating() {
	          if (afterAnimating.done) {
	            return;
	          }
	          afterAnimating.done = true;

	          $animate.leave(domEl).then(function() {
	            domEl.remove();
	            if (closedDeferred) {
	              closedDeferred.resolve();
	            }
	          });

	          scope.$destroy();
	          if (done) {
	            done();
	          }
	        }
	      }

	      $document.on('keydown', keydownListener);

	      $rootScope.$on('$destroy', function() {
	        $document.off('keydown', keydownListener);
	      });

	      function keydownListener(evt) {
	        if (evt.isDefaultPrevented()) {
	          return evt;
	        }

	        var modal = openedWindows.top();
	        if (modal) {
	          switch (evt.which) {
	            case 27: {
	              if (modal.value.keyboard) {
	                evt.preventDefault();
	                $rootScope.$apply(function() {
	                  $modalStack.dismiss(modal.key, 'escape key press');
	                });
	              }
	              break;
	            }
	            case 9: {
	              var list = $modalStack.loadFocusElementList(modal);
	              var focusChanged = false;
	              if (evt.shiftKey) {
	                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
	                  focusChanged = $modalStack.focusLastFocusableElement(list);
	                }
	              } else {
	                if ($modalStack.isFocusInLastItem(evt, list)) {
	                  focusChanged = $modalStack.focusFirstFocusableElement(list);
	                }
	              }

	              if (focusChanged) {
	                evt.preventDefault();
	                evt.stopPropagation();
	              }

	              break;
	            }
	          }
	        }
	      }

	      $modalStack.open = function(modalInstance, modal) {
	        var modalOpener = $document[0].activeElement,
	          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

	        toggleTopWindowClass(false);

	        openedWindows.add(modalInstance, {
	          deferred: modal.deferred,
	          renderDeferred: modal.renderDeferred,
	          closedDeferred: modal.closedDeferred,
	          modalScope: modal.scope,
	          backdrop: modal.backdrop,
	          keyboard: modal.keyboard,
	          openedClass: modal.openedClass,
	          windowTopClass: modal.windowTopClass,
	          animation: modal.animation,
	          appendTo: modal.appendTo
	        });

	        openedClasses.put(modalBodyClass, modalInstance);

	        var appendToElement = modal.appendTo,
	            currBackdropIndex = backdropIndex();

	        if (!appendToElement.length) {
	          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
	        }

	        if (currBackdropIndex >= 0 && !backdropDomEl) {
	          backdropScope = $rootScope.$new(true);
	          backdropScope.modalOptions = modal;
	          backdropScope.index = currBackdropIndex;
	          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
	          backdropDomEl.attr('backdrop-class', modal.backdropClass);
	          if (modal.animation) {
	            backdropDomEl.attr('modal-animation', 'true');
	          }
	          $compile(backdropDomEl)(backdropScope);
	          $animate.enter(backdropDomEl, appendToElement);
	        }

	        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
	        angularDomEl.attr({
	          'template-url': modal.windowTemplateUrl,
	          'window-class': modal.windowClass,
	          'window-top-class': modal.windowTopClass,
	          'size': modal.size,
	          'index': openedWindows.length() - 1,
	          'animate': 'animate'
	        }).html(modal.content);
	        if (modal.animation) {
	          angularDomEl.attr('modal-animation', 'true');
	        }

	        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement)
	          .then(function() {
	            if (!modal.scope.$$uibDestructionScheduled) {
	              $animate.addClass(appendToElement, modalBodyClass);
	            }
	          });

	        openedWindows.top().value.modalDomEl = angularDomEl;
	        openedWindows.top().value.modalOpener = modalOpener;
	      };

	      function broadcastClosing(modalWindow, resultOrReason, closing) {
	        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
	      }

	      $modalStack.close = function(modalInstance, result) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.resolve(result);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };

	      $modalStack.dismiss = function(modalInstance, reason) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.reject(reason);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };

	      $modalStack.dismissAll = function(reason) {
	        var topModal = this.getTop();
	        while (topModal && this.dismiss(topModal.key, reason)) {
	          topModal = this.getTop();
	        }
	      };

	      $modalStack.getTop = function() {
	        return openedWindows.top();
	      };

	      $modalStack.modalRendered = function(modalInstance) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow) {
	          modalWindow.value.renderDeferred.resolve();
	        }
	      };

	      $modalStack.focusFirstFocusableElement = function(list) {
	        if (list.length > 0) {
	          list[0].focus();
	          return true;
	        }
	        return false;
	      };

	      $modalStack.focusLastFocusableElement = function(list) {
	        if (list.length > 0) {
	          list[list.length - 1].focus();
	          return true;
	        }
	        return false;
	      };

	      $modalStack.isModalFocused = function(evt, modalWindow) {
	        if (evt && modalWindow) {
	          var modalDomEl = modalWindow.value.modalDomEl;
	          if (modalDomEl && modalDomEl.length) {
	            return (evt.target || evt.srcElement) === modalDomEl[0];
	          }
	        }
	        return false;
	      };

	      $modalStack.isFocusInFirstItem = function(evt, list) {
	        if (list.length > 0) {
	          return (evt.target || evt.srcElement) === list[0];
	        }
	        return false;
	      };

	      $modalStack.isFocusInLastItem = function(evt, list) {
	        if (list.length > 0) {
	          return (evt.target || evt.srcElement) === list[list.length - 1];
	        }
	        return false;
	      };

	      $modalStack.loadFocusElementList = function(modalWindow) {
	        if (modalWindow) {
	          var modalDomE1 = modalWindow.value.modalDomEl;
	          if (modalDomE1 && modalDomE1.length) {
	            var elements = modalDomE1[0].querySelectorAll(tabableSelector);
	            return elements ?
	              Array.prototype.filter.call(elements, function(element) {
	                return isVisible(element);
	              }) : elements;
	          }
	        }
	      };

	      return $modalStack;
	    }])

	  .provider('$uibModal', function() {
	    var $modalProvider = {
	      options: {
	        animation: true,
	        backdrop: true, //can also be false or 'static'
	        keyboard: true
	      },
	      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
	        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
	          var $modal = {};

	          function getTemplatePromise(options) {
	            return options.template ? $q.when(options.template) :
	              $templateRequest(angular.isFunction(options.templateUrl) ?
	                options.templateUrl() : options.templateUrl);
	          }

	          var promiseChain = null;
	          $modal.getPromiseChain = function() {
	            return promiseChain;
	          };

	          $modal.open = function(modalOptions) {
	            var modalResultDeferred = $q.defer();
	            var modalOpenedDeferred = $q.defer();
	            var modalClosedDeferred = $q.defer();
	            var modalRenderDeferred = $q.defer();

	            //prepare an instance of a modal to be injected into controllers and returned to a caller
	            var modalInstance = {
	              result: modalResultDeferred.promise,
	              opened: modalOpenedDeferred.promise,
	              closed: modalClosedDeferred.promise,
	              rendered: modalRenderDeferred.promise,
	              close: function (result) {
	                return $modalStack.close(modalInstance, result);
	              },
	              dismiss: function (reason) {
	                return $modalStack.dismiss(modalInstance, reason);
	              }
	            };

	            //merge and clean up options
	            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
	            modalOptions.resolve = modalOptions.resolve || {};
	            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

	            //verify options
	            if (!modalOptions.template && !modalOptions.templateUrl) {
	              throw new Error('One of template or templateUrl options is required.');
	            }

	            var templateAndResolvePromise =
	              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);

	            function resolveWithTemplate() {
	              return templateAndResolvePromise;
	            }

	            // Wait for the resolution of the existing promise chain.
	            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
	            // Then add to $modalStack and resolve opened.
	            // Finally clean up the chain variable if no subsequent modal has overwritten it.
	            var samePromise;
	            samePromise = promiseChain = $q.all([promiseChain])
	              .then(resolveWithTemplate, resolveWithTemplate)
	              .then(function resolveSuccess(tplAndVars) {
	                var providedScope = modalOptions.scope || $rootScope;

	                var modalScope = providedScope.$new();
	                modalScope.$close = modalInstance.close;
	                modalScope.$dismiss = modalInstance.dismiss;

	                modalScope.$on('$destroy', function() {
	                  if (!modalScope.$$uibDestructionScheduled) {
	                    modalScope.$dismiss('$uibUnscheduledDestruction');
	                  }
	                });

	                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};

	                //controllers
	                if (modalOptions.controller) {
	                  ctrlLocals.$scope = modalScope;
	                  ctrlLocals.$uibModalInstance = modalInstance;
	                  angular.forEach(tplAndVars[1], function(value, key) {
	                    ctrlLocals[key] = value;
	                  });

	                  // the third param will make the controller instantiate later,private api
	                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
	                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true);
	                  if (modalOptions.controllerAs) {
	                    ctrlInstance = ctrlInstantiate.instance;

	                    if (modalOptions.bindToController) {
	                      ctrlInstance.$close = modalScope.$close;
	                      ctrlInstance.$dismiss = modalScope.$dismiss;
	                      angular.extend(ctrlInstance, providedScope);
	                    }

	                    ctrlInstance = ctrlInstantiate();

	                    modalScope[modalOptions.controllerAs] = ctrlInstance;
	                  } else {
	                    ctrlInstance = ctrlInstantiate();
	                  }

	                  if (angular.isFunction(ctrlInstance.$onInit)) {
	                    ctrlInstance.$onInit();
	                  }
	                }

	                $modalStack.open(modalInstance, {
	                  scope: modalScope,
	                  deferred: modalResultDeferred,
	                  renderDeferred: modalRenderDeferred,
	                  closedDeferred: modalClosedDeferred,
	                  content: tplAndVars[0],
	                  animation: modalOptions.animation,
	                  backdrop: modalOptions.backdrop,
	                  keyboard: modalOptions.keyboard,
	                  backdropClass: modalOptions.backdropClass,
	                  windowTopClass: modalOptions.windowTopClass,
	                  windowClass: modalOptions.windowClass,
	                  windowTemplateUrl: modalOptions.windowTemplateUrl,
	                  size: modalOptions.size,
	                  openedClass: modalOptions.openedClass,
	                  appendTo: modalOptions.appendTo
	                });
	                modalOpenedDeferred.resolve(true);

	            }, function resolveError(reason) {
	              modalOpenedDeferred.reject(reason);
	              modalResultDeferred.reject(reason);
	            })['finally'](function() {
	              if (promiseChain === samePromise) {
	                promiseChain = null;
	              }
	            });

	            return modalInstance;
	          };

	          return $modal;
	        }
	      ]
	    };

	    return $modalProvider;
	  });

	angular.module('ui.bootstrap.paging', [])
	/**
	 * Helper internal service for generating common controller code between the
	 * pager and pagination components
	 */
	.factory('uibPaging', ['$parse', function($parse) {
	  return {
	    create: function(ctrl, $scope, $attrs) {
	      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
	      ctrl._watchers = [];

	      ctrl.init = function(ngModelCtrl, config) {
	        ctrl.ngModelCtrl = ngModelCtrl;
	        ctrl.config = config;

	        ngModelCtrl.$render = function() {
	          ctrl.render();
	        };

	        if ($attrs.itemsPerPage) {
	          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
	            ctrl.itemsPerPage = parseInt(value, 10);
	            $scope.totalPages = ctrl.calculateTotalPages();
	            ctrl.updatePage();
	          }));
	        } else {
	          ctrl.itemsPerPage = config.itemsPerPage;
	        }

	        $scope.$watch('totalItems', function(newTotal, oldTotal) {
	          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
	            $scope.totalPages = ctrl.calculateTotalPages();
	            ctrl.updatePage();
	          }
	        });
	      };

	      ctrl.calculateTotalPages = function() {
	        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
	        return Math.max(totalPages || 0, 1);
	      };

	      ctrl.render = function() {
	        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
	      };

	      $scope.selectPage = function(page, evt) {
	        if (evt) {
	          evt.preventDefault();
	        }

	        var clickAllowed = !$scope.ngDisabled || !evt;
	        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
	          if (evt && evt.target) {
	            evt.target.blur();
	          }
	          ctrl.ngModelCtrl.$setViewValue(page);
	          ctrl.ngModelCtrl.$render();
	        }
	      };

	      $scope.getText = function(key) {
	        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
	      };

	      $scope.noPrevious = function() {
	        return $scope.page === 1;
	      };

	      $scope.noNext = function() {
	        return $scope.page === $scope.totalPages;
	      };

	      ctrl.updatePage = function() {
	        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

	        if ($scope.page > $scope.totalPages) {
	          $scope.selectPage($scope.totalPages);
	        } else {
	          ctrl.ngModelCtrl.$render();
	        }
	      };

	      $scope.$on('$destroy', function() {
	        while (ctrl._watchers.length) {
	          ctrl._watchers.shift()();
	        }
	      });
	    }
	  };
	}]);

	angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])

	.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
	  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

	  uibPaging.create(this, $scope, $attrs);
	}])

	.constant('uibPagerConfig', {
	  itemsPerPage: 10,
	  previousText: '« Previous',
	  nextText: 'Next »',
	  align: true
	})

	.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
	  return {
	    scope: {
	      totalItems: '=',
	      previousText: '@',
	      nextText: '@',
	      ngDisabled: '='
	    },
	    require: ['uibPager', '?ngModel'],
	    controller: 'UibPagerController',
	    controllerAs: 'pager',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/pager/pager.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	      if (!ngModelCtrl) {
	        return; // do nothing if no ng-model
	      }

	      paginationCtrl.init(ngModelCtrl, uibPagerConfig);
	    }
	  };
	}]);

	angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])
	.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
	  var ctrl = this;
	  // Setup configuration parameters
	  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
	    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
	    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
	    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
	    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;
	  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
	  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;

	  uibPaging.create(this, $scope, $attrs);

	  if ($attrs.maxSize) {
	    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
	      maxSize = parseInt(value, 10);
	      ctrl.render();
	    }));
	  }

	  // Create page object used in template
	  function makePage(number, text, isActive) {
	    return {
	      number: number,
	      text: text,
	      active: isActive
	    };
	  }

	  function getPages(currentPage, totalPages) {
	    var pages = [];

	    // Default page limits
	    var startPage = 1, endPage = totalPages;
	    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

	    // recompute if maxSize
	    if (isMaxSized) {
	      if (rotate) {
	        // Current page is displayed in the middle of the visible ones
	        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
	        endPage = startPage + maxSize - 1;

	        // Adjust if limit is exceeded
	        if (endPage > totalPages) {
	          endPage = totalPages;
	          startPage = endPage - maxSize + 1;
	        }
	      } else {
	        // Visible pages are paginated with maxSize
	        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

	        // Adjust last page if limit is exceeded
	        endPage = Math.min(startPage + maxSize - 1, totalPages);
	      }
	    }

	    // Add page number links
	    for (var number = startPage; number <= endPage; number++) {
	      var page = makePage(number, pageLabel(number), number === currentPage);
	      pages.push(page);
	    }

	    // Add links to move between page sets
	    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
	      if (startPage > 1) {
	        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning
	        var previousPageSet = makePage(startPage - 1, '...', false);
	        pages.unshift(previousPageSet);
	      }
	        if (boundaryLinkNumbers) {
	          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential
	            var secondPageLink = makePage(2, '2', false);
	            pages.unshift(secondPageLink);
	          }
	          //add the first page
	          var firstPageLink = makePage(1, '1', false);
	          pages.unshift(firstPageLink);
	        }
	      }

	      if (endPage < totalPages) {
	        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end
	        var nextPageSet = makePage(endPage + 1, '...', false);
	        pages.push(nextPageSet);
	      }
	        if (boundaryLinkNumbers) {
	          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential
	            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
	            pages.push(secondToLastPageLink);
	          }
	          //add the last page
	          var lastPageLink = makePage(totalPages, totalPages, false);
	          pages.push(lastPageLink);
	        }
	      }
	    }
	    return pages;
	  }

	  var originalRender = this.render;
	  this.render = function() {
	    originalRender();
	    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
	      $scope.pages = getPages($scope.page, $scope.totalPages);
	    }
	  };
	}])

	.constant('uibPaginationConfig', {
	  itemsPerPage: 10,
	  boundaryLinks: false,
	  boundaryLinkNumbers: false,
	  directionLinks: true,
	  firstText: 'First',
	  previousText: 'Previous',
	  nextText: 'Next',
	  lastText: 'Last',
	  rotate: true,
	  forceEllipses: false
	})

	.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
	  return {
	    scope: {
	      totalItems: '=',
	      firstText: '@',
	      previousText: '@',
	      nextText: '@',
	      lastText: '@',
	      ngDisabled:'='
	    },
	    require: ['uibPagination', '?ngModel'],
	    controller: 'UibPaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/pagination/pagination.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }

	      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
	    }
	  };
	}]);

	/**
	 * The following features are still outstanding: animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html tooltips, and selector delegation.
	 */
	angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

	/**
	 * The $tooltip service creates tooltip- and popover-like directives as well as
	 * houses global options for them.
	 */
	.provider('$uibTooltip', function() {
	  // The default options tooltip and popover.
	  var defaultOptions = {
	    placement: 'top',
	    placementClassPrefix: '',
	    animation: true,
	    popupDelay: 0,
	    popupCloseDelay: 0,
	    useContentExp: false
	  };

	  // Default hide triggers for each show trigger
	  var triggerMap = {
	    'mouseenter': 'mouseleave',
	    'click': 'click',
	    'outsideClick': 'outsideClick',
	    'focus': 'blur',
	    'none': ''
	  };

	  // The options specified to the provider globally.
	  var globalOptions = {};

	  /**
	   * `options({})` allows global configuration of all tooltips in the
	   * application.
	   *
	   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
	   *     // place tooltips left instead of top by default
	   *     $tooltipProvider.options( { placement: 'left' } );
	   *   });
	   */
		this.options = function(value) {
			angular.extend(globalOptions, value);
		};

	  /**
	   * This allows you to extend the set of trigger mappings available. E.g.:
	   *
	   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
	   */
	  this.setTriggers = function setTriggers(triggers) {
	    angular.extend(triggerMap, triggers);
	  };

	  /**
	   * This is a helper function for translating camel-case to snake_case.
	   */
	  function snake_case(name) {
	    var regexp = /[A-Z]/g;
	    var separator = '-';
	    return name.replace(regexp, function(letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }

	  /**
	   * Returns the actual instance of the $tooltip service.
	   * TODO support multiple triggers
	   */
	  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
	    var openedTooltips = $$stackedMap.createNew();
	    $document.on('keypress', keypressListener);

	    $rootScope.$on('$destroy', function() {
	      $document.off('keypress', keypressListener);
	    });

	    function keypressListener(e) {
	      if (e.which === 27) {
	        var last = openedTooltips.top();
	        if (last) {
	          last.value.close();
	          openedTooltips.removeTop();
	          last = null;
	        }
	      }
	    }

	    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
	      options = angular.extend({}, defaultOptions, globalOptions, options);

	      /**
	       * Returns an object of show and hide triggers.
	       *
	       * If a trigger is supplied,
	       * it is used to show the tooltip; otherwise, it will use the `trigger`
	       * option passed to the `$tooltipProvider.options` method; else it will
	       * default to the trigger supplied to this directive factory.
	       *
	       * The hide trigger is based on the show trigger. If the `trigger` option
	       * was passed to the `$tooltipProvider.options` method, it will use the
	       * mapped trigger from `triggerMap` or the passed trigger if the map is
	       * undefined; otherwise, it uses the `triggerMap` value of the show
	       * trigger; else it will just use the show trigger.
	       */
	      function getTriggers(trigger) {
	        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
	        var hide = show.map(function(trigger) {
	          return triggerMap[trigger] || trigger;
	        });
	        return {
	          show: show,
	          hide: hide
	        };
	      }

	      var directiveName = snake_case(ttType);

	      var startSym = $interpolate.startSymbol();
	      var endSym = $interpolate.endSymbol();
	      var template =
	        '<div '+ directiveName + '-popup '+
	          'title="' + startSym + 'title' + endSym + '" '+
	          (options.useContentExp ?
	            'content-exp="contentExp()" ' :
	            'content="' + startSym + 'content' + endSym + '" ') +
	          'placement="' + startSym + 'placement' + endSym + '" '+
	          'popup-class="' + startSym + 'popupClass' + endSym + '" '+
	          'animation="animation" ' +
	          'is-open="isOpen"' +
	          'origin-scope="origScope" ' +
	          'class="uib-position-measure"' +
	          '>' +
	        '</div>';

	      return {
	        compile: function(tElem, tAttrs) {
	          var tooltipLinker = $compile(template);

	          return function link(scope, element, attrs, tooltipCtrl) {
	            var tooltip;
	            var tooltipLinkedScope;
	            var transitionTimeout;
	            var showTimeout;
	            var hideTimeout;
	            var positionTimeout;
	            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
	            var triggers = getTriggers(undefined);
	            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
	            var ttScope = scope.$new(true);
	            var repositionScheduled = false;
	            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
	            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
	            var observers = [];
	            var lastPlacement;

	            var positionTooltip = function() {
	              // check if tooltip exists and is not empty
	              if (!tooltip || !tooltip.html()) { return; }

	              if (!positionTimeout) {
	                positionTimeout = $timeout(function() {
	                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
	                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });

	                  if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {
	                    tooltip.removeClass(lastPlacement.split('-')[0]);
	                    tooltip.addClass(ttPosition.placement.split('-')[0]);
	                  }

	                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
	                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);
	                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
	                  }

	                  // first time through tt element will have the
	                  // uib-position-measure class or if the placement
	                  // has changed we need to position the arrow.
	                  if (tooltip.hasClass('uib-position-measure')) {
	                    $position.positionArrow(tooltip, ttPosition.placement);
	                    tooltip.removeClass('uib-position-measure');
	                  } else if (lastPlacement !== ttPosition.placement) {
	                    $position.positionArrow(tooltip, ttPosition.placement);
	                  }
	                  lastPlacement = ttPosition.placement;

	                  positionTimeout = null;
	                }, 0, false);
	              }
	            };

	            // Set up the correct scope to allow transclusion later
	            ttScope.origScope = scope;

	            // By default, the tooltip is not open.
	            // TODO add ability to start tooltip opened
	            ttScope.isOpen = false;
	            openedTooltips.add(ttScope, {
	              close: hide
	            });

	            function toggleTooltipBind() {
	              if (!ttScope.isOpen) {
	                showTooltipBind();
	              } else {
	                hideTooltipBind();
	              }
	            }

	            // Show the tooltip with delay if specified, otherwise show it immediately
	            function showTooltipBind() {
	              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
	                return;
	              }

	              cancelHide();
	              prepareTooltip();

	              if (ttScope.popupDelay) {
	                // Do nothing if the tooltip was already scheduled to pop-up.
	                // This happens if show is triggered multiple times before any hide is triggered.
	                if (!showTimeout) {
	                  showTimeout = $timeout(show, ttScope.popupDelay, false);
	                }
	              } else {
	                show();
	              }
	            }

	            function hideTooltipBind() {
	              cancelShow();

	              if (ttScope.popupCloseDelay) {
	                if (!hideTimeout) {
	                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
	                }
	              } else {
	                hide();
	              }
	            }

	            // Show the tooltip popup element.
	            function show() {
	              cancelShow();
	              cancelHide();

	              // Don't show empty tooltips.
	              if (!ttScope.content) {
	                return angular.noop;
	              }

	              createTooltip();

	              // And show the tooltip.
	              ttScope.$evalAsync(function() {
	                ttScope.isOpen = true;
	                assignIsOpen(true);
	                positionTooltip();
	              });
	            }

	            function cancelShow() {
	              if (showTimeout) {
	                $timeout.cancel(showTimeout);
	                showTimeout = null;
	              }

	              if (positionTimeout) {
	                $timeout.cancel(positionTimeout);
	                positionTimeout = null;
	              }
	            }

	            // Hide the tooltip popup element.
	            function hide() {
	              if (!ttScope) {
	                return;
	              }

	              // First things first: we don't show it anymore.
	              ttScope.$evalAsync(function() {
	                if (ttScope) {
	                  ttScope.isOpen = false;
	                  assignIsOpen(false);
	                  // And now we remove it from the DOM. However, if we have animation, we
	                  // need to wait for it to expire beforehand.
	                  // FIXME: this is a placeholder for a port of the transitions library.
	                  // The fade transition in TWBS is 150ms.
	                  if (ttScope.animation) {
	                    if (!transitionTimeout) {
	                      transitionTimeout = $timeout(removeTooltip, 150, false);
	                    }
	                  } else {
	                    removeTooltip();
	                  }
	                }
	              });
	            }

	            function cancelHide() {
	              if (hideTimeout) {
	                $timeout.cancel(hideTimeout);
	                hideTimeout = null;
	              }

	              if (transitionTimeout) {
	                $timeout.cancel(transitionTimeout);
	                transitionTimeout = null;
	              }
	            }

	            function createTooltip() {
	              // There can only be one tooltip element per directive shown at once.
	              if (tooltip) {
	                return;
	              }

	              tooltipLinkedScope = ttScope.$new();
	              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
	                if (appendToBody) {
	                  $document.find('body').append(tooltip);
	                } else {
	                  element.after(tooltip);
	                }
	              });

	              prepObservers();
	            }

	            function removeTooltip() {
	              cancelShow();
	              cancelHide();
	              unregisterObservers();

	              if (tooltip) {
	                tooltip.remove();
	                tooltip = null;
	              }
	              if (tooltipLinkedScope) {
	                tooltipLinkedScope.$destroy();
	                tooltipLinkedScope = null;
	              }
	            }

	            /**
	             * Set the initial scope values. Once
	             * the tooltip is created, the observers
	             * will be added to keep things in sync.
	             */
	            function prepareTooltip() {
	              ttScope.title = attrs[prefix + 'Title'];
	              if (contentParse) {
	                ttScope.content = contentParse(scope);
	              } else {
	                ttScope.content = attrs[ttType];
	              }

	              ttScope.popupClass = attrs[prefix + 'Class'];
	              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
	              var placement = $position.parsePlacement(ttScope.placement);
	              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

	              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
	              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
	              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
	              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
	            }

	            function assignIsOpen(isOpen) {
	              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
	                isOpenParse.assign(scope, isOpen);
	              }
	            }

	            ttScope.contentExp = function() {
	              return ttScope.content;
	            };

	            /**
	             * Observe the relevant attributes.
	             */
	            attrs.$observe('disabled', function(val) {
	              if (val) {
	                cancelShow();
	              }

	              if (val && ttScope.isOpen) {
	                hide();
	              }
	            });

	            if (isOpenParse) {
	              scope.$watch(isOpenParse, function(val) {
	                if (ttScope && !val === ttScope.isOpen) {
	                  toggleTooltipBind();
	                }
	              });
	            }

	            function prepObservers() {
	              observers.length = 0;

	              if (contentParse) {
	                observers.push(
	                  scope.$watch(contentParse, function(val) {
	                    ttScope.content = val;
	                    if (!val && ttScope.isOpen) {
	                      hide();
	                    }
	                  })
	                );

	                observers.push(
	                  tooltipLinkedScope.$watch(function() {
	                    if (!repositionScheduled) {
	                      repositionScheduled = true;
	                      tooltipLinkedScope.$$postDigest(function() {
	                        repositionScheduled = false;
	                        if (ttScope && ttScope.isOpen) {
	                          positionTooltip();
	                        }
	                      });
	                    }
	                  })
	                );
	              } else {
	                observers.push(
	                  attrs.$observe(ttType, function(val) {
	                    ttScope.content = val;
	                    if (!val && ttScope.isOpen) {
	                      hide();
	                    } else {
	                      positionTooltip();
	                    }
	                  })
	                );
	              }

	              observers.push(
	                attrs.$observe(prefix + 'Title', function(val) {
	                  ttScope.title = val;
	                  if (ttScope.isOpen) {
	                    positionTooltip();
	                  }
	                })
	              );

	              observers.push(
	                attrs.$observe(prefix + 'Placement', function(val) {
	                  ttScope.placement = val ? val : options.placement;
	                  var placement = $position.parsePlacement(ttScope.placement);
	                  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];
	                  if (ttScope.isOpen) {
	                    positionTooltip();
	                  }
	                })
	              );
	            }

	            function unregisterObservers() {
	              if (observers.length) {
	                angular.forEach(observers, function(observer) {
	                  observer();
	                });
	                observers.length = 0;
	              }
	            }

	            // hide tooltips/popovers for outsideClick trigger
	            function bodyHideTooltipBind(e) {
	              if (!ttScope || !ttScope.isOpen || !tooltip) {
	                return;
	              }
	              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
	              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
	                hideTooltipBind();
	              }
	            }

	            var unregisterTriggers = function() {
	              triggers.show.forEach(function(trigger) {
	                if (trigger === 'outsideClick') {
	                  element.off('click', toggleTooltipBind);
	                } else {
	                  element.off(trigger, showTooltipBind);
	                  element.off(trigger, toggleTooltipBind);
	                }
	              });
	              triggers.hide.forEach(function(trigger) {
	                if (trigger === 'outsideClick') {
	                  $document.off('click', bodyHideTooltipBind);
	                } else {
	                  element.off(trigger, hideTooltipBind);
	                }
	              });
	            };

	            function prepTriggers() {
	              var val = attrs[prefix + 'Trigger'];
	              unregisterTriggers();

	              triggers = getTriggers(val);

	              if (triggers.show !== 'none') {
	                triggers.show.forEach(function(trigger, idx) {
	                  if (trigger === 'outsideClick') {
	                    element.on('click', toggleTooltipBind);
	                    $document.on('click', bodyHideTooltipBind);
	                  } else if (trigger === triggers.hide[idx]) {
	                    element.on(trigger, toggleTooltipBind);
	                  } else if (trigger) {
	                    element.on(trigger, showTooltipBind);
	                    element.on(triggers.hide[idx], hideTooltipBind);
	                  }

	                  element.on('keypress', function(e) {
	                    if (e.which === 27) {
	                      hideTooltipBind();
	                    }
	                  });
	                });
	              }
	            }

	            prepTriggers();

	            var animation = scope.$eval(attrs[prefix + 'Animation']);
	            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

	            var appendToBodyVal;
	            var appendKey = prefix + 'AppendToBody';
	            if (appendKey in attrs && attrs[appendKey] === undefined) {
	              appendToBodyVal = true;
	            } else {
	              appendToBodyVal = scope.$eval(attrs[appendKey]);
	            }

	            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

	            // Make sure tooltip is destroyed and removed.
	            scope.$on('$destroy', function onDestroyTooltip() {
	              unregisterTriggers();
	              removeTooltip();
	              openedTooltips.remove(ttScope);
	              ttScope = null;
	            });
	          };
	        }
	      };
	    };
	  }];
	})

	// This is mostly ngInclude code but with a custom scope
	.directive('uibTooltipTemplateTransclude', [
	         '$animate', '$sce', '$compile', '$templateRequest',
	function ($animate, $sce, $compile, $templateRequest) {
	  return {
	    link: function(scope, elem, attrs) {
	      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

	      var changeCounter = 0,
	        currentScope,
	        previousElement,
	        currentElement;

	      var cleanupLastIncludeContent = function() {
	        if (previousElement) {
	          previousElement.remove();
	          previousElement = null;
	        }

	        if (currentScope) {
	          currentScope.$destroy();
	          currentScope = null;
	        }

	        if (currentElement) {
	          $animate.leave(currentElement).then(function() {
	            previousElement = null;
	          });
	          previousElement = currentElement;
	          currentElement = null;
	        }
	      };

	      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
	        var thisChangeId = ++changeCounter;

	        if (src) {
	          //set the 2nd param to true to ignore the template request error so that the inner
	          //contents and scope can be cleaned up.
	          $templateRequest(src, true).then(function(response) {
	            if (thisChangeId !== changeCounter) { return; }
	            var newScope = origScope.$new();
	            var template = response;

	            var clone = $compile(template)(newScope, function(clone) {
	              cleanupLastIncludeContent();
	              $animate.enter(clone, elem);
	            });

	            currentScope = newScope;
	            currentElement = clone;

	            currentScope.$emit('$includeContentLoaded', src);
	          }, function() {
	            if (thisChangeId === changeCounter) {
	              cleanupLastIncludeContent();
	              scope.$emit('$includeContentError', src);
	            }
	          });
	          scope.$emit('$includeContentRequested', src);
	        } else {
	          cleanupLastIncludeContent();
	        }
	      });

	      scope.$on('$destroy', cleanupLastIncludeContent);
	    }
	  };
	}])

	/**
	 * Note that it's intentional that these classes are *not* applied through $animate.
	 * They must not be animated as they're expected to be present on the tooltip on
	 * initialization.
	 */
	.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
	  return {
	    restrict: 'A',
	    link: function(scope, element, attrs) {
	      // need to set the primary position so the
	      // arrow has space during position measure.
	      // tooltip.positionTooltip()
	      if (scope.placement) {
	        // // There are no top-left etc... classes
	        // // in TWBS, so we need the primary position.
	        var position = $uibPosition.parsePlacement(scope.placement);
	        element.addClass(position[0]);
	      }

	      if (scope.popupClass) {
	        element.addClass(scope.popupClass);
	      }

	      if (scope.animation()) {
	        element.addClass(attrs.tooltipAnimationClass);
	      }
	    }
	  };
	}])

	.directive('uibTooltipPopup', function() {
	  return {
	    replace: true,
	    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'uib/template/tooltip/tooltip-popup.html'
	  };
	})

	.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
	}])

	.directive('uibTooltipTemplatePopup', function() {
	  return {
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
	  };
	})

	.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}])

	.directive('uibTooltipHtmlPopup', function() {
	  return {
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
	  };
	})

	.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}]);

	/**
	 * The following features are still outstanding: popup delay, animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, and selector delegatation.
	 */
	angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

	.directive('uibPopoverTemplatePopup', function() {
	  return {
	    replace: true,
	    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'uib/template/popover/popover-template.html'
	  };
	})

	.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
	    useContentExp: true
	  });
	}])

	.directive('uibPopoverHtmlPopup', function() {
	  return {
	    replace: true,
	    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'uib/template/popover/popover-html.html'
	  };
	})

	.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
	    useContentExp: true
	  });
	}])

	.directive('uibPopoverPopup', function() {
	  return {
	    replace: true,
	    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'uib/template/popover/popover.html'
	  };
	})

	.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibPopover', 'popover', 'click');
	}]);

	angular.module('ui.bootstrap.progressbar', [])

	.constant('uibProgressConfig', {
	  animate: true,
	  max: 100
	})

	.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
	  var self = this,
	      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

	  this.bars = [];
	  $scope.max = getMaxOrDefault();

	  this.addBar = function(bar, element, attrs) {
	    if (!animate) {
	      element.css({'transition': 'none'});
	    }

	    this.bars.push(bar);

	    bar.max = getMaxOrDefault();
	    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

	    bar.$watch('value', function(value) {
	      bar.recalculatePercentage();
	    });

	    bar.recalculatePercentage = function() {
	      var totalPercentage = self.bars.reduce(function(total, bar) {
	        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
	        return total + bar.percent;
	      }, 0);

	      if (totalPercentage > 100) {
	        bar.percent -= totalPercentage - 100;
	      }
	    };

	    bar.$on('$destroy', function() {
	      element = null;
	      self.removeBar(bar);
	    });
	  };

	  this.removeBar = function(bar) {
	    this.bars.splice(this.bars.indexOf(bar), 1);
	    this.bars.forEach(function (bar) {
	      bar.recalculatePercentage();
	    });
	  };

	  //$attrs.$observe('maxParam', function(maxParam) {
	  $scope.$watch('maxParam', function(maxParam) {
	    self.bars.forEach(function(bar) {
	      bar.max = getMaxOrDefault();
	      bar.recalculatePercentage();
	    });
	  });

	  function getMaxOrDefault () {
	    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
	  }
	}])

	.directive('uibProgress', function() {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'UibProgressController',
	    require: 'uibProgress',
	    scope: {
	      maxParam: '=?max'
	    },
	    templateUrl: 'uib/template/progressbar/progress.html'
	  };
	})

	.directive('uibBar', function() {
	  return {
	    replace: true,
	    transclude: true,
	    require: '^uibProgress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'uib/template/progressbar/bar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, element, attrs);
	    }
	  };
	})

	.directive('uibProgressbar', function() {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'UibProgressController',
	    scope: {
	      value: '=',
	      maxParam: '=?max',
	      type: '@'
	    },
	    templateUrl: 'uib/template/progressbar/progressbar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
	    }
	  };
	});

	angular.module('ui.bootstrap.rating', [])

	.constant('uibRatingConfig', {
	  max: 5,
	  stateOn: null,
	  stateOff: null,
	  enableReset: true,
	  titles : ['one', 'two', 'three', 'four', 'five']
	})

	.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
	  var ngModelCtrl = { $setViewValue: angular.noop },
	    self = this;

	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;

	    ngModelCtrl.$formatters.push(function(value) {
	      if (angular.isNumber(value) && value << 0 !== value) {
	        value = Math.round(value);
	      }

	      return value;
	    });

	    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
	    this.enableReset = angular.isDefined($attrs.enableReset) ?
	      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
	    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
	    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
	      tmpTitles : ratingConfig.titles;

	    var ratingStates = angular.isDefined($attrs.ratingStates) ?
	      $scope.$parent.$eval($attrs.ratingStates) :
	      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
	    $scope.range = this.buildTemplateObjects(ratingStates);
	  };

	  this.buildTemplateObjects = function(states) {
	    for (var i = 0, n = states.length; i < n; i++) {
	      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
	    }
	    return states;
	  };

	  this.getTitle = function(index) {
	    if (index >= this.titles.length) {
	      return index + 1;
	    }

	    return this.titles[index];
	  };

	  $scope.rate = function(value) {
	    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
	      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
	      ngModelCtrl.$setViewValue(newViewValue);
	      ngModelCtrl.$render();
	    }
	  };

	  $scope.enter = function(value) {
	    if (!$scope.readonly) {
	      $scope.value = value;
	    }
	    $scope.onHover({value: value});
	  };

	  $scope.reset = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.onLeave();
	  };

	  $scope.onKeydown = function(evt) {
	    if (/(37|38|39|40)/.test(evt.which)) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
	    }
	  };

	  this.render = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.title = self.getTitle($scope.value - 1);
	  };
	}])

	.directive('uibRating', function() {
	  return {
	    require: ['uibRating', 'ngModel'],
	    scope: {
	      readonly: '=?readOnly',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'UibRatingController',
	    templateUrl: 'uib/template/rating/rating.html',
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	      ratingCtrl.init(ngModelCtrl);
	    }
	  };
	});

	angular.module('ui.bootstrap.tabs', [])

	.controller('UibTabsetController', ['$scope', function ($scope) {
	  var ctrl = this,
	    oldIndex;
	  ctrl.tabs = [];

	  ctrl.select = function(index, evt) {
	    if (!destroyed) {
	      var previousIndex = findTabIndex(oldIndex);
	      var previousSelected = ctrl.tabs[previousIndex];
	      if (previousSelected) {
	        previousSelected.tab.onDeselect({
	          $event: evt
	        });
	        previousSelected.tab.active = false;
	      }

	      var selected = ctrl.tabs[index];
	      if (selected) {
	        selected.tab.onSelect({
	          $event: evt
	        });
	        selected.tab.active = true;
	        ctrl.active = selected.index;
	        oldIndex = selected.index;
	      } else if (!selected && angular.isNumber(oldIndex)) {
	        ctrl.active = null;
	        oldIndex = null;
	      }
	    }
	  };

	  ctrl.addTab = function addTab(tab) {
	    ctrl.tabs.push({
	      tab: tab,
	      index: tab.index
	    });
	    ctrl.tabs.sort(function(t1, t2) {
	      if (t1.index > t2.index) {
	        return 1;
	      }

	      if (t1.index < t2.index) {
	        return -1;
	      }

	      return 0;
	    });

	    if (tab.index === ctrl.active || !angular.isNumber(ctrl.active) && ctrl.tabs.length === 1) {
	      var newActiveIndex = findTabIndex(tab.index);
	      ctrl.select(newActiveIndex);
	    }
	  };

	  ctrl.removeTab = function removeTab(tab) {
	    var index = findTabIndex(tab.index);

	    if (tab.index === ctrl.active) {
	      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
	        index - 1 : index + 1 % ctrl.tabs.length;
	      ctrl.select(newActiveTabIndex);
	    }

	    ctrl.tabs.splice(index, 1);
	  };

	  $scope.$watch('tabset.active', function(val) {
	    if (angular.isNumber(val) && val !== oldIndex) {
	      ctrl.select(findTabIndex(val));
	    }
	  });

	  var destroyed;
	  $scope.$on('$destroy', function() {
	    destroyed = true;
	  });

	  function findTabIndex(index) {
	    for (var i = 0; i < ctrl.tabs.length; i++) {
	      if (ctrl.tabs[i].index === index) {
	        return i;
	      }
	    }
	  }
	}])

	.directive('uibTabset', function() {
	  return {
	    transclude: true,
	    replace: true,
	    scope: {},
	    bindToController: {
	      active: '=?',
	      type: '@'
	    },
	    controller: 'UibTabsetController',
	    controllerAs: 'tabset',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/tabs/tabset.html';
	    },
	    link: function(scope, element, attrs) {
	      scope.vertical = angular.isDefined(attrs.vertical) ?
	        scope.$parent.$eval(attrs.vertical) : false;
	      scope.justified = angular.isDefined(attrs.justified) ?
	        scope.$parent.$eval(attrs.justified) : false;
	      if (angular.isUndefined(attrs.active)) {
	        scope.active = 0;
	      }
	    }
	  };
	})

	.directive('uibTab', ['$parse', function($parse) {
	  return {
	    require: '^uibTabset',
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'uib/template/tabs/tab.html';
	    },
	    transclude: true,
	    scope: {
	      heading: '@',
	      index: '=?',
	      classes: '@?',
	      onSelect: '&select', //This callback is called in contentHeadingTransclude
	                          //once it inserts the tab's content into the dom
	      onDeselect: '&deselect'
	    },
	    controller: function() {
	      //Empty controller so other directives can require being 'under' a tab
	    },
	    controllerAs: 'tab',
	    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
	      scope.disabled = false;
	      if (attrs.disable) {
	        scope.$parent.$watch($parse(attrs.disable), function(value) {
	          scope.disabled = !! value;
	        });
	      }

	      if (angular.isUndefined(attrs.index)) {
	        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
	          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;
	        } else {
	          scope.index = 0;
	        }
	      }

	      if (angular.isUndefined(attrs.classes)) {
	        scope.classes = '';
	      }

	      scope.select = function(evt) {
	        if (!scope.disabled) {
	          var index;
	          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
	            if (tabsetCtrl.tabs[i].tab === scope) {
	              index = i;
	              break;
	            }
	          }

	          tabsetCtrl.select(index, evt);
	        }
	      };

	      tabsetCtrl.addTab(scope);
	      scope.$on('$destroy', function() {
	        tabsetCtrl.removeTab(scope);
	      });

	      //We need to transclude later, once the content container is ready.
	      //when this link happens, we're inside a tab heading.
	      scope.$transcludeFn = transclude;
	    }
	  };
	}])

	.directive('uibTabHeadingTransclude', function() {
	  return {
	    restrict: 'A',
	    require: '^uibTab',
	    link: function(scope, elm) {
	      scope.$watch('headingElement', function updateHeadingElement(heading) {
	        if (heading) {
	          elm.html('');
	          elm.append(heading);
	        }
	      });
	    }
	  };
	})

	.directive('uibTabContentTransclude', function() {
	  return {
	    restrict: 'A',
	    require: '^uibTabset',
	    link: function(scope, elm, attrs) {
	      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

	      //Now our tab is ready to be transcluded: both the tab heading area
	      //and the tab content area are loaded.  Transclude 'em both.
	      tab.$transcludeFn(tab.$parent, function(contents) {
	        angular.forEach(contents, function(node) {
	          if (isTabHeading(node)) {
	            //Let tabHeadingTransclude know.
	            tab.headingElement = node;
	          } else {
	            elm.append(node);
	          }
	        });
	      });
	    }
	  };

	  function isTabHeading(node) {
	    return node.tagName && (
	      node.hasAttribute('uib-tab-heading') ||
	      node.hasAttribute('data-uib-tab-heading') ||
	      node.hasAttribute('x-uib-tab-heading') ||
	      node.tagName.toLowerCase() === 'uib-tab-heading' ||
	      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
	      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
	      node.tagName.toLowerCase() === 'uib:tab-heading'
	    );
	  }
	});

	angular.module('ui.bootstrap.timepicker', [])

	.constant('uibTimepickerConfig', {
	  hourStep: 1,
	  minuteStep: 1,
	  secondStep: 1,
	  showMeridian: true,
	  showSeconds: false,
	  meridians: null,
	  readonlyInput: false,
	  mousewheel: true,
	  arrowkeys: true,
	  showSpinners: true,
	  templateUrl: 'uib/template/timepicker/timepicker.html'
	})

	.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
	  var selected = new Date(),
	    watchers = [],
	    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
	    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

	  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
	  $element.removeAttr('tabindex');

	  this.init = function(ngModelCtrl_, inputs) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;

	    ngModelCtrl.$formatters.unshift(function(modelValue) {
	      return modelValue ? new Date(modelValue) : null;
	    });

	    var hoursInputEl = inputs.eq(0),
	        minutesInputEl = inputs.eq(1),
	        secondsInputEl = inputs.eq(2);

	    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

	    if (mousewheel) {
	      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	    }

	    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
	    if (arrowkeys) {
	      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	    }

	    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
	    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	  };

	  var hourStep = timepickerConfig.hourStep;
	  if ($attrs.hourStep) {
	    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
	      hourStep = +value;
	    }));
	  }

	  var minuteStep = timepickerConfig.minuteStep;
	  if ($attrs.minuteStep) {
	    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
	      minuteStep = +value;
	    }));
	  }

	  var min;
	  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
	    var dt = new Date(value);
	    min = isNaN(dt) ? undefined : dt;
	  }));

	  var max;
	  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
	    var dt = new Date(value);
	    max = isNaN(dt) ? undefined : dt;
	  }));

	  var disabled = false;
	  if ($attrs.ngDisabled) {
	    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
	      disabled = value;
	    }));
	  }

	  $scope.noIncrementHours = function() {
	    var incrementedSelected = addMinutes(selected, hourStep * 60);
	    return disabled || incrementedSelected > max ||
	      incrementedSelected < selected && incrementedSelected < min;
	  };

	  $scope.noDecrementHours = function() {
	    var decrementedSelected = addMinutes(selected, -hourStep * 60);
	    return disabled || decrementedSelected < min ||
	      decrementedSelected > selected && decrementedSelected > max;
	  };

	  $scope.noIncrementMinutes = function() {
	    var incrementedSelected = addMinutes(selected, minuteStep);
	    return disabled || incrementedSelected > max ||
	      incrementedSelected < selected && incrementedSelected < min;
	  };

	  $scope.noDecrementMinutes = function() {
	    var decrementedSelected = addMinutes(selected, -minuteStep);
	    return disabled || decrementedSelected < min ||
	      decrementedSelected > selected && decrementedSelected > max;
	  };

	  $scope.noIncrementSeconds = function() {
	    var incrementedSelected = addSeconds(selected, secondStep);
	    return disabled || incrementedSelected > max ||
	      incrementedSelected < selected && incrementedSelected < min;
	  };

	  $scope.noDecrementSeconds = function() {
	    var decrementedSelected = addSeconds(selected, -secondStep);
	    return disabled || decrementedSelected < min ||
	      decrementedSelected > selected && decrementedSelected > max;
	  };

	  $scope.noToggleMeridian = function() {
	    if (selected.getHours() < 12) {
	      return disabled || addMinutes(selected, 12 * 60) > max;
	    }

	    return disabled || addMinutes(selected, -12 * 60) < min;
	  };

	  var secondStep = timepickerConfig.secondStep;
	  if ($attrs.secondStep) {
	    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
	      secondStep = +value;
	    }));
	  }

	  $scope.showSeconds = timepickerConfig.showSeconds;
	  if ($attrs.showSeconds) {
	    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
	      $scope.showSeconds = !!value;
	    }));
	  }

	  // 12H / 24H mode
	  $scope.showMeridian = timepickerConfig.showMeridian;
	  if ($attrs.showMeridian) {
	    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
	      $scope.showMeridian = !!value;

	      if (ngModelCtrl.$error.time) {
	        // Evaluate from template
	        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
	        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	          selected.setHours(hours);
	          refresh();
	        }
	      } else {
	        updateTemplate();
	      }
	    }));
	  }

	  // Get $scope.hours in 24H mode if valid
	  function getHoursFromTemplate() {
	    var hours = +$scope.hours;
	    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
	      hours >= 0 && hours < 24;
	    if (!valid) {
	      return undefined;
	    }

	    if ($scope.showMeridian) {
	      if (hours === 12) {
	        hours = 0;
	      }
	      if ($scope.meridian === meridians[1]) {
	        hours = hours + 12;
	      }
	    }
	    return hours;
	  }

	  function getMinutesFromTemplate() {
	    var minutes = +$scope.minutes;
	    return minutes >= 0 && minutes < 60 ? minutes : undefined;
	  }

	  function getSecondsFromTemplate() {
	    var seconds = +$scope.seconds;
	    return seconds >= 0 && seconds < 60 ? seconds : undefined;
	  }

	  function pad(value, noPad) {
	    if (value === null) {
	      return '';
	    }

	    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
	      '0' + value : value.toString();
	  }

	  // Respond on mousewheel spin
	  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
	    var isScrollingUp = function(e) {
	      if (e.originalEvent) {
	        e = e.originalEvent;
	      }
	      //pick correct delta variable depending on event
	      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
	      return e.detail || delta > 0;
	    };

	    hoursInputEl.bind('mousewheel wheel', function(e) {
	      if (!disabled) {
	        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
	      }
	      e.preventDefault();
	    });

	    minutesInputEl.bind('mousewheel wheel', function(e) {
	      if (!disabled) {
	        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
	      }
	      e.preventDefault();
	    });

	     secondsInputEl.bind('mousewheel wheel', function(e) {
	      if (!disabled) {
	        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
	      }
	      e.preventDefault();
	    });
	  };

	  // Respond on up/down arrowkeys
	  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
	    hoursInputEl.bind('keydown', function(e) {
	      if (!disabled) {
	        if (e.which === 38) { // up
	          e.preventDefault();
	          $scope.incrementHours();
	          $scope.$apply();
	        } else if (e.which === 40) { // down
	          e.preventDefault();
	          $scope.decrementHours();
	          $scope.$apply();
	        }
	      }
	    });

	    minutesInputEl.bind('keydown', function(e) {
	      if (!disabled) {
	        if (e.which === 38) { // up
	          e.preventDefault();
	          $scope.incrementMinutes();
	          $scope.$apply();
	        } else if (e.which === 40) { // down
	          e.preventDefault();
	          $scope.decrementMinutes();
	          $scope.$apply();
	        }
	      }
	    });

	    secondsInputEl.bind('keydown', function(e) {
	      if (!disabled) {
	        if (e.which === 38) { // up
	          e.preventDefault();
	          $scope.incrementSeconds();
	          $scope.$apply();
	        } else if (e.which === 40) { // down
	          e.preventDefault();
	          $scope.decrementSeconds();
	          $scope.$apply();
	        }
	      }
	    });
	  };

	  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
	    if ($scope.readonlyInput) {
	      $scope.updateHours = angular.noop;
	      $scope.updateMinutes = angular.noop;
	      $scope.updateSeconds = angular.noop;
	      return;
	    }

	    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
	      ngModelCtrl.$setViewValue(null);
	      ngModelCtrl.$setValidity('time', false);
	      if (angular.isDefined(invalidHours)) {
	        $scope.invalidHours = invalidHours;
	      }

	      if (angular.isDefined(invalidMinutes)) {
	        $scope.invalidMinutes = invalidMinutes;
	      }

	      if (angular.isDefined(invalidSeconds)) {
	        $scope.invalidSeconds = invalidSeconds;
	      }
	    };

	    $scope.updateHours = function() {
	      var hours = getHoursFromTemplate(),
	        minutes = getMinutesFromTemplate();

	      ngModelCtrl.$setDirty();

	      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	        selected.setHours(hours);
	        selected.setMinutes(minutes);
	        if (selected < min || selected > max) {
	          invalidate(true);
	        } else {
	          refresh('h');
	        }
	      } else {
	        invalidate(true);
	      }
	    };

	    hoursInputEl.bind('blur', function(e) {
	      ngModelCtrl.$setTouched();
	      if ($scope.hours === null || $scope.hours === '') {
	        invalidate(true);
	      } else if (!$scope.invalidHours && $scope.hours < 10) {
	        $scope.$apply(function() {
	          $scope.hours = pad($scope.hours, !padHours);
	        });
	      }
	    });

	    $scope.updateMinutes = function() {
	      var minutes = getMinutesFromTemplate(),
	        hours = getHoursFromTemplate();

	      ngModelCtrl.$setDirty();

	      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
	        selected.setHours(hours);
	        selected.setMinutes(minutes);
	        if (selected < min || selected > max) {
	          invalidate(undefined, true);
	        } else {
	          refresh('m');
	        }
	      } else {
	        invalidate(undefined, true);
	      }
	    };

	    minutesInputEl.bind('blur', function(e) {
	      ngModelCtrl.$setTouched();
	      if ($scope.minutes === null) {
	        invalidate(undefined, true);
	      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
	        $scope.$apply(function() {
	          $scope.minutes = pad($scope.minutes);
	        });
	      }
	    });

	    $scope.updateSeconds = function() {
	      var seconds = getSecondsFromTemplate();

	      ngModelCtrl.$setDirty();

	      if (angular.isDefined(seconds)) {
	        selected.setSeconds(seconds);
	        refresh('s');
	      } else {
	        invalidate(undefined, undefined, true);
	      }
	    };

	    secondsInputEl.bind('blur', function(e) {
	      if (!$scope.invalidSeconds && $scope.seconds < 10) {
	        $scope.$apply( function() {
	          $scope.seconds = pad($scope.seconds);
	        });
	      }
	    });

	  };

	  this.render = function() {
	    var date = ngModelCtrl.$viewValue;

	    if (isNaN(date)) {
	      ngModelCtrl.$setValidity('time', false);
	      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	    } else {
	      if (date) {
	        selected = date;
	      }

	      if (selected < min || selected > max) {
	        ngModelCtrl.$setValidity('time', false);
	        $scope.invalidHours = true;
	        $scope.invalidMinutes = true;
	      } else {
	        makeValid();
	      }
	      updateTemplate();
	    }
	  };

	  // Call internally when we know that model is valid.
	  function refresh(keyboardChange) {
	    makeValid();
	    ngModelCtrl.$setViewValue(new Date(selected));
	    updateTemplate(keyboardChange);
	  }

	  function makeValid() {
	    ngModelCtrl.$setValidity('time', true);
	    $scope.invalidHours = false;
	    $scope.invalidMinutes = false;
	    $scope.invalidSeconds = false;
	  }

	  function updateTemplate(keyboardChange) {
	    if (!ngModelCtrl.$modelValue) {
	      $scope.hours = null;
	      $scope.minutes = null;
	      $scope.seconds = null;
	      $scope.meridian = meridians[0];
	    } else {
	      var hours = selected.getHours(),
	        minutes = selected.getMinutes(),
	        seconds = selected.getSeconds();

	      if ($scope.showMeridian) {
	        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
	      }

	      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
	      if (keyboardChange !== 'm') {
	        $scope.minutes = pad(minutes);
	      }
	      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

	      if (keyboardChange !== 's') {
	        $scope.seconds = pad(seconds);
	      }
	      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	    }
	  }

	  function addSecondsToSelected(seconds) {
	    selected = addSeconds(selected, seconds);
	    refresh();
	  }

	  function addMinutes(selected, minutes) {
	    return addSeconds(selected, minutes*60);
	  }

	  function addSeconds(date, seconds) {
	    var dt = new Date(date.getTime() + seconds * 1000);
	    var newDate = new Date(date);
	    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
	    return newDate;
	  }

	  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
	    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

	  $scope.incrementHours = function() {
	    if (!$scope.noIncrementHours()) {
	      addSecondsToSelected(hourStep * 60 * 60);
	    }
	  };

	  $scope.decrementHours = function() {
	    if (!$scope.noDecrementHours()) {
	      addSecondsToSelected(-hourStep * 60 * 60);
	    }
	  };

	  $scope.incrementMinutes = function() {
	    if (!$scope.noIncrementMinutes()) {
	      addSecondsToSelected(minuteStep * 60);
	    }
	  };

	  $scope.decrementMinutes = function() {
	    if (!$scope.noDecrementMinutes()) {
	      addSecondsToSelected(-minuteStep * 60);
	    }
	  };

	  $scope.incrementSeconds = function() {
	    if (!$scope.noIncrementSeconds()) {
	      addSecondsToSelected(secondStep);
	    }
	  };

	  $scope.decrementSeconds = function() {
	    if (!$scope.noDecrementSeconds()) {
	      addSecondsToSelected(-secondStep);
	    }
	  };

	  $scope.toggleMeridian = function() {
	    var minutes = getMinutesFromTemplate(),
	        hours = getHoursFromTemplate();

	    if (!$scope.noToggleMeridian()) {
	      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
	        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
	      } else {
	        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
	      }
	    }
	  };

	  $scope.blur = function() {
	    ngModelCtrl.$setTouched();
	  };

	  $scope.$on('$destroy', function() {
	    while (watchers.length) {
	      watchers.shift()();
	    }
	  });
	}])

	.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
	  return {
	    require: ['uibTimepicker', '?^ngModel'],
	    controller: 'UibTimepickerController',
	    controllerAs: 'timepicker',
	    replace: true,
	    scope: {},
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || uibTimepickerConfig.templateUrl;
	    },
	    link: function(scope, element, attrs, ctrls) {
	      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	      if (ngModelCtrl) {
	        timepickerCtrl.init(ngModelCtrl, element.find('input'));
	      }
	    }
	  };
	}]);

	angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

	/**
	 * A helper service that can parse typeahead's syntax (string provided by users)
	 * Extracted to a separate service for ease of unit testing
	 */
	  .factory('uibTypeaheadParser', ['$parse', function($parse) {
	    //                      00000111000000000000022200000000000000003333333333333330000000000044000
	    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
	    return {
	      parse: function(input) {
	        var match = input.match(TYPEAHEAD_REGEXP);
	        if (!match) {
	          throw new Error(
	            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
	              ' but got "' + input + '".');
	        }

	        return {
	          itemName: match[3],
	          source: $parse(match[4]),
	          viewMapper: $parse(match[2] || match[1]),
	          modelMapper: $parse(match[1])
	        };
	      }
	    };
	  }])

	  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
	    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
	    var HOT_KEYS = [9, 13, 27, 38, 40];
	    var eventDebounceTime = 200;
	    var modelCtrl, ngModelOptions;
	    //SUPPORTED ATTRIBUTES (OPTIONS)

	    //minimal no of characters that needs to be entered before typeahead kicks-in
	    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
	    if (!minLength && minLength !== 0) {
	      minLength = 1;
	    }

	    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
	        minLength = !newVal && newVal !== 0 ? 1 : newVal;
	    });
	    
	    //minimal wait time after last character typed before typeahead kicks-in
	    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

	    //should it restrict model values to the ones selected from the popup only?
	    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
	      isEditable = newVal !== false;
	    });

	    //binding to a variable that indicates if matches are being retrieved asynchronously
	    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

	    //a callback executed when a match is selected
	    var onSelectCallback = $parse(attrs.typeaheadOnSelect);

	    //should it select highlighted popup value when losing focus?
	    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

	    //binding to a variable that indicates if there were no results after the query is completed
	    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

	    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

	    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

	    var appendTo = attrs.typeaheadAppendTo ?
	      originalScope.$eval(attrs.typeaheadAppendTo) : null;

	    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

	    //If input matches an item of the list exactly, select it automatically
	    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

	    //binding to a variable that indicates if dropdown is open
	    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

	    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

	    //INTERNAL VARIABLES

	    //model setter executed upon match selection
	    var parsedModel = $parse(attrs.ngModel);
	    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
	    var $setModelValue = function(scope, newValue) {
	      if (angular.isFunction(parsedModel(originalScope)) &&
	        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
	        return invokeModelSetter(scope, {$$$p: newValue});
	      }

	      return parsedModel.assign(scope, newValue);
	    };

	    //expressions used by typeahead
	    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

	    var hasFocus;

	    //Used to avoid bug in iOS webview where iOS keyboard does not fire
	    //mousedown & mouseup events
	    //Issue #3699
	    var selected;

	    //create a child scope for the typeahead directive so we are not polluting original scope
	    //with typeahead-specific data (matches, query etc.)
	    var scope = originalScope.$new();
	    var offDestroy = originalScope.$on('$destroy', function() {
	      scope.$destroy();
	    });
	    scope.$on('$destroy', offDestroy);

	    // WAI-ARIA
	    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	    element.attr({
	      'aria-autocomplete': 'list',
	      'aria-expanded': false,
	      'aria-owns': popupId
	    });

	    var inputsContainer, hintInputElem;
	    //add read-only input to show hint
	    if (showHint) {
	      inputsContainer = angular.element('<div></div>');
	      inputsContainer.css('position', 'relative');
	      element.after(inputsContainer);
	      hintInputElem = element.clone();
	      hintInputElem.attr('placeholder', '');
	      hintInputElem.attr('tabindex', '-1');
	      hintInputElem.val('');
	      hintInputElem.css({
	        'position': 'absolute',
	        'top': '0px',
	        'left': '0px',
	        'border-color': 'transparent',
	        'box-shadow': 'none',
	        'opacity': 1,
	        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
	        'color': '#999'
	      });
	      element.css({
	        'position': 'relative',
	        'vertical-align': 'top',
	        'background-color': 'transparent'
	      });
	      inputsContainer.append(hintInputElem);
	      hintInputElem.after(element);
	    }

	    //pop-up element used to display matches
	    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
	    popUpEl.attr({
	      id: popupId,
	      matches: 'matches',
	      active: 'activeIdx',
	      select: 'select(activeIdx, evt)',
	      'move-in-progress': 'moveInProgress',
	      query: 'query',
	      position: 'position',
	      'assign-is-open': 'assignIsOpen(isOpen)',
	      debounce: 'debounceUpdate'
	    });
	    //custom item template
	    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	    }

	    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
	      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
	    }

	    var resetHint = function() {
	      if (showHint) {
	        hintInputElem.val('');
	      }
	    };

	    var resetMatches = function() {
	      scope.matches = [];
	      scope.activeIdx = -1;
	      element.attr('aria-expanded', false);
	      resetHint();
	    };

	    var getMatchId = function(index) {
	      return popupId + '-option-' + index;
	    };

	    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	    // This attribute is added or removed automatically when the `activeIdx` changes.
	    scope.$watch('activeIdx', function(index) {
	      if (index < 0) {
	        element.removeAttr('aria-activedescendant');
	      } else {
	        element.attr('aria-activedescendant', getMatchId(index));
	      }
	    });

	    var inputIsExactMatch = function(inputValue, index) {
	      if (scope.matches.length > index && inputValue) {
	        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
	      }

	      return false;
	    };

	    var getMatchesAsync = function(inputValue, evt) {
	      var locals = {$viewValue: inputValue};
	      isLoadingSetter(originalScope, true);
	      isNoResultsSetter(originalScope, false);
	      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
	        //it might happen that several async queries were in progress if a user were typing fast
	        //but we are interested only in responses that correspond to the current view value
	        var onCurrentRequest = inputValue === modelCtrl.$viewValue;
	        if (onCurrentRequest && hasFocus) {
	          if (matches && matches.length > 0) {
	            scope.activeIdx = focusFirst ? 0 : -1;
	            isNoResultsSetter(originalScope, false);
	            scope.matches.length = 0;

	            //transform labels
	            for (var i = 0; i < matches.length; i++) {
	              locals[parserResult.itemName] = matches[i];
	              scope.matches.push({
	                id: getMatchId(i),
	                label: parserResult.viewMapper(scope, locals),
	                model: matches[i]
	              });
	            }

	            scope.query = inputValue;
	            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	            //due to other elements being rendered
	            recalculatePosition();

	            element.attr('aria-expanded', true);

	            //Select the single remaining option if user input matches
	            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
	              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
	                $$debounce(function() {
	                  scope.select(0, evt);
	                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
	              } else {
	                scope.select(0, evt);
	              }
	            }

	            if (showHint) {
	              var firstLabel = scope.matches[0].label;
	              if (angular.isString(inputValue) &&
	                inputValue.length > 0 &&
	                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
	                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
	              } else {
	                hintInputElem.val('');
	              }
	            }
	          } else {
	            resetMatches();
	            isNoResultsSetter(originalScope, true);
	          }
	        }
	        if (onCurrentRequest) {
	          isLoadingSetter(originalScope, false);
	        }
	      }, function() {
	        resetMatches();
	        isLoadingSetter(originalScope, false);
	        isNoResultsSetter(originalScope, true);
	      });
	    };

	    // bind events only if appendToBody params exist - performance feature
	    if (appendToBody) {
	      angular.element($window).on('resize', fireRecalculating);
	      $document.find('body').on('scroll', fireRecalculating);
	    }

	    // Declare the debounced function outside recalculating for
	    // proper debouncing
	    var debouncedRecalculate = $$debounce(function() {
	      // if popup is visible
	      if (scope.matches.length) {
	        recalculatePosition();
	      }

	      scope.moveInProgress = false;
	    }, eventDebounceTime);

	    // Default progress type
	    scope.moveInProgress = false;

	    function fireRecalculating() {
	      if (!scope.moveInProgress) {
	        scope.moveInProgress = true;
	        scope.$digest();
	      }

	      debouncedRecalculate();
	    }

	    // recalculate actual position and set new values to scope
	    // after digest loop is popup in right position
	    function recalculatePosition() {
	      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	      scope.position.top += element.prop('offsetHeight');
	    }

	    //we need to propagate user's query so we can higlight matches
	    scope.query = undefined;

	    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	    var timeoutPromise;

	    var scheduleSearchWithTimeout = function(inputValue) {
	      timeoutPromise = $timeout(function() {
	        getMatchesAsync(inputValue);
	      }, waitTime);
	    };

	    var cancelPreviousTimeout = function() {
	      if (timeoutPromise) {
	        $timeout.cancel(timeoutPromise);
	      }
	    };

	    resetMatches();

	    scope.assignIsOpen = function (isOpen) {
	      isOpenSetter(originalScope, isOpen);
	    };

	    scope.select = function(activeIdx, evt) {
	      //called from within the $digest() cycle
	      var locals = {};
	      var model, item;

	      selected = true;
	      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	      model = parserResult.modelMapper(originalScope, locals);
	      $setModelValue(originalScope, model);
	      modelCtrl.$setValidity('editable', true);
	      modelCtrl.$setValidity('parse', true);

	      onSelectCallback(originalScope, {
	        $item: item,
	        $model: model,
	        $label: parserResult.viewMapper(originalScope, locals),
	        $event: evt
	      });

	      resetMatches();

	      //return focus to the input element if a match was selected via a mouse click event
	      // use timeout to avoid $rootScope:inprog error
	      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
	        $timeout(function() { element[0].focus(); }, 0, false);
	      }
	    };

	    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	    element.on('keydown', function(evt) {
	      //typeahead is open and an "interesting" key was pressed
	      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	        return;
	      }

	      /**
	       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
	       * or
	       * shift + tab is pressed to bring focus to the previous element
	       * then clear the results
	       */
	      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13) || evt.which === 9 && !!evt.shiftKey) {
	        resetMatches();
	        scope.$digest();
	        return;
	      }

	      evt.preventDefault();
	      var target;
	      switch (evt.which) {
	        case 9:
	        case 13:
	          scope.$apply(function () {
	            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
	              $$debounce(function() {
	                scope.select(scope.activeIdx, evt);
	              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
	            } else {
	              scope.select(scope.activeIdx, evt);
	            }
	          });
	          break;
	        case 27:
	          evt.stopPropagation();

	          resetMatches();
	          originalScope.$digest();
	          break;
	        case 38:
	          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
	          scope.$digest();
	          target = popUpEl.find('li')[scope.activeIdx];
	          target.parentNode.scrollTop = target.offsetTop;
	          break;
	        case 40:
	          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	          scope.$digest();
	          target = popUpEl.find('li')[scope.activeIdx];
	          target.parentNode.scrollTop = target.offsetTop;
	          break;
	      }
	    });

	    element.bind('focus', function (evt) {
	      hasFocus = true;
	      if (minLength === 0 && !modelCtrl.$viewValue) {
	        $timeout(function() {
	          getMatchesAsync(modelCtrl.$viewValue, evt);
	        }, 0);
	      }
	    });

	    element.bind('blur', function(evt) {
	      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
	        selected = true;
	        scope.$apply(function() {
	          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
	            $$debounce(function() {
	              scope.select(scope.activeIdx, evt);
	            }, scope.debounceUpdate.blur);
	          } else {
	            scope.select(scope.activeIdx, evt);
	          }
	        });
	      }
	      if (!isEditable && modelCtrl.$error.editable) {
	        modelCtrl.$viewValue = '';
	        // Reset validity as we are clearing
	        modelCtrl.$setValidity('editable', true);
	        modelCtrl.$setValidity('parse', true);
	        element.val('');
	      }
	      hasFocus = false;
	      selected = false;
	    });

	    // Keep reference to click handler to unbind it.
	    var dismissClickHandler = function(evt) {
	      // Issue #3973
	      // Firefox treats right click as a click on document
	      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
	        resetMatches();
	        if (!$rootScope.$$phase) {
	          originalScope.$digest();
	        }
	      }
	    };

	    $document.on('click', dismissClickHandler);

	    originalScope.$on('$destroy', function() {
	      $document.off('click', dismissClickHandler);
	      if (appendToBody || appendTo) {
	        $popup.remove();
	      }

	      if (appendToBody) {
	        angular.element($window).off('resize', fireRecalculating);
	        $document.find('body').off('scroll', fireRecalculating);
	      }
	      // Prevent jQuery cache memory leak
	      popUpEl.remove();

	      if (showHint) {
	          inputsContainer.remove();
	      }
	    });

	    var $popup = $compile(popUpEl)(scope);

	    if (appendToBody) {
	      $document.find('body').append($popup);
	    } else if (appendTo) {
	      angular.element(appendTo).eq(0).append($popup);
	    } else {
	      element.after($popup);
	    }

	    this.init = function(_modelCtrl, _ngModelOptions) {
	      modelCtrl = _modelCtrl;
	      ngModelOptions = _ngModelOptions;

	      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);

	      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	      modelCtrl.$parsers.unshift(function(inputValue) {
	        hasFocus = true;

	        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
	          if (waitTime > 0) {
	            cancelPreviousTimeout();
	            scheduleSearchWithTimeout(inputValue);
	          } else {
	            getMatchesAsync(inputValue);
	          }
	        } else {
	          isLoadingSetter(originalScope, false);
	          cancelPreviousTimeout();
	          resetMatches();
	        }

	        if (isEditable) {
	          return inputValue;
	        }

	        if (!inputValue) {
	          // Reset in case user had typed something previously.
	          modelCtrl.$setValidity('editable', true);
	          return null;
	        }

	        modelCtrl.$setValidity('editable', false);
	        return undefined;
	      });

	      modelCtrl.$formatters.push(function(modelValue) {
	        var candidateViewValue, emptyViewValue;
	        var locals = {};

	        // The validity may be set to false via $parsers (see above) if
	        // the model is restricted to selected values. If the model
	        // is set manually it is considered to be valid.
	        if (!isEditable) {
	          modelCtrl.$setValidity('editable', true);
	        }

	        if (inputFormatter) {
	          locals.$model = modelValue;
	          return inputFormatter(originalScope, locals);
	        }

	        //it might happen that we don't have enough info to properly render input value
	        //we need to check for this situation and simply return model value if we can't apply custom formatting
	        locals[parserResult.itemName] = modelValue;
	        candidateViewValue = parserResult.viewMapper(originalScope, locals);
	        locals[parserResult.itemName] = undefined;
	        emptyViewValue = parserResult.viewMapper(originalScope, locals);

	        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
	      });
	    };
	  }])

	  .directive('uibTypeahead', function() {
	    return {
	      controller: 'UibTypeaheadController',
	      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
	      link: function(originalScope, element, attrs, ctrls) {
	        ctrls[2].init(ctrls[0], ctrls[1]);
	      }
	    };
	  })

	  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
	    return {
	      scope: {
	        matches: '=',
	        query: '=',
	        active: '=',
	        position: '&',
	        moveInProgress: '=',
	        select: '&',
	        assignIsOpen: '&',
	        debounce: '&'
	      },
	      replace: true,
	      templateUrl: function(element, attrs) {
	        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
	      },
	      link: function(scope, element, attrs) {
	        scope.templateUrl = attrs.templateUrl;

	        scope.isOpen = function() {
	          var isDropdownOpen = scope.matches.length > 0;
	          scope.assignIsOpen({ isOpen: isDropdownOpen });
	          return isDropdownOpen;
	        };

	        scope.isActive = function(matchIdx) {
	          return scope.active === matchIdx;
	        };

	        scope.selectActive = function(matchIdx) {
	          scope.active = matchIdx;
	        };

	        scope.selectMatch = function(activeIdx, evt) {
	          var debounce = scope.debounce();
	          if (angular.isNumber(debounce) || angular.isObject(debounce)) {
	            $$debounce(function() {
	              scope.select({activeIdx: activeIdx, evt: evt});
	            }, angular.isNumber(debounce) ? debounce : debounce['default']);
	          } else {
	            scope.select({activeIdx: activeIdx, evt: evt});
	          }
	        };
	      }
	    };
	  }])

	  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
	    return {
	      scope: {
	        index: '=',
	        match: '=',
	        query: '='
	      },
	      link: function(scope, element, attrs) {
	        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
	        $templateRequest(tplUrl).then(function(tplContent) {
	          var tplEl = angular.element(tplContent.trim());
	          element.replaceWith(tplEl);
	          $compile(tplEl)(scope);
	        });
	      }
	    };
	  }])

	  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
	    var isSanitizePresent;
	    isSanitizePresent = $injector.has('$sanitize');

	    function escapeRegexp(queryToEscape) {
	      // Regex: capture the whole query string and replace it with the string that will be used to match
	      // the results, for example if the capture is "a" the result will be \a
	      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	    }

	    function containsHtml(matchItem) {
	      return /<.*>/g.test(matchItem);
	    }

	    return function(matchItem, query) {
	      if (!isSanitizePresent && containsHtml(matchItem)) {
	        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
	      }
	      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
	      if (!isSanitizePresent) {
	        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
	      }
	      return matchItem;
	    };
	  }]);

	angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/accordion/accordion-group.html",
	    "<div class=\"panel\" ng-class=\"panelClass || 'panel-default'\">\n" +
	    "  <div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
	    "    <h4 class=\"panel-title\">\n" +
	    "      <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
	    "    </h4>\n" +
	    "  </div>\n" +
	    "  <div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
	    "    <div class=\"panel-body\" ng-transclude></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/accordion/accordion.html",
	    "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
	}]);

	angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/alert/alert.html",
	    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
	    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
	    "        <span aria-hidden=\"true\">&times;</span>\n" +
	    "        <span class=\"sr-only\">Close</span>\n" +
	    "    </button>\n" +
	    "    <div ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/carousel/carousel.html",
	    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
	    "  <div class=\"carousel-inner\" ng-transclude></div>\n" +
	    "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" +
	    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
	    "    <span class=\"sr-only\">previous</span>\n" +
	    "  </a>\n" +
	    "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" +
	    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
	    "    <span class=\"sr-only\">next</span>\n" +
	    "  </a>\n" +
	    "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
	    "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
	    "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
	    "    </li>\n" +
	    "  </ol>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/carousel/slide.html",
	    "<div ng-class=\"{\n" +
	    "    'active': active\n" +
	    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
	    "");
	}]);

	angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/datepicker/datepicker.html",
	    "<div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
	    "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" +
	    "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" +
	    "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/datepicker/day.html",
	    "<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
	    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
	    "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
	    "        id=\"{{::dt.uid}}\"\n" +
	    "        ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
	    "          uib-is-class=\"\n" +
	    "            'btn-info' for selectedDt,\n" +
	    "            'active' for activeDt\n" +
	    "            on dt\"\n" +
	    "          ng-click=\"select(dt.date)\"\n" +
	    "          ng-disabled=\"::dt.disabled\"\n" +
	    "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);

	angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/datepicker/month.html",
	    "<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
	    "        id=\"{{::dt.uid}}\"\n" +
	    "        ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" class=\"btn btn-default\"\n" +
	    "          uib-is-class=\"\n" +
	    "            'btn-info' for selectedDt,\n" +
	    "            'active' for activeDt\n" +
	    "            on dt\"\n" +
	    "          ng-click=\"select(dt.date)\"\n" +
	    "          ng-disabled=\"::dt.disabled\"\n" +
	    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);

	angular.module("uib/template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/datepicker/popup.html",
	    "<div>\n" +
	    "  <ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
	    "    <li ng-transclude></li>\n" +
	    "    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
	    "      <span class=\"btn-group pull-left\">\n" +
	    "        <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
	    "        <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
	    "      </span>\n" +
	    "      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
	    "    </li>\n" +
	    "  </ul>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/datepicker/year.html",
	    "<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
	    "        id=\"{{::dt.uid}}\"\n" +
	    "        ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" class=\"btn btn-default\"\n" +
	    "          uib-is-class=\"\n" +
	    "            'btn-info' for selectedDt,\n" +
	    "            'active' for activeDt\n" +
	    "            on dt\"\n" +
	    "          ng-click=\"select(dt.date)\"\n" +
	    "          ng-disabled=\"::dt.disabled\"\n" +
	    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);

	angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/modal/backdrop.html",
	    "<div class=\"modal-backdrop\"\n" +
	    "     uib-modal-animation-class=\"fade\"\n" +
	    "     modal-in-class=\"in\"\n" +
	    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
	    "></div>\n" +
	    "");
	}]);

	angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/modal/window.html",
	    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
	    "    uib-modal-animation-class=\"fade\"\n" +
	    "    modal-in-class=\"in\"\n" +
	    "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" +
	    "    <div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/pager/pager.html",
	    "<ul class=\"pager\">\n" +
	    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);

	angular.module("uib/template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/pagination/pager.html",
	    "<ul class=\"pager\">\n" +
	    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);

	angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/pagination/pagination.html",
	    "<ul class=\"pagination\">\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);

	angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/tooltip/tooltip-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\"\n" +
	    "    uib-tooltip-template-transclude=\"contentExp()\"\n" +
	    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/popover/popover-html.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/popover/popover-template.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\"\n" +
	    "        uib-tooltip-template-transclude=\"contentExp()\"\n" +
	    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/popover/popover.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/progressbar/bar.html",
	    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
	    "");
	}]);

	angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/progressbar/progress.html",
	    "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
	}]);

	angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/progressbar/progressbar.html",
	    "<div class=\"progress\">\n" +
	    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/rating/rating.html",
	    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
	    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
	    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
	    "</span>\n" +
	    "");
	}]);

	angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/tabs/tab.html",
	    "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" +
	    "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" +
	    "</li>\n" +
	    "");
	}]);

	angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/tabs/tabset.html",
	    "<div>\n" +
	    "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
	    "  <div class=\"tab-content\">\n" +
	    "    <div class=\"tab-pane\"\n" +
	    "         ng-repeat=\"tab in tabset.tabs\"\n" +
	    "         ng-class=\"{active: tabset.active === tab.index}\"\n" +
	    "         uib-tab-content-transclude=\"tab\">\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/timepicker/timepicker.html",
	    "<table class=\"uib-timepicker\">\n" +
	    "  <tbody>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
	    "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
	    "      </td>\n" +
	    "      <td class=\"uib-separator\">:</td>\n" +
	    "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
	    "      </td>\n" +
	    "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
	    "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
	    "      </td>\n" +
	    "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
	    "    </tr>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
	    "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);

	angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/typeahead/typeahead-match.html",
	    "<a href\n" +
	    "   tabindex=\"-1\"\n" +
	    "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
	    "   ng-attr-title=\"{{match.label}}\"></a>\n" +
	    "");
	}]);

	angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("uib/template/typeahead/typeahead-popup.html",
	    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
	    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
	    "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
	    "    </li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	angular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
	angular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll;}</style>'); angular.$$uibPositionCss = true; });
	angular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
	angular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
	angular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
	angular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });

/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Binds a CodeMirror widget to a <textarea> element.
	 */
	angular.module('ui.codemirror', [])
	  .constant('uiCodemirrorConfig', {})
	  .directive('uiCodemirror', ['$timeout', 'uiCodemirrorConfig', uiCodemirrorDirective]);

	/**
	 * @ngInject
	 */
	function uiCodemirrorDirective($timeout, uiCodemirrorConfig) {

	  return {
	    restrict: 'EA',
	    require: '?ngModel',
	    compile: function compile() {

	      // Require CodeMirror
	      if (angular.isUndefined(window.CodeMirror)) {
	        throw new Error('ui-codemirror needs CodeMirror to work... (o rly?)');
	      }

	      return postLink;
	    }
	  };

	  function postLink(scope, iElement, iAttrs, ngModel) {

	    var codemirrorOptions = angular.extend(
	      { value: iElement.text() },
	      uiCodemirrorConfig.codemirror || {},
	      scope.$eval(iAttrs.uiCodemirror),
	      scope.$eval(iAttrs.uiCodemirrorOpts)
	    );

	    var codemirror = newCodemirrorEditor(iElement, codemirrorOptions);

	    configOptionsWatcher(
	      codemirror,
	      iAttrs.uiCodemirror || iAttrs.uiCodemirrorOpts,
	      scope
	    );

	    configNgModelLink(codemirror, ngModel, scope);

	    configUiRefreshAttribute(codemirror, iAttrs.uiRefresh, scope);

	    // Allow access to the CodeMirror instance through a broadcasted event
	    // eg: $broadcast('CodeMirror', function(cm){...});
	    scope.$on('CodeMirror', function(event, callback) {
	      if (angular.isFunction(callback)) {
	        callback(codemirror);
	      } else {
	        throw new Error('the CodeMirror event requires a callback function');
	      }
	    });

	    // onLoad callback
	    if (angular.isFunction(codemirrorOptions.onLoad)) {
	      codemirrorOptions.onLoad(codemirror);
	    }
	  }

	  function newCodemirrorEditor(iElement, codemirrorOptions) {
	    var codemirrot;

	    if (iElement[0].tagName === 'TEXTAREA') {
	      // Might bug but still ...
	      codemirrot = window.CodeMirror.fromTextArea(iElement[0], codemirrorOptions);
	    } else {
	      iElement.html('');
	      codemirrot = new window.CodeMirror(function(cm_el) {
	        iElement.append(cm_el);
	      }, codemirrorOptions);
	    }

	    return codemirrot;
	  }

	  function configOptionsWatcher(codemirrot, uiCodemirrorAttr, scope) {
	    if (!uiCodemirrorAttr) { return; }

	    var codemirrorDefaultsKeys = Object.keys(window.CodeMirror.defaults);
	    scope.$watch(uiCodemirrorAttr, updateOptions, true);
	    function updateOptions(newValues, oldValue) {
	      if (!angular.isObject(newValues)) { return; }
	      codemirrorDefaultsKeys.forEach(function(key) {
	        if (newValues.hasOwnProperty(key)) {

	          if (oldValue && newValues[key] === oldValue[key]) {
	            return;
	          }

	          codemirrot.setOption(key, newValues[key]);
	        }
	      });
	    }
	  }

	  function configNgModelLink(codemirror, ngModel, scope) {
	    if (!ngModel) { return; }
	    // CodeMirror expects a string, so make sure it gets one.
	    // This does not change the model.
	    ngModel.$formatters.push(function(value) {
	      if (angular.isUndefined(value) || value === null) {
	        return '';
	      } else if (angular.isObject(value) || angular.isArray(value)) {
	        throw new Error('ui-codemirror cannot use an object or an array as a model');
	      }
	      return value;
	    });


	    // Override the ngModelController $render method, which is what gets called when the model is updated.
	    // This takes care of the synchronizing the codeMirror element with the underlying model, in the case that it is changed by something else.
	    ngModel.$render = function() {
	      //Code mirror expects a string so make sure it gets one
	      //Although the formatter have already done this, it can be possible that another formatter returns undefined (for example the required directive)
	      var safeViewValue = ngModel.$viewValue || '';
	      codemirror.setValue(safeViewValue);
	    };


	    // Keep the ngModel in sync with changes from CodeMirror
	    codemirror.on('change', function(instance) {
	      var newValue = instance.getValue();
	      if (newValue !== ngModel.$viewValue) {
	        scope.$evalAsync(function() {
	          ngModel.$setViewValue(newValue);
	        });
	      }
	    });
	  }

	  function configUiRefreshAttribute(codeMirror, uiRefreshAttr, scope) {
	    if (!uiRefreshAttr) { return; }

	    scope.$watch(uiRefreshAttr, function(newVal, oldVal) {
	      // Skip the initial watch firing
	      if (newVal !== oldVal) {
	        $timeout(function() {
	          codeMirror.refresh();
	        });
	      }
	    });
	  }

	}


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _Factory = __webpack_require__(161);

	var _Factory2 = _interopRequireDefault(_Factory);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	__webpack_require__(143).polyfill(); // for IE

	__webpack_require__(136);
	__webpack_require__(123);
	__webpack_require__(31);

	var moduleName = 'ng-admin';
	var factory = angular.module('AdminDescriptionModule', []);
	factory.constant('AdminDescription', new _Factory2.default());

	var ngadmin = angular.module(moduleName, ['ui.select', 'main', 'crud', 'AdminDescriptionModule']);

	ngadmin.config(['NgAdminConfigurationProvider', 'AdminDescription', function (NgAdminConfigurationProvider, AdminDescription) {
	    NgAdminConfigurationProvider.setAdminDescription(AdminDescription);
	}]);

	ngadmin.config(['uiSelectConfig', function (uiSelectConfig) {
	    uiSelectConfig.theme = 'bootstrap';
	}]);

	exports.default = moduleName;
	module.exports = exports['default'];

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _angular = __webpack_require__(3);

	var _angular2 = _interopRequireDefault(_angular);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	__webpack_require__(194);
	__webpack_require__(196);
	__webpack_require__(195);

	__webpack_require__(29);

	var CrudModule = _angular2.default.module('crud', ['ui.router', 'ui.bootstrap', 'ui.codemirror', 'ngSanitize', 'textAngular', 'ngInflection', 'ngFileUpload', 'ngNumeraljs']);

	CrudModule.controller('ListLayoutController', __webpack_require__(102));
	CrudModule.controller('ListController', __webpack_require__(101));
	CrudModule.controller('ShowController', __webpack_require__(120));
	CrudModule.controller('FormController', __webpack_require__(100));
	CrudModule.controller('DeleteController', __webpack_require__(61));
	CrudModule.controller('BatchDeleteController', __webpack_require__(60));

	CrudModule.service('EntryFormatter', __webpack_require__(112));
	CrudModule.service('PromisesResolver', __webpack_require__(113));
	CrudModule.service('ReadQueries', __webpack_require__(116));
	CrudModule.service('ReferenceRefresher', __webpack_require__(117));
	CrudModule.service('WriteQueries', __webpack_require__(118));

	CrudModule.service('RestWrapper', __webpack_require__(114));

	CrudModule.directive('maJsonValidator', __webpack_require__(122));

	CrudModule.directive('maField', __webpack_require__(68));
	CrudModule.directive('maButtonField', __webpack_require__(62));
	CrudModule.directive('maChoiceField', __webpack_require__(64));
	CrudModule.directive('maChoicesField', __webpack_require__(65));
	CrudModule.directive('maDateField', __webpack_require__(66));
	CrudModule.directive('maEmbeddedListField', __webpack_require__(67));
	CrudModule.directive('maInputField', __webpack_require__(70));
	CrudModule.directive('maJsonField', __webpack_require__(71));
	CrudModule.directive('maFileField', __webpack_require__(69));
	CrudModule.directive('maCheckboxField', __webpack_require__(63));
	CrudModule.directive('maReferenceField', __webpack_require__(72));
	CrudModule.directive('maReferenceManyField', __webpack_require__(73));
	CrudModule.directive('maTextField', __webpack_require__(75));
	CrudModule.directive('maWysiwygField', __webpack_require__(76));
	CrudModule.directive('maTemplateField', __webpack_require__(74));
	CrudModule.directive('uiSelectRequired', __webpack_require__(77));

	CrudModule.provider('FieldViewConfiguration', __webpack_require__(85));

	CrudModule.directive('maListActions', __webpack_require__(110));
	CrudModule.directive('maDatagrid', __webpack_require__(103));
	CrudModule.directive('maDatagridPagination', __webpack_require__(108));
	CrudModule.directive('maDatagridInfinitePagination', __webpack_require__(105));
	CrudModule.directive('maDatagridItemSelector', __webpack_require__(106));
	CrudModule.directive('maDatagridMultiSelector', __webpack_require__(107));
	CrudModule.directive('maFilterForm', __webpack_require__(99));
	CrudModule.directive('maFilter', __webpack_require__(98));

	CrudModule.directive('maColumn', __webpack_require__(46));
	CrudModule.directive('maBooleanColumn', __webpack_require__(44));
	CrudModule.directive('maChoicesColumn', __webpack_require__(45));
	CrudModule.directive('maDateColumn', __webpack_require__(47));
	CrudModule.directive('maEmbeddedListColumn', __webpack_require__(48));
	CrudModule.directive('maJsonColumn', __webpack_require__(49));
	CrudModule.directive('maNumberColumn', __webpack_require__(50));
	CrudModule.directive('maReferenceColumn', __webpack_require__(51));
	CrudModule.directive('maReferencedListColumn', __webpack_require__(55));
	CrudModule.directive('maReferenceLinkColumn', __webpack_require__(52));
	CrudModule.directive('maReferenceManyColumn', __webpack_require__(53));
	CrudModule.directive('maReferenceManyLinkColumn', __webpack_require__(54));
	CrudModule.directive('maStringColumn', __webpack_require__(56));
	CrudModule.directive('maTemplateColumn', __webpack_require__(57));
	CrudModule.directive('maWysiwygColumn', __webpack_require__(58));

	CrudModule.directive('maBackButton', __webpack_require__(32));
	CrudModule.directive('maCreateButton', __webpack_require__(34));
	CrudModule.directive('maEditButton', __webpack_require__(36));
	CrudModule.directive('maFilterButton', __webpack_require__(38));
	CrudModule.directive('maFilteredListButton', __webpack_require__(39));
	CrudModule.directive('maShowButton', __webpack_require__(41));
	CrudModule.directive('maListButton', __webpack_require__(40));
	CrudModule.directive('maDeleteButton', __webpack_require__(35));
	CrudModule.directive('maBatchDeleteButton', __webpack_require__(33));
	CrudModule.directive('maExportToCsvButton', __webpack_require__(37));
	CrudModule.directive('maSubmitButton', __webpack_require__(42));
	CrudModule.directive('maViewBatchActions', __webpack_require__(43));

	CrudModule.directive('maShowItem', __webpack_require__(121));
	CrudModule.directive('maViewActions', __webpack_require__(115));
	CrudModule.directive('compile', __webpack_require__(111));

	CrudModule.config(__webpack_require__(119));
	CrudModule.config(__webpack_require__(59));

	CrudModule.factory('Papa', function () {
	    return __webpack_require__(191);
	});

	CrudModule.factory('notification', function () {
	    var humane = __webpack_require__(157);
	    humane.timeout = 5000;
	    humane.clickToClose = true;
	    return humane;
	});

	CrudModule.factory('progression', function () {
	    return __webpack_require__(190);
	});

	CrudModule.run(['Restangular', 'NgAdminConfiguration', function (Restangular, NgAdminConfiguration) {
	    Restangular.setBaseUrl(NgAdminConfiguration().baseApiUrl());
	}]);

	exports.default = CrudModule;
	module.exports = exports['default'];

/***/ },
/* 32 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maBackButtonDirective;
	/**
	 * Link to previous page
	 *
	 * Usage:
	 * <ma-back-button entry="entry" size="xs"></ma-back-button>
	 */
	function maBackButtonDirective($window) {
	    return {
	        restrict: 'E',
	        scope: {
	            size: '@',
	            label: '@'
	        },
	        link: function link(scope) {
	            scope.label = scope.label || 'BACK';
	            scope.back = function () {
	                return $window.history.back();
	            };
	        },
	        template: ' <a class="btn btn-default" ng-class="size ? \'btn-\' + size : \'\'" ng-click="back()">\n<span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n</a>'
	    };
	}

	maBackButtonDirective.$inject = ['$window'];
	module.exports = exports['default'];

/***/ },
/* 33 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maBatchDeleteButtonDirective;
	function maBatchDeleteButtonDirective($state) {
	    return {
	        restrict: 'E',
	        scope: {
	            entity: '&',
	            selection: '&',
	            label: '@'
	        },
	        link: function link($scope) {
	            $scope.label = $scope.label || 'DELETE';
	            $scope.gotoBatchDelete = function () {
	                var ids = $scope.selection().map(function (entry) {
	                    return entry.identifierValue;
	                });

	                $state.go('batchDelete', angular.extend({
	                    ids: ids,
	                    entity: $scope.entity().name()
	                }, $state.params));
	            };
	        },
	        template: '<span ng-click="gotoBatchDelete()">\n<span class="glyphicon glyphicon-trash" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n</span>'
	    };
	}

	maBatchDeleteButtonDirective.$inject = ['$state'];
	module.exports = exports['default'];

/***/ },
/* 34 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = maCreateButtonDirective;
	/**
	 * Link to create
	 *
	 * Usage:
	 * <ma-create-button entity="entity" default-values="{}" size="xs"></ma-create-button>
	 */
	function maCreateButtonDirective($state) {
	    return {
	        restrict: 'E',
	        scope: {
	            entity: '&',
	            entityName: '@',
	            defaultValues: '&',
	            size: '@',
	            label: '@'
	        },
	        link: function link(scope, element, attrs) {
	            scope.label = scope.label || 'CREATE';
	            var entityName = scope.entity() ? scope.entity().name() : attrs.entityName;
	            var stateParams = entityName == $state.params.entity ? _extends({}, $state.params) : {};
	            stateParams.entity = entityName;
	            stateParams.defaultValues = scope.defaultValues();
	            scope.stateParams = stateParams;
	        },
	        template: ' <a class="btn btn-default" ng-class="size ? \'btn-\' + size : \'\'" ui-sref="create(stateParams)">\n<span class="glyphicon glyphicon-plus" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n</a>'
	    };
	}

	maCreateButtonDirective.$inject = ['$state'];
	module.exports = exports['default'];

/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = maDeleteButtonDirective;
	/**
	 * Link to delete
	 *
	 * Usage:
	 * <ma-delete-button entity="entity" entry="entry" size="xs"></ma-delete-button>
	 */
	function maDeleteButtonDirective($state) {
	    return {
	        restrict: 'E',
	        scope: {
	            entity: '&',
	            entityName: '@',
	            entry: '&',
	            size: '@',
	            label: '@'
	        },
	        link: function link(scope, element, attrs) {
	            scope.label = scope.label || 'DELETE';
	            var entityName = scope.entity() ? scope.entity().name() : attrs.entityName;
	            var stateParams = entityName == $state.params.entity ? _extends({}, $state.params) : {};
	            stateParams.entity = entityName;
	            stateParams.id = scope.entry().identifierValue;
	            scope.stateParams = stateParams;
	        },
	        template: ' <a class="btn btn-default" ng-class="size ? \'btn-\' + size : \'\'" ui-sref="delete(stateParams)">\n<span class="glyphicon glyphicon-trash" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n</a>'
	    };
	}

	maDeleteButtonDirective.$inject = ['$state'];
	module.exports = exports['default'];

/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = maEditButtonDirective;
	/**
	 * Link to edit
	 *
	 * Usage:
	 * <ma-edit-button entity="entity" entry="entry" size="xs"></ma-edit-button>
	 */
	function maEditButtonDirective($state) {
	    return {
	        restrict: 'E',
	        scope: {
	            entity: '&',
	            entityName: '@',
	            entry: '&',
	            size: '@',
	            label: '@'
	        },
	        link: function link(scope, element, attrs) {
	            scope.label = scope.label || 'EDIT';
	            var entityName = scope.entity() ? scope.entity().name() : attrs.entityName;
	            var stateParams = entityName == $state.params.entity ? _extends({}, $state.params) : {};
	            stateParams.entity = entityName;
	            stateParams.id = scope.entry().identifierValue;
	            scope.stateParams = stateParams;
	        },
	        template: ' <a class="btn btn-default" ng-class="size ? \'btn-\' + size : \'\'" ui-sref="edit(stateParams)">\n<span class="glyphicon glyphicon-pencil" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n</a>'
	    };
	}

	maEditButtonDirective.$inject = ['$state'];
	module.exports = exports['default'];

/***/ },
/* 37 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maExportToCsvButton;
	function maExportToCsvButton($stateParams, Papa, notification, AdminDescription, entryFormatter, ReadQueries) {
	    return {
	        restrict: 'E',
	        scope: {
	            entity: '&',
	            label: '@',
	            datastore: '&'
	        },
	        link: function link(scope) {
	            scope.label = scope.label || 'EXPORT';
	            scope.datastore = scope.datastore();
	            scope.entity = scope.entity();
	            var exportView = scope.entity.exportView();
	            var listView = scope.entity.listView();
	            if (exportView.fields().length === 0) {
	                var exportFields = listView.exportFields();
	                if (exportFields === null) {
	                    exportFields = listView.fields();
	                }
	                exportView.fields(exportFields);
	                exportView.filters(listView.filters());
	                exportView.name(listView.name()); // to enable reuse of sortField
	            }
	            scope.has_export = exportView.fields().length > 0;
	            var formatEntry = entryFormatter.getFormatter(exportView.fields());

	            scope.exportToCsv = function () {
	                var rawEntries;

	                ReadQueries.getAll(exportView, -1, $stateParams.search, $stateParams.sortField, $stateParams.sortDir).then(function (response) {
	                    rawEntries = response.data;
	                    return rawEntries;
	                }).then(function (rawEntries) {
	                    return ReadQueries.getReferenceData(exportView.fields(), rawEntries);
	                }).then(function (referenceData) {
	                    var references = exportView.getReferences();
	                    for (var name in referenceData) {
	                        AdminDescription.getEntryConstructor().createArrayFromRest(referenceData[name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                            return scope.datastore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                        });
	                    }
	                }).then(function () {
	                    var entries = exportView.mapEntries(rawEntries);

	                    // shortcut to diplay collection of entry with included referenced values
	                    scope.datastore.fillReferencesValuesFromCollection(entries, exportView.getReferences(), true);

	                    var results = [];
	                    for (var i = entries.length - 1; i >= 0; i--) {
	                        results[i] = formatEntry(entries[i]);
	                    }
	                    var csv = Papa.unparse(results, listView.exportOptions());
	                    var fakeLink = document.createElement('a');
	                    document.body.appendChild(fakeLink);

	                    fakeLink.setAttribute('href', 'data:application/octet-stream;charset=utf-8,' + encodeURIComponent(csv));
	                    fakeLink.setAttribute('download', scope.entity.name() + '.csv');
	                    fakeLink.click();
	                }, function (error) {
	                    notification.log(error.message, { addnCls: 'humane-flatty-error' });
	                });
	            };
	        },
	        template: '<span ng-if="has_export">\n    <a class="btn btn-default" ng-click="exportToCsv()">\n        <span class="glyphicon glyphicon-download" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n    </a>\n</span>'
	    };
	}

	maExportToCsvButton.$inject = ['$stateParams', 'Papa', 'notification', 'AdminDescription', 'EntryFormatter', 'ReadQueries'];
	module.exports = exports['default'];

/***/ },
/* 38 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maFilterButton;
	function maFilterButton() {
	    return {
	        restrict: 'E',
	        scope: {
	            filters: '&',
	            enabledFilters: '=',
	            enableFilter: '&',
	            label: "@"
	        },
	        link: function link(scope) {
	            scope.label = scope.label || 'ADD_FILTER';
	            scope.notYetEnabledFilters = function () {
	                return scope.filters().filter(function (filter) {
	                    return scope.enabledFilters.indexOf(filter) === -1;
	                });
	            };
	            scope.hasFilters = function () {
	                return scope.notYetEnabledFilters().length > 0;
	            };
	        },
	        template: '<span class="btn-group" uib-dropdown is-open="isopen" ng-if="hasFilters()">\n    <button type="button" class="btn btn-default dropdown-toggle" uib-dropdown-toggle >\n        <span class="glyphicon glyphicon-filter" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>&nbsp;<span class="caret"></span>\n    </button>\n    <ul class="dropdown-menu" role="menu">\n        <li ng-repeat="filter in notYetEnabledFilters()" ng-switch="button">\n            <a ng-click="enableFilter()(filter)">{{ filter.label() | translate }}</a>\n        </li>\n    </ul>\n</span>'
	    };
	}

	maFilterButton.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maFilteredListButtonDirective;
	/**
	 * Link to filtered list
	 *
	 * Usage:
	 *
	 *     <!-- In a scope where the current entry is a post, link tio the related comments -->
	 *     <ma-filtered-list-button
	 *       entity-name="comments"
	 *       filter="{ post_id: entry.values.id }"
	 *       text="See related comments"
	 *       size="xs">
	 *     </ma-filtered-list-button>')
	 *
	 * Usage as a template field:
	 *
	 * nga.field('', 'template')
	 *   .label('')
	 *   .template('<ma-filtered-list-button entity-name="comments" filter="{ post_id: entry.values.id }"></ma-filtered-list-button>')
	 */
	function maFilteredListButtonDirective() {
	    return {
	        restrict: 'E',
	        scope: {
	            entityName: '@',
	            filter: '&',
	            label: '@',
	            size: '@'
	        },
	        link: function link(scope) {
	            scope.label = scope.label || 'SEE_RELATED';
	            scope.stateParams = { 'entity': scope.entityName, 'search': scope.filter() };
	        },
	        template: ' <a class="btn btn-default" ng-class="size ? \'btn-\' + size : \'\'" ui-sref="list(stateParams)">\n    <span class="glyphicon glyphicon-list" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}" translate-values="{ entityName: entityName }"></span>\n</a>'
	    };
	}

	maFilteredListButtonDirective.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = maListButtonDirective;
	/**
	 * Link to list
	 *
	 * Usage:
	 * <ma-list-button entity="entity" size="xs"></ma-list-button>
	 */
	function maListButtonDirective($state) {
	    return {
	        restrict: 'E',
	        scope: {
	            entity: '&',
	            entityName: '@',
	            size: '@',
	            label: '@'
	        },
	        link: function link(scope, element, attrs) {
	            scope.label = scope.label || 'LIST';
	            var entityName = scope.entity() ? scope.entity().name() : attrs.entityName;
	            var stateParams = entityName == $state.params.entity ? _extends({}, $state.params) : {};
	            stateParams.entity = entityName;
	            scope.stateParams = stateParams;
	        },
	        template: ' <a class="btn btn-default" ng-class="size ? \'btn-\' + size : \'\'" ui-sref="list(stateParams)">\n<span class="glyphicon glyphicon-list" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n</a>'
	    };
	}

	maListButtonDirective.$inject = ['$state'];
	module.exports = exports['default'];

/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = maShowButtonDirective;
	/**
	 * Link to show
	 *
	 * Usage:
	 * <ma-show-button entity="entity" entry="entry" size="xs"></ma-show-button>
	 */
	function maShowButtonDirective($state) {
	    return {
	        restrict: 'E',
	        scope: {
	            entity: '&',
	            entityName: '@',
	            entry: '&',
	            size: '@',
	            label: '@'
	        },
	        link: function link(scope, element, attrs) {
	            scope.label = scope.label || 'SHOW';
	            var entityName = scope.entity() ? scope.entity().name() : attrs.entityName;
	            var stateParams = entityName == $state.params.entity ? _extends({}, $state.params) : {};
	            stateParams.entity = entityName;
	            stateParams.id = scope.entry().identifierValue;
	            scope.stateParams = stateParams;
	        },
	        template: ' <a class="btn btn-default" ng-class="size ? \'btn-\' + size : \'\'" ui-sref="show(stateParams)">\n<span class="glyphicon glyphicon-eye-open" aria-hidden="true"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span>\n</a>'
	    };
	}

	maShowButtonDirective.$inject = ['$state'];
	module.exports = exports['default'];

/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maSubmitButtonDirective;
	/**
	 * Save button
	 *
	 * Usage:
	 * <ma-submit-button label="Save changes"></ma-submit-button>
	 */
	function maSubmitButtonDirective() {
	    return {
	        restrict: 'E',
	        scope: {
	            label: '@'
	        },
	        link: function link(scope) {
	            scope.label = scope.label || 'SAVE';
	        },
	        template: '<button type="submit" class="btn btn-primary"><span class="glyphicon glyphicon-ok"></span>&nbsp;<span class="hidden-xs" translate="{{ ::label }}"></span></button>'
	    };
	}

	maSubmitButtonDirective.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 43 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maViewBatchActionsDirective;
	function maViewBatchActionsDirective() {
	    return {
	        restrict: 'E',
	        scope: {
	            'entity': '=',
	            'selection': '=',
	            'buttons': '&',
	            'label': '@'
	        },
	        link: function link(scope) {
	            scope.label = scope.label || 'N_SELECTED';
	            scope.isopen = false;
	            scope.toggleDropdown = function ($event) {
	                $event.preventDefault();
	                $event.stopPropagation();
	                scope.isopen = !scope.isopen;
	            };
	            scope.buttons = scope.buttons();
	            if (typeof scope.buttons === 'string') {
	                scope.customTemplate = scope.buttons;
	                scope.buttons = null;
	            }
	        },
	        // the ng-class hidden is necessary to hide the inner blank space used for spacing buttons when the selection is not empty
	        template: '<span ng-if="selection" ng-class="{hidden:!selection || selection.length==0}"> <span class="btn-group" uib-dropdown is-open="isopen"><button type="button" ng-if="selection.length" class="btn btn-default dropdown-toggle" uib-dropdown-toggle >\n            <span translate="{{ ::label }}" translate-values="{ length: selection.length }"></span>&nbsp;<span class="caret"></span>\n        </button>\n        <ul class="dropdown-menu" role="menu">\n            <li ng-repeat="button in buttons" ng-switch="button">\n                <a ng-switch-when="delete">\n                    <ma-batch-delete-button selection="selection" entity="entity"/>\n                </a>\n                <a ng-switch-default>\n                    <span compile="button"></span>\n                </a>\n            </li>\n        </ul>\n    </span>\n</span>'
	    };
	}

	maViewBatchActionsDirective.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 44 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maBooleanColumn;
	function maBooleanColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            value: '&'
	        },
	        link: function link(scope) {
	            scope.value = scope.value();
	        },
	        template: '<span class="glyphicon" ng-class="{\'glyphicon-ok\': !!value, \'glyphicon-remove\': !value }"></span>'
	    };
	}

	maBooleanColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 45 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maChoicesColumn;
	function maChoicesColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            values: '&'
	        },
	        template: '<span ng-repeat="ref in values() track by $index" class="label label-default">{{ ref }}</span>'
	    };
	}

	maChoicesColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 46 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = maColumn;
	function maColumn($state, $anchorScroll, $compile, Configuration, FieldViewConfiguration) {

	    function getDetailLinkRouteName(field, entity) {
	        if (entity.isReadOnly) {
	            return entity.showView().enabled ? 'show' : false;
	        }
	        if (field.detailLinkRoute() == 'edit' && entity.editionView().enabled) {
	            return 'edit';
	        }
	        return entity.showView().enabled ? 'show' : false;
	    }

	    function isDetailLink(field, entity) {
	        if (field.isDetailLink() === false) {
	            return false;
	        }
	        if (field.type() == 'reference' || field.type() == 'reference_many') {
	            var relatedEntity = Configuration().getEntity(field.targetEntity().name());
	            if (!relatedEntity) {
	                return false;
	            }
	            return getDetailLinkRouteName(field, relatedEntity) !== false;
	        }
	        return getDetailLinkRouteName(field, entity) !== false;
	    }

	    return {
	        restrict: 'E',
	        scope: {
	            field: '&',
	            entry: '&',
	            entity: '&',
	            datastore: '&'
	        },
	        link: function link(scope, element) {
	            scope.datastore = scope.datastore();
	            scope.field = scope.field();
	            scope.entry = scope.entry();
	            scope.value = typeof scope.entry === 'undefined' ? '' : scope.entry.values[scope.field.name()];
	            scope.entity = scope.entity();
	            var customTemplate = scope.field.getTemplateValue(scope.entry);
	            if (customTemplate && !scope.field.templateIncludesLabel()) {
	                element.append(customTemplate);
	            } else {
	                var type = scope.field.type();
	                if (isDetailLink(scope.field, scope.entity)) {
	                    element.append(FieldViewConfiguration[type].getLinkWidget());
	                } else {
	                    element.append(FieldViewConfiguration[type].getReadWidget());
	                }
	            }
	            scope.detailState = false;
	            scope.detailStateParams = {};
	            if (typeof scope.entry !== 'undefined') {
	                scope.detailState = getDetailLinkRouteName(scope.field, scope.entity);
	                scope.detailStateParams = _extends({}, $state.params, {
	                    entity: scope.entry.entityName,
	                    id: scope.entry.identifierValue
	                });
	            }
	            $compile(element.contents())(scope);
	        }
	    };
	}

	maColumn.$inject = ['$state', '$anchorScroll', '$compile', 'NgAdminConfiguration', 'FieldViewConfiguration'];
	module.exports = exports['default'];

/***/ },
/* 47 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDateColumn;
	function maDateColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            value: '&',
	            field: '&'
	        },
	        link: function link(scope) {
	            var field = scope.field();
	            scope.format = field.format();
	            if (!scope.format) {
	                scope.format = field.type() === 'date' ? 'yyyy-MM-dd' : 'yyyy-MM-dd HH:mm:ss';
	            }
	        },
	        template: '<span>{{ value() | date:format }}</span>'
	    };
	}

	maDateColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maEmbeddedListColumn;

	var _Entry = __webpack_require__(4);

	var _Entry2 = _interopRequireDefault(_Entry);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function sorter(sortField, sortDir) {
	    return function (entry1, entry2) {
	        // use < and > instead of substraction to sort strings properly
	        var sortFactor = sortDir === 'DESC' ? -1 : 1;
	        if (entry1.values[sortField] > entry2.values[sortField]) {
	            return sortFactor;
	        }
	        if (entry1.values[sortField] < entry2.values[sortField]) {
	            return -1 * sortFactor;
	        }
	        return 0;
	    };
	}

	function maEmbeddedListColumn(NgAdminConfiguration) {
	    var application = NgAdminConfiguration(); // jshint ignore:line
	    return {
	        scope: {
	            'field': '&',
	            'value': '&',
	            'datastore': '&'
	        },
	        restrict: 'E',
	        link: {
	            pre: function pre(scope) {
	                var field = scope.field();
	                var targetEntity = field.targetEntity();
	                var targetEntityName = targetEntity.name();
	                var targetFields = field.targetFields();
	                var sortField = field.sortField();
	                var sortDir = field.sortDir();
	                var filterFunc;
	                if (field.permanentFilters()) {
	                    (function () {
	                        var filters = field.permanentFilters();
	                        var filterKeys = Object.keys(filters);
	                        filterFunc = function filterFunc(entry) {
	                            return filterKeys.reduce(function (isFiltered, key) {
	                                return isFiltered && entry.values[key] === filters[key];
	                            }, true);
	                        };
	                    })();
	                } else {
	                    filterFunc = function filterFunc() {
	                        return true;
	                    };
	                }
	                var entries = _Entry2.default.createArrayFromRest(scope.value() || [], targetFields, targetEntityName, targetEntity.identifier().name()).sort(sorter(sortField, sortDir)).filter(filterFunc);
	                if (!targetEntityName) {
	                    (function () {
	                        var index = 0;
	                        entries = entries.map(function (e) {
	                            e._identifierValue = index++;
	                            return e;
	                        });
	                    })();
	                }
	                scope.field = field;
	                scope.targetFields = targetFields;
	                scope.entries = entries;
	                scope.entity = targetEntityName ? application.getEntity(targetEntityName) : targetEntity;
	                scope.sortField = sortField;
	                scope.sortDir = sortDir;
	                scope.sort = function (field) {
	                    var sortDir = 'ASC';
	                    var sortField = field.name();
	                    if (scope.sortField === sortField) {
	                        // inverse sort dir
	                        sortDir = scope.sortDir === 'ASC' ? 'DESC' : 'ASC';
	                    }
	                    scope.entries = scope.entries.sort(sorter(sortField, sortDir));
	                    scope.sortField = sortField;
	                    scope.sortDir = sortDir;
	                };
	            }
	        },
	        template: '\n<ma-datagrid ng-if="::entries.length > 0"\n    entries="entries"\n    fields="::targetFields"\n    list-actions="::field.listActions()"\n    entity="::entity"\n    datastore="::datastore()"\n    sort-field="sortField"\n    sort-dir="sortDir"\n    sort="::sort">\n</ma-datagrid>'
	    };
	}

	maEmbeddedListColumn.$inject = ['NgAdminConfiguration'];
	module.exports = exports['default'];

/***/ },
/* 49 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maJsonColumn;
	function maJsonColumn($compile) {
	    return {
	        restrict: 'E',
	        scope: {
	            value: '&'
	        },
	        link: function link(scope, element) {
	            scope.guessType = function (obj) {
	                var type = Object.prototype.toString.call(obj);

	                if (type === "[object Object]") {
	                    return "Object";
	                }

	                if (type === "[object Array]") {
	                    return "Array";
	                }

	                return "Literal";
	            };

	            var template = '<span ng-switch="guessType(value())">\n    <table class="table table-condensed" ng-switch-when="Array">\n        <tbody>\n            <tr ng-repeat="val in value() track by $index">\n                <td ng-switch="guessType(val)">\n                    <ma-json-column ng-switch-when="Object" value="::val"></ma-json-column>\n                    <ma-json-column ng-switch-when="Array" value="::val"></ma-json-column>\n                    <span ng-switch-when="Literal">{{ val }}</span>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <table class="table table-condensed table-bordered" ng-switch-when="Object">\n        <tbody>\n            <tr ng-repeat="(key, val) in value() track by key">\n                <th class="active">{{ key }}</th>\n                <td ng-switch="guessType(val)">\n                    <ma-json-column ng-switch-when="Object" value="::val"></ma-json-column>\n                    <ma-json-column ng-switch-when="Array" value="::val"></ma-json-column>\n                    <span ng-switch-when="Literal">{{ val }}</span>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n</span>';

	            var newElement = angular.element(template);
	            $compile(newElement)(scope);
	            element.replaceWith(newElement);
	        }
	    };
	}

	maJsonColumn.$inject = ['$compile'];
	module.exports = exports['default'];

/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maNumberColumn;
	function maNumberColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            value: '&',
	            field: '&'
	        },
	        template: '<span>{{ value() | numeraljs:field().format() }}</span>'
	    };
	}

	maNumberColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 51 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maReferenceColumn;
	function maReferenceColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            field: '&',
	            value: '&',
	            datastore: '&'
	        },
	        link: {
	            pre: function pre(scope) {
	                var value = scope.value();
	                scope.field = scope.field();
	                scope.targetEntity = scope.field.targetEntity();
	                scope.targetField = scope.field.targetField();
	                var identifierName = scope.targetEntity.identifier().name();
	                scope.referencedEntry = scope.datastore().getFirstEntry(scope.targetEntity.uniqueId + '_values', function (entry) {
	                    return entry.values[identifierName] == value;
	                });
	            }
	        },
	        template: '<ma-column field="::targetField" entry="::referencedEntry" entity="::targetEntity" datastore="::datastore()"></ma-column>'
	    };
	}

	maReferenceColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maReferenceLinkColumn;
	function getDetailLinkRouteName(field, entity) {
	    if (entity.isReadOnly) {
	        return entity.showView().enabled ? 'show' : false;
	    }
	    if (field.detailLinkRoute() == 'edit' && entity.editionView().enabled) {
	        return 'edit';
	    }
	    return entity.showView().enabled ? 'show' : false;
	}

	function maReferenceLinkColumn(NgAdminConfiguration) {
	    return {
	        restrict: 'E',
	        scope: {
	            entry: '&',
	            field: '&',
	            value: '&',
	            datastore: '&'
	        },
	        link: {
	            pre: function pre(scope) {
	                var field = scope.field();
	                var referenceEntity = field.targetEntity().name();
	                var relatedEntity = NgAdminConfiguration().getEntity(referenceEntity);
	                var referenceId = scope.entry().values[field.name()];
	                scope.route = getDetailLinkRouteName(field, relatedEntity);
	                scope.stateParams = {
	                    entity: referenceEntity,
	                    id: referenceId
	                };
	                scope.field = field;
	            }
	        },
	        template: '<a ui-sref="{{route}}(stateParams)"><ma-reference-column field="::field" value="::value()" datastore="::datastore()"></ma-reference-column></a>'
	    };
	}

	maReferenceLinkColumn.$inject = ['NgAdminConfiguration'];
	module.exports = exports['default'];

/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maReferenceManyColumn;
	function maReferenceManyColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            values: '&'
	        },
	        template: '<span ng-repeat="ref in values() track by $index">\n    <span class="label label-default">{{ ref }}</span>\n</span>'
	    };
	}

	maReferenceManyColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 54 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maReferenceManyLinkColumn;
	function maReferenceManyLinkColumn(NgAdminConfiguration) {
	    return {
	        restrict: 'E',
	        scope: {
	            field: '&',
	            values: '&',
	            ids: '&'
	        },
	        link: function link(scope) {
	            scope.field = scope.field();
	            scope.values = scope.values();
	            scope.ids = scope.ids();
	            scope.referenceEntity = scope.field.targetEntity().name();
	            scope.route = NgAdminConfiguration().getEntity(scope.referenceEntity).isReadOnly ? 'show' : 'edit';
	        },
	        template: '<a ng-repeat="ref in values track by $index" ui-sref="{{route}}({ entity: referenceEntity, id: ids[$index] })" class="multiple">\n    <span class="label label-default">{{ ref }}</span>\n</a>'
	    };
	}

	maReferenceManyLinkColumn.$inject = ['NgAdminConfiguration'];
	module.exports = exports['default'];

/***/ },
/* 55 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maReferencedListColumn;
	function isSortFieldForMe(sortField, field) {
	    if (!sortField) return false;
	    return sortField.split('.')[0] == field.targetEntity().name() + '_ListView';
	}

	function maReferencedListColumn(NgAdminConfiguration, $stateParams) {
	    return {
	        scope: {
	            'field': '&',
	            'datastore': '&'
	        },
	        restrict: 'E',
	        link: {
	            pre: function pre(scope) {
	                scope.field = scope.field();
	                var targetEntity = scope.field.targetEntity();
	                scope.entries = scope.datastore().getEntries(targetEntity.uniqueId + '_list');
	                scope.entity = NgAdminConfiguration().getEntity(targetEntity.name());
	                scope.sortField = isSortFieldForMe($stateParams.sortField, scope.field) ? $stateParams.sortField : scope.field.getSortFieldName();
	                scope.sortDir = $stateParams.sortDir || scope.field.sortDir();
	            }
	        },
	        template: '\n<ma-datagrid ng-if="::entries.length > 0" name="{{ field.datagridName() }}"\n    entries="::entries"\n    fields="::field.targetFields()"\n    list-actions="::field.listActions()"\n    entity="::entity"\n    sort-field="::sortField"\n    sort-dir="::sortDir"\n    datastore="::datastore()"\n    entry-css-classes="::field.entryCssClasses()">\n</ma-datagrid>'
	    };
	}

	maReferencedListColumn.$inject = ['NgAdminConfiguration', '$stateParams'];
	module.exports = exports['default'];

/***/ },
/* 56 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maStringColumn;
	function maStringColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            value: '&'
	        },
	        template: '<span>{{ value() | translate }}</span>'
	    };
	}

	maStringColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 57 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maTemplateColumn;
	function maTemplateColumn() {
	    return {
	        restrict: 'E',
	        scope: {
	            field: '&',
	            entry: '&',
	            entity: '&'
	        },
	        link: function link(scope) {
	            scope.field = scope.field();
	            scope.entry = scope.entry();
	            scope.entity = scope.entity();
	        },
	        template: '<span compile="field.getTemplateValue(entry)"></span>'
	    };
	}

	maTemplateColumn.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 58 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maWysiwygColumn;
	function maWysiwygColumn($filter) {
	    return {
	        restrict: 'E',
	        scope: {
	            value: '&',
	            field: '&'
	        },
	        link: function link(scope) {
	            var value = scope.value();
	            if (scope.field().stripTags()) {
	                value = $filter('stripTags')(value);
	            }
	            scope.htmlValue = value;
	        },
	        template: '<span ng-bind-html="htmlValue"></span>'
	    };
	}

	maWysiwygColumn.$inject = ['$filter'];
	module.exports = exports['default'];

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = factories;
	function factories(fvp) {
	    fvp.registerFieldView('boolean', __webpack_require__(78));
	    fvp.registerFieldView('choice', __webpack_require__(79));
	    fvp.registerFieldView('choices', __webpack_require__(80));
	    fvp.registerFieldView('date', __webpack_require__(81));
	    fvp.registerFieldView('datetime', __webpack_require__(82));
	    fvp.registerFieldView('email', __webpack_require__(83));
	    fvp.registerFieldView('embedded_list', __webpack_require__(84));
	    fvp.registerFieldView('file', __webpack_require__(86));
	    fvp.registerFieldView('float', __webpack_require__(87));
	    fvp.registerFieldView('json', __webpack_require__(88));
	    fvp.registerFieldView('number', __webpack_require__(89));
	    fvp.registerFieldView('password', __webpack_require__(90));
	    fvp.registerFieldView('referenced_list', __webpack_require__(93));
	    fvp.registerFieldView('reference', __webpack_require__(91));
	    fvp.registerFieldView('reference_many', __webpack_require__(92));
	    fvp.registerFieldView('string', __webpack_require__(94));
	    fvp.registerFieldView('template', __webpack_require__(95));
	    fvp.registerFieldView('text', __webpack_require__(96));
	    fvp.registerFieldView('wysiwyg', __webpack_require__(97));
	}

	factories.$inject = ['FieldViewConfigurationProvider'];
	module.exports = exports['default'];

/***/ },
/* 60 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var BatchDeleteController = function () {
	    function BatchDeleteController($scope, $state, $translate, WriteQueries, progression, notification, view) {
	        _classCallCheck(this, BatchDeleteController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.$translate = $translate;
	        this.WriteQueries = WriteQueries;
	        this.progression = progression;
	        this.notification = notification;
	        this.view = view;
	        this.entity = view.getEntity();
	        this.entityIds = $state.params.ids;
	        this.selection = []; // fixme: query db to get selection
	        this.title = view.title();
	        this.description = view.description();
	        this.actions = view.actions();
	        this.loadingPage = false;
	        this.fields = view.fields();

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    _createClass(BatchDeleteController, [{
	        key: 'batchDelete',
	        value: function batchDelete() {
	            var _this = this;

	            var entityName = this.entity.name();
	            var $translate = this.$translate;
	            var $state = this.$state;
	            var progression = this.progression;
	            var notification = this.notification;

	            progression.start();
	            return this.WriteQueries.batchDelete(this.view, this.entityIds).then(function () {
	                return $state.go($state.get('list'), angular.extend({ entity: entityName }, $state.params));
	            })
	            // no need to call progression.done() in case of success, as it's called by the view dislayed afterwards
	            .then(function () {
	                return $translate('BATCH_DELETE_SUCCESS');
	            }).then(function (text) {
	                return notification.log(text, { addnCls: 'humane-flatty-success' });
	            }).catch(function (error) {
	                var errorMessage = _this.config.getErrorMessageFor(_this.view, error) | 'ERROR_MESSAGE';
	                progression.done();
	                $translate(errorMessage, {
	                    status: error && error.status,
	                    details: error && error.data && _typeof(error.data) === 'object' ? JSON.stringify(error.data) : {}
	                }).then(function (text) {
	                    return notification.log(text, { addnCls: 'humane-flatty-error' });
	                });
	            });
	        }
	    }, {
	        key: 'back',
	        value: function back() {
	            this.$state.go(this.$state.get('list'), angular.extend({
	                entity: this.entity.name()
	            }, this.$state.params));
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	            this.$state = undefined;
	            this.$translate = undefined;
	            this.WriteQueries = undefined;
	            this.progression = undefined;
	            this.notification = undefined;
	        }
	    }]);

	    return BatchDeleteController;
	}();

	exports.default = BatchDeleteController;


	BatchDeleteController.$inject = ['$scope', '$state', '$translate', 'WriteQueries', 'progression', 'notification', 'view'];
	module.exports = exports['default'];

/***/ },
/* 61 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DeleteController = function () {
	    function DeleteController($scope, $window, $state, $q, $translate, WriteQueries, Configuration, progression, notification, params, view, entry) {
	        var _this = this;

	        _classCallCheck(this, DeleteController);

	        this.$scope = $scope;
	        this.$window = $window;
	        this.$state = $state;
	        this.$translate = $translate;
	        this.WriteQueries = WriteQueries;
	        this.config = Configuration();
	        this.entityLabel = params.entity;
	        this.entityId = params.id;
	        this.view = view;
	        this.title = view.title();
	        this.description = view.description();
	        this.actions = view.actions();
	        this.entity = view.getEntity();
	        this.progression = progression;
	        this.notification = notification;
	        this.$scope.entry = entry;
	        this.$scope.view = view;

	        $scope.$on('$destroy', this.destroy.bind(this));

	        this.previousStateParametersDeferred = $q.defer();
	        $scope.$on('$stateChangeSuccess', function (event, to, toParams, from, fromParams) {
	            _this.previousStateParametersDeferred.resolve(fromParams);
	        });
	    }

	    _createClass(DeleteController, [{
	        key: 'deleteOne',
	        value: function deleteOne() {
	            var _this2 = this;

	            var entityName = this.entity.name();
	            var $translate = this.$translate;
	            var notification = this.notification;
	            var progression = this.progression;

	            progression.start();
	            return this.WriteQueries.deleteOne(this.view, this.entityId).then(function () {
	                return _this2.previousStateParametersDeferred.promise;
	            }).then(function (previousStateParameters) {
	                // if previous page was related to deleted entity, redirect to list
	                if (previousStateParameters.entity === entityName && previousStateParameters.id === _this2.entityId) {
	                    return _this2.$state.go(_this2.$state.get('list'), angular.extend({
	                        entity: entityName
	                    }, _this2.$state.params));
	                }
	                return _this2.back();
	            })
	            // no need to call progression.done() in case of success, as it's called by the view dislayed afterwards
	            .then(function () {
	                return $translate('DELETE_SUCCESS');
	            }).then(function (text) {
	                return notification.log(text, { addnCls: 'humane-flatty-success' });
	            }).catch(function (error) {
	                var errorMessage = _this2.config.getErrorMessageFor(_this2.view, error) | 'ERROR_MESSAGE';
	                progression.done();
	                $translate(errorMessage, {
	                    status: error && error.status,
	                    details: error && error.data && _typeof(error.data) === 'object' ? JSON.stringify(error.data) : {}
	                }).then(function (text) {
	                    return notification.log(text, { addnCls: 'humane-flatty-error' });
	                });
	            });
	        }
	    }, {
	        key: 'back',
	        value: function back() {
	            this.$window.history.back();
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	            this.$window = undefined;
	            this.$state = undefined;
	            this.$translate = undefined;
	            this.WriteQueries = undefined;
	            this.view = undefined;
	            this.entity = undefined;
	            this.progression = undefined;
	            this.notification = undefined;
	        }
	    }]);

	    return DeleteController;
	}();

	exports.default = DeleteController;


	DeleteController.$inject = ['$scope', '$window', '$state', '$q', '$translate', 'WriteQueries', 'NgAdminConfiguration', 'progression', 'notification', 'params', 'view', 'entry'];
	module.exports = exports['default'];

/***/ },
/* 62 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maButtonField;
	/**
	 * Toggle input
	 *
	 * @example <ma-button-field type="text" field="field" value="value"></ma-button-field>
	 */
	function maButtonField() {
	    return {
	        scope: {
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: function link(scope, element) {
	            var field = scope.field();
	            scope.name = field.name();
	            scope.label = field.label();
	            scope.value = !!scope.value;
	            var a = element.children()[0];
	            var attributes = field.attributes();
	            for (var name in attributes) {
	                a.setAttribute(name, attributes[name]);
	            }
	            scope.toggle = function () {
	                this.value = !this.value;
	            };
	            scope.isActive = function () {
	                return !!this.value;
	            };
	        },
	        template: '<a class="btn btn-default" ng-click="toggle()" id="{{ name }}" ng-class="{active: isActive()}" >{{ label | translate }}</a>'
	    };
	}

	maButtonField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 63 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maCheckboxField;
	/**
	 * Generic edition field
	 *
	 * @example <ma-checkbox-field type="text" field="field" value="value"></ma-checkbox-field>
	 */
	function maCheckboxField() {
	    return {
	        scope: {
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: function link(scope, element) {
	            var field = scope.field();
	            scope.name = field.name();
	            scope.v = field.validation();
	            scope.value = !!scope.value;
	            var input = element.children()[0];
	            var attributes = field.attributes();
	            for (var name in attributes) {
	                input.setAttribute(name, attributes[name]);
	            }
	        },
	        template: '<input type="checkbox" ng-model="value" id="{{ name }}" name="{{ name }}" class="form-control" />'
	    };
	}

	maCheckboxField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 64 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maChoiceField;
	function updateChoices(scope, choices) {
	    scope.choices = choices;
	    scope.$root.$$phase || scope.$digest();
	}

	function maChoiceField($compile) {
	    return {
	        scope: {
	            'field': '&',
	            'value': '=',
	            'entry': '=?',
	            'datastore': '&?',
	            'refresh': '&',
	            'choices': '&?'
	        },
	        restrict: 'E',
	        compile: function compile() {
	            return {
	                pre: function pre(scope, element) {
	                    var field = scope.field();
	                    var attributes = field.attributes();
	                    scope.placeholder = attributes && attributes.placeholder || 'FILTER_VALUES';
	                    scope.name = field.name();
	                    scope.v = field.validation();
	                    scope.$watch('value', function (newValue, oldValue) {
	                        if (newValue !== oldValue && newValue === undefined) {
	                            // fix for https://github.com/angular-ui/ui-select/issues/863
	                            scope.value = null;
	                        }
	                    });

	                    var refreshAttributes = '';
	                    var itemsFilter = '| filter: {label: $select.search}';
	                    if (field.type().indexOf('reference') === 0 && field.remoteComplete()) {
	                        // FIXME wrong place to do that
	                        scope.refreshDelay = field.remoteCompleteOptions().refreshDelay;
	                        refreshAttributes = 'refresh-delay="refreshDelay" refresh="refresh({ $search: $select.search })"';
	                        itemsFilter = '';
	                    }

	                    var choices = typeof scope.choices == 'function' && scope.choices() ? scope.choices() : field.choices ? field.choices() : [];

	                    var template = '\n                        <ui-select ng-model="$parent.value" ng-required="v.required" id="{{ name }}" name="{{ name }}">\n                            <ui-select-match allow-clear="{{ !v.required }}" placeholder="{{ placeholder | translate }}">{{ $select.selected.label | translate }}</ui-select-match>\n                            <ui-select-choices ' + refreshAttributes + ' repeat="item.value as item in choices ' + itemsFilter + '  track by $index">\n                                {{ item.label | translate }}\n                            </ui-select-choices>\n                        </ui-select>';

	                    // as choices may be a function depending of another entry field, we need to watch the whole entry
	                    scope.$watch('entry', function (newEntry, oldEntry) {
	                        if (typeof choices !== 'function') {
	                            scope.choices = choices;
	                            return;
	                        }

	                        scope.choices = choices(newEntry);
	                        if (!angular.equals(scope.choices, choices(oldEntry))) {
	                            scope.value = null;
	                        }
	                    }, true);

	                    element.html(template);

	                    var select = element.children()[0];
	                    for (var name in attributes) {
	                        select.setAttribute(name, attributes[name]);
	                    }

	                    $compile(element.contents())(scope);
	                },
	                post: function post(scope) {
	                    scope.$on('choices:update', function (e, data) {
	                        updateChoices(scope, data.choices);
	                    });
	                }
	            };
	        }
	    };
	}

	maChoiceField.$inject = ['$compile'];
	module.exports = exports['default'];

/***/ },
/* 65 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maChoicesField;
	/**
	 * Edition field for a selection of elements in a list - a multiple select.
	 *
	 * @example <ma-choices-field entry="entry" field="field" value="value"></ma-choices-field>
	 */
	function maChoicesField($compile) {
	    'use strict';

	    return {
	        scope: {
	            'field': '&',
	            'value': '=',
	            'entry': '=?',
	            'datastore': '&?',
	            'refresh': '&'
	        },
	        restrict: 'E',
	        compile: function compile() {
	            return {
	                pre: function pre(scope, element) {
	                    var field = scope.field();
	                    var attributes = field.attributes();
	                    scope.placeholder = attributes && attributes.placeholder || 'FILTER_VALUES';
	                    scope.name = field.name();
	                    scope.v = field.validation();

	                    var refreshAttributes = '';
	                    var itemsFilter = '| filter: {label: $select.search}';
	                    if (field.type().indexOf('reference') === 0 && field.remoteComplete()) {
	                        scope.refreshDelay = field.remoteCompleteOptions().refreshDelay;
	                        refreshAttributes = 'refresh-delay="refreshDelay" refresh="refresh({ $search: $select.search })"';
	                        itemsFilter = '';
	                    }

	                    var choices = field.choices ? field.choices() : [];

	                    scope.onRemove = function () {
	                        scope.refresh({ $search: this.$select.search });
	                    };

	                    var template = '\n                        <ui-select ' + (scope.v.required ? 'ui-select-required' : '') + ' multiple on-remove="onRemove()" ng-model="$parent.value" ng-required="v.required" id="{{ name }}" name="{{ name }}">\n                            <ui-select-match placeholder="{{ placeholder | translate }}">{{ $item.label | translate }}</ui-select-match>\n                            <ui-select-choices ' + refreshAttributes + ' repeat="item.value as item in choices ' + itemsFilter + '">\n                                {{ item.label | translate }}\n                            </ui-select-choices>\n                        </ui-select>';

	                    scope.choices = typeof choices === 'function' ? choices(scope.entry) : choices;
	                    element.html(template);

	                    var select = element.children()[0];

	                    for (var name in attributes) {
	                        select.setAttribute(name, attributes[name]);
	                    }

	                    $compile(element.contents())(scope);
	                },
	                post: function post(scope) {
	                    scope.$on('choices:update', function (e, data) {
	                        scope.choices = data.choices;
	                        scope.$root.$$phase || scope.$digest();
	                    });
	                }
	            };
	        }
	    };
	}

	maChoicesField.$inject = ['$compile'];
	module.exports = exports['default'];

/***/ },
/* 66 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDateField;
	/**
	 * Edition field for a date - a text input with a datepicker.
	 *
	 * @example <ma-date-field field="field" value="value"></ma-date-field>
	 */
	function maDateField() {
	    return {
	        scope: {
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: function link(scope, element) {
	            var field = scope.field();
	            scope.name = field.name();
	            scope.rawValue = scope.value == null ? null : scope.value instanceof Date ? scope.value : new Date(scope.value);
	            scope.$watch('rawValue', function (rawValue) {
	                scope.value = field.parse()(rawValue);
	            });
	            scope.format = field.format();
	            if (!scope.format) {
	                scope.format = field.type() === 'date' ? 'yyyy-MM-dd' : 'yyyy-MM-dd HH:mm:ss';
	            }

	            scope.v = field.validation();
	            scope.isOpen = false;
	            var input = element.find('input').eq(0);
	            var attributes = field.attributes();
	            for (var name in attributes) {
	                input.attr(name, attributes[name]);
	            }
	            scope.toggleDatePicker = function ($event) {
	                $event.preventDefault();
	                $event.stopPropagation();
	                scope.isOpen = !scope.isOpen;
	            };
	        },
	        template: '<div class="input-group datepicker">\n    <input\n        type="text" ng-model="rawValue" id="{{ name }}" name="{{ name }}" class="form-control"\n        uib-datepicker-popup="{{ format }}" is-open="isOpen" ng-required="v.required"\n        close-text="{{ \'CLOSE\' | translate }}" clear-text="{{ \'CLEAR\' | translate }}" current-text="{{ \'CURRENT\' | translate }}"/>\n    <span class="input-group-btn">\n        <button type="button" class="btn btn-default" ng-click="toggleDatePicker($event)">\n            <i class="glyphicon glyphicon-calendar"></i>\n        </button>\n    </span>\n</div>'
	    };
	}

	maDateField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maEmbeddedListField;

	var _Entry = __webpack_require__(4);

	var _Entry2 = _interopRequireDefault(_Entry);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function maEmbeddedListField() {
	    return {
	        scope: {
	            'field': '&',
	            'value': '=',
	            'datastore': '&'
	        },
	        restrict: 'E',
	        link: {
	            pre: function pre(scope) {
	                var field = scope.field();
	                var targetEntity = field.targetEntity();
	                var targetEntityName = targetEntity.name();
	                var targetFields = field.targetFields();
	                var sortField = field.sortField();
	                var sortDir = field.sortDir() === 'DESC' ? -1 : 1;
	                var filterFunc;
	                if (field.permanentFilters()) {
	                    (function () {
	                        var filters = field.permanentFilters();
	                        var filterKeys = Object.keys(filters);
	                        filterFunc = function filterFunc(entry) {
	                            return filterKeys.reduce(function (isFiltered, key) {
	                                return isFiltered && entry.values[key] === filters[key];
	                            }, true);
	                        };
	                    })();
	                } else {
	                    filterFunc = function filterFunc() {
	                        return true;
	                    };
	                }
	                scope.fields = targetFields;
	                scope.targetEntity = targetEntity;
	                scope.entries = _Entry2.default.createArrayFromRest(scope.value || [], targetFields, targetEntityName, targetEntity.identifier().name()).sort(function (entry1, entry2) {
	                    // use < and > instead of substraction to sort strings properly
	                    if (entry1.values[sortField] > entry2.values[sortField]) {
	                        return sortDir;
	                    }
	                    if (entry1.values[sortField] < entry2.values[sortField]) {
	                        return -1 * sortDir;
	                    }
	                    return 0;
	                }).filter(filterFunc);
	                scope.addNew = function () {
	                    return scope.entries.push(_Entry2.default.createForFields(targetFields));
	                };
	                scope.remove = function (entry) {
	                    scope.entries = scope.entries.filter(function (e) {
	                        return e !== entry;
	                    });
	                };
	                scope.$watch('entries', function (newEntries, oldEntries) {
	                    if (newEntries === oldEntries) {
	                        return;
	                    }
	                    scope.value = newEntries.map(function (e) {
	                        return e.transformToRest(targetFields);
	                    });
	                }, true);
	            }
	        },
	        template: '\n<div class="row"><div class="col-sm-12">\n    <ng-form ng-repeat="entry in entries track by $index" class="subentry" name="subform_{{$index}}" ng-init="formName = \'subform_\' + $index">\n        <div class="remove_button_container">\n            <a class="btn btn-default btn-sm" ng-click="remove(entry)"><span class="glyphicon glyphicon-minus-sign" aria-hidden="true"></span>&nbsp;<span translate="REMOVE"></span></a>\n        </div>\n        <div class="form-field form-group" ng-repeat="field in ::fields track by $index">\n            <ma-field field="::field" value="entry.values[field.name()]" entry="entry" entity="::targetEntity" form="formName" datastore="::datastore()"></ma-field>\n        </div>\n        <hr/>\n    </ng-form>\n    <div class="form-group">\n        <div class="col-sm-offset-2 col-sm-10">\n            <a class="btn btn-default btn-sm" ng-click="addNew()"><span class="glyphicon glyphicon-plus-sign" aria-hidden="true"></span>&nbsp;<span translate="ADD_NEW" translate-values="{ name: field().name() }"></span></a>\n        </div>\n    </div>\n</div></div>'
	    };
	}

	maEmbeddedListField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 68 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maField;
	function maField(FieldViewConfiguration, $compile) {
	    return {
	        restrict: 'E',
	        scope: {
	            field: '&',
	            entry: '=',
	            value: '=',
	            entity: '&',
	            form: '&',
	            datastore: '&'
	        },
	        link: function link(scope, element) {
	            var field = scope.field();
	            var type = field.type();
	            scope.field = field;
	            scope.type = type;
	            scope.entity = scope.entity();
	            scope.form = scope.form();
	            scope.datastore = scope.datastore();
	            scope.getCssClasses = function (entry) {
	                return 'ng-admin-field-' + field.name().replace('.', '_') + ' ng-admin-type-' + type + ' ' + (field.getCssClasses(entry) || 'col-sm-10 col-md-8 col-lg-7');
	            };

	            scope.getInput = function () {
	                return scope.form[field.name()];
	            };

	            /**
	             * Should validation status be displayed for a given field?
	             *
	             * - No for non-editable fields, or template fields which not have a corresponding input
	             * - No for non-altered input
	             * - Yes otherwise
	             */
	            scope.fieldHasValidation = function () {
	                var input = this.getInput();
	                return input && input.$dirty;
	            };

	            scope.fieldIsValid = function () {
	                var input = this.getInput();
	                return input && input.$valid;
	            };

	            scope.getFieldValidationClass = function () {
	                if (this.fieldHasValidation()) {
	                    return this.fieldIsValid() ? 'has-success' : 'has-error';
	                }
	            };

	            var fieldTemplate;
	            if (scope.field.editable()) {
	                fieldTemplate = '<div ng-class="getCssClasses(entry)">\n    ' + (!field.templateIncludesLabel() && field.getTemplateValue(scope.entry) || FieldViewConfiguration[type].getWriteWidget()) + '\n    <span ng-show="fieldHasValidation()" class="glyphicon form-control-feedback" ng-class="fieldIsValid() ? \'glyphicon-ok\' : \'glyphicon-remove\'"></span>\n</div>';
	            } else {
	                fieldTemplate = '<div ng-class="field.getCssClasses(entry)||\'col-sm-10\'">\n    <p class="form-control-static">\n        <ma-column field="::field" entry="::entry" entity="::entity" datastore="::datastore"></ma-column>\n    </p>\n</div>';
	            }

	            var template = '<div id="row-{{ field.name() }}" class="form-field form-group has-feedback" ng-class="getFieldValidationClass()">\n    <label for="{{ field.name() }}" class="col-sm-2 control-label">\n        {{ field.label() | translate }}<span ng-if="field.validation().required">&nbsp;*</span>&nbsp;\n    </label>\n    ' + fieldTemplate + '\n</div>';

	            element.append(template);
	            $compile(element.contents())(scope);
	        }
	    };
	}

	maField.$inject = ['FieldViewConfiguration', '$compile'];
	module.exports = exports['default'];

/***/ },
/* 69 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maFileField;
	/**
	 * Edition field for a file - a file uploader.
	 *
	 * @example <ma-file-field field="field"></ma-file-field>
	 */
	function maFileField(Upload) {
	    return {
	        scope: {
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: {
	            pre: function pre(scope) {
	                var uploadInformation = scope.field().uploadInformation();
	                if (!uploadInformation.hasOwnProperty('url')) {
	                    throw new Error('You must provide a URL property to allow the upload of files.');
	                }

	                scope.multiple = uploadInformation.hasOwnProperty('multiple') ? uploadInformation.multiple : false;
	                scope.accept = "*";
	                if (uploadInformation.hasOwnProperty('accept')) {
	                    scope.accept = uploadInformation.accept;
	                }
	                scope.apifilename = uploadInformation.hasOwnProperty('apifilename') ? uploadInformation.apifilename : false;

	                var files = scope.value ? scope.value.split(',') : [];
	                scope.files = {};
	                for (var file in files) {
	                    scope.files[files[file]] = {
	                        "name": files[file],
	                        "progress": 0
	                    };
	                }
	            },
	            post: function post(scope, element) {
	                var field = scope.field();
	                scope.name = field.name();
	                scope.v = field.validation();
	                if (scope.value) {
	                    scope.v.required = false;
	                }
	                var input = element.find('input')[0];
	                var attributes = field.attributes();
	                for (var name in attributes) {
	                    input.setAttribute(name, attributes[name]);
	                }

	                scope.fileSelected = function (selectedFiles) {
	                    if (!selectedFiles || !selectedFiles.length) {
	                        return;
	                    }

	                    var uploadParams;

	                    scope.files = {};
	                    for (var file in selectedFiles) {
	                        uploadParams = angular.copy(scope.field().uploadInformation());
	                        uploadParams.file = selectedFiles[file];
	                        Upload.upload(uploadParams).progress(function (evt) {
	                            scope.files[evt.config.file.name] = {
	                                "name": evt.config.file.name,
	                                "progress": Math.min(100, parseInt(100.0 * evt.loaded / evt.total))
	                            };
	                        }).success(function (data, status, headers, config) {
	                            scope.files[config.file.name] = {
	                                "name": scope.apifilename ? data[scope.apifilename] : config.file.name,
	                                "progress": 0
	                            };
	                            if (scope.apifilename) {
	                                var apiNames = Object.keys(scope.files).map(function (fileindex) {
	                                    return scope.files[fileindex].name;
	                                });
	                                scope.value = apiNames.join(',');
	                            } else {
	                                scope.value = Object.keys(scope.files).join(',');
	                            }
	                        }).error(function (data, status, headers, config) {
	                            delete scope.files[config.file.name];

	                            scope.value = Object.keys(scope.files).join(',');
	                        });
	                    }
	                };

	                scope.selectFile = function () {
	                    input.click();
	                };
	            }
	        },
	        template: '<div class="row">\n    <div class="col-md-2">\n        <a class="btn btn-default" ng-click="selectFile()">\n            <span translate="BROWSE"></span>\n        </a>\n    </div>\n    <div class="col-md-10">\n        <div class="row" ng-repeat="file in files track by $index">\n            <div class="col-md-3" style="padding-top: 6px;">\n                <div class="progress" style="margin-bottom: 0;" ng-if="file.progress">\n                    <div class="progress-bar" role="progressbar" aria-valuenow="{{ file.progress }}" aria-valuemin="0" aria-valuemax="100" style="width: {{ file.progress }}%;">\n                        <span class="sr-only" translate="N_COMPLETE" translate-values="{ progress: file.progress }"></span>\n                    </div>\n                </div>\n            </div>\n            <div class="col-md-9" style="padding-top: 6px;"><small><em>{{ file.name }}<em><small></div>\n        </div>\n    </div>\n</div>\n<input type="file" ngf-multiple="multiple" accept="{{ accept }}" ngf-select="fileSelected($files)"\n       id="{{ name }}" name="{{ name }}" ng-required="v.required" style="display:none" />'
	    };
	}

	maFileField.$inject = ['Upload'];
	module.exports = exports['default'];

/***/ },
/* 70 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maInputField;
	/**
	 * Generic edition field
	 *
	 * @example <ma-input-field type="text" field="field" value="value"></ma-input-field>
	 */
	function maInputField() {
	    return {
	        scope: {
	            'type': '@',
	            'step': '@?',
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: function link(scope, element) {
	            var field = scope.field();
	            scope.name = field.name();
	            scope.v = field.validation();
	            var input = element.children()[0];
	            var attributes = field.attributes();
	            for (var name in attributes) {
	                if (name === 'step') {
	                    // allow to use `step` attribute instead of `scope.step`
	                    scope.step = attributes[name];
	                    continue;
	                }

	                input.setAttribute(name, attributes[name]);
	            }
	        },
	        template: '<input type="{{ type || \'text\' }}" ng-attr-step="{{ step }}" ng-model="value"\n    id="{{ name }}" name="{{ name }}" class="form-control"\n    ng-required="v.required" ng-minlength="v.minlength" ng-maxlength="v.maxlength" ng-pattern="v.pattern" />'
	    };
	}

	maInputField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maJsonField;
	var codemirror = __webpack_require__(2);

	global.jsonlint = __webpack_require__(159);

	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(140);
	__webpack_require__(139);
	__webpack_require__(141);
	__webpack_require__(142);

	codemirror.defineOption("matchBrackets", true);
	codemirror.defineOption("autoCloseBrackets", true);
	codemirror.defineOption("lineWrapping", true);
	codemirror.defineOption("tabSize", 2);
	codemirror.defineOption("mode", "application/json");
	codemirror.defineOption("gutters", ["CodeMirror-lint-markers"]);
	codemirror.defineOption("lint", true);
	codemirror.defineOption("styleActiveLine", true);

	global.CodeMirror = codemirror;

	/**
	 * Edition field for a JSON string in a textarea.
	 *
	 * @example <ma-json-field field="field" value="value"></ma-json-field>
	 */
	function maJsonField() {
	    return {
	        scope: {
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: function link(scope, element) {
	            var field = scope.field();
	            scope.name = field.name();
	            scope.v = field.validation();
	            scope.jsonValue = scope.value === null ? '' : angular.toJson(scope.value, true);
	            var input = element.children()[0];
	            var attributes = field.attributes();
	            for (var name in attributes) {
	                input.setAttribute(name, attributes[name]);
	            }
	            scope.$watch('jsonValue', function (jsonValue) {
	                if (jsonValue == '' || typeof jsonValue === 'undefined') {
	                    scope.value = null;

	                    return;
	                }
	                try {
	                    var value = angular.fromJson(jsonValue);
	                    scope.value = value;
	                } catch (e) {
	                    // incorrect JSON, do not convert back to value
	                }
	            });
	        },
	        template: '<textarea ui-codemirror ng-model="jsonValue" id="{{ name }}" name="{{ name }}" ng-required="v.required" ma-json-validator>' + '</textarea>'
	    };
	}

	maJsonField.$inject = [];
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 72 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maReferenceField;
	function maReferenceField(ReferenceRefresher) {
	    return {
	        scope: {
	            'field': '&',
	            'value': '=',
	            'entry': '=?',
	            'datastore': '&?'
	        },
	        restrict: 'E',
	        link: function link(scope) {
	            var field = scope.field();
	            var identifierName = field.targetEntity().identifier().name();
	            scope.name = field.name();
	            scope.v = field.validation();

	            if (!field.remoteComplete()) {
	                // fetch choices from the datastore, populated during routing resolve
	                var initialEntries = scope.datastore().getEntries(field.targetEntity().uniqueId + '_choices');
	                if (scope.value) {
	                    var isCurrentValueInInitialEntries = initialEntries.filter(function (e) {
	                        return e.identifierValue === scope.value;
	                    }).length > 0;
	                    if (!isCurrentValueInInitialEntries) {
	                        initialEntries.unshift(scope.datastore().getEntries(field.targetEntity().uniqueId + '_values').find(function (entry) {
	                            return entry.values[identifierName] == scope.value;
	                        }));
	                    }
	                }
	                var initialChoices = initialEntries.map(function (entry) {
	                    return {
	                        value: entry.values[identifierName],
	                        label: entry.values[field.targetField().name()]
	                    };
	                });
	                scope.$broadcast('choices:update', { choices: initialChoices });
	            } else {
	                // ui-select doesn't allow to prepopulate autocomplete selects, see https://github.com/angular-ui/ui-select/issues/1197
	                // let ui-select fetch the options using the ReferenceRefresher
	                scope.refresh = function refresh(search) {
	                    return ReferenceRefresher.refresh(field, scope.value, search).then(function addCurrentChoice(results) {
	                        if (!search && scope.value) {
	                            var isCurrentValueInEntries = results.filter(function (e) {
	                                return e.value === scope.value;
	                            }).length > 0;
	                            if (!isCurrentValueInEntries) {
	                                var currentEntry = scope.datastore().getEntries(field.targetEntity().uniqueId + '_values').find(function (entry) {
	                                    return entry.values[identifierName] == scope.value;
	                                });
	                                results.unshift({
	                                    value: currentEntry.values[identifierName],
	                                    label: currentEntry.values[field.targetField().name()]
	                                });
	                            }
	                        }
	                        return results;
	                    }).then(function (formattedResults) {
	                        scope.$broadcast('choices:update', { choices: formattedResults });
	                    });
	                };
	            }
	        },
	        template: '<ma-choice-field\n                field="field()"\n                datastore="datastore()"\n                refresh="refresh($search)"\n                value="value">\n            </ma-choice-field>'
	    };
	}

	maReferenceField.$inject = ['ReferenceRefresher'];
	module.exports = exports['default'];

/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maReferenceManyField;
	function maReferenceManyField(ReferenceRefresher) {
	    return {
	        scope: {
	            'field': '&',
	            'value': '=',
	            'entry': '=?',
	            'datastore': '&?'
	        },
	        restrict: 'E',
	        link: function link(scope) {
	            var field = scope.field();
	            var identifierName = field.targetEntity().identifier().name();
	            scope.name = field.name();
	            scope.v = field.validation();
	            scope.choices = [];

	            var setInitialChoices = function setInitialChoices(initialEntries) {
	                if (scope.value && scope.value.length) {
	                    scope.value.map(function (value) {
	                        var isCurrentValueInInitialEntries = initialEntries.filter(function (e) {
	                            return e.identifierValue === value;
	                        }).length > 0;
	                        if (value && !isCurrentValueInInitialEntries) {
	                            initialEntries.push(scope.datastore().getEntries(field.targetEntity().uniqueId + '_values').filter(function (entry) {
	                                return entry.values[identifierName] == value;
	                            }).pop());
	                        }
	                    });
	                }
	                var initialChoices = initialEntries.map(function (entry) {
	                    return {
	                        value: entry.values[identifierName],
	                        label: entry.values[field.targetField().name()]
	                    };
	                });
	                scope.$broadcast('choices:update', { choices: initialChoices });
	            };

	            if (!field.remoteComplete()) {
	                // fetch choices from the datastore
	                var initialEntries = scope.datastore().getEntries(field.targetEntity().uniqueId + '_choices');
	                setInitialChoices(initialEntries);
	            } else {
	                var _initialEntries = [];
	                setInitialChoices(_initialEntries);

	                // ui-select doesn't allow to prepopulate autocomplete selects, see https://github.com/angular-ui/ui-select/issues/1197
	                // let ui-select fetch the options using the ReferenceRefresher
	                scope.refresh = function (search) {
	                    return ReferenceRefresher.refresh(field, scope.value, search).then(function (formattedResults) {
	                        scope.$broadcast('choices:update', { choices: formattedResults });
	                    });
	                };
	            }
	        },
	        template: '<ma-choices-field\n                field="field()"\n                datastore="datastore()"\n                refresh="refresh($search)"\n                value="value">\n            </ma-choices-field>'
	    };
	}

	maReferenceManyField.$inject = ['ReferenceRefresher'];
	module.exports = exports['default'];

/***/ },
/* 74 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maTemplateField;
	function maTemplateField() {
	    return {
	        restrict: 'E',
	        scope: {
	            field: '&',
	            entry: '&',
	            entity: '&',
	            value: '=',
	            values: '='
	        },
	        link: function link(scope) {
	            scope.field = scope.field();
	            scope.entry = scope.entry();
	            scope.entity = scope.entity();
	        },
	        template: '<span compile="field.getTemplateValue(entry)"></span>'
	    };
	}

	maTemplateField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 75 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maTextField;
	/**
	 * Edition field for a multiline string - a textarea.
	 *
	 * @example <ma-text-field field="field" value="value"></ma-text-field>
	 */
	function maTextField() {
	    return {
	        scope: {
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: function link(scope, element) {
	            var field = scope.field();
	            scope.name = field.name();
	            scope.v = field.validation();
	            var input = element.children()[0];
	            var attributes = field.attributes();
	            for (var name in attributes) {
	                input.setAttribute(name, attributes[name]);
	            }
	        },
	        template: '<textarea ng-model="value" id="{{ name }}" name="{{ name }}" class="form-control"\n    ng-required="v.required" ng-minlength="v.minlength" ng-maxlength="v.maxlength" ng-pattern="v.pattern">\n</textarea>'
	    };
	}

	maTextField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maWysiwygField;
	/**
	 * Edition field for a multiline HTML string - a rich text editor.
	 *
	 * @example <ma-wysiwyg-field field="field" value="value"></ma-wysiwyg-field>
	 */
	function maWysiwygField() {
	    return {
	        scope: {
	            'field': '&',
	            'value': '='
	        },
	        restrict: 'E',
	        link: function link(scope, element) {
	            var field = scope.field();
	            scope.name = field.name();
	        },
	        template: '<div text-angular ta-unsafe-sanitizer="{{ !field.sanitize() }}" ng-model="value" id="{{ name }}" name="{{ name }}" ' + 'ta-text-editor-class="border-around" ta-html-editor-class="border-around">' + '</div>'
	    };
	}

	maWysiwygField.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 77 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = uiSelectRequired;
	/**
	 * Directive created to fix a bug with ui-select and multiple required values.
	 * @see https://github.com/angular-ui/ui-select/issues/258
	 */
	function uiSelectRequired() {
	    return {
	        restrict: 'A',
	        require: 'ngModel',
	        link: function link(scope, elm, attrs, ctrl) {
	            ctrl.$validators.uiSelectRequired = function (modelValue, viewValue) {
	                var determineVal;
	                if (angular.isArray(modelValue)) {
	                    determineVal = modelValue;
	                } else if (angular.isArray(viewValue)) {
	                    determineVal = viewValue;
	                } else {
	                    return false;
	                }

	                return determineVal.length > 0;
	            };
	        }
	    };
	}

	uiSelectRequired.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 78 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-boolean-column value="::value"></ma-boolean-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-choice-field field="::field" value="value" choices="::field.filterChoices()"></ma-choice-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<div class="row">\n        <ma-choice-field class="col-sm-4 col-md-3" ng-if="!field.validation().required" field="::field" value="$parent.value"></ma-choice-field>\n        <ma-checkbox-field class="col-sm-4 col-md-3" ng-if="!!field.validation().required" field="::field" value="$parent.value"></ma-checkbox-field>\n    </div>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 79 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-string-column value="::field.getLabelForChoice(value, entry)"></ma-string-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-choice-field field="::field" value="value"></ma-choice-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-choice-field field="::field" entry="entry" value="value"></ma-choice-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 80 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-choices-column values="::value"></ma-choices-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-choices-field field="::field" value="value"></ma-choices-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-choices-field field="::field" entry="::entry" value="value"></ma-choices-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-date-column field="::field" value="::value"></ma-date-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-date-field field="::field" value="value"></ma-date-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<div class="date_widget"><ma-date-field field="::field" value="value"></ma-date-field></div>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-date-column field="::field" value="::value"></ma-date-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-date-field field="::field" value="value"></ma-date-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<div class="datetime_widget"><ma-date-field field="::field" value="value"></ma-date-field></div>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 83 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-string-column value="::value"></ma-string-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-input-field field="::field" value="value"></ma-input-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-input-field type="email" field="::field" value="value"></ma-input-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-embedded-list-column field="::field" value="::value" datastore="::datastore"></ma-embedded-list-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return 'error: cannot display referenced_list field as linkable';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return 'error: cannot display referenced_list field as filter';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-embedded-list-field field="::field" value="value" datastore="::datastore"></ma-embedded-list-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 85 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FieldViewConfiguration = function () {
	    function FieldViewConfiguration() {
	        _classCallCheck(this, FieldViewConfiguration);

	        this.fieldViews = {};
	    }

	    _createClass(FieldViewConfiguration, [{
	        key: "registerFieldView",
	        value: function registerFieldView(type, FieldView) {
	            this.fieldViews[type] = FieldView;
	        }
	    }, {
	        key: "$get",
	        value: function $get() {
	            return this.fieldViews;
	        }
	    }]);

	    return FieldViewConfiguration;
	}();

	exports.default = FieldViewConfiguration;


	FieldViewConfiguration.$inject = [];
	module.exports = exports["default"];

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return 'error: cannot display file field as readable';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return 'error: cannot display file field as linkable';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return 'error: cannot display file field as filter';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-file-field field="::field" value="value"></ma-file-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 87 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-number-column field="::field" value="::value"></ma-number-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-input-field type="number" step="any" field="::field" value="value"></ma-input-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-input-field type="number" step="any" field="::field" value="value"></ma-input-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 88 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-json-column value="::value"></ma-json-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return 'error: cannot display a json field as linkable';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-input-field field="::field" value="value"></ma-input-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-json-field field="::field" value="value"></ma-json-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-number-column field="::field" value="::value"></ma-number-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-input-field type="number" field="::field" value="value"></ma-input-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-input-field type="number" field="::field" value="value"></ma-input-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 90 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return 'error: cannot display password field as readable';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return 'error: cannot display password field as linkable';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return 'error: cannot display password field as filter';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-input-field type="password" field="::field" value="value"></ma-input-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 91 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-reference-column field="::field" value="::value" datastore="::datastore"></ma-reference-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<ma-reference-link-column entry="::entry" field="::field" value="::value" datastore="::datastore"></ma-reference-link-column>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-reference-field field="::field" value="value" datastore="::datastore"></ma-reference-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-reference-field field="::field" value="value" datastore="::datastore"></ma-reference-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 92 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-choices-column values="::entry.listValues[field.name()]"></ma-choices-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<ma-reference-many-link-column ids="::value" values="::entry.listValues[field.name()]" field="::field"></ma-reference-many-link-column>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-reference-many-field field="::field" value="value" datastore="::datastore"></ma-reference-many-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-reference-many-field field="::field" value="value" datastore="::datastore"></ma-reference-many-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-referenced-list-column field="::field" datastore="::datastore"></ma-referenced-list-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return 'error: cannot display referenced_list field as linkable';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return 'error: cannot display referenced_list field as filter';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-referenced-list-column field="::field" datastore="::datastore"></ma-referenced-list-column>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 94 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-string-column value="::value"></ma-string-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-input-field field="::field" value="value"></ma-input-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-input-field field="::field" value="value"></ma-input-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 95 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-template-column entry="::entry" field="::field" entity="::entity"></ma-template-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-template-field field="::field" value="value" values="values" filters="filters"></ma-template-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-template-field field="::field" value="value" entry="entry" entity="::entity"></ma-template-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 96 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-string-column value="::value"></ma-string-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-input-field field="::field" value="value"></ma-input-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-text-field field="::field" value="value"></ma-text-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 97 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    getReadWidget: function getReadWidget() {
	        return '<ma-wysiwyg-column field="::field" value="::value"></ma-wysiwyg-column>';
	    },
	    getLinkWidget: function getLinkWidget() {
	        return '<a ui-sref="{{detailState}}(detailStateParams)">' + module.exports.getReadWidget() + '</a>';
	    },
	    getFilterWidget: function getFilterWidget() {
	        return '<ma-input-field field="::field" value="value"></ma-input-field>';
	    },
	    getWriteWidget: function getWriteWidget() {
	        return '<ma-wysiwyg-field field="::field" value="value"></ma-wysiwyg-field>';
	    }
	};
	module.exports = exports['default'];

/***/ },
/* 98 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maFilter;
	function maFilter(FieldViewConfiguration, $compile) {
	    return {
	        restrict: 'E',
	        scope: {
	            field: '=',
	            datastore: '&',
	            values: '=',
	            value: '='
	        },
	        link: function link(scope, element) {
	            scope.datastore = scope.datastore();
	            element.append(scope.field.getTemplateValue(scope.values) || FieldViewConfiguration[scope.field.type()].getFilterWidget());
	            $compile(element.contents())(scope);
	        }
	    };
	}

	maFilter.$inject = ['FieldViewConfiguration', '$compile'];
	module.exports = exports['default'];

/***/ },
/* 99 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maFilterForm;
	function maFilterForm() {
	    return {
	        restrict: 'E',
	        scope: {
	            filters: '=',
	            datastore: '&',
	            values: '=',
	            removeFilter: '&'
	        },
	        link: function link(scope) {
	            scope.datastore = scope.datastore();
	            scope.removeFilter = scope.removeFilter();
	            scope.shouldFilter = function () {
	                return Object.keys(scope.filters).length;
	            };
	        },
	        template: '<div class="row">\n    <form class="filters col-md-offset-6 col-md-6 form-horizontal" ng-if="shouldFilter()">\n        <div class="filter {{ field.name() }} form-group input-{{ field.type() }}" ng-repeat="field in filters track by field.name()">\n            <div class="col-sm-1 col-xs-1 remove_filter">\n                <a ng-if="!field.pinned()" ng-click="removeFilter(field)"><span class="glyphicon glyphicon-remove"></span></a>\n            </div>\n            <label for="{{ field.name() }}" class="col-sm-4 col-xs-11 control-label">\n                {{ field.label() | translate }}<span ng-if="field.validation().required">&nbsp;*</span>&nbsp;\n            </label>\n            <div class="col-sm-7" ng-switch="field.type()" ng-class="field.getCssClasses(entry)">\n                <ma-filter field="::field" value="values[field.name()]" values="values" datastore="datastore"></ma-filter>\n            </div>\n        </div>\n    </form>\n</div>'
	    };
	}

	maFilterForm.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 100 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FormController = function () {
	    function FormController($scope, $state, $injector, $translate, previousState, WriteQueries, Configuration, progression, notification, view, dataStore) {
	        _classCallCheck(this, FormController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.$injector = $injector;
	        this.$translate = $translate;
	        this.previousState = previousState;
	        this.WriteQueries = WriteQueries;
	        this.dataStore = dataStore;
	        this.progression = progression;
	        this.notification = notification;
	        this.title = view.title();
	        this.description = view.description();
	        this.actions = view.actions();
	        this.fields = view.fields();
	        this.config = Configuration();
	        this.view = view;
	        this.entity = this.view.getEntity();
	        this.$scope.entry = dataStore.getFirstEntry(this.entity.uniqueId);
	        this.$scope.view = view;
	        this.$scope.entity = this.entity;

	        // in case of entity identifier being modified
	        this.originEntityId = this.$scope.entry.values[this.entity.identifier().name()];

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    _createClass(FormController, [{
	        key: 'validateEntry',
	        value: function validateEntry() {
	            var _this = this;

	            if (!this.form.$valid) {
	                this.$translate('INVALID_FORM').then(function (text) {
	                    return _this.notification.log(text, { addnCls: 'humane-flatty-error' });
	                });
	                return false;
	            }

	            try {
	                this.view.validate(this.$scope.entry);
	            } catch (error) {
	                this.notification.log(error, { addnCls: 'humane-flatty-error' });
	                return false;
	            }

	            return true;
	        }
	    }, {
	        key: 'submitCreation',
	        value: function submitCreation($event) {
	            var _this2 = this;

	            $event.preventDefault();
	            if (!this.validateEntry()) {
	                return;
	            }
	            var entity = this.entity;
	            var view = this.view;
	            var $state = this.$state;
	            var progression = this.progression;
	            var notification = this.notification;
	            var $translate = this.$translate;

	            var route = entity.showView().enabled ? 'show' : 'list';
	            var restEntry = this.$scope.entry.transformToRest(view.fields());
	            var entry = null;
	            progression.start();
	            this.WriteQueries.createOne(view, restEntry).then(function (rawEntry) {
	                entry = view.mapEntry(rawEntry);
	                return entry;
	            }).then(function (entry) {
	                return view.onSubmitSuccess() && _this2.$injector.invoke(view.onSubmitSuccess(), view, { $event: $event, entity: entity, entry: entry, route: route, controller: _this2, form: _this2.form, progression: progression, notification: notification });
	            }).then(function (customHandlerReturnValue) {
	                return customHandlerReturnValue === false ? new Promise(function (resolve) {
	                    return resolve();
	                }) : $state.go(_this2.$state.get(route), { entity: entity.name(), id: entry.identifierValue });
	            }).then(function () {
	                return progression.done();
	            }).then(function () {
	                return $translate('CREATION_SUCCESS');
	            }).then(function (text) {
	                return notification.log(text, { addnCls: 'humane-flatty-success' });
	            }).catch(function (error) {
	                var errorMessage = _this2.config.getErrorMessageFor(_this2.view, error) | 'ERROR_MESSAGE';
	                var customHandlerReturnValue = view.onSubmitError() && _this2.$injector.invoke(view.onSubmitError(), view, { $event: $event, error: error, errorMessage: errorMessage, entity: entity, entry: entry, route: route, controller: _this2, form: _this2.form, progression: progression, notification: notification });
	                if (customHandlerReturnValue === false) return;
	                progression.done();
	                $translate(errorMessage, {
	                    status: error && error.status,
	                    details: error && error.data && _typeof(error.data) === 'object' ? JSON.stringify(error.data) : {}
	                }).then(function (text) {
	                    return notification.log(text, { addnCls: 'humane-flatty-error' });
	                });
	            });
	        }
	    }, {
	        key: 'submitEdition',
	        value: function submitEdition($event) {
	            var _this3 = this;

	            $event.preventDefault();
	            if (!this.validateEntry()) {
	                return;
	            }
	            var view = this.view;
	            var $state = this.$state;
	            var previousState = this.previousState;
	            var progression = this.progression;
	            var notification = this.notification;
	            var $translate = this.$translate;

	            var restEntry = this.$scope.entry.transformToRest(view.fields());
	            var entry = null;
	            progression.start();
	            this.WriteQueries.updateOne(view, restEntry, this.originEntityId).then(function (rawEntry) {
	                entry = view.mapEntry(rawEntry);
	                return entry;
	            }).then(function (entry) {
	                return view.onSubmitSuccess() && _this3.$injector.invoke(view.onSubmitSuccess(), view, { $event: $event, entity: _this3.entity, entry: entry, controller: _this3, form: _this3.form, progression: progression, notification: notification });
	            }).then(function (customHandlerReturnValue) {
	                if (customHandlerReturnValue === false) return;
	                $state.go(previousState.name, previousState.params).then(function () {
	                    return progression.done();
	                }).then(function () {
	                    return $translate('EDITION_SUCCESS');
	                }).then(function (text) {
	                    return notification.log(text, { addnCls: 'humane-flatty-success' });
	                });
	            }).catch(function (error) {
	                var errorMessage = _this3.config.getErrorMessageFor(_this3.view, error) | 'ERROR_MESSAGE';
	                var customHandlerReturnValue = view.onSubmitError() && _this3.$injector.invoke(view.onSubmitError(), view, { $event: $event, error: error, errorMessage: errorMessage, entity: _this3.entity, entry: entry, controller: _this3, form: _this3.form, progression: progression, notification: notification });
	                if (customHandlerReturnValue === false) return;
	                progression.done();
	                $translate(errorMessage, {
	                    status: error && error.status,
	                    details: error && error.data && _typeof(error.data) === 'object' ? JSON.stringify(error.data) : {}
	                }).then(function (text) {
	                    return notification.log(text, { addnCls: 'humane-flatty-error' });
	                });
	            });
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	            this.$state = undefined;
	            this.$injector = undefined;
	            this.$translate = undefined;
	            this.previousState = undefined;
	            this.WriteQueries = undefined;
	            this.dataStore = undefined;
	            this.view = undefined;
	            this.entity = undefined;
	        }
	    }]);

	    return FormController;
	}();

	exports.default = FormController;


	FormController.$inject = ['$scope', '$state', '$injector', '$translate', 'previousState', 'WriteQueries', 'NgAdminConfiguration', 'progression', 'notification', 'view', 'dataStore'];
	module.exports = exports['default'];

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Entry = __webpack_require__(4);

	var _Entry2 = _interopRequireDefault(_Entry);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ListController = function () {
	    function ListController($scope, $stateParams, $location, $anchorScroll, ReadQueries, progression, view, dataStore, totalItems) {
	        _classCallCheck(this, ListController);

	        this.$scope = $scope;
	        this.$stateParams = $stateParams;
	        this.$location = $location;
	        this.$anchorScroll = $anchorScroll;
	        this.ReadQueries = ReadQueries;
	        this.progression = progression;
	        this.view = view;
	        this.entity = view.getEntity();
	        this.loadingPage = false;
	        this.search = $stateParams.search;
	        this.dataStore = dataStore;
	        this.fields = view.fields();
	        this.listActions = view.listActions();
	        this.totalItems = totalItems;
	        this.page = $stateParams.page || 1;
	        this.infinitePagination = this.view.infinitePagination();
	        this.entryCssClasses = this.view.getEntryCssClasses.bind(this.view);
	        this.nextPageCallback = this.nextPage.bind(this);
	        this.setPageCallback = this.setPage.bind(this);
	        this.sortField = this.$stateParams.sortField || this.view.getSortFieldName();
	        this.sortDir = this.$stateParams.sortDir || this.view.sortDir();

	        if ($scope.selectionUpdater) {
	            $scope.selection = $scope.selection || [];
	            $scope.$watch('selection', $scope.selectionUpdater);
	        } else {
	            $scope.selection = null;
	        }

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    _createClass(ListController, [{
	        key: 'nextPage',
	        value: function nextPage(page) {
	            var _this = this;

	            if (this.loadingPage) {
	                return;
	            }

	            var view = this.view,
	                dataStore = this.dataStore;

	            this.progression.start();

	            var references = view.getReferences();
	            var data = void 0;

	            this.ReadQueries.getAll(view, page, this.search, this.sortField, this.sortDir).then(function (response) {
	                data = response.data;
	                return _this.ReadQueries.getReferenceData(view.fields(), data);
	            }).then(function (referenceData) {
	                _this.progression.done();

	                for (var name in referenceData) {
	                    _Entry2.default.createArrayFromRest(referenceData[name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                    });
	                }
	            }).then(function () {
	                view.mapEntries(data).map(function (entry) {
	                    dataStore.fillReferencesValuesFromEntry(entry, references, true);
	                    dataStore.addEntry(_this.entity.uniqueId, entry);
	                });

	                _this.loadingPage = false;
	            });
	        }
	    }, {
	        key: 'setPage',
	        value: function setPage(number) {
	            this.$location.search('page', number);
	            this.$anchorScroll(0);
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	            this.$stateParams = undefined;
	            this.$location = undefined;
	            this.$anchorScroll = undefined;
	            this.dataStore = undefined;
	        }
	    }]);

	    return ListController;
	}();

	exports.default = ListController;


	ListController.$inject = ['$scope', '$stateParams', '$location', '$anchorScroll', 'ReadQueries', 'progression', 'view', 'dataStore', 'totalItems'];
	module.exports = exports['default'];

/***/ },
/* 102 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/* globals _ */
	function getCurrentSearchParam(location, filters) {
	    var search = location.search().search ? JSON.parse(location.search().search) : {};
	    filters.map(function (filter) {
	        if (search[filter.name()]) {
	            search[filter.name()] = filter.getMappedValue(search[filter.name()]);
	        }
	    });
	    return search;
	}

	var ListLayoutController = function () {
	    function ListLayoutController($scope, $stateParams, $state, $location, $timeout, view, dataStore) {
	        var _this = this;

	        _classCallCheck(this, ListLayoutController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.view = view;
	        this.dataStore = dataStore;
	        this.entity = view.getEntity();
	        this.actions = view.actions();
	        this.batchActions = view.batchActions();
	        this.loadingPage = false;
	        this.filters = view.filters();
	        this.search = getCurrentSearchParam($location, this.filters);
	        this.path = $location.path();
	        // since search isn't a $stateParam of the listLayout state,
	        // the controller doesn't change when the search changes
	        // so we must update filter values manually when the location changes
	        $scope.$watch(function () {
	            return $location.search() && $location.search().search;
	        }, function (newval, oldval) {
	            if (newval === oldval) {
	                return;
	            }
	            if ($location.path() !== _this.path) {
	                return; // already transitioned to another page
	            }
	            _this.search = getCurrentSearchParam($location, _this.filters);
	            _this.enabledFilters = _this.getEnabledFilters();
	        });
	        // apply filters when filter values change
	        $scope.$watch(function () {
	            return _this.search;
	        }, _.debounce(function (newValues, oldValues) {
	            if (newValues != oldValues) {
	                _this.updateFilters();
	            }
	        }, 500), true);
	        this.filters = view.filters();
	        this.enabledFilters = this.getEnabledFilters();
	        this.hasFilters = Object.keys(this.filters).length > 0;
	        this.focusedFilterId = null;
	        this.enableFilter = this.enableFilter.bind(this);
	        this.removeFilter = this.removeFilter.bind(this);
	        if (this.batchActions.length) {
	            // required in scope to communicate with listView
	            $scope.selectionUpdater = function (selection) {
	                return $scope.selection = selection;
	            };
	            $scope.selection = [];
	        }

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    _createClass(ListLayoutController, [{
	        key: 'enableFilter',
	        value: function enableFilter(filter) {
	            var _this2 = this;

	            var defaultValue = filter.defaultValue();
	            if (defaultValue !== null) {
	                this.search[filter.name()] = defaultValue;
	            }
	            this.enabledFilters.push(filter);
	            this.focusedFilterId = filter.name();
	            this.$timeout(function () {
	                var el = window.document.getElementById(_this2.focusedFilterId);
	                if (el && el.focus) {
	                    el.focus();
	                }
	            }, 200, false);
	        }
	    }, {
	        key: 'getEnabledFilters',
	        value: function getEnabledFilters() {
	            var _this3 = this;

	            return this.filters.filter(function (filter) {
	                if (filter.pinned()) {
	                    return true;
	                }
	                return _this3.search && filter.name() in _this3.search;
	            });
	        }
	    }, {
	        key: 'updateFilters',
	        value: function updateFilters() {
	            var values = {},
	                filters = this.enabledFilters,
	                fieldName,
	                field,
	                i;
	            for (i in filters) {
	                field = filters[i];
	                fieldName = field.name();
	                if (this.search[fieldName] === '') {
	                    delete this.search[fieldName];
	                    continue;
	                }

	                if (field.type() === 'boolean' && fieldName in this.search || // for boolean false is the same as null
	                field.type() !== 'boolean' && this.search[fieldName] !== null) {
	                    values[fieldName] = field.getTransformedValue(this.search[fieldName]);
	                }
	            }
	            this.$stateParams.search = values;
	            this.$stateParams.page = 1;
	            this.$state.go('list', this.$stateParams);
	        }
	    }, {
	        key: 'removeFilter',
	        value: function removeFilter(filter) {
	            delete this.search[filter.name()];
	            this.enabledFilters = this.enabledFilters.filter(function (f) {
	                return f !== filter;
	            });
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	            this.$state = undefined;
	            this.$stateParams = undefined;
	            this.$timeout = undefined;
	            this.dataStore = undefined;
	        }
	    }]);

	    return ListLayoutController;
	}();

	exports.default = ListLayoutController;


	ListLayoutController.$inject = ['$scope', '$stateParams', '$state', '$location', '$timeout', 'view', 'dataStore'];
	module.exports = exports['default'];

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDatagrid;

	var _maDatagridController = __webpack_require__(104);

	var _maDatagridController2 = _interopRequireDefault(_maDatagridController);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function maDatagrid() {
	    return {
	        restrict: 'E',
	        scope: {
	            name: '@',
	            entries: '=',
	            selection: '=',
	            fields: '&',
	            listActions: '&',
	            entity: '&',
	            entryCssClasses: '&?',
	            datastore: '&',
	            sortField: '&',
	            sortDir: '&',
	            sort: '&'
	        },
	        controllerAs: 'datagrid',
	        controller: _maDatagridController2.default,
	        template: '<table class="grid table table-condensed table-hover table-striped">\n    <thead>\n        <tr>\n            <th ng-if="selection">\n                <ma-datagrid-multi-selector toggle-select-all="toggleSelectAll()" selection="selection" entries="entries"/>\n            </th>\n            <th ng-repeat="field in fields() track by $index" ng-class="field.getCssClasses()" class="ng-admin-column-{{ ::field.name() }} ng-admin-type-{{ ::field.type() }}">\n                <a ng-click="datagrid.sortCallback(field)">\n                    <span class="glyphicon {{ sortDir() === \'DESC\' ? \'glyphicon-chevron-up\': \'glyphicon-chevron-down\' }}" ng-if="datagrid.isSorting(field)"></span>\n                    {{ field.label() | translate }}\n                </a>\n            </th>\n            <th ng-if="datagrid.shouldDisplayActions" class="ng-admin-column-actions" translate="ACTIONS"></th>\n        </tr>\n    </thead>\n\n    <tbody>\n        <tr ng-repeat="entry in entries track by entry.identifierValue" ng-class="getEntryCssClasses(entry)">\n            <td ng-if="selection">\n                <ma-datagrid-item-selector toggle-select="toggleSelect(entry)" selection="selection" entry="entry"/>\n            </td>\n            <td ng-repeat="field in fields() track by $index" ng-class="field.getCssClasses(entry)" class="ng-admin-column-{{ ::field.name() }} ng-admin-type-{{ ::field.type() }}">\n                <ma-column field="::field" entry="::entry" entity="::entity" datastore="datagrid.datastore"></ma-column>\n            </td>\n            <td ng-if="datagrid.shouldDisplayActions" class="ng-admin-column-actions">\n                <ma-list-actions entry="::entry" entity="::entity" buttons="listActions()"></ma-list-actions>\n            </td>\n        </tr>\n    </tbody>\n</table>'
	    };
	}

	maDatagrid.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 104 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DatagridController = function () {
	    function DatagridController($scope, $location, $stateParams, $anchorScroll) {
	        _classCallCheck(this, DatagridController);

	        $scope.entity = $scope.entity();
	        this.$scope = $scope;
	        this.$location = $location;
	        this.$anchorScroll = $anchorScroll;
	        this.datastore = this.$scope.datastore();
	        this.filters = {};
	        this.shouldDisplayActions = this.$scope.listActions() && this.$scope.listActions().length > 0;
	        $scope.getEntryCssClasses = this.getEntryCssClasses.bind(this);
	        $scope.toggleSelect = this.toggleSelect.bind(this);
	        $scope.toggleSelectAll = this.toggleSelectAll.bind(this);
	        this.sortField = $scope.sortField();
	        this.sortDir = $scope.sortDir();
	        this.sortCallback = $scope.sort() ? $scope.sort() : this.sort.bind(this);
	    }

	    /**
	     * Return true if a column is being sorted
	     *
	     * @param {Field} field
	     *
	     * @returns {Boolean}
	     */


	    _createClass(DatagridController, [{
	        key: 'isSorting',
	        value: function isSorting(field) {
	            return this.$scope.sortField() === this.getSortName(field);
	        }

	        /**
	         * Return 'even'|'odd' based on the index parameter
	         *
	         * @param {Number} index
	         * @returns {string}
	         */

	    }, {
	        key: 'itemClass',
	        value: function itemClass(index) {
	            return index % 2 === 0 ? 'even' : 'odd';
	        }

	        /**
	         *
	         * @param {Field} field
	         */

	    }, {
	        key: 'sort',
	        value: function sort(field) {
	            var dir = 'ASC',
	                fieldName = this.getSortName(field);

	            if (this.sortField === fieldName) {
	                dir = this.sortDir === 'ASC' ? 'DESC' : 'ASC';
	            }

	            this.$location.search('sortField', fieldName);
	            this.$location.search('sortDir', dir);
	        }

	        /**
	         * Return fieldName like (view.fieldName) to sort
	         *
	         * @param {Field} field
	         *
	         * @returns {String}
	         */

	    }, {
	        key: 'getSortName',
	        value: function getSortName(field) {
	            return this.$scope.name ? this.$scope.name + '.' + field.name() : field.name();
	        }
	    }, {
	        key: 'getEntryCssClasses',
	        value: function getEntryCssClasses(entry) {
	            var entryCssClasses = this.$scope.entryCssClasses;
	            if (typeof entryCssClasses !== 'function') {
	                return;
	            }
	            var getEntryCssClasses = entryCssClasses();
	            if (typeof getEntryCssClasses !== 'function') {
	                return;
	            }
	            return getEntryCssClasses(entry.values);
	        }
	    }, {
	        key: 'toggleSelect',
	        value: function toggleSelect(entry) {
	            var selection = this.$scope.selection.slice();

	            var index = selection.indexOf(entry);

	            if (index === -1) {
	                this.$scope.selection = selection.concat(entry);
	                return;
	            }
	            selection.splice(index, 1);
	            this.$scope.selection = selection;
	        }
	    }, {
	        key: 'toggleSelectAll',
	        value: function toggleSelectAll() {

	            if (this.$scope.selection.length < this.$scope.entries.length) {
	                this.$scope.selection = this.$scope.entries;
	                return;
	            }

	            this.$scope.selection = [];
	        }
	    }]);

	    return DatagridController;
	}();

	exports.default = DatagridController;


	DatagridController.$inject = ['$scope', '$location', '$stateParams', '$anchorScroll'];
	module.exports = exports['default'];

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDatagridInfinitePagination;

	var _angular = __webpack_require__(3);

	var _angular2 = _interopRequireDefault(_angular);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function maDatagridInfinitePagination($window, $document) {

	    var windowElement = _angular2.default.element($window);
	    var offset = 100,
	        body = $document[0].body;

	    return {
	        restrict: 'E',
	        scope: {
	            perPage: '@',
	            totalItems: '@',
	            nextPage: '&'
	        },
	        link: function link(scope) {
	            var perPage = parseInt(scope.perPage, 10) || 1,
	                totalItems = parseInt(scope.totalItems, 10),
	                nbPages = Math.ceil(totalItems / perPage) || 1,
	                page = 1;
	            function handler() {
	                if (body.offsetHeight - $window.innerHeight - $window.scrollY < offset) {
	                    if (page >= nbPages) {
	                        return;
	                    }
	                    page++;
	                    scope.nextPage()(page);
	                }
	            }
	            windowElement.bind('scroll', handler);
	            scope.$on('$destroy', function destroy() {
	                windowElement.unbind('scroll', handler);
	            });
	        }
	    };
	}

	maDatagridInfinitePagination.$inject = ['$window', '$document'];
	module.exports = exports['default'];

/***/ },
/* 106 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDatagridItemSelector;
	function maDatagridItemSelector() {
	    return {
	        restrict: 'E',
	        scope: {
	            entry: '=',
	            selection: '=',
	            toggleSelect: '&'
	        },
	        template: '<input type="checkbox" ng-click="toggle(entry)" ng-checked="isInSelection()"/>',
	        link: function link(scope) {
	            scope.toggle = function (entry) {
	                return scope.toggleSelect({ entry: entry });
	            };
	            var e = scope.entry;
	            scope.isInSelection = function () {
	                return scope.selection.filter(function (s) {
	                    return s._entityName == e._entityName && s._identifierValue == e._identifierValue;
	                }).length > 0;
	            };
	        }
	    };
	}

	maDatagridItemSelector.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 107 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDatagridMultiSelector;
	function maDatagridMultiSelector() {
	    return {
	        restrict: 'E',
	        scope: {
	            entries: '=',
	            selection: '=',
	            toggleSelectAll: '&'
	        },
	        template: '<input type="checkbox" ng-click="toggleSelectAll()" ng-checked="selection.length == entries.length" />',
	        link: function link(scope, element) {
	            scope.$watch('selection', function (selection) {
	                element.children()[0].indeterminate = selection.length > 0 && selection.length != scope.entries.length;
	            });
	            scope.$watch('entries', function (entries) {
	                element.children()[0].indeterminate = scope.selection.length > 0 && scope.selection.length != entries.length;
	            });
	        }
	    };
	}

	maDatagridMultiSelector.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDatagridPagination;

	var _maDatagridPagination = __webpack_require__(151);

	var _maDatagridPagination2 = _interopRequireDefault(_maDatagridPagination);

	var _maDatagridPaginationController = __webpack_require__(109);

	var _maDatagridPaginationController2 = _interopRequireDefault(_maDatagridPaginationController);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function maDatagridPagination() {
	    return {
	        restrict: 'E',
	        scope: {
	            page: '@',
	            perPage: '@',
	            totalItems: '@',
	            setPage: '&'
	        },
	        template: _maDatagridPagination2.default,
	        controllerAs: 'paginationCtrl',
	        controller: _maDatagridPaginationController2.default
	    };
	}

	maDatagridPagination.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _angular = __webpack_require__(3);

	var _angular2 = _interopRequireDefault(_angular);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DatagridPaginationController = function () {
	    function DatagridPaginationController($scope) {
	        _classCallCheck(this, DatagridPaginationController);

	        this.$scope = $scope;
	        var perPage = parseInt(this.$scope.perPage, 10) || 1,
	            totalItems = parseInt(this.$scope.totalItems, 10),
	            page = Math.max(parseInt(this.$scope.page, 10), 1);

	        this.nbPages = Math.ceil(totalItems / perPage) || 1;
	        this.page = Math.min(this.nbPages, page);
	        this.offsetEnd = Math.min(this.page * perPage, totalItems);
	        this.offsetBegin = Math.min((this.page - 1) * perPage + 1, this.offsetEnd);
	        this.totalItems = totalItems;
	        this.displayPagination = perPage < totalItems;

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    /**
	     * Return an array with the range between min & max, useful for pagination
	     *
	     * @param {int} min
	     * @param {int} max
	     * @returns {Array}
	     */


	    _createClass(DatagridPaginationController, [{
	        key: 'range',
	        value: function range(page) {
	            var input = [],
	                nbPages = this.nbPages;

	            // display page links around the current page
	            if (page > 2) {
	                input.push('1');
	            }
	            if (page == 4) {
	                input.push('2');
	            }
	            if (page > 4) {
	                input.push('.');
	            }
	            if (page > 1) {
	                input.push(page - 1);
	            }
	            input.push(page);
	            if (page < nbPages) {
	                input.push(page + 1);
	            }
	            if (page == nbPages - 3) {
	                input.push(nbPages - 1);
	            }
	            if (page < nbPages - 3) {
	                input.push('.');
	            }
	            if (page < nbPages - 1) {
	                input.push(nbPages);
	            }

	            return input;
	        }

	        /**
	         * Link to page number of the list
	         *
	         * @param {int} number
	         */

	    }, {
	        key: 'setPage',
	        value: function setPage(number) {
	            if (number <= 0 || number > this.nbPages) {
	                return;
	            }
	            this.$scope.setPage()(number);
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	        }
	    }]);

	    return DatagridPaginationController;
	}();

	exports.default = DatagridPaginationController;


	DatagridPaginationController.$inject = ['$scope'];
	module.exports = exports['default'];

/***/ },
/* 110 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maListActions;
	function maListActions() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        scope: {
	            'buttons': '&',
	            'entry': '&',
	            'entity': '&'
	        },
	        link: function link($scope) {
	            $scope.buttons = $scope.buttons();
	            $scope.entry = $scope.entry();
	            $scope.entity = $scope.entity();
	            $scope.customTemplate = false;
	            if (typeof $scope.buttons === 'string') {
	                $scope.customTemplate = $scope.buttons;
	                $scope.buttons = null;
	            }
	        },
	        template: '<span compile="customTemplate">\n    <span ng-repeat="button in ::buttons" ng-switch="button">\n        <ma-show-button ng-switch-when="show" entry="::entry" entity="::entity" size="xs"></ma-show-button>\n        <ma-edit-button ng-switch-when="edit" ng-if="::entity.editionView().enabled" entry="::entry" entity="::entity" size="xs"></ma-edit-button>\n        <ma-delete-button ng-switch-when="delete" ng-if="::entity.deletionView().enabled" entry="::entry" entity="::entity" size="xs"></ma-delete-button>\n        <span ng-switch-default><span compile="button"></span></span>\n    </span>\n</span>'
	    };
	}

	maListActions.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 111 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Compile;
	// @see https://docs.angularjs.org/api/ng/service/$compile
	function Compile($injector) {
	    var $compile = $injector.get('$compile');

	    return {
	        transclude: true,
	        link: function link(scope, element, attrs, controller, transcludeFn) {
	            var unbindWatcher = scope.$watch(function (scope) {
	                // watch the 'compile' expression for changes
	                return scope.$eval(attrs.compile);
	            }, function (value) {
	                if (false === value) {
	                    // use the default tag content
	                    transcludeFn(scope, function (clone) {
	                        element.append(clone);
	                    });
	                    return;
	                }
	                // when the 'compile' expression changes assign it into the current DOM
	                element.html(value);

	                // compile the new DOM and link it to the current scope.
	                $compile(element.contents())(scope);

	                if (attrs.compileOnce == 'true') {
	                    unbindWatcher();
	                }
	            });
	        }
	    };
	}

	Compile.$inject = ['$injector'];
	module.exports = exports['default'];

/***/ },
/* 112 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EntryFormatter = function () {
	    function EntryFormatter($filter) {
	        _classCallCheck(this, EntryFormatter);

	        this.formatDate = function (format) {
	            return function (date) {
	                return $filter('date')(date, format);
	            };
	        };
	        this.formatNumber = function (format) {
	            return function (number) {
	                return $filter('numeraljs')(number, format);
	            };
	        };
	    }

	    _createClass(EntryFormatter, [{
	        key: 'formatField',
	        value: function formatField(field) {
	            var label = field.label() || field.name();
	            var type = field.type();
	            switch (type) {
	                case 'boolean':
	                case 'choice':
	                case 'choices':
	                case 'string':
	                case 'text':
	                case 'wysiwyg':
	                case 'email':
	                case 'json':
	                case 'file':
	                    return function (entry) {
	                        return {
	                            name: label,
	                            value: entry.values[field.name()]
	                        };
	                    };
	                case 'template':
	                    return function (entry) {
	                        return {
	                            name: label,
	                            value: field.getTemplateValue(entry)
	                        };
	                    };
	                case 'number':
	                case 'float':
	                    var formatNumber = this.formatNumber(field.format());
	                    return function (entry) {
	                        return {
	                            name: label,
	                            value: formatNumber(entry.values[field.name()])
	                        };
	                    };
	                case 'date':
	                case 'datetime':
	                    var format = field.format();
	                    if (!format) {
	                        format = type === 'date' ? 'yyyy-MM-dd' : 'yyyy-MM-dd HH:mm:ss';
	                    }

	                    var formatDate = this.formatDate(format);
	                    return function (entry) {
	                        return {
	                            name: label,
	                            value: formatDate(entry.values[field.name()])
	                        };
	                    };
	                case 'reference':
	                    return function (entry) {
	                        return {
	                            name: label,
	                            value: entry.listValues[field.name()]
	                        };
	                    };
	                case 'reference_many':
	                    return function (entry) {
	                        return {
	                            name: label,
	                            value: entry.listValues[field.name()].join(', ')
	                        };
	                    };
	                case 'referenced_list':
	                    return; //ignored
	            }
	        }
	    }, {
	        key: 'getFormatter',
	        value: function getFormatter(fields) {
	            var fieldsFormatters = fields.map(this.formatField.bind(this));

	            return function formatEntry(entry) {
	                var result = {};
	                fieldsFormatters.map(function (formatter) {
	                    if (!formatter) {
	                        return;
	                    }
	                    return formatter(entry);
	                }).forEach(function (field) {
	                    if (!field) {
	                        return;
	                    }
	                    result[field.name] = field.value;
	                });

	                return result;
	            };
	        }
	    }]);

	    return EntryFormatter;
	}();

	exports.default = EntryFormatter;


	EntryFormatter.$inject = ['$filter'];
	module.exports = exports['default'];

/***/ },
/* 113 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = PromisesResolver;
	function PromisesResolver(AdminDescription) {
	    return AdminDescription.getPromisesResolver();
	}

	PromisesResolver.$inject = ['AdminDescription'];
	module.exports = exports['default'];

/***/ },
/* 114 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var RestWrapper = function () {
	    function RestWrapper(Restangular) {
	        _classCallCheck(this, RestWrapper);

	        this.Restangular = Restangular;

	        Restangular.setFullResponse(true);
	    }

	    /**
	     * Returns the promise of one resource by URL
	     *
	     * @param {String} entityName
	     * @param {String} url
	     *
	     * @returns {promise}
	     */


	    _createClass(RestWrapper, [{
	        key: 'getOne',
	        value: function getOne(entityName, url) {
	            return this.Restangular.oneUrl(entityName, url).get().then(function (response) {
	                return response.data;
	            });
	        }

	        /**
	         * Returns the promise of a list of resources
	         *
	         * @param {Object} params
	         * @param {String} entityName
	         * @param {String} url
	         *
	         * @returns {promise}
	         */

	    }, {
	        key: 'getList',
	        value: function getList(params, entityName, url) {
	            return this.Restangular.allUrl(entityName, url).getList(params);
	        }
	    }, {
	        key: 'createOne',
	        value: function createOne(rawEntity, entityName, url, method) {
	            var resource = this.Restangular.oneUrl(entityName, url),
	                operation = method ? resource.customOperation(method, null, {}, {}, rawEntity) : resource.customPOST(rawEntity);

	            return operation.then(function (response) {
	                return response.data;
	            });
	        }
	    }, {
	        key: 'updateOne',
	        value: function updateOne(rawEntity, entityName, url, method) {
	            var resource = this.Restangular.oneUrl(entityName, url),
	                operation = method ? resource.customOperation(method, null, {}, {}, rawEntity) : resource.customPUT(rawEntity);

	            return operation.then(function (response) {
	                return response.data;
	            });
	        }
	    }, {
	        key: 'deleteOne',
	        value: function deleteOne(entityName, url) {
	            return this.Restangular.oneUrl(entityName, url).customDELETE();
	        }
	    }]);

	    return RestWrapper;
	}();

	exports.default = RestWrapper;


	RestWrapper.$inject = ['Restangular'];
	module.exports = exports['default'];

/***/ },
/* 115 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = ViewActions;
	function ViewActions($injector) {
	    var $compile = $injector.get('$compile');

	    return {
	        restrict: 'E',
	        transclude: true,
	        scope: {
	            override: '&',
	            entry: '=',
	            entity: '=',
	            selection: '=',
	            batchButtons: '&',
	            datastore: '=',
	            search: '=',
	            filters: '&',
	            enabledFilters: '=',
	            enableFilter: '&'
	        },
	        link: function link($scope, element, attrs, controller, transcludeFn) {
	            var override = $scope.override();
	            if (!override) {
	                // use the default tag content
	                transcludeFn($scope, function (clone) {
	                    element.append(clone);
	                });
	                return;
	            }
	            if (typeof override === 'string') {
	                // custom template, use it instead of default template
	                element.html(override);
	                $compile(element.contents())($scope);
	                return;
	            }
	            // list of buttons - default template
	            $scope.buttons = override;
	        },
	        template: '<span ng-repeat="button in buttons" ng-switch="button" class="view_actions">\n    <ma-filter-button ng-switch-when="filter" filters="filters()" enabled-filters="enabledFilters" enable-filter="enableFilter()"></ma-filter-button>\n    <ma-view-batch-actions ng-switch-when="batch" buttons="batchButtons()" selection="selection" entity="entity"></ma-view-batch-actions>\n    <ma-back-button ng-switch-when="back"></ma-back-button>\n    <ma-list-button ng-switch-when="list" entity="entity"></ma-list-button>\n    <ma-create-button ng-switch-when="create" entity="entity"></ma-create-button>\n    <ma-show-button ng-switch-when="show" entry="entry" entity="entity"></ma-show-button>\n    <ma-edit-button ng-switch-when="edit" entry="entry" entity="entity"></ma-edit-button>\n    <ma-delete-button ng-switch-when="delete" entry="entry" entity="entity"></ma-delete-button>\n    <ma-export-to-csv-button ng-switch-when="export" datastore="datastore" entity="entity"></ma-export-to-csv-button>\n    <span ng-switch-default><span compile="button"></span></span>\n</span>'
	    };
	}

	ViewActions.$inject = ['$injector'];
	module.exports = exports['default'];

/***/ },
/* 116 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ReadQueries;
	/**
	 * @param {RestWrapper} RestWrapper
	 * @param {Configuration} Configuration
	 * @param {AdminDescription} AdminDescription
	 * @param {PromisesResolver} PromisesResolver
	 *
	 * @returns {ReadQueries}
	 * @constructor
	 */
	function ReadQueries(RestWrapper, Configuration, AdminDescription, PromisesResolver) {
	  return AdminDescription.getReadQueries(RestWrapper, PromisesResolver, Configuration());
	}

	ReadQueries.$inject = ['RestWrapper', 'NgAdminConfiguration', 'AdminDescription', 'PromisesResolver'];
	module.exports = exports['default'];

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Entry = __webpack_require__(4);

	var _Entry2 = _interopRequireDefault(_Entry);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ReferenceRefresher = function () {
	    function ReferenceRefresher(ReadQueries) {
	        _classCallCheck(this, ReferenceRefresher);

	        this.ReadQueries = ReadQueries;
	    }

	    _createClass(ReferenceRefresher, [{
	        key: 'refresh',
	        value: function refresh(field, currentValue, search) {
	            var _this = this;

	            var referenceFields = {};
	            referenceFields[field.name()] = field;

	            var promise = this.ReadQueries.getAllReferencedData(referenceFields, search).then(function (r) {
	                return r[field.name()];
	            }).then(function (results) {
	                return _this._transformRecords(field, results);
	            });

	            if (field.type() === 'reference_many' || field.type() === 'choices') {
	                promise = promise.then(function (formattedResults) {
	                    return _this._removeDuplicates(formattedResults, currentValue);
	                });
	            }

	            return promise;
	        }
	    }, {
	        key: '_removeDuplicates',
	        value: function _removeDuplicates(results, currentValue) {
	            // remove already assigned values: ui-select still return them if multiple
	            if (!currentValue) {
	                return results;
	            }

	            if (!Array.isArray(currentValue)) {
	                currentValue = [currentValue];
	            }

	            return results.filter(function (fr) {
	                return currentValue.indexOf(fr.value) === -1;
	            });
	        }
	    }, {
	        key: '_transformRecords',
	        value: function _transformRecords(field, records) {
	            var targetEntity = field.targetEntity();
	            var targetField = field.targetField();
	            var valueFieldName = targetEntity.identifier().name();
	            var labelFieldName = targetField.name();
	            return _Entry2.default.createArrayFromRest(records, [targetField], targetEntity.name(), valueFieldName).map(function (r) {
	                return {
	                    value: r.values[valueFieldName],
	                    label: r.values[labelFieldName]
	                };
	            });
	        }
	    }]);

	    return ReferenceRefresher;
	}();

	exports.default = ReferenceRefresher;


	ReferenceRefresher.$inject = ['ReadQueries'];
	module.exports = exports['default'];

/***/ },
/* 118 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = WriteQueries;
	/**
	 * @param {RestWrapper} RestWrapper
	 * @param {Configuration} Configuration
	 * @param {AdminDescription} AdminDescription
	 * @param {PromisesResolver} PromisesResolver
	 *
	 * @returns {ReadQueries}
	 * @constructor
	 */
	function WriteQueries(RestWrapper, Configuration, AdminDescription, PromisesResolver) {
	  return AdminDescription.getWriteQueries(RestWrapper, PromisesResolver, Configuration());
	}

	WriteQueries.$inject = ['RestWrapper', 'NgAdminConfiguration', 'AdminDescription', 'PromisesResolver'];
	module.exports = exports['default'];

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _DataStore = __webpack_require__(16);

	var _DataStore2 = _interopRequireDefault(_DataStore);

	var _Entry = __webpack_require__(4);

	var _Entry2 = _interopRequireDefault(_Entry);

	var _batchDelete = __webpack_require__(145);

	var _batchDelete2 = _interopRequireDefault(_batchDelete);

	var _delete = __webpack_require__(146);

	var _delete2 = _interopRequireDefault(_delete);

	var _create = __webpack_require__(147);

	var _create2 = _interopRequireDefault(_create);

	var _edit = __webpack_require__(148);

	var _edit2 = _interopRequireDefault(_edit);

	var _list = __webpack_require__(149);

	var _list2 = _interopRequireDefault(_list);

	var _listLayout = __webpack_require__(150);

	var _listLayout2 = _interopRequireDefault(_listLayout);

	var _show = __webpack_require__(152);

	var _show2 = _interopRequireDefault(_show);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function templateProvider(viewName, defaultView) {
	    return ['$stateParams', 'NgAdminConfiguration', function ($stateParams, Configuration) {
	        var customTemplate;
	        var view = Configuration().getViewByEntityAndType($stateParams.entity, viewName);
	        customTemplate = view.template();
	        if (customTemplate) {
	            return customTemplate;
	        }
	        customTemplate = Configuration().customTemplate()(viewName);
	        if (customTemplate) {
	            return customTemplate;
	        }
	        return defaultView;
	    }];
	}

	function viewProvider(viewName) {
	    return ['$stateParams', 'NgAdminConfiguration', function ($stateParams, Configuration) {
	        var view;
	        try {
	            view = Configuration().getViewByEntityAndType($stateParams.entity, viewName);
	        } catch (e) {
	            var error404 = new Error('Unknown view or entity name');
	            error404.status = 404; // trigger the 404 error
	            throw error404;
	        }
	        if (!view.enabled) {
	            throw new Error('The ' + viewName + ' is disabled for this entity');
	        }
	        return view;
	    }];
	}

	function routing($stateProvider) {

	    $stateProvider.state('listLayout', {
	        abstract: true,
	        url: '/:entity/list',
	        params: {
	            entity: null
	        },
	        parent: 'ng-admin',
	        controller: 'ListLayoutController',
	        controllerAs: 'llCtrl',
	        templateProvider: templateProvider('ListView', _listLayout2.default),
	        resolve: {
	            dataStore: function dataStore() {
	                return new _DataStore2.default();
	            },
	            view: viewProvider('ListView'),
	            filterData: ['ReadQueries', 'view', function (ReadQueries, view) {
	                return ReadQueries.getAllReferencedData(view.getFilterReferences(false));
	            }],
	            filterEntries: ['dataStore', 'view', 'filterData', function (dataStore, view, filterData) {
	                var filters = view.getFilterReferences(false);
	                for (var name in filterData) {
	                    _Entry2.default.createArrayFromRest(filterData[name], [filters[name].targetField()], filters[name].targetEntity().name(), filters[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(filters[name].targetEntity().uniqueId + '_choices', entry);
	                    });
	                }
	            }]
	        }
	    }).state('list', {
	        url: '?{search:json}&{page:int}&sortField&sortDir',
	        params: {
	            page: { value: 1, squash: true },
	            search: { value: {}, squash: true },
	            sortField: null,
	            sortDir: null
	        },
	        parent: 'listLayout',
	        views: {
	            grid: {
	                controller: 'ListController',
	                controllerAs: 'listController',
	                template: _list2.default,
	                resolve: {
	                    dataStore: function dataStore() {
	                        return new _DataStore2.default();
	                    },
	                    view: viewProvider('ListView'),
	                    response: ['$stateParams', 'ReadQueries', 'view', function ($stateParams, ReadQueries, view) {
	                        var page = $stateParams.page,
	                            filters = $stateParams.search,
	                            sortField = $stateParams.sortField,
	                            sortDir = $stateParams.sortDir;

	                        return ReadQueries.getAll(view, page, filters, sortField, sortDir);
	                    }],
	                    totalItems: ['response', function (response) {
	                        return response.totalItems;
	                    }],
	                    referenceData: ['ReadQueries', 'view', 'response', function (ReadQueries, view, response) {
	                        return ReadQueries.getReferenceData(view.fields(), response.data);
	                    }],
	                    referenceEntries: ['dataStore', 'view', 'referenceData', function (dataStore, view, referenceData) {
	                        var references = view.getReferences();
	                        for (var name in referenceData) {
	                            _Entry2.default.createArrayFromRest(referenceData[name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                                return dataStore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                            });
	                        }
	                    }],
	                    entries: ['dataStore', 'view', 'response', 'referenceEntries', function (dataStore, view, response, referenceEntries) {
	                        var entries = view.mapEntries(response.data);

	                        // shortcut to diplay collection of entry with included referenced values
	                        dataStore.fillReferencesValuesFromCollection(entries, view.getReferences(), true);

	                        // set entries here ???
	                        dataStore.setEntries(view.getEntity().uniqueId, entries);

	                        return entries;
	                    }],
	                    prepare: ['view', '$stateParams', 'dataStore', 'entries', '$window', '$injector', function (view, $stateParams, dataStore, entries, $window, $injector) {
	                        return view.prepare() && $injector.invoke(view.prepare(), view, {
	                            query: $stateParams,
	                            datastore: dataStore,
	                            view: view,
	                            Entry: _Entry2.default,
	                            entries: entries,
	                            window: $window
	                        });
	                    }]
	                }
	            }
	        }
	    });

	    $stateProvider.state('show', {
	        parent: 'ng-admin',
	        url: '/:entity/show/:id?sortField&sortDir',
	        controller: 'ShowController',
	        controllerAs: 'showController',
	        templateProvider: templateProvider('ShowView', _show2.default),
	        params: {
	            entity: null,
	            id: null,
	            page: { value: 1, squash: true },
	            search: { value: {}, squash: true },
	            sortField: null,
	            sortDir: null
	        },
	        resolve: {
	            dataStore: function dataStore() {
	                return new _DataStore2.default();
	            },
	            view: viewProvider('ShowView'),
	            rawEntry: ['$stateParams', 'ReadQueries', 'view', function ($stateParams, ReadQueries, view) {
	                return ReadQueries.getOne(view.getEntity(), view.type, $stateParams.id, view.identifier(), view.getUrl());
	            }],
	            entry: ['view', 'rawEntry', function (view, rawEntry) {
	                return view.mapEntry(rawEntry);
	            }],
	            referenceData: ['ReadQueries', 'view', 'entry', function (ReadQueries, view, entry) {
	                return ReadQueries.getReferenceData(view.fields(), [entry.values]);
	            }],
	            referenceEntries: ['dataStore', 'view', 'referenceData', function (dataStore, view, referenceData) {
	                var references = view.getReferences();
	                for (var name in referenceData) {
	                    _Entry2.default.createArrayFromRest(referenceData[name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                    });
	                }
	            }],
	            referencedListData: ['$stateParams', 'ReadQueries', 'view', 'entry', function ($stateParams, ReadQueries, view, entry) {
	                return ReadQueries.getReferencedListData(view.getReferencedLists(), $stateParams.sortField, $stateParams.sortDir, entry.identifierValue);
	            }],
	            referencedListEntries: ['dataStore', 'view', 'referencedListData', function (dataStore, view, referencedListData) {
	                var referencedLists = view.getReferencedLists();
	                for (var name in referencedLists) {
	                    _Entry2.default.createArrayFromRest(referencedListData[name], referencedLists[name].targetFields(), referencedLists[name].targetEntity().name(), referencedLists[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(referencedLists[name].targetEntity().uniqueId + '_list', entry);
	                    });
	                }
	            }],
	            entryWithReferences: ['dataStore', 'view', 'entry', 'referenceEntries', function (dataStore, view, entry, referenceEntries) {
	                dataStore.fillReferencesValuesFromEntry(entry, view.getReferences(), true);
	                dataStore.addEntry(view.getEntity().uniqueId, entry);
	            }],
	            referenceDataForReferencedLists: ['$q', 'ReadQueries', 'view', 'referencedListData', function ($q, ReadQueries, view, referencedListData) {
	                var referencedLists = view.getReferencedLists();
	                var promises = {};
	                Object.keys(referencedLists).map(function (name) {
	                    promises[name] = ReadQueries.getReferenceData(referencedLists[name].targetFields(), referencedListData[name]);
	                });
	                return $q.all(promises);
	            }],
	            referenceEntriesForReferencedLists: ['dataStore', 'view', 'referenceDataForReferencedLists', function (dataStore, view, referenceDataForReferencedLists) {
	                var referencedLists = view.getReferencedLists();
	                Object.keys(referencedLists).map(function (referencedListName) {
	                    var references = referencedLists[referencedListName].getReferences();
	                    for (var name in references) {
	                        if (!referenceDataForReferencedLists[referencedListName][name]) {
	                            continue;
	                        }
	                        _Entry2.default.createArrayFromRest(referenceDataForReferencedLists[referencedListName][name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                            return dataStore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                        });
	                    }
	                });
	                return true;
	            }],
	            prepare: ['view', '$stateParams', 'dataStore', 'entry', 'entryWithReferences', 'referencedListEntries', 'referenceEntriesForReferencedLists', '$window', '$injector', function (view, $stateParams, dataStore, entry, entryWithReferences, referencedListEntries, referenceEntriesForReferencedLists, $window, $injector) {
	                return view.prepare() && $injector.invoke(view.prepare(), view, {
	                    query: $stateParams,
	                    datastore: dataStore,
	                    view: view,
	                    Entry: _Entry2.default,
	                    entry: entry,
	                    window: $window
	                });
	            }]
	        }
	    });

	    $stateProvider.state('create', {
	        parent: 'ng-admin',
	        url: '/:entity/create?{defaultValues:json}',
	        controller: 'FormController',
	        controllerAs: 'formController',
	        templateProvider: templateProvider('CreateView', _create2.default),
	        params: {
	            page: { value: 1, squash: true },
	            search: { value: {}, squash: true },
	            defaultValues: { value: {}, squash: true },
	            sortField: null,
	            sortDir: null
	        },
	        resolve: {
	            dataStore: function dataStore() {
	                return new _DataStore2.default();
	            },
	            previousState: ['$state', '$stateParams', function ($state, $stateParams) {
	                return {
	                    name: $state.current.name || 'edit',
	                    params: Object.keys($state.params).length > 0 ? $state.params : $stateParams
	                };
	            }],
	            view: viewProvider('CreateView'),
	            entry: ['$stateParams', 'dataStore', 'view', function ($stateParams, dataStore, view) {
	                var entry = _Entry2.default.createForFields(view.getFields(), view.entity.name());
	                Object.keys($stateParams.defaultValues).forEach(function (key) {
	                    return entry.values[key] = $stateParams.defaultValues[key];
	                });
	                dataStore.addEntry(view.getEntity().uniqueId, entry);

	                return entry;
	            }],
	            choiceData: ['ReadQueries', 'view', function (ReadQueries, view) {
	                return ReadQueries.getAllReferencedData(view.getReferences(false));
	            }],
	            choiceEntries: ['dataStore', 'view', 'choiceData', function (dataStore, view, filterData) {
	                var choices = view.getReferences(false);
	                for (var name in filterData) {
	                    _Entry2.default.createArrayFromRest(filterData[name], [choices[name].targetField()], choices[name].targetEntity().name(), choices[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(choices[name].targetEntity().uniqueId + '_choices', entry);
	                    });
	                }
	            }],
	            prepare: ['view', '$stateParams', 'dataStore', 'entry', 'choiceEntries', '$window', '$injector', function (view, $stateParams, dataStore, entry, choiceEntries, $window, $injector) {
	                return view.prepare() && $injector.invoke(view.prepare(), view, {
	                    query: $stateParams,
	                    datastore: dataStore,
	                    view: view,
	                    Entry: _Entry2.default,
	                    entry: entry,
	                    window: $window
	                });
	            }]
	        }
	    });

	    $stateProvider.state('edit', {
	        parent: 'ng-admin',
	        url: '/:entity/edit/:id?sortField&sortDir',
	        controller: 'FormController',
	        controllerAs: 'formController',
	        templateProvider: templateProvider('EditView', _edit2.default),
	        params: {
	            entity: null,
	            id: null,
	            page: { value: 1, squash: true },
	            search: { value: {}, squash: true },
	            sortField: null,
	            sortDir: null
	        },
	        resolve: {
	            dataStore: function dataStore() {
	                return new _DataStore2.default();
	            },
	            previousState: ['$state', '$stateParams', function ($state, $stateParams) {
	                return {
	                    name: $state.current.name || 'edit',
	                    params: Object.keys($state.params).length > 0 ? $state.params : $stateParams
	                };
	            }],
	            view: viewProvider('EditView'),
	            rawEntry: ['$stateParams', 'ReadQueries', 'view', function ($stateParams, ReadQueries, view) {
	                return ReadQueries.getOne(view.getEntity(), view.type, $stateParams.id, view.identifier(), view.getUrl($stateParams.id));
	            }],
	            entry: ['view', 'rawEntry', function (view, rawEntry) {
	                return view.mapEntry(rawEntry);
	            }],
	            referenceData: ['ReadQueries', 'view', 'entry', function (ReadQueries, view, entry) {
	                return ReadQueries.getReferenceData(view.fields(), [entry.values]);
	            }],
	            referenceEntries: ['dataStore', 'view', 'referenceData', function (dataStore, view, referenceData) {
	                var references = view.getReferences();
	                for (var name in referenceData) {
	                    _Entry2.default.createArrayFromRest(referenceData[name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                    });
	                }
	            }],
	            referencedListData: ['$stateParams', 'ReadQueries', 'view', 'entry', function ($stateParams, ReadQueries, view, entry) {
	                return ReadQueries.getReferencedListData(view.getReferencedLists(), $stateParams.sortField, $stateParams.sortDir, entry.identifierValue);
	            }],
	            referencedListEntries: ['dataStore', 'view', 'referencedListData', function (dataStore, view, referencedListData) {
	                var referencedLists = view.getReferencedLists();
	                for (var name in referencedLists) {
	                    _Entry2.default.createArrayFromRest(referencedListData[name], referencedLists[name].targetFields(), referencedLists[name].targetEntity().name(), referencedLists[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(referencedLists[name].targetEntity().uniqueId + '_list', entry);
	                    });
	                }
	            }],
	            entryWithReferences: ['dataStore', 'view', 'entry', 'referenceEntries', function (dataStore, view, entry, referenceEntries) {
	                dataStore.fillReferencesValuesFromEntry(entry, view.getReferences(), true);
	                dataStore.addEntry(view.getEntity().uniqueId, entry);
	            }],
	            choiceData: ['ReadQueries', 'view', function (ReadQueries, view) {
	                return ReadQueries.getAllReferencedData(view.getReferences(false));
	            }],
	            choiceEntries: ['dataStore', 'view', 'choiceData', function (dataStore, view, filterData) {
	                var choices = view.getReferences(false);
	                for (var name in filterData) {
	                    _Entry2.default.createArrayFromRest(filterData[name], [choices[name].targetField()], choices[name].targetEntity().name(), choices[name].targetEntity().identifier().name()).map(function (entry) {
	                        return dataStore.addEntry(choices[name].targetEntity().uniqueId + '_choices', entry);
	                    });
	                }
	            }],
	            referenceDataForReferencedLists: ['$q', 'ReadQueries', 'view', 'referencedListData', function ($q, ReadQueries, view, referencedListData) {
	                var referencedLists = view.getReferencedLists();
	                var promises = {};
	                Object.keys(referencedLists).map(function (name) {
	                    promises[name] = ReadQueries.getReferenceData(referencedLists[name].targetFields(), referencedListData[name]);
	                });
	                return $q.all(promises);
	            }],
	            referenceEntriesForReferencedLists: ['dataStore', 'view', 'referenceDataForReferencedLists', function (dataStore, view, referenceDataForReferencedLists) {
	                var referencedLists = view.getReferencedLists();
	                Object.keys(referencedLists).map(function (referencedListName) {
	                    var references = referencedLists[referencedListName].getReferences();
	                    for (var name in references) {
	                        if (!referenceDataForReferencedLists[referencedListName][name]) {
	                            continue;
	                        }
	                        _Entry2.default.createArrayFromRest(referenceDataForReferencedLists[referencedListName][name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                            return dataStore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                        });
	                    }
	                });
	                return true;
	            }],
	            prepare: ['view', '$stateParams', 'dataStore', 'entry', 'referenceEntriesForReferencedLists', 'choiceEntries', 'entryWithReferences', '$window', '$injector', function (view, $stateParams, dataStore, entry, referenceEntriesForReferencedLists, choiceEntries, entryWithReferences, $window, $injector) {
	                return view.prepare() && $injector.invoke(view.prepare(), view, {
	                    query: $stateParams,
	                    datastore: dataStore,
	                    view: view,
	                    Entry: _Entry2.default,
	                    entry: entry,
	                    window: $window
	                });
	            }]
	        }
	    });

	    $stateProvider.state('delete', {
	        parent: 'ng-admin',
	        url: '/:entity/delete/:id',
	        controller: 'DeleteController',
	        controllerAs: 'deleteController',
	        templateProvider: templateProvider('DeleteView', _delete2.default),
	        params: {
	            page: { value: 1, squash: true },
	            search: { value: {}, squash: true },
	            sortField: null,
	            sortDir: null
	        },
	        resolve: {
	            dataStore: function dataStore() {
	                return new _DataStore2.default();
	            },
	            view: viewProvider('DeleteView'),
	            params: ['$stateParams', function ($stateParams) {
	                return $stateParams;
	            }],
	            rawEntry: ['$stateParams', 'ReadQueries', 'view', function ($stateParams, ReadQueries, view) {
	                return ReadQueries.getOne(view.getEntity(), view.type, $stateParams.id, view.identifier(), view.getUrl());
	            }],
	            entry: ['view', 'rawEntry', function (view, rawEntry) {
	                return view.mapEntry(rawEntry);
	            }],
	            prepare: ['view', '$stateParams', 'dataStore', 'entry', '$window', '$injector', function (view, $stateParams, dataStore, entry, $window, $injector) {
	                return view.prepare() && $injector.invoke(view.prepare(), view, {
	                    query: $stateParams,
	                    datastore: dataStore,
	                    view: view,
	                    Entry: _Entry2.default,
	                    entry: entry,
	                    window: $window
	                });
	            }]
	        }
	    });

	    $stateProvider.state('batchDelete', {
	        parent: 'ng-admin',
	        url: '/:entity/batch-delete/{ids:json}',
	        controller: 'BatchDeleteController',
	        controllerAs: 'batchDeleteController',
	        templateProvider: templateProvider('BatchDeleteView', _batchDelete2.default),
	        params: {
	            entity: null,
	            ids: [],
	            page: { value: 1, squash: true },
	            search: { value: {}, squash: true },
	            sortField: null,
	            sortDir: null
	        },
	        resolve: {
	            view: viewProvider('BatchDeleteView'),
	            params: ['$stateParams', function ($stateParams) {
	                return $stateParams;
	            }]
	        }
	    });
	}

	routing.$inject = ['$stateProvider'];

	exports.default = routing;
	module.exports = exports['default'];

/***/ },
/* 120 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ShowController = function () {
	    function ShowController($scope, $location, view, dataStore) {
	        _classCallCheck(this, ShowController);

	        this.$scope = $scope;
	        this.$location = $location;
	        this.title = view.title();
	        this.description = view.description();
	        this.actions = view.actions();

	        this.fields = view.fields();
	        this.$scope.entry = dataStore.getFirstEntry(view.getEntity().uniqueId);
	        this.$scope.view = view;
	        this.view = view;
	        this.entity = this.view.getEntity();
	        this.dataStore = dataStore;

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    _createClass(ShowController, [{
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	            this.$location = undefined;
	            this.view = undefined;
	            this.entity = undefined;
	            this.dataStore = undefined;
	        }
	    }]);

	    return ShowController;
	}();

	exports.default = ShowController;


	ShowController.$inject = ['$scope', '$location', 'view', 'dataStore'];
	module.exports = exports['default'];

/***/ },
/* 121 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maShowItem;
	/**
	 * A directive containing a label and a column
	 *
	 * To be used in the showView
	 */
	function maShowItem() {
	    return {
	        restrict: 'E',
	        scope: {
	            field: '&',
	            entry: '&',
	            entity: '&',
	            datastore: '&'
	        },
	        link: {
	            pre: function pre(scope) {
	                scope.field = scope.field();
	                scope.entry = scope.entry();
	                scope.entity = scope.entity();
	                scope.datastore = scope.datastore();
	            }
	        },
	        template: '<div class="col-lg-12 form-group">\n    <label class="col-sm-2 control-label">{{ field.label() | translate }}</label>\n    <div class="show-value" ng-class="(field.getCssClasses(entry) || \'col-sm-10 col-md-8 col-lg-7\')">\n        <div ng-class="::\'ng-admin-field-\' + field.name() + \' \' + \'ng-admin-type-\' + field.type()">\n            <ma-column field="::field" entry="::entry" entity="::entity" datastore="::datastore"></ma-column>\n        </div>\n    </div>\n</div>'
	    };
	}

	maShowItem.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 122 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maJsonValidator;
	function maJsonValidator() {
	    return {
	        require: 'ngModel',
	        link: function link(scope, elm, attr, ctrl) {
	            ctrl.$validators.json = function (value) {
	                if (ctrl.$isEmpty(value)) {
	                    return true;
	                }

	                try {
	                    angular.fromJson(value);

	                    return true;
	                } catch (e) {
	                    return false;
	                }
	            };
	        }
	    };
	}

	maJsonValidator.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _angular = __webpack_require__(3);

	var _angular2 = _interopRequireDefault(_angular);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	__webpack_require__(13);
	__webpack_require__(193);

	var MainModule = _angular2.default.module('main', ['ui.router', 'restangular', 'pascalprecht.translate']);

	MainModule.controller('AppController', __webpack_require__(124));
	MainModule.controller('DashboardController', __webpack_require__(125));
	MainModule.provider('NgAdminConfiguration', __webpack_require__(130));

	MainModule.filter('orderElement', __webpack_require__(128));
	MainModule.filter('stripTags', __webpack_require__(129));

	MainModule.directive('maDashboardPanel', __webpack_require__(126));
	MainModule.directive('maMenuBar', __webpack_require__(127));

	MainModule.config(__webpack_require__(131));
	MainModule.config(__webpack_require__(132));
	MainModule.config(__webpack_require__(133));

	MainModule.run(__webpack_require__(134));
	MainModule.run(__webpack_require__(135));

/***/ },
/* 124 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @param {$scope}  $scope
	 * @param {$state}  $state
	 * @param {NgAdmin} Configuration
	 * @constructor
	 */
	var AppController = function () {
	    function AppController($scope, $state, Configuration) {
	        _classCallCheck(this, AppController);

	        var application = Configuration();
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$scope.isCollapsed = true;
	        this.menu = application.menu();
	        this.applicationName = application.title();
	        this.header = application.header();

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    _createClass(AppController, [{
	        key: 'displayHome',
	        value: function displayHome() {
	            this.$state.go(this.$state.get('dashboard'));
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$scope = undefined;
	            this.$state = undefined;
	        }
	    }]);

	    return AppController;
	}();

	exports.default = AppController;


	AppController.$inject = ['$scope', '$state', 'NgAdminConfiguration'];
	module.exports = exports['default'];

/***/ },
/* 125 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @param {$scope} $scope
	 * @param {$state} $state
	 * @param {PanelBuilder} PanelBuilder
	 * @constructor
	 */
	var DashboardController = function () {
	    function DashboardController($scope, $state, collections, entries, hasEntities, dataStore) {
	        _classCallCheck(this, DashboardController);

	        this.$state = $state;
	        this.collections = collections;
	        this.entries = entries;
	        this.hasEntities = hasEntities;
	        this.datastore = dataStore;

	        $scope.$on('$destroy', this.destroy.bind(this));
	    }

	    _createClass(DashboardController, [{
	        key: 'gotoList',
	        value: function gotoList(entityName) {
	            this.$state.go(this.$state.get('list'), { entity: entityName });
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$state = undefined;
	        }
	    }]);

	    return DashboardController;
	}();

	exports.default = DashboardController;


	DashboardController.$inject = ['$scope', '$state', 'collections', 'entries', 'hasEntities', 'dataStore'];
	module.exports = exports['default'];

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maDashboardPanel;
	function maDashboardPanel($state) {
	    return {
	        restrict: 'E',
	        scope: {
	            collection: '&',
	            entries: '&',
	            datastore: '&'
	        },
	        link: function link(scope) {
	            scope.gotoList = function () {
	                $state.go($state.get('list'), { entity: scope.collection().entity.name() });
	            };
	        },
	        template: '<div class="panel-heading">\n    <a ng-click="gotoList()">{{ (collection().title() || collection().entity.label()) | translate }}</a>\n</div>\n<ma-datagrid name="{{ collection().name() }}"\n    entries="entries()"\n    fields="::collection().fields()"\n    entity="::collection().entity"\n    list-actions="::collection().listActions()"\n    datastore="datastore()">\n</ma-datagrid>'
	    };
	}

	maDashboardPanel.$inject = ['$state'];
	module.exports = exports['default'];

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = maMenuBar;

	var _menuBar = __webpack_require__(156);

	var _menuBar2 = _interopRequireDefault(_menuBar);

	var _angular = __webpack_require__(3);

	var _angular2 = _interopRequireDefault(_angular);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function maMenuBar($location, $rootScope, $compile) {
	    return {
	        restrict: 'E',
	        scope: {
	            'menu': '&'
	        },
	        link: function link(scope, element) {
	            scope.menu = scope.menu();
	            scope.path = $location.path();
	            // initialize openMenus
	            var openMenus = scope.menu.children().filter(function (menu) {
	                return menu.isChildActive(scope.path);
	            });
	            // manually render on change to avoid checking menu.isActive at each dirty check
	            var listener = $rootScope.$on('$locationChangeSuccess', function () {
	                scope.path = $location.path();
	                render();
	            });
	            $rootScope.$on('$destroy', listener);
	            scope.toggleMenu = function (menu) {
	                // handle click on parent menu manually
	                // because we chose bindOnce in the template for performance reasons
	                if (openMenus.indexOf(menu) !== -1) {
	                    // menu is already open, the click closes it
	                    // except if a submenu is open
	                    if (menu.isChildActive(scope.path)) {
	                        return;
	                    }
	                    openMenus.splice(openMenus.indexOf(menu), 1);
	                    closeMenu(menu);
	                } else {
	                    // menu is closed, the click opens it
	                    openMenus.push(menu);
	                    openMenu(menu);
	                }
	                // we don't render() in that case because it would cut the animation
	                return;
	            };
	            scope.activateLink = function (menu) {
	                if (!menu.link()) {
	                    return;
	                }
	                // close all open menus
	                // no need to close the menus with animation using closeMenu(),
	                // the menu will rerender anyway because of the listener on $locationChangeSuccess
	                // so the animation don't work in that case
	                if (menu.autoClose()) {
	                    openMenus = [];
	                }
	            };
	            scope.isOpen = function (menu) {
	                return menu.isChildActive(scope.path) || openMenus.indexOf(menu) !== -1;
	            };
	            render();

	            function render() {
	                element.html(_menuBar2.default);
	                $compile(element.contents())(scope);
	            }
	            function closeMenu(menu) {
	                var elements = getElementsForMenu(menu);
	                elements.ul.addClass('collapsed');
	                elements.arrow.removeClass('glyphicon-menu-down');
	                elements.arrow.addClass('glyphicon-menu-right');
	            }
	            function openMenu(menu) {
	                var elements = getElementsForMenu(menu);
	                elements.ul.removeClass('collapsed');
	                elements.arrow.removeClass('glyphicon-menu-right');
	                elements.arrow.addClass('glyphicon-menu-down');
	            }
	            function getElementsForMenu(menu) {
	                var parentLi;
	                _angular2.default.forEach(element.find('li'), function (li) {
	                    var liElement = _angular2.default.element(li);
	                    if (liElement.attr('data-menu-id') == menu.uuid) {
	                        parentLi = liElement;
	                    }
	                });
	                return {
	                    arrow: _angular2.default.element(parentLi.find('a')[0].getElementsByClassName('arrow')[0]),
	                    ul: parentLi.find('ul').eq(0)
	                };
	            }
	        }
	    };
	}

	maMenuBar.$inject = ['$location', '$rootScope', '$compile'];
	module.exports = exports['default'];

/***/ },
/* 128 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = OrderElement;
	function OrderElement() {
	    return function (input) {
	        var results = [],
	            objectKey;

	        for (objectKey in input) {
	            results.push(input[objectKey]);
	        }

	        results.sort(function (field1, field2) {
	            return typeof field1.order === 'function' ? field1.order() - field2.order() : field1.order - field2.order;
	        });

	        return results;
	    };
	}

	OrderElement.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = stripTags;
	function stripTags() {
	    return function (input) {
	        return input.replace(/(<([^>]+)>)/ig, '');
	    };
	}

	stripTags.$inject = [];
	module.exports = exports['default'];

/***/ },
/* 130 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NgAdminConfiguration = function () {
	    function NgAdminConfiguration($compileProvider) {
	        _classCallCheck(this, NgAdminConfiguration);

	        this.config = null;
	        this.adminDescription = null;
	        this.$compileProvider = $compileProvider;
	    }

	    _createClass(NgAdminConfiguration, [{
	        key: 'setAdminDescription',
	        value: function setAdminDescription(adminDescription) {
	            this.adminDescription = adminDescription;
	        }
	    }, {
	        key: 'configure',
	        value: function configure(config) {
	            this.config = config;

	            this.$compileProvider.debugInfoEnabled(this.config.debug());
	        }
	    }, {
	        key: '$get',
	        value: function $get() {
	            var config = this.config;
	            return function () {
	                return config;
	            };
	        }
	    }, {
	        key: 'application',
	        value: function application(name, debug) {
	            return this.adminDescription.application(name, debug);
	        }
	    }, {
	        key: 'entity',
	        value: function entity(name) {
	            return this.adminDescription.entity(name);
	        }
	    }, {
	        key: 'field',
	        value: function field(name, type) {
	            return this.adminDescription.field(name, type);
	        }
	    }, {
	        key: 'registerFieldType',
	        value: function registerFieldType(name, type) {
	            return this.adminDescription.registerFieldType(name, type);
	        }
	    }, {
	        key: 'getFieldConstructor',
	        value: function getFieldConstructor(name) {
	            return this.adminDescription.getFieldConstructor(name);
	        }
	    }, {
	        key: 'menu',
	        value: function menu(entity) {
	            return this.adminDescription.menu(entity);
	        }
	    }, {
	        key: 'collection',
	        value: function collection(_collection) {
	            return this.adminDescription.collection(_collection);
	        }
	    }, {
	        key: 'dashboard',
	        value: function dashboard(_dashboard) {
	            return this.adminDescription.dashboard(_dashboard);
	        }
	    }]);

	    return NgAdminConfiguration;
	}();

	exports.default = NgAdminConfiguration;


	NgAdminConfiguration.$inject = ['$compileProvider'];
	module.exports = exports['default'];

/***/ },
/* 131 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = http;
	function http($httpProvider) {
	    $httpProvider.useApplyAsync(true);
	}

	http.$inject = ['$httpProvider'];
	module.exports = exports['default'];

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _layout = __webpack_require__(155);

	var _layout2 = _interopRequireDefault(_layout);

	var _dashboard = __webpack_require__(154);

	var _dashboard2 = _interopRequireDefault(_dashboard);

	var _ = __webpack_require__(153);

	var _2 = _interopRequireDefault(_);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function dataStoreProvider() {
	    return ['AdminDescription', function (AdminDescription) {
	        return AdminDescription.getDataStore();
	    }];
	}

	function entryConstructorProvider() {
	    return ['AdminDescription', function (AdminDescription) {
	        return AdminDescription.getEntryConstructor();
	    }];
	}

	function routing($stateProvider, $urlRouterProvider) {

	    $stateProvider.state('ng-admin', {
	        abstract: true,
	        views: {
	            'ng-admin': {
	                controller: 'AppController',
	                controllerAs: 'appController',
	                templateProvider: ['NgAdminConfiguration', function (Configuration) {
	                    return Configuration().layout() || _layout2.default;
	                }]
	            }
	        }
	    });

	    $stateProvider.state('dashboard', {
	        parent: 'ng-admin',
	        url: '/dashboard?sortField&sortDir',
	        params: {
	            sortField: null,
	            sortDir: null
	        },
	        controller: 'DashboardController',
	        controllerAs: 'dashboardController',
	        templateProvider: ['NgAdminConfiguration', function (Configuration) {
	            return Configuration().dashboard().template() || _dashboard2.default;
	        }],
	        resolve: {
	            dataStore: dataStoreProvider(),
	            Entry: entryConstructorProvider(),
	            hasEntities: ['NgAdminConfiguration', function (Configuration) {
	                return Configuration().entities.length > 0;
	            }],
	            collections: ['NgAdminConfiguration', function (Configuration) {
	                return Configuration().dashboard().collections();
	            }],
	            responses: ['$stateParams', '$q', 'collections', 'dataStore', 'Entry', 'ReadQueries', function ($stateParams, $q, collections, dataStore, Entry, ReadQueries) {
	                var sortField = 'sortField' in $stateParams ? $stateParams.sortField : null;
	                var sortDir = 'sortDir' in $stateParams ? $stateParams.sortDir : null;

	                var promises = {},
	                    collection,
	                    collectionSortField,
	                    collectionSortDir,
	                    collectionName;

	                for (collectionName in collections) {
	                    collection = collections[collectionName];
	                    collectionSortField = collection.getSortFieldName();
	                    collectionSortDir = collection.sortDir();
	                    if (sortField && sortField.split('.')[0] === collection.name()) {
	                        collectionSortField = sortField;
	                        collectionSortDir = sortDir;
	                    }
	                    promises[collectionName] = function (collection, collectionSortField, collectionSortDir) {
	                        var rawEntries;

	                        return ReadQueries.getAll(collection, 1, {}, collectionSortField, collectionSortDir).then(function (response) {
	                            rawEntries = response.data;
	                            return rawEntries;
	                        }).then(function (rawEntries) {
	                            return ReadQueries.getReferenceData(collection.fields(), rawEntries);
	                        }).then(function (referenceData) {
	                            var references = collection.getReferences();
	                            for (var name in referenceData) {
	                                Entry.createArrayFromRest(referenceData[name], [references[name].targetField()], references[name].targetEntity().name(), references[name].targetEntity().identifier().name()).map(function (entry) {
	                                    return dataStore.addEntry(references[name].targetEntity().uniqueId + '_values', entry);
	                                });
	                            }
	                        }).then(function () {
	                            var entries = collection.mapEntries(rawEntries);

	                            // shortcut to display collection of entry with included referenced values
	                            dataStore.fillReferencesValuesFromCollection(entries, collection.getReferences(), true);

	                            return entries;
	                        });
	                    }(collection, collectionSortField, collectionSortDir);
	                }

	                return $q.all(promises);
	            }],
	            entries: ['responses', 'collections', function (responses, collections) {
	                var collectionName,
	                    entries = {};

	                for (collectionName in responses) {
	                    entries[collections[collectionName].name()] = responses[collectionName];
	                }

	                return entries;
	            }]
	        }
	    });

	    $stateProvider.state('ma-404', {
	        parent: 'ng-admin',
	        template: _2.default
	    });

	    $urlRouterProvider.when('', '/dashboard');

	    $urlRouterProvider.otherwise(function ($injector, $location) {
	        var state = $injector.get('$state');
	        state.go('ma-404');
	        return $location.path();
	    });
	}

	routing.$inject = ['$stateProvider', '$urlRouterProvider'];

	exports.default = routing;
	module.exports = exports['default'];

/***/ },
/* 133 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = translate;
	function translate($translateProvider) {
	  $translateProvider.translations('en', {
	    'BACK': 'Back',
	    'DELETE': 'Delete',
	    'CREATE': 'Create',
	    'EDIT': 'Edit',
	    'EXPORT': 'Export',
	    'ADD_FILTER': 'Add filter',
	    'SEE_RELATED': 'See all related {{ entityName }}',
	    'LIST': 'List',
	    'SHOW': 'Show',
	    'SAVE': 'Save',
	    'N_SELECTED': '{{ length }} Selected',
	    'ARE_YOU_SURE': 'Are you sure?',
	    'YES': 'Yes',
	    'NO': 'No',
	    'FILTER_VALUES': 'Filter values',
	    'CLOSE': 'Close',
	    'CLEAR': 'Clear',
	    'CURRENT': 'Current',
	    'REMOVE': 'Remove',
	    'ADD_NEW': 'Add new {{ name }}',
	    'BROWSE': 'Browse',
	    'N_COMPLETE': '{{ progress }}% Complete',
	    'CREATE_NEW': 'Create new',
	    'SUBMIT': 'Submit',
	    'SAVE_CHANGES': 'Save changes',
	    'BATCH_DELETE_SUCCESS': 'Elements successfully deleted',
	    'DELETE_SUCCESS': 'Element successfully deleted',
	    'ERROR_MESSAGE': 'Oops, an error occurred (code: {{ status }})',
	    'INVALID_FORM': 'Invalid form',
	    'CREATION_SUCCESS': 'Element successfully created',
	    'EDITION_SUCCESS': 'Changes successfully saved',
	    'ACTIONS': 'Actions',
	    'PAGINATION': '<strong>{{ begin }}</strong> - <strong>{{ end }}</strong> of <strong>{{ total }}</strong>',
	    'NO_PAGINATION': 'No record found',
	    'PREVIOUS': '« Prev',
	    'NEXT': 'Next »',
	    'DETAIL': 'Detail',
	    'STATE_CHANGE_ERROR': 'State change error: {{ message }}',
	    'NOT_FOUND': 'Not Found',
	    'NOT_FOUND_DETAILS': 'The page you are looking for cannot be found. Take a break before trying again.'
	  });
	  $translateProvider.preferredLanguage('en');
	  $translateProvider.useSanitizeValueStrategy('sanitize');
	}

	translate.$inject = ['$translateProvider'];
	module.exports = exports['default'];

/***/ },
/* 134 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = errorHandler;
	function errorHandler($rootScope, $state, $translate, notification) {
	    $rootScope.$on("$stateChangeError", function handleError(event, toState, toParams, fromState, fromParams, error) {
	        if (error.status == 404) {
	            $state.go('ma-404');
	            event.preventDefault();
	        } else {
	            $translate('STATE_CHANGE_ERROR', { message: error.message }).then(function (text) {
	                return notification.log(text, { addnCls: 'humane-flatty-error' });
	            });
	            throw error;
	        }
	    });
	}

	errorHandler.$inject = ['$rootScope', '$state', '$translate', 'notification'];
	module.exports = exports['default'];

/***/ },
/* 135 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = loader;
	/**
	 * Display loader on each route change
	 *
	 * @param {$rootScope}  $rootScope
	 * @param {$window}     $window
	 * @param {progression} progression
	 */
	function loader($rootScope, $window, progression) {
	    $rootScope.$on('$stateChangeStart', function () {
	        progression.start();
	    });

	    $rootScope.$on('$stateChangeSuccess', function () {
	        progression.done();
	        $window.scrollTo(0, 0);
	    });

	    $rootScope.$on("$stateChangeError", function () {
	        progression.done();
	    });
	}

	loader.$inject = ['$rootScope', '$window', 'progression'];
	module.exports = exports['default'];

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	global.rangy = __webpack_require__(25);
	global.rangy = __webpack_require__(192);
	global.numeral = __webpack_require__(24);

	__webpack_require__(3);
	__webpack_require__(13);
	__webpack_require__(189);
	__webpack_require__(198);
	__webpack_require__(27);

	__webpack_require__(26);
	__webpack_require__(28);
	__webpack_require__(188);

	global._ = __webpack_require__(199);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(2));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  var defaults = {
	    pairs: "()[]{}''\"\"",
	    triples: "",
	    explode: "[]{}"
	  };

	  var Pos = CodeMirror.Pos;

	  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      cm.removeKeyMap(keyMap);
	      cm.state.closeBrackets = null;
	    }
	    if (val) {
	      cm.state.closeBrackets = val;
	      cm.addKeyMap(keyMap);
	    }
	  });

	  function getOption(conf, name) {
	    if (name == "pairs" && typeof conf == "string") return conf;
	    if (typeof conf == "object" && conf[name] != null) return conf[name];
	    return defaults[name];
	  }

	  var bind = defaults.pairs + "`";
	  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};
	  for (var i = 0; i < bind.length; i++)
	    keyMap["'" + bind.charAt(i) + "'"] = handler(bind.charAt(i));

	  function handler(ch) {
	    return function(cm) { return handleChar(cm, ch); };
	  }

	  function getConfig(cm) {
	    var deflt = cm.state.closeBrackets;
	    if (!deflt) return null;
	    var mode = cm.getModeAt(cm.getCursor());
	    return mode.closeBrackets || deflt;
	  }

	  function handleBackspace(cm) {
	    var conf = getConfig(cm);
	    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

	    var pairs = getOption(conf, "pairs");
	    var ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) return CodeMirror.Pass;
	      var around = charsAround(cm, ranges[i].head);
	      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	    }
	    for (var i = ranges.length - 1; i >= 0; i--) {
	      var cur = ranges[i].head;
	      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
	    }
	  }

	  function handleEnter(cm) {
	    var conf = getConfig(cm);
	    var explode = conf && getOption(conf, "explode");
	    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;

	    var ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) return CodeMirror.Pass;
	      var around = charsAround(cm, ranges[i].head);
	      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	    }
	    cm.operation(function() {
	      cm.replaceSelection("\n\n", null);
	      cm.execCommand("goCharLeft");
	      ranges = cm.listSelections();
	      for (var i = 0; i < ranges.length; i++) {
	        var line = ranges[i].head.line;
	        cm.indentLine(line, null, true);
	        cm.indentLine(line + 1, null, true);
	      }
	    });
	  }

	  function contractSelection(sel) {
	    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
	    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
	            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};
	  }

	  function handleChar(cm, ch) {
	    var conf = getConfig(cm);
	    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

	    var pairs = getOption(conf, "pairs");
	    var pos = pairs.indexOf(ch);
	    if (pos == -1) return CodeMirror.Pass;
	    var triples = getOption(conf, "triples");

	    var identical = pairs.charAt(pos + 1) == ch;
	    var ranges = cm.listSelections();
	    var opening = pos % 2 == 0;

	    var type;
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i], cur = range.head, curType;
	      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
	      if (opening && !range.empty()) {
	        curType = "surround";
	      } else if ((identical || !opening) && next == ch) {
	        if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
	          curType = "skipThree";
	        else
	          curType = "skip";
	      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&
	                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&
	                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {
	        curType = "addFour";
	      } else if (identical) {
	        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = "both";
	        else return CodeMirror.Pass;
	      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||
	                             isClosingBracket(next, pairs) ||
	                             /\s/.test(next))) {
	        curType = "both";
	      } else {
	        return CodeMirror.Pass;
	      }
	      if (!type) type = curType;
	      else if (type != curType) return CodeMirror.Pass;
	    }

	    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
	    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
	    cm.operation(function() {
	      if (type == "skip") {
	        cm.execCommand("goCharRight");
	      } else if (type == "skipThree") {
	        for (var i = 0; i < 3; i++)
	          cm.execCommand("goCharRight");
	      } else if (type == "surround") {
	        var sels = cm.getSelections();
	        for (var i = 0; i < sels.length; i++)
	          sels[i] = left + sels[i] + right;
	        cm.replaceSelections(sels, "around");
	        sels = cm.listSelections().slice();
	        for (var i = 0; i < sels.length; i++)
	          sels[i] = contractSelection(sels[i]);
	        cm.setSelections(sels);
	      } else if (type == "both") {
	        cm.replaceSelection(left + right, null);
	        cm.triggerElectric(left + right);
	        cm.execCommand("goCharLeft");
	      } else if (type == "addFour") {
	        cm.replaceSelection(left + left + left + left, "before");
	        cm.execCommand("goCharRight");
	      }
	    });
	  }

	  function isClosingBracket(ch, pairs) {
	    var pos = pairs.lastIndexOf(ch);
	    return pos > -1 && pos % 2 == 1;
	  }

	  function charsAround(cm, pos) {
	    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
	                          Pos(pos.line, pos.ch + 1));
	    return str.length == 2 ? str : null;
	  }

	  // Project the token type that will exists after the given char is
	  // typed, and use it to determine whether it would cause the start
	  // of a string token.
	  function enteringString(cm, pos, ch) {
	    var line = cm.getLine(pos.line);
	    var token = cm.getTokenAt(pos);
	    if (/\bstring2?\b/.test(token.type)) return false;
	    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);
	    stream.pos = stream.start = token.start;
	    for (;;) {
	      var type1 = cm.getMode().token(stream, token.state);
	      if (stream.pos >= pos.ch + 1) return /\bstring2?\b/.test(type1);
	      stream.start = stream.pos;
	    }
	  }
	});


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(2));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
	    (document.documentMode == null || document.documentMode < 8);

	  var Pos = CodeMirror.Pos;

	  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};

	  function findMatchingBracket(cm, where, strict, config) {
	    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
	    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
	    if (!match) return null;
	    var dir = match.charAt(1) == ">" ? 1 : -1;
	    if (strict && (dir > 0) != (pos == where.ch)) return null;
	    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

	    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
	    if (found == null) return null;
	    return {from: Pos(where.line, pos), to: found && found.pos,
	            match: found && found.ch == match.charAt(0), forward: dir > 0};
	  }

	  // bracketRegex is used to specify which type of bracket to scan
	  // should be a regexp, e.g. /[[\]]/
	  //
	  // Note: If "where" is on an open bracket, then this bracket is ignored.
	  //
	  // Returns false when no bracket was found, null when it reached
	  // maxScanLines and gave up
	  function scanForBracket(cm, where, dir, style, config) {
	    var maxScanLen = (config && config.maxScanLineLength) || 10000;
	    var maxScanLines = (config && config.maxScanLines) || 1000;

	    var stack = [];
	    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/;
	    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
	                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
	    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
	      var line = cm.getLine(lineNo);
	      if (!line) continue;
	      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
	      if (line.length > maxScanLen) continue;
	      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
	      for (; pos != end; pos += dir) {
	        var ch = line.charAt(pos);
	        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
	          var match = matching[ch];
	          if ((match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
	          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
	          else stack.pop();
	        }
	      }
	    }
	    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
	  }

	  function matchBrackets(cm, autoclear, config) {
	    // Disable brace matching in long lines, since it'll cause hugely slow updates
	    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
	    var marks = [], ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++) {
	      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);
	      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
	        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
	        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
	        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
	          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
	      }
	    }

	    if (marks.length) {
	      // Kludge to work around the IE bug from issue #1193, where text
	      // input stops going to the textare whever this fires.
	      if (ie_lt8 && cm.state.focused) cm.focus();

	      var clear = function() {
	        cm.operation(function() {
	          for (var i = 0; i < marks.length; i++) marks[i].clear();
	        });
	      };
	      if (autoclear) setTimeout(clear, 800);
	      else return clear;
	    }
	  }

	  var currentlyHighlighted = null;
	  function doMatchBrackets(cm) {
	    cm.operation(function() {
	      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
	      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
	    });
	  }

	  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      cm.off("cursorActivity", doMatchBrackets);
	      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
	    }
	    if (val) {
	      cm.state.matchBrackets = typeof val == "object" ? val : {};
	      cm.on("cursorActivity", doMatchBrackets);
	    }
	  });

	  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
	  CodeMirror.defineExtension("findMatchingBracket", function(pos, strict, config){
	    return findMatchingBracket(this, pos, strict, config);
	  });
	  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
	    return scanForBracket(this, pos, dir, style, config);
	  });
	});


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// Depends on jsonlint.js from https://github.com/zaach/jsonlint

	// declare global: jsonlint

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(2));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	CodeMirror.registerHelper("lint", "json", function(text) {
	  var found = [];
	  jsonlint.parseError = function(str, hash) {
	    var loc = hash.loc;
	    found.push({from: CodeMirror.Pos(loc.first_line - 1, loc.first_column),
	                to: CodeMirror.Pos(loc.last_line - 1, loc.last_column),
	                message: str});
	  };
	  try { jsonlint.parse(text); }
	  catch(e) {}
	  return found;
	});

	});


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(2));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	  var GUTTER_ID = "CodeMirror-lint-markers";

	  function showTooltip(e, content) {
	    var tt = document.createElement("div");
	    tt.className = "CodeMirror-lint-tooltip";
	    tt.appendChild(content.cloneNode(true));
	    document.body.appendChild(tt);

	    function position(e) {
	      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
	      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
	      tt.style.left = (e.clientX + 5) + "px";
	    }
	    CodeMirror.on(document, "mousemove", position);
	    position(e);
	    if (tt.style.opacity != null) tt.style.opacity = 1;
	    return tt;
	  }
	  function rm(elt) {
	    if (elt.parentNode) elt.parentNode.removeChild(elt);
	  }
	  function hideTooltip(tt) {
	    if (!tt.parentNode) return;
	    if (tt.style.opacity == null) rm(tt);
	    tt.style.opacity = 0;
	    setTimeout(function() { rm(tt); }, 600);
	  }

	  function showTooltipFor(e, content, node) {
	    var tooltip = showTooltip(e, content);
	    function hide() {
	      CodeMirror.off(node, "mouseout", hide);
	      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
	    }
	    var poll = setInterval(function() {
	      if (tooltip) for (var n = node;; n = n.parentNode) {
	        if (n && n.nodeType == 11) n = n.host;
	        if (n == document.body) return;
	        if (!n) { hide(); break; }
	      }
	      if (!tooltip) return clearInterval(poll);
	    }, 400);
	    CodeMirror.on(node, "mouseout", hide);
	  }

	  function LintState(cm, options, hasGutter) {
	    this.marked = [];
	    this.options = options;
	    this.timeout = null;
	    this.hasGutter = hasGutter;
	    this.onMouseOver = function(e) { onMouseOver(cm, e); };
	    this.waitingFor = 0
	  }

	  function parseOptions(_cm, options) {
	    if (options instanceof Function) return {getAnnotations: options};
	    if (!options || options === true) options = {};
	    return options;
	  }

	  function clearMarks(cm) {
	    var state = cm.state.lint;
	    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
	    for (var i = 0; i < state.marked.length; ++i)
	      state.marked[i].clear();
	    state.marked.length = 0;
	  }

	  function makeMarker(labels, severity, multiple, tooltips) {
	    var marker = document.createElement("div"), inner = marker;
	    marker.className = "CodeMirror-lint-marker-" + severity;
	    if (multiple) {
	      inner = marker.appendChild(document.createElement("div"));
	      inner.className = "CodeMirror-lint-marker-multiple";
	    }

	    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
	      showTooltipFor(e, labels, inner);
	    });

	    return marker;
	  }

	  function getMaxSeverity(a, b) {
	    if (a == "error") return a;
	    else return b;
	  }

	  function groupByLine(annotations) {
	    var lines = [];
	    for (var i = 0; i < annotations.length; ++i) {
	      var ann = annotations[i], line = ann.from.line;
	      (lines[line] || (lines[line] = [])).push(ann);
	    }
	    return lines;
	  }

	  function annotationTooltip(ann) {
	    var severity = ann.severity;
	    if (!severity) severity = "error";
	    var tip = document.createElement("div");
	    tip.className = "CodeMirror-lint-message-" + severity;
	    tip.appendChild(document.createTextNode(ann.message));
	    return tip;
	  }

	  function lintAsync(cm, getAnnotations, passOptions) {
	    var state = cm.state.lint
	    var id = ++state.waitingFor
	    function abort() {
	      id = -1
	      cm.off("change", abort)
	    }
	    cm.on("change", abort)
	    getAnnotations(cm.getValue(), function(annotations, arg2) {
	      cm.off("change", abort)
	      if (state.waitingFor != id) return
	      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
	      updateLinting(cm, annotations)
	    }, passOptions, cm);
	  }

	  function startLinting(cm) {
	    var state = cm.state.lint, options = state.options;
	    var passOptions = options.options || options; // Support deprecated passing of `options` property in options
	    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
	    if (!getAnnotations) return;
	    if (options.async || getAnnotations.async) {
	      lintAsync(cm, getAnnotations, passOptions)
	    } else {
	      updateLinting(cm, getAnnotations(cm.getValue(), passOptions, cm));
	    }
	  }

	  function updateLinting(cm, annotationsNotSorted) {
	    clearMarks(cm);
	    var state = cm.state.lint, options = state.options;

	    var annotations = groupByLine(annotationsNotSorted);

	    for (var line = 0; line < annotations.length; ++line) {
	      var anns = annotations[line];
	      if (!anns) continue;

	      var maxSeverity = null;
	      var tipLabel = state.hasGutter && document.createDocumentFragment();

	      for (var i = 0; i < anns.length; ++i) {
	        var ann = anns[i];
	        var severity = ann.severity;
	        if (!severity) severity = "error";
	        maxSeverity = getMaxSeverity(maxSeverity, severity);

	        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
	        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

	        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
	          className: "CodeMirror-lint-mark-" + severity,
	          __annotation: ann
	        }));
	      }

	      if (state.hasGutter)
	        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
	                                                       state.options.tooltips));
	    }
	    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
	  }

	  function onChange(cm) {
	    var state = cm.state.lint;
	    if (!state) return;
	    clearTimeout(state.timeout);
	    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
	  }

	  function popupTooltips(annotations, e) {
	    var target = e.target || e.srcElement;
	    var tooltip = document.createDocumentFragment();
	    for (var i = 0; i < annotations.length; i++) {
	      var ann = annotations[i];
	      tooltip.appendChild(annotationTooltip(ann));
	    }
	    showTooltipFor(e, tooltip, target);
	  }

	  function onMouseOver(cm, e) {
	    var target = e.target || e.srcElement;
	    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
	    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
	    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

	    var annotations = [];
	    for (var i = 0; i < spans.length; ++i) {
	      var ann = spans[i].__annotation;
	      if (ann) annotations.push(ann);
	    }
	    if (annotations.length) popupTooltips(annotations, e);
	  }

	  CodeMirror.defineOption("lint", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      clearMarks(cm);
	      if (cm.state.lint.options.lintOnChange !== false)
	        cm.off("change", onChange);
	      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
	      clearTimeout(cm.state.lint.timeout);
	      delete cm.state.lint;
	    }

	    if (val) {
	      var gutters = cm.getOption("gutters"), hasLintGutter = false;
	      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
	      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
	      if (state.options.lintOnChange !== false)
	        cm.on("change", onChange);
	      if (state.options.tooltips != false)
	        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

	      startLinting(cm);
	    }
	  });

	  CodeMirror.defineExtension("performLint", function() {
	    if (this.state.lint) startLinting(this);
	  });
	});


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// Because sometimes you need to style the cursor's line.
	//
	// Adds an option 'styleActiveLine' which, when enabled, gives the
	// active line's wrapping <div> the CSS class "CodeMirror-activeline",
	// and gives its background <div> the class "CodeMirror-activeline-background".

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(2));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	  var WRAP_CLASS = "CodeMirror-activeline";
	  var BACK_CLASS = "CodeMirror-activeline-background";
	  var GUTT_CLASS = "CodeMirror-activeline-gutter";

	  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
	    var prev = old && old != CodeMirror.Init;
	    if (val && !prev) {
	      cm.state.activeLines = [];
	      updateActiveLines(cm, cm.listSelections());
	      cm.on("beforeSelectionChange", selectionChange);
	    } else if (!val && prev) {
	      cm.off("beforeSelectionChange", selectionChange);
	      clearActiveLines(cm);
	      delete cm.state.activeLines;
	    }
	  });

	  function clearActiveLines(cm) {
	    for (var i = 0; i < cm.state.activeLines.length; i++) {
	      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
	      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
	      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
	    }
	  }

	  function sameArray(a, b) {
	    if (a.length != b.length) return false;
	    for (var i = 0; i < a.length; i++)
	      if (a[i] != b[i]) return false;
	    return true;
	  }

	  function updateActiveLines(cm, ranges) {
	    var active = [];
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i];
	      if (!range.empty()) continue;
	      var line = cm.getLineHandleVisualStart(range.head.line);
	      if (active[active.length - 1] != line) active.push(line);
	    }
	    if (sameArray(cm.state.activeLines, active)) return;
	    cm.operation(function() {
	      clearActiveLines(cm);
	      for (var i = 0; i < active.length; i++) {
	        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
	        cm.addLineClass(active[i], "background", BACK_CLASS);
	        cm.addLineClass(active[i], "gutter", GUTT_CLASS);
	      }
	      cm.state.activeLines = active;
	    });
	  }

	  function selectionChange(cm, sel) {
	    updateActiveLines(cm, sel.ranges);
	  }
	});


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(2));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	function expressionAllowed(stream, state, backUp) {
	  return /^(?:operator|sof|keyword c|case|new|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
	    (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
	}

	CodeMirror.defineMode("javascript", function(config, parserConfig) {
	  var indentUnit = config.indentUnit;
	  var statementIndent = parserConfig.statementIndent;
	  var jsonldMode = parserConfig.jsonld;
	  var jsonMode = parserConfig.json || jsonldMode;
	  var isTS = parserConfig.typescript;
	  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

	  // Tokenizer

	  var keywords = function(){
	    function kw(type) {return {type: type, style: "keyword"};}
	    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
	    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

	    var jsKeywords = {
	      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
	      "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "throw": C, "debugger": C,
	      "var": kw("var"), "const": kw("var"), "let": kw("var"),
	      "function": kw("function"), "catch": kw("catch"),
	      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
	      "in": operator, "typeof": operator, "instanceof": operator,
	      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
	      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
	      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
	      "await": C, "async": kw("async")
	    };

	    // Extend the 'normal' keywords with the TypeScript language extensions
	    if (isTS) {
	      var type = {type: "variable", style: "variable-3"};
	      var tsKeywords = {
	        // object-like things
	        "interface": kw("class"),
	        "implements": C,
	        "namespace": C,
	        "module": kw("module"),
	        "enum": kw("module"),
	        "type": kw("type"),

	        // scope modifiers
	        "public": kw("modifier"),
	        "private": kw("modifier"),
	        "protected": kw("modifier"),
	        "abstract": kw("modifier"),

	        // operators
	        "as": operator,

	        // types
	        "string": type, "number": type, "boolean": type, "any": type
	      };

	      for (var attr in tsKeywords) {
	        jsKeywords[attr] = tsKeywords[attr];
	      }
	    }

	    return jsKeywords;
	  }();

	  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
	  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

	  function readRegexp(stream) {
	    var escaped = false, next, inSet = false;
	    while ((next = stream.next()) != null) {
	      if (!escaped) {
	        if (next == "/" && !inSet) return;
	        if (next == "[") inSet = true;
	        else if (inSet && next == "]") inSet = false;
	      }
	      escaped = !escaped && next == "\\";
	    }
	  }

	  // Used as scratch variables to communicate multiple values without
	  // consing up tons of objects.
	  var type, content;
	  function ret(tp, style, cont) {
	    type = tp; content = cont;
	    return style;
	  }
	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (ch == '"' || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
	      return ret("number", "number");
	    } else if (ch == "." && stream.match("..")) {
	      return ret("spread", "meta");
	    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
	      return ret(ch);
	    } else if (ch == "=" && stream.eat(">")) {
	      return ret("=>", "operator");
	    } else if (ch == "0" && stream.eat(/x/i)) {
	      stream.eatWhile(/[\da-f]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/o/i)) {
	      stream.eatWhile(/[0-7]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/b/i)) {
	      stream.eatWhile(/[01]/i);
	      return ret("number", "number");
	    } else if (/\d/.test(ch)) {
	      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
	      return ret("number", "number");
	    } else if (ch == "/") {
	      if (stream.eat("*")) {
	        state.tokenize = tokenComment;
	        return tokenComment(stream, state);
	      } else if (stream.eat("/")) {
	        stream.skipToEnd();
	        return ret("comment", "comment");
	      } else if (expressionAllowed(stream, state, 1)) {
	        readRegexp(stream);
	        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
	        return ret("regexp", "string-2");
	      } else {
	        stream.eatWhile(isOperatorChar);
	        return ret("operator", "operator", stream.current());
	      }
	    } else if (ch == "`") {
	      state.tokenize = tokenQuasi;
	      return tokenQuasi(stream, state);
	    } else if (ch == "#") {
	      stream.skipToEnd();
	      return ret("error", "error");
	    } else if (isOperatorChar.test(ch)) {
	      stream.eatWhile(isOperatorChar);
	      return ret("operator", "operator", stream.current());
	    } else if (wordRE.test(ch)) {
	      stream.eatWhile(wordRE);
	      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
	      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
	                     ret("variable", "variable", word);
	    }
	  }

	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, next;
	      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
	        state.tokenize = tokenBase;
	        return ret("jsonld-keyword", "meta");
	      }
	      while ((next = stream.next()) != null) {
	        if (next == quote && !escaped) break;
	        escaped = !escaped && next == "\\";
	      }
	      if (!escaped) state.tokenize = tokenBase;
	      return ret("string", "string");
	    };
	  }

	  function tokenComment(stream, state) {
	    var maybeEnd = false, ch;
	    while (ch = stream.next()) {
	      if (ch == "/" && maybeEnd) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ret("comment", "comment");
	  }

	  function tokenQuasi(stream, state) {
	    var escaped = false, next;
	    while ((next = stream.next()) != null) {
	      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      escaped = !escaped && next == "\\";
	    }
	    return ret("quasi", "string-2", stream.current());
	  }

	  var brackets = "([{}])";
	  // This is a crude lookahead trick to try and notice that we're
	  // parsing the argument patterns for a fat-arrow function before we
	  // actually hit the arrow token. It only works if the arrow is on
	  // the same line as the arguments and there's no strange noise
	  // (comments) in between. Fallback is to only notice when we hit the
	  // arrow, and not declare the arguments as locals for the arrow
	  // body.
	  function findFatArrow(stream, state) {
	    if (state.fatArrowAt) state.fatArrowAt = null;
	    var arrow = stream.string.indexOf("=>", stream.start);
	    if (arrow < 0) return;

	    var depth = 0, sawSomething = false;
	    for (var pos = arrow - 1; pos >= 0; --pos) {
	      var ch = stream.string.charAt(pos);
	      var bracket = brackets.indexOf(ch);
	      if (bracket >= 0 && bracket < 3) {
	        if (!depth) { ++pos; break; }
	        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
	      } else if (bracket >= 3 && bracket < 6) {
	        ++depth;
	      } else if (wordRE.test(ch)) {
	        sawSomething = true;
	      } else if (/["'\/]/.test(ch)) {
	        return;
	      } else if (sawSomething && !depth) {
	        ++pos;
	        break;
	      }
	    }
	    if (sawSomething && !depth) state.fatArrowAt = pos;
	  }

	  // Parser

	  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

	  function JSLexical(indented, column, type, align, prev, info) {
	    this.indented = indented;
	    this.column = column;
	    this.type = type;
	    this.prev = prev;
	    this.info = info;
	    if (align != null) this.align = align;
	  }

	  function inScope(state, varname) {
	    for (var v = state.localVars; v; v = v.next)
	      if (v.name == varname) return true;
	    for (var cx = state.context; cx; cx = cx.prev) {
	      for (var v = cx.vars; v; v = v.next)
	        if (v.name == varname) return true;
	    }
	  }

	  function parseJS(state, style, type, content, stream) {
	    var cc = state.cc;
	    // Communicate our context to the combinators.
	    // (Less wasteful than consing up a hundred closures on every call.)
	    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

	    if (!state.lexical.hasOwnProperty("align"))
	      state.lexical.align = true;

	    while(true) {
	      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
	      if (combinator(type, content)) {
	        while(cc.length && cc[cc.length - 1].lex)
	          cc.pop()();
	        if (cx.marked) return cx.marked;
	        if (type == "variable" && inScope(state, content)) return "variable-2";
	        return style;
	      }
	    }
	  }

	  // Combinator utils

	  var cx = {state: null, column: null, marked: null, cc: null};
	  function pass() {
	    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
	  }
	  function cont() {
	    pass.apply(null, arguments);
	    return true;
	  }
	  function register(varname) {
	    function inList(list) {
	      for (var v = list; v; v = v.next)
	        if (v.name == varname) return true;
	      return false;
	    }
	    var state = cx.state;
	    cx.marked = "def";
	    if (state.context) {
	      if (inList(state.localVars)) return;
	      state.localVars = {name: varname, next: state.localVars};
	    } else {
	      if (inList(state.globalVars)) return;
	      if (parserConfig.globalVars)
	        state.globalVars = {name: varname, next: state.globalVars};
	    }
	  }

	  // Combinators

	  var defaultVars = {name: "this", next: {name: "arguments"}};
	  function pushcontext() {
	    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
	    cx.state.localVars = defaultVars;
	  }
	  function popcontext() {
	    cx.state.localVars = cx.state.context.vars;
	    cx.state.context = cx.state.context.prev;
	  }
	  function pushlex(type, info) {
	    var result = function() {
	      var state = cx.state, indent = state.indented;
	      if (state.lexical.type == "stat") indent = state.lexical.indented;
	      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
	        indent = outer.indented;
	      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
	    };
	    result.lex = true;
	    return result;
	  }
	  function poplex() {
	    var state = cx.state;
	    if (state.lexical.prev) {
	      if (state.lexical.type == ")")
	        state.indented = state.lexical.indented;
	      state.lexical = state.lexical.prev;
	    }
	  }
	  poplex.lex = true;

	  function expect(wanted) {
	    function exp(type) {
	      if (type == wanted) return cont();
	      else if (wanted == ";") return pass();
	      else return cont(exp);
	    };
	    return exp;
	  }

	  function statement(type, value) {
	    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
	    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
	    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
	    if (type == "{") return cont(pushlex("}"), block, poplex);
	    if (type == ";") return cont();
	    if (type == "if") {
	      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
	        cx.state.cc.pop()();
	      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
	    }
	    if (type == "function") return cont(functiondef);
	    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
	    if (type == "variable") return cont(pushlex("stat"), maybelabel);
	    if (type == "switch") return cont(pushlex("form"), parenExpr, pushlex("}", "switch"), expect("{"),
	                                      block, poplex, poplex);
	    if (type == "case") return cont(expression, expect(":"));
	    if (type == "default") return cont(expect(":"));
	    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
	                                     statement, poplex, popcontext);
	    if (type == "class") return cont(pushlex("form"), className, poplex);
	    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
	    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
	    if (type == "module") return cont(pushlex("form"), pattern, pushlex("}"), expect("{"), block, poplex, poplex)
	    if (type == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
	    if (type == "async") return cont(statement)
	    return pass(pushlex("stat"), expression, expect(";"), poplex);
	  }
	  function expression(type) {
	    return expressionInner(type, false);
	  }
	  function expressionNoComma(type) {
	    return expressionInner(type, true);
	  }
	  function parenExpr(type) {
	    if (type != "(") return pass()
	    return cont(pushlex(")"), expression, expect(")"), poplex)
	  }
	  function expressionInner(type, noComma) {
	    if (cx.state.fatArrowAt == cx.stream.start) {
	      var body = noComma ? arrowBodyNoComma : arrowBody;
	      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
	      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
	    }

	    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
	    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
	    if (type == "function") return cont(functiondef, maybeop);
	    if (type == "keyword c" || type == "async") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
	    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
	    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
	    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
	    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
	    if (type == "quasi") return pass(quasi, maybeop);
	    if (type == "new") return cont(maybeTarget(noComma));
	    return cont();
	  }
	  function maybeexpression(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expression);
	  }
	  function maybeexpressionNoComma(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expressionNoComma);
	  }

	  function maybeoperatorComma(type, value) {
	    if (type == ",") return cont(expression);
	    return maybeoperatorNoComma(type, value, false);
	  }
	  function maybeoperatorNoComma(type, value, noComma) {
	    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
	    var expr = noComma == false ? expression : expressionNoComma;
	    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
	    if (type == "operator") {
	      if (/\+\+|--/.test(value)) return cont(me);
	      if (value == "?") return cont(expression, expect(":"), expr);
	      return cont(expr);
	    }
	    if (type == "quasi") { return pass(quasi, me); }
	    if (type == ";") return;
	    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
	    if (type == ".") return cont(property, me);
	    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
	  }
	  function quasi(type, value) {
	    if (type != "quasi") return pass();
	    if (value.slice(value.length - 2) != "${") return cont(quasi);
	    return cont(expression, continueQuasi);
	  }
	  function continueQuasi(type) {
	    if (type == "}") {
	      cx.marked = "string-2";
	      cx.state.tokenize = tokenQuasi;
	      return cont(quasi);
	    }
	  }
	  function arrowBody(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expression);
	  }
	  function arrowBodyNoComma(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expressionNoComma);
	  }
	  function maybeTarget(noComma) {
	    return function(type) {
	      if (type == ".") return cont(noComma ? targetNoComma : target);
	      else return pass(noComma ? expressionNoComma : expression);
	    };
	  }
	  function target(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
	  }
	  function targetNoComma(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
	  }
	  function maybelabel(type) {
	    if (type == ":") return cont(poplex, statement);
	    return pass(maybeoperatorComma, expect(";"), poplex);
	  }
	  function property(type) {
	    if (type == "variable") {cx.marked = "property"; return cont();}
	  }
	  function objprop(type, value) {
	    if (type == "async") {
	      cx.marked = "property";
	      return cont(objprop);
	    } else if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      if (value == "get" || value == "set") return cont(getterSetter);
	      return cont(afterprop);
	    } else if (type == "number" || type == "string") {
	      cx.marked = jsonldMode ? "property" : (cx.style + " property");
	      return cont(afterprop);
	    } else if (type == "jsonld-keyword") {
	      return cont(afterprop);
	    } else if (type == "modifier") {
	      return cont(objprop)
	    } else if (type == "[") {
	      return cont(expression, expect("]"), afterprop);
	    } else if (type == "spread") {
	      return cont(expression);
	    } else if (type == ":") {
	      return pass(afterprop)
	    }
	  }
	  function getterSetter(type) {
	    if (type != "variable") return pass(afterprop);
	    cx.marked = "property";
	    return cont(functiondef);
	  }
	  function afterprop(type) {
	    if (type == ":") return cont(expressionNoComma);
	    if (type == "(") return pass(functiondef);
	  }
	  function commasep(what, end) {
	    function proceed(type, value) {
	      if (type == ",") {
	        var lex = cx.state.lexical;
	        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
	        return cont(function(type, value) {
	          if (type == end || value == end) return pass()
	          return pass(what)
	        }, proceed);
	      }
	      if (type == end || value == end) return cont();
	      return cont(expect(end));
	    }
	    return function(type, value) {
	      if (type == end || value == end) return cont();
	      return pass(what, proceed);
	    };
	  }
	  function contCommasep(what, end, info) {
	    for (var i = 3; i < arguments.length; i++)
	      cx.cc.push(arguments[i]);
	    return cont(pushlex(end, info), commasep(what, end), poplex);
	  }
	  function block(type) {
	    if (type == "}") return cont();
	    return pass(statement, block);
	  }
	  function maybetype(type, value) {
	    if (isTS) {
	      if (type == ":") return cont(typeexpr);
	      if (value == "?") return cont(maybetype);
	    }
	  }
	  function maybedefault(_, value) {
	    if (value == "=") return cont(expressionNoComma);
	  }
	  function typeexpr(type) {
	    if (type == "variable") {cx.marked = "variable-3"; return cont(afterType);}
	    if (type == "{") return cont(commasep(typeprop, "}"))
	    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType)
	  }
	  function maybeReturnType(type) {
	    if (type == "=>") return cont(typeexpr)
	  }
	  function typeprop(type) {
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property"
	      return cont(typeprop)
	    } else if (type == ":") {
	      return cont(typeexpr)
	    }
	  }
	  function typearg(type) {
	    if (type == "variable") return cont(typearg)
	    else if (type == ":") return cont(typeexpr)
	  }
	  function afterType(type, value) {
	    if (value == "<") return cont(commasep(typeexpr, ">"), afterType)
	    if (type == "[") return cont(expect("]"), afterType)
	  }
	  function vardef() {
	    return pass(pattern, maybetype, maybeAssign, vardefCont);
	  }
	  function pattern(type, value) {
	    if (type == "modifier") return cont(pattern)
	    if (type == "variable") { register(value); return cont(); }
	    if (type == "spread") return cont(pattern);
	    if (type == "[") return contCommasep(pattern, "]");
	    if (type == "{") return contCommasep(proppattern, "}");
	  }
	  function proppattern(type, value) {
	    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
	      register(value);
	      return cont(maybeAssign);
	    }
	    if (type == "variable") cx.marked = "property";
	    if (type == "spread") return cont(pattern);
	    if (type == "}") return pass();
	    return cont(expect(":"), pattern, maybeAssign);
	  }
	  function maybeAssign(_type, value) {
	    if (value == "=") return cont(expressionNoComma);
	  }
	  function vardefCont(type) {
	    if (type == ",") return cont(vardef);
	  }
	  function maybeelse(type, value) {
	    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
	  }
	  function forspec(type) {
	    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
	  }
	  function forspec1(type) {
	    if (type == "var") return cont(vardef, expect(";"), forspec2);
	    if (type == ";") return cont(forspec2);
	    if (type == "variable") return cont(formaybeinof);
	    return pass(expression, expect(";"), forspec2);
	  }
	  function formaybeinof(_type, value) {
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return cont(maybeoperatorComma, forspec2);
	  }
	  function forspec2(type, value) {
	    if (type == ";") return cont(forspec3);
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return pass(expression, expect(";"), forspec3);
	  }
	  function forspec3(type) {
	    if (type != ")") cont(expression);
	  }
	  function functiondef(type, value) {
	    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
	    if (type == "variable") {register(value); return cont(functiondef);}
	    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext);
	  }
	  function funarg(type) {
	    if (type == "spread") return cont(funarg);
	    return pass(pattern, maybetype, maybedefault);
	  }
	  function className(type, value) {
	    if (type == "variable") {register(value); return cont(classNameAfter);}
	  }
	  function classNameAfter(type, value) {
	    if (value == "extends") return cont(isTS ? typeexpr : expression, classNameAfter);
	    if (type == "{") return cont(pushlex("}"), classBody, poplex);
	  }
	  function classBody(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      if ((value == "static" || value == "get" || value == "set" ||
	           (isTS && (value == "public" || value == "private" || value == "protected"))) &&
	          cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
	        cx.marked = "keyword";
	        return cont(classBody);
	      }
	      cx.marked = "property";
	      return cont(isTS ? classfield : functiondef, classBody);
	    }
	    if (value == "*") {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (type == ";") return cont(classBody);
	    if (type == "}") return cont();
	  }
	  function classfield(type) {
	    if (type == ":") return cont(typeexpr)
	    return pass(functiondef)
	  }
	  function afterExport(_type, value) {
	    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
	    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
	    return pass(statement);
	  }
	  function afterImport(type) {
	    if (type == "string") return cont();
	    return pass(importSpec, maybeFrom);
	  }
	  function importSpec(type, value) {
	    if (type == "{") return contCommasep(importSpec, "}");
	    if (type == "variable") register(value);
	    if (value == "*") cx.marked = "keyword";
	    return cont(maybeAs);
	  }
	  function maybeAs(_type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
	  }
	  function maybeFrom(_type, value) {
	    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
	  }
	  function arrayLiteral(type) {
	    if (type == "]") return cont();
	    return pass(commasep(expressionNoComma, "]"));
	  }

	  function isContinuedStatement(state, textAfter) {
	    return state.lastType == "operator" || state.lastType == "," ||
	      isOperatorChar.test(textAfter.charAt(0)) ||
	      /[,.]/.test(textAfter.charAt(0));
	  }

	  // Interface

	  return {
	    startState: function(basecolumn) {
	      var state = {
	        tokenize: tokenBase,
	        lastType: "sof",
	        cc: [],
	        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
	        localVars: parserConfig.localVars,
	        context: parserConfig.localVars && {vars: parserConfig.localVars},
	        indented: basecolumn || 0
	      };
	      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
	        state.globalVars = parserConfig.globalVars;
	      return state;
	    },

	    token: function(stream, state) {
	      if (stream.sol()) {
	        if (!state.lexical.hasOwnProperty("align"))
	          state.lexical.align = false;
	        state.indented = stream.indentation();
	        findFatArrow(stream, state);
	      }
	      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
	      var style = state.tokenize(stream, state);
	      if (type == "comment") return style;
	      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
	      return parseJS(state, style, type, content, stream);
	    },

	    indent: function(state, textAfter) {
	      if (state.tokenize == tokenComment) return CodeMirror.Pass;
	      if (state.tokenize != tokenBase) return 0;
	      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
	      // Kludge to prevent 'maybelse' from blocking lexical scope pops
	      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
	        var c = state.cc[i];
	        if (c == poplex) lexical = lexical.prev;
	        else if (c != maybeelse) break;
	      }
	      while ((lexical.type == "stat" || lexical.type == "form") &&
	             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
	                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
	                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
	        lexical = lexical.prev;
	      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
	        lexical = lexical.prev;
	      var type = lexical.type, closing = firstChar == type;

	      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
	      else if (type == "form" && firstChar == "{") return lexical.indented;
	      else if (type == "form") return lexical.indented + indentUnit;
	      else if (type == "stat")
	        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
	      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
	        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
	      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
	      else return lexical.indented + (closing ? 0 : indentUnit);
	    },

	    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
	    blockCommentStart: jsonMode ? null : "/*",
	    blockCommentEnd: jsonMode ? null : "*/",
	    lineComment: jsonMode ? null : "//",
	    fold: "brace",
	    closeBrackets: "()[]{}''\"\"``",

	    helperType: jsonMode ? "json" : "javascript",
	    jsonldMode: jsonldMode,
	    jsonMode: jsonMode,

	    expressionAllowed: expressionAllowed,
	    skipExpression: function(state) {
	      var top = state.cc[state.cc.length - 1]
	      if (top == expression || top == expressionNoComma) state.cc.pop()
	    }
	  };
	});

	CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

	CodeMirror.defineMIME("text/javascript", "javascript");
	CodeMirror.defineMIME("text/ecmascript", "javascript");
	CodeMirror.defineMIME("application/javascript", "javascript");
	CodeMirror.defineMIME("application/x-javascript", "javascript");
	CodeMirror.defineMIME("application/ecmascript", "javascript");
	CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
	CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
	CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

	});


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   2.3.0
	 */

	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }

	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }

	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }

	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }

	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$toString = {}.toString;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;

	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }

	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }

	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }

	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';

	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      var nextTick = process.nextTick;
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // setImmediate should be used instead instead
	      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
	      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
	        nextTick = setImmediate;
	      }
	      return function() {
	        nextTick(lib$es6$promise$asap$$flush);
	      };
	    }

	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }

	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });

	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }

	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }

	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }

	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];

	        callback(arg);

	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }

	      lib$es6$promise$asap$$len = 0;
	    }

	    function lib$es6$promise$asap$$attemptVertex() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(202);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }

	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }

	    function lib$es6$promise$$internal$$noop() {}

	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;

	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	    function lib$es6$promise$$internal$$selfFullfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }

	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }

	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }

	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }

	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;

	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));

	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }

	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }

	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
	      if (maybeThenable.constructor === promise.constructor) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }

	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }

	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }

	      lib$es6$promise$$internal$$publish(promise);
	    }

	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;

	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }

	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;

	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }

	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;

	      parent._onerror = null;

	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }

	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;

	      if (subscribers.length === 0) { return; }

	      var child, callback, detail = promise._result;

	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];

	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }

	      promise._subscribers.length = 0;
	    }

	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }

	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }

	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;

	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }

	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }

	      } else {
	        value = detail;
	        succeeded = true;
	      }

	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }

	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }

	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      var enumerator = this;

	      enumerator._instanceConstructor = Constructor;
	      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

	      if (enumerator._validateInput(input)) {
	        enumerator._input     = input;
	        enumerator.length     = input.length;
	        enumerator._remaining = input.length;

	        enumerator._init();

	        if (enumerator.length === 0) {
	          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	        } else {
	          enumerator.length = enumerator.length || 0;
	          enumerator._enumerate();
	          if (enumerator._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
	      }
	    }

	    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
	      return lib$es6$promise$utils$$isArray(input);
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
	      return new Error('Array Methods must be provided an Array');
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
	      this._result = new Array(this.length);
	    };

	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var enumerator = this;

	      var length  = enumerator.length;
	      var promise = enumerator.promise;
	      var input   = enumerator._input;

	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        enumerator._eachEntry(input[i], i);
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var enumerator = this;
	      var c = enumerator._instanceConstructor;

	      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
	        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
	          entry._onerror = null;
	          enumerator._settledAt(entry._state, i, entry._result);
	        } else {
	          enumerator._willSettleAt(c.resolve(entry), i);
	        }
	      } else {
	        enumerator._remaining--;
	        enumerator._result[i] = entry;
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var enumerator = this;
	      var promise = enumerator.promise;

	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        enumerator._remaining--;

	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          enumerator._result[i] = value;
	        }
	      }

	      if (enumerator._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;

	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      var promise = new Constructor(lib$es6$promise$$internal$$noop);

	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
	        return promise;
	      }

	      var length = entries.length;

	      function onFulfillment(value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }

	      function onRejection(reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      }

	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
	      }

	      return promise;
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }

	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

	    var lib$es6$promise$promise$$counter = 0;

	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }

	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }

	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.

	      Terminology
	      -----------

	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.

	      A promise can be in one of three states: pending, fulfilled, or rejected.

	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.

	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.


	      Basic Usage:
	      ------------

	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);

	        // on failure
	        reject(reason);
	      });

	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```

	      Advanced Usage:
	      ---------------

	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.

	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();

	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();

	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }

	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```

	      Unlike callbacks, promises are great composable primitives.

	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON

	        return values;
	      });
	      ```

	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this._id = lib$es6$promise$promise$$counter++;
	      this._state = undefined;
	      this._result = undefined;
	      this._subscribers = [];

	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        if (!lib$es6$promise$utils$$isFunction(resolver)) {
	          lib$es6$promise$promise$$needsResolver();
	        }

	        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
	          lib$es6$promise$promise$$needsNew();
	        }

	        lib$es6$promise$$internal$$initializePromise(this, resolver);
	      }
	    }

	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,

	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.

	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```

	      Chaining
	      --------

	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.

	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });

	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```

	      Assimilation
	      ------------

	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.

	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```

	      If the assimliated promise rejects, then the downstream promise will also reject.

	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```

	      Simple Example
	      --------------

	      Synchronous Example

	      ```javascript
	      var result;

	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```

	      Errback Example

	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```

	      Promise Example;

	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```

	      Advanced Example
	      --------------

	      Synchronous Example

	      ```javascript
	      var author, books;

	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```

	      Errback Example

	      ```js

	      function foundBooks(books) {

	      }

	      function failure(reason) {

	      }

	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```

	      Promise Example;

	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```

	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: function(onFulfillment, onRejection) {
	        var parent = this;
	        var state = parent._state;

	        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
	          return this;
	        }

	        var child = new this.constructor(lib$es6$promise$$internal$$noop);
	        var result = parent._result;

	        if (state) {
	          var callback = arguments[state - 1];
	          lib$es6$promise$asap$$asap(function(){
	            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
	          });
	        } else {
	          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	        }

	        return child;
	      },

	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.

	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }

	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }

	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```

	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;

	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }

	      var P = local.Promise;

	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }

	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };

	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(200)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }

	    lib$es6$promise$polyfill$$default();
	}).call(this);


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(12).setImmediate, (function() { return this; }()), __webpack_require__(201)(module)))

/***/ },
/* 144 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row list-header\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n            <ma-view-actions override=\"::batchDeleteController.actions\" selection=\"batchDeleteController.selection\" entity=\"::batchDeleteController.entity\">\n                <ma-list-button ng-if=\"::entity.listView().enabled\" entity=\"::entity\"></ma-list-button>\n            </ma-view-actions>\n            <h1 compile=\"::batchDeleteController.title\">\n                {{ 'DELETE' | translate }} {{ ::batchDeleteController.entityIds.length }} {{ ::batchDeleteController.view.entity.name() | humanize | pluralize | translate }}\n            </h1>\n        </div>\n    </div>\n</div>\n\n<div class=\"row\">\n    <div class=\"col-lg-12\">\n        <p translate=\"ARE_YOU_SURE\"></p>\n        <button class=\"btn btn-danger\" ng-click=\"batchDeleteController.batchDelete()\" translate=\"YES\"></button>\n        <button class=\"btn btn-default\" ng-click=\"batchDeleteController.back()\" translate=\"NO\"></button>\n    </div>\n</div>\n\n<div ng-if=\"selection\" class=\"row list-view\" ng-class=\"::'ng-admin-entity-' + batchDeleteController.entity.name()\">\n    <div class=\"col-lg-12\">\n        <ma-datagrid name=\"{{ ::batchDeleteController.view.name() }}\"\n                  entries=\"batchDeleteController.selection\"\n                  fields=\"::batchDeleteController.fields\"\n                  entity=\"::batchDeleteController.entity\">\n        </ma-datagrid>\n    </div>\n</div>\n";

/***/ },
/* 146 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n            <ma-view-actions override=\"::deleteController.actions\" entry=\"::entry\" entity=\"::deleteController.entity\">\n                <ma-list-button ng-if=\"::entity.listView().enabled\" entity=\"::entity\"></ma-list-button>\n            </ma-view-actions>\n            <h1 compile=\"::deleteController.title\">\n                {{ 'DELETE' | translate }} {{ ::deleteController.view.entity.label() | humanize:true | singularize | translate }}  #{{ ::entry.identifierValue }}\n            </h1>\n            <p class=\"lead\" ng-if=\"::deleteController.description\" compile=\"::deleteController.description\">{{ ::deleteController.description }}</p>\n        </div>\n    </div>\n</div>\n\n<div class=\"row\" id=\"delete-view\">\n    <div class=\"col-lg-12\">\n        <p translate=\"ARE_YOU_SURE\"></p>\n        <button class=\"btn btn-danger\" ng-click=\"deleteController.deleteOne()\" translate=\"YES\"></button>\n        <button class=\"btn btn-default\" ng-click=\"deleteController.back()\" translate=\"NO\"></button>\n    </div>\n</div>\n";

/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n            <ma-view-actions override=\"::formController.actions\" entry=\"entry\" entity=\"::formController.entity\">\n                <ma-list-button ng-if=\"::entity.listView().enabled\" entity=\"::entity\"></ma-list-button>\n            </ma-view-actions>\n            <h1 compile=\"::formController.title\">\n                {{ 'CREATE_NEW' | translate }} {{ ::formController.view.entity.label() | humanize:true | singularize | translate }}\n            </h1>\n            <p class=\"lead\" ng-if=\"::formController.description\" compile=\"::formController.description\">{{ ::formController.description }}</p>\n        </div>\n    </div>\n</div>\n\n<div class=\"row\" id=\"create-view\" ng-class=\"::'ng-admin-entity-' + formController.entity.name()\">\n    <form class=\"col-lg-12 form-horizontal\" name=\"formController.form\" ng-submit=\"formController.submitCreation($event)\">\n        <div ng-repeat=\"field in ::formController.fields track by $index\" compile=\"::field.getTemplateValueWithLabel(entry)\">\n            <ma-field field=\"::field\" value=\"entry.values[field.name()]\" entry=\"entry\" entity=\"::entity\" form=\"formController.form\" datastore=\"::formController.dataStore\"></ma-field>\n        </div>\n\n        <div class=\"form-group\">\n            <div class=\"col-sm-offset-2 col-sm-10\">\n                <ma-submit-button label=\"SUBMIT\"></ma-submit-button>\n            </div>\n        </div>\n    </form>\n</div>\n";

/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n            <ma-view-actions override=\"::formController.actions\" entry=\"entry\" entity=\"::formController.entity\">\n                <ma-list-button ng-if=\"::entity.listView().enabled\" entity=\"::entity\"></ma-list-button>\n                <ma-delete-button ng-if=\"::entity.deletionView().enabled\" entry=\"entry\" entity=\"::entity\"></ma-delete-button>\n            </ma-view-actions>\n            <h1 compile=\"::formController.title\">\n                {{ 'EDIT' | translate }} {{ ::formController.entity.label() | humanize:true | singularize | translate }}  #{{ ::entry.identifierValue }}\n            </h1>\n            <p class=\"lead\" ng-if=\"::formController.description\" compile=\"::formController.description\">{{ ::formController.description }}</p>\n        </div>\n    </div>\n</div>\n\n<div class=\"row\" id=\"edit-view\" ng-class=\"::'ng-admin-entity-' + formController.entity.name()\">\n    <form class=\"col-lg-12 form-horizontal\" name=\"formController.form\" ng-submit=\"formController.submitEdition($event)\">\n        <div ng-repeat=\"field in ::formController.fields track by $index\" compile=\"::field.getTemplateValueWithLabel(entry)\">\n            <ma-field field=\"::field\" value=\"entry.values[field.name()]\" entry=\"entry\" entity=\"::entity\" form=\"formController.form\" datastore=\"::formController.dataStore\"></ma-field>\n        </div>\n\n        <div class=\"form-group\">\n            <div class=\"col-sm-offset-2 col-sm-10\">\n                <ma-submit-button label=\"SAVE_CHANGES\"></ma-submit-button>\n            </div>\n        </div>\n    </form>\n</div>\n";

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row list-view\" ng-class=\"::'ng-admin-entity-' + listController.entity.name()\">\n    <div class=\"col-lg-12\">\n        <ma-datagrid name=\"{{ ::listController.view.name() }}\"\n                  entries=\"listController.dataStore.getEntries(listController.entity.uniqueId)\"\n                  selection=\"selection\"\n                  fields=\"::listController.fields\"\n                  list-actions=\"::listController.listActions\"\n                  entity=\"::listController.entity\"\n                  sort-field=\"::listController.sortField\"\n                  sort-dir=\"::listController.sortDir\"\n                  entry-css-classes=\"::listController.entryCssClasses\"\n                  datastore=\"listController.dataStore\">\n        </ma-datagrid>\n    </div>\n</div>\n\n<div class=\"row\" ng-if=\"::!listController.infinitePagination\">\n    <div class=\"col-lg-12\">\n        <ma-datagrid-pagination\n            page=\"{{ listController.page }}\"\n            per-page=\"{{ ::listController.view.perPage() }}\"\n            total-items=\"{{ listController.totalItems }}\"\n            set-page=\"::listController.setPageCallback\">\n        </ma-datagrid-pagination>\n    </div>\n</div>\n\n<ma-datagrid-infinite-pagination ng-if=\"::listController.infinitePagination\"\n            per-page=\"{{ ::listController.view.perPage() }}\"\n            total-items=\"{{ ::listController.totalItems }}\"\n            next-page=\"::listController.nextPageCallback\">\n</ma-datagrid-infinite-pagination>\n";

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row list-header\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n\n            <ma-view-actions override=\"::llCtrl.actions\" selection=\"selection\" batch-buttons=\"::llCtrl.batchActions\" entity=\"::llCtrl.entity\" datastore=\"::llCtrl.dataStore\" search=\"::llCtrl.search\" filters=\"::llCtrl.filters\" enabled-filters=\"llCtrl.enabledFilters\" enable-filter=\"llCtrl.enableFilter\">\n                <ma-filter-button filters=\"filters()\" enabled-filters=\"enabledFilters\" enable-filter=\"enableFilter()\"></ma-filter-button>\n                <ma-view-batch-actions buttons=\"::batchButtons()\" selection=\"selection\" entity=\"::entity\"></ma-view-batch-actions>\n                <ma-export-to-csv-button entity=\"::entity\" datastore=\"::datastore\"></ma-export-to-csv-button>\n                <ma-create-button ng-if=\"::entity.creationView().enabled\" entity=\"::entity\"></ma-create-button>\n            </ma-view-actions>\n\n            <h1 compile=\"::llCtrl.view.title()\">\n                {{ ::llCtrl.view.entity.label() | humanize | pluralize | translate }} {{ 'LIST' | translate }}\n            </h1>\n            <p class=\"lead\" ng-if=\"::llCtrl.view.description()\" compile=\"::llCtrl.view.description()\">{{ ::llCtrl.view.description() }}</p>\n        </div>\n\n        <ma-filter-form ng-if=\"llCtrl.hasFilters\" filters=\"llCtrl.enabledFilters\" values=\"llCtrl.search\" datastore=\"::llCtrl.dataStore\" remove-filter=\"::llCtrl.removeFilter\"></ma-filter-form>\n\n    </div>\n</div>\n\n<div ui-view=\"grid\"></div>\n";

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = "<nav class=\"pagination-bar\">\n\n    <div class=\"total\" ng-if=\"paginationCtrl.totalItems > 0\" translate=\"PAGINATION\" translate-values=\"{ begin: paginationCtrl.offsetBegin, end: paginationCtrl.offsetEnd, total: paginationCtrl.totalItems }\">\n    </div>\n\n    <div class=\"total no-record\" ng-if=\"paginationCtrl.totalItems == 0\">\n        <strong translate=\"NO_PAGINATION\"></strong>\n    </div>\n\n    <ul class=\"pagination pagination-sm pull-right\" role=\"group\" aria-label=\"pagination\" ng-if=\"paginationCtrl.displayPagination\">\n        <li><a href ng-if=\"paginationCtrl.page != 1\" ng-click=\"paginationCtrl.setPage(paginationCtrl.page - 1)\" translate=\"PREVIOUS\"></a></li>\n        <li ng-repeat=\"n in paginationCtrl.range(paginationCtrl.page) track by $index\" ng-class=\"{'active': n == paginationCtrl.page}\">\n            <a href ng-if=\"n != '.'\" ng-click=\"paginationCtrl.setPage(n)\">{{ n }}</a>\n            <span ng-if=\"n == '.'\">&hellip;</span>\n        </li>\n        <li><a href ng-if=\"paginationCtrl.page != paginationCtrl.nbPages\" ng-click=\"paginationCtrl.setPage(paginationCtrl.page + 1)\" translate=\"NEXT\"></a></li>\n    </ul>\n</nav>\n";

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n            <ma-view-actions override=\"::showController.actions\" entry=\"entry\" entity=\"::showController.entity\">\n                <ma-list-button ng-if=\"::entity.listView().enabled\" entity=\"::entity\"></ma-list-button>\n                <ma-edit-button ng-if=\"::entity.editionView().enabled\" entry=\"entry\" entity=\"::entity\"></ma-edit-button>\n                <ma-delete-button ng-if=\"::entity.deletionView().enabled\" entry=\"entry\" entity=\"::entity\"></ma-delete-button>\n            </ma-view-actions>\n            <h1 compile=\"::showController.title\">\n                {{ ::showController.view.entity.label() | humanize | singularize | translate }}  #{{ ::entry.identifierValue }} {{ 'DETAIL' | translate }}\n            </h1>\n            <p class=\"lead\" ng-if=\"::showController.description\" compile=\"::showController.description\">{{ ::showController.description }}</p>\n        </div>\n    </div>\n</div>\n\n\n<div class=\"row form-horizontal\" id=\"show-view\">\n\n    <div ng-repeat=\"field in ::showController.fields track by $index\" compile=\"::field.getTemplateValueWithLabel(entry)\">\n        <ma-show-item field=\"::field\" entry=\"::entry\" entity=\"::showController.entity\" datastore=\"::showController.dataStore\"></ma-show-item>\n    </div>\n\n</div>\n";

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n            <h1>{{ 'NOT_FOUND' | translate }}</h1>\n        </div>\n    </div>\n</div>\n\n<div class=\"row dashboard-content\">\n    <div class=\"col-lg-12\">\n        {{ 'NOT_FOUND_DETAILS' | translate }}\n        <br/>\n        <br/>\n        <br/>\n        <br/>\n    </div>\n\n    <pre class=\"ascii col-lg-offset-4 col-lg-4 col-md-offset-3 col-md-6 col-sm-offset-2 col-sm-8 col-cs-offset-1 col-xs-10\">\n\n       |\\      _,,,---,,_\n       /,`.-'`'    -.  ;-;;,_\n      |,4-  ) )-,_..;\\ (  `'-'\n     '---''(_/--'  `-'\\_)\n\n    </pre>\n</div>\n";

/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\" ng-if=\"dashboardController.hasEntities\">\n    <div class=\"col-lg-12\">\n        <div class=\"page-header\">\n            <h1>{{ 'Dashboard' | translate }}</h1>\n        </div>\n    </div>\n</div>\n\n<div class=\"row dashboard-content\">\n    <div class=\"col-lg-6\">\n        <div class=\"panel panel-default\" ng-repeat=\"collection in dashboardController.collections | orderElement\" ng-if=\"$even\">\n            <ma-dashboard-panel collection=\"collection\" entries=\"dashboardController.entries[collection.name()]\" datastore=\"dashboardController.datastore\"></ma-dashboard-panel>\n        </div>\n    </div>\n    <div class=\"col-lg-6\">\n        <div class=\"panel panel-default\" ng-repeat=\"collection in dashboardController.collections | orderElement\" ng-if=\"$odd\">\n            <ma-dashboard-panel collection=\"collection\" entries=\"dashboardController.entries[collection.name()]\" datastore=\"dashboardController.datastore\"></ma-dashboard-panel>\n        </div>\n    </div>\n</div>\n\n<div class=\"row\" ng-if=\"!dashboardController.hasEntities\">\n    <div class=\"col-lg-12\">\n        <div class=\"dashboard-invite\">\n            <p>All dependencies are set, ng-admin is ready to run!</p>\n            <p>Now you can <a href=\"https://github.com/marmelab/ng-admin/blob/master/README.md#configuring-ng-admin\">update the configuration</a>: add entities to the admin, then refresh.</p>\n        </div>\n    </div>\n</div>\n";

/***/ },
/* 155 */
/***/ function(module, exports) {

	module.exports = "<div id=\"wrapper\">\n    <nav id=\"header-nav\" class=\"navbar navbar-default navbar-static-top\" role=\"navigation\">\n        <span compile=\"::appController.header\">\n        <div class=\"navbar-header\">\n            <button type=\"button\" class=\"navbar-toggle\" ng-click=\"isCollapsed = !isCollapsed\">\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n            </button>\n            <a href=\"#\" ng-click=\"appController.displayHome()\" class=\"navbar-brand\">{{ ::appController.applicationName }}</a>\n        </div>\n        </span>\n\n        <ma-menu-bar menu=\"::appController.menu\"></ma-menu-bar>\n    </nav>\n\n    <div id=\"page-wrapper\">\n        <div ui-view></div>\n    </div>\n    <div id=\"loader\"></div>\n</div>\n";

/***/ },
/* 156 */
/***/ function(module, exports) {

	module.exports = "<div class=\"navbar-default sidebar\" role=\"navigation\" compile=\"menu.template()\">\n    <div class=\"sidebar-nav navbar-collapse collapse\" uib-collapse=\"$parent.isCollapsed\">\n        <ul class=\"nav\" id=\"side-menu\">\n            <li class=\"entities-repeat\" ng-repeat=\"(key, menu) in ::menu.children()\" data-menu-id=\"{{ ::menu.uuid }}\" compile=\"menu.template()\">\n                <a ng-if=\"::menu.hasChild()\" ng-click=\"toggleMenu(menu)\" ng-class=\"::{'active': menu.isActive(path)}\">\n                    <span compile=\"::menu.icon()\"><span class=\"glyphicon glyphicon-list\"></span></span>\n                    {{ menu.title() | translate }}\n                    <span class=\"glyphicon arrow\" ng-class=\"::{'glyphicon-menu-down': isOpen(menu), 'glyphicon-menu-right': !isOpen(menu) }\"></span>\n                </a>\n                <a ng-if=\"::!menu.hasChild()\" href=\"#{{ menu.link() }}\" ng-click=\"activateLink(menu)\" ng-class=\"::{'active': menu.isActive(path)}\">\n                    <span compile=\"::menu.icon()\"><span class=\"glyphicon glyphicon-list\"></span></span>\n                    {{ menu.title() | translate }}\n                </a>\n                <ul ng-if=\"::menu.hasChild()\" class=\"nav nav-second-level collapsible\" ng-class=\"::{'collapsed': !isOpen(menu) }\">\n                    <li ng-repeat=\"menu in ::menu.children()\" data-menu-id=\"{{ ::menu.uuid }}\" compile=\"menu.template()\">\n                        <a href=\"#{{menu.link()}}\" ng-click=\"activateLink(menu)\" ng-class=\"::{'active': menu.isActive(path)}\">\n                            <span compile=\"::menu.icon()\"><span class=\"glyphicon glyphicon-list\"></span></span>\n                            {{ menu.title() | translate }}\n                        </a>\n                    </li>\n                </ul>\n            </li>\n        </ul>\n    </div>\n</div>\n";

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * humane.js
	 * Humanized Messages for Notifications
	 * @author Marc Harter (@wavded)
	 * @example
	 *   humane.log('hello world');
	 * @license MIT
	 * See more usage examples at: http://wavded.github.com/humane-js/
	 */

	;!function (name, context, definition) {
	   if (true) module.exports = definition(name, context)
	   else if (typeof define === 'function' && typeof define.amd  === 'object') define(definition)
	   else context[name] = definition(name, context)
	}('humane', this, function (name, context) {
	   var win = window
	   var doc = document

	   var ENV = {
	      on: function (el, type, cb) {
	         'addEventListener' in win ? el.addEventListener(type,cb,false) : el.attachEvent('on'+type,cb)
	      },
	      off: function (el, type, cb) {
	         'removeEventListener' in win ? el.removeEventListener(type,cb,false) : el.detachEvent('on'+type,cb)
	      },
	      bind: function (fn, ctx) {
	         return function () { fn.apply(ctx,arguments) }
	      },
	      isArray: Array.isArray || function (obj) { return Object.prototype.toString.call(obj) === '[object Array]' },
	      config: function (preferred, fallback) {
	         return preferred != null ? preferred : fallback
	      },
	      transSupport: false,
	      useFilter: /msie [678]/i.test(navigator.userAgent), // sniff, sniff
	      _checkTransition: function () {
	         var el = doc.createElement('div')
	         var vendors = { webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' }

	         for (var vendor in vendors)
	            if (vendor + 'Transition' in el.style) {
	               this.vendorPrefix = vendors[vendor]
	               this.transSupport = true
	            }
	      }
	   }
	   ENV._checkTransition()

	   var Humane = function (o) {
	      o || (o = {})
	      this.queue = []
	      this.baseCls = o.baseCls || 'humane'
	      this.addnCls = o.addnCls || ''
	      this.timeout = 'timeout' in o ? o.timeout : 2500
	      this.waitForMove = o.waitForMove || false
	      this.clickToClose = o.clickToClose || false
	      this.timeoutAfterMove = o.timeoutAfterMove || false
	      this.container = o.container

	      try { this._setupEl() } // attempt to setup elements
	      catch (e) {
	        ENV.on(win,'load',ENV.bind(this._setupEl, this)) // dom wasn't ready, wait till ready
	      }
	   }

	   Humane.prototype = {
	      constructor: Humane,
	      _setupEl: function () {
	         var el = doc.createElement('div')
	         el.style.display = 'none'
	         if (!this.container){
	           if(doc.body) this.container = doc.body;
	           else throw 'document.body is null'
	         }
	         this.container.appendChild(el)
	         this.el = el
	         this.removeEvent = ENV.bind(function(){
	            var timeoutAfterMove = ENV.config(this.currentMsg.timeoutAfterMove,this.timeoutAfterMove)
	            if (!timeoutAfterMove){
	               this.remove()
	            } else {
	               setTimeout(ENV.bind(this.remove,this),timeoutAfterMove)
	            }
	         },this)

	         this.transEvent = ENV.bind(this._afterAnimation,this)
	         this._run()
	      },
	      _afterTimeout: function () {
	         if (!ENV.config(this.currentMsg.waitForMove,this.waitForMove)) this.remove()

	         else if (!this.removeEventsSet) {
	            ENV.on(doc.body,'mousemove',this.removeEvent)
	            ENV.on(doc.body,'click',this.removeEvent)
	            ENV.on(doc.body,'keypress',this.removeEvent)
	            ENV.on(doc.body,'touchstart',this.removeEvent)
	            this.removeEventsSet = true
	         }
	      },
	      _run: function () {
	         if (this._animating || !this.queue.length || !this.el) return

	         this._animating = true
	         if (this.currentTimer) {
	            clearTimeout(this.currentTimer)
	            this.currentTimer = null
	         }

	         var msg = this.queue.shift()
	         var clickToClose = ENV.config(msg.clickToClose,this.clickToClose)

	         if (clickToClose) {
	            ENV.on(this.el,'click',this.removeEvent)
	            ENV.on(this.el,'touchstart',this.removeEvent)
	         }

	         var timeout = ENV.config(msg.timeout,this.timeout)

	         if (timeout > 0)
	            this.currentTimer = setTimeout(ENV.bind(this._afterTimeout,this), timeout)

	         if (ENV.isArray(msg.html)) msg.html = '<ul><li>'+msg.html.join('<li>')+'</ul>'

	         this.el.innerHTML = msg.html
	         this.currentMsg = msg
	         this.el.className = this.baseCls
	         if (ENV.transSupport) {
	            this.el.style.display = 'block'
	            setTimeout(ENV.bind(this._showMsg,this),50)
	         } else {
	            this._showMsg()
	         }

	      },
	      _setOpacity: function (opacity) {
	         if (ENV.useFilter){
	            try{
	               this.el.filters.item('DXImageTransform.Microsoft.Alpha').Opacity = opacity*100
	            } catch(err){}
	         } else {
	            this.el.style.opacity = String(opacity)
	         }
	      },
	      _showMsg: function () {
	         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)
	         if (ENV.transSupport) {
	            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-animate'
	         }
	         else {
	            var opacity = 0
	            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-js-animate'
	            this._setOpacity(0) // reset value so hover states work
	            this.el.style.display = 'block'

	            var self = this
	            var interval = setInterval(function(){
	               if (opacity < 1) {
	                  opacity += 0.1
	                  if (opacity > 1) opacity = 1
	                  self._setOpacity(opacity)
	               }
	               else clearInterval(interval)
	            }, 30)
	         }
	      },
	      _hideMsg: function () {
	         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)
	         if (ENV.transSupport) {
	            this.el.className = this.baseCls+' '+addnCls
	            ENV.on(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)
	         }
	         else {
	            var opacity = 1
	            var self = this
	            var interval = setInterval(function(){
	               if(opacity > 0) {
	                  opacity -= 0.1
	                  if (opacity < 0) opacity = 0
	                  self._setOpacity(opacity);
	               }
	               else {
	                  self.el.className = self.baseCls+' '+addnCls
	                  clearInterval(interval)
	                  self._afterAnimation()
	               }
	            }, 30)
	         }
	      },
	      _afterAnimation: function () {
	         if (ENV.transSupport) ENV.off(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)

	         if (this.currentMsg.cb) this.currentMsg.cb()
	         this.el.style.display = 'none'

	         this._animating = false
	         this._run()
	      },
	      remove: function (e) {
	         var cb = typeof e == 'function' ? e : null

	         ENV.off(doc.body,'mousemove',this.removeEvent)
	         ENV.off(doc.body,'click',this.removeEvent)
	         ENV.off(doc.body,'keypress',this.removeEvent)
	         ENV.off(doc.body,'touchstart',this.removeEvent)
	         ENV.off(this.el,'click',this.removeEvent)
	         ENV.off(this.el,'touchstart',this.removeEvent)
	         this.removeEventsSet = false

	         if (cb && this.currentMsg) this.currentMsg.cb = cb
	         if (this._animating) this._hideMsg()
	         else if (cb) cb()
	      },
	      log: function (html, o, cb, defaults) {
	         var msg = {}
	         if (defaults)
	           for (var opt in defaults)
	               msg[opt] = defaults[opt]

	         if (typeof o == 'function') cb = o
	         else if (o)
	            for (var opt in o) msg[opt] = o[opt]

	         msg.html = html
	         if (cb) msg.cb = cb
	         this.queue.push(msg)
	         this._run()
	         return this
	      },
	      spawn: function (defaults) {
	         var self = this
	         return function (html, o, cb) {
	            self.log.call(self,html,o,cb,defaults)
	            return self
	         }
	      },
	      create: function (o) { return new Humane(o) }
	   }
	   return new Humane()
	});


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * inflection
	 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
	 * MIT Licensed
	 *
	 * @fileoverview
	 * A port of inflection-js to node.js module.
	 */

	( function ( root, factory ){
	  if( true ){
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }else if( typeof exports === 'object' ){
	    module.exports = factory();
	  }else{
	    root.inflection = factory();
	  }
	}( this, function (){

	  /**
	   * @description This is a list of nouns that use the same form for both singular and plural.
	   *              This list should remain entirely in lower case to correctly match Strings.
	   * @private
	   */
	  var uncountable_words = [
	    'equipment', 'information', 'rice', 'money', 'species',
	    'series', 'fish', 'sheep', 'moose', 'deer', 'news'
	  ];

	  /**
	   * @description These rules translate from the singular form of a noun to its plural form.
	   * @private
	   */
	  var plural_rules = [

	    // do not replace if its already a plural word
	    [ new RegExp( '(m)en$',      'gi' )],
	    [ new RegExp( '(pe)ople$',   'gi' )],
	    [ new RegExp( '(child)ren$', 'gi' )],
	    [ new RegExp( '([ti])a$',    'gi' )],
	    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' )],
	    [ new RegExp( '(hive)s$',           'gi' )],
	    [ new RegExp( '(tive)s$',           'gi' )],
	    [ new RegExp( '(curve)s$',          'gi' )],
	    [ new RegExp( '([lr])ves$',         'gi' )],
	    [ new RegExp( '([^fo])ves$',        'gi' )],
	    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' )],
	    [ new RegExp( '(s)eries$',          'gi' )],
	    [ new RegExp( '(m)ovies$',          'gi' )],
	    [ new RegExp( '(x|ch|ss|sh)es$',    'gi' )],
	    [ new RegExp( '([m|l])ice$',        'gi' )],
	    [ new RegExp( '(bus)es$',           'gi' )],
	    [ new RegExp( '(o)es$',             'gi' )],
	    [ new RegExp( '(shoe)s$',           'gi' )],
	    [ new RegExp( '(cris|ax|test)es$',  'gi' )],
	    [ new RegExp( '(octop|vir)i$',      'gi' )],
	    [ new RegExp( '(alias|status)es$',  'gi' )],
	    [ new RegExp( '^(ox)en',            'gi' )],
	    [ new RegExp( '(vert|ind)ices$',    'gi' )],
	    [ new RegExp( '(matr)ices$',        'gi' )],
	    [ new RegExp( '^feet$',             'gi' )],
	    [ new RegExp( '^teeth$',            'gi' )],
	    [ new RegExp( '^geese$',            'gi' )],
	    [ new RegExp( '(quiz)zes$',         'gi' )],

	    // original rule
	    [ new RegExp( '(m)an$', 'gi' ),                 '$1en' ],
	    [ new RegExp( '(pe)rson$', 'gi' ),              '$1ople' ],
	    [ new RegExp( '(child)$', 'gi' ),               '$1ren' ],
	    [ new RegExp( '^(ox)$', 'gi' ),                 '$1en' ],
	    [ new RegExp( '(ax|test)is$', 'gi' ),           '$1es' ],
	    [ new RegExp( '(octop|vir)us$', 'gi' ),         '$1i' ],
	    [ new RegExp( '(alias|status)$', 'gi' ),        '$1es' ],
	    [ new RegExp( '(bu)s$', 'gi' ),                 '$1ses' ],
	    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' ), '$1oes' ],
	    [ new RegExp( '([ti])um$', 'gi' ),              '$1a' ],
	    [ new RegExp( 'sis$', 'gi' ),                   'ses' ],
	    [ new RegExp( '(?:([^f])fe|([lr])f)$', 'gi' ),  '$1$2ves' ],
	    [ new RegExp( '(hive)$', 'gi' ),                '$1s' ],
	    [ new RegExp( '([^aeiouy]|qu)y$', 'gi' ),       '$1ies' ],
	    [ new RegExp( '(x|ch|ss|sh)$', 'gi' ),          '$1es' ],
	    [ new RegExp( '(matr|vert|ind)ix|ex$', 'gi' ),  '$1ices' ],
	    [ new RegExp( '([m|l])ouse$', 'gi' ),           '$1ice' ],
	    [ new RegExp( '^foot$', 'gi' ),                 'feet' ],
	    [ new RegExp( '^tooth$', 'gi' ),                'teeth' ],
	    [ new RegExp( '^goose$', 'gi' ),                'geese' ],
	    [ new RegExp( '(quiz)$', 'gi' ),                '$1zes' ],

	    [ new RegExp( 's$', 'gi' ), 's' ],
	    [ new RegExp( '$', 'gi' ),  's' ]
	  ];

	  /**
	   * @description These rules translate from the plural form of a noun to its singular form.
	   * @private
	   */
	  var singular_rules = [

	    // do not replace if its already a singular word
	    [ new RegExp( '(m)an$',                 'gi' )],
	    [ new RegExp( '(pe)rson$',              'gi' )],
	    [ new RegExp( '(child)$',               'gi' )],
	    [ new RegExp( '^(ox)$',                 'gi' )],
	    [ new RegExp( '(ax|test)is$',           'gi' )],
	    [ new RegExp( '(octop|vir)us$',         'gi' )],
	    [ new RegExp( '(alias|status)$',        'gi' )],
	    [ new RegExp( '(bu)s$',                 'gi' )],
	    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' )],
	    [ new RegExp( '([ti])um$',              'gi' )],
	    [ new RegExp( 'sis$',                   'gi' )],
	    [ new RegExp( '(?:([^f])fe|([lr])f)$',  'gi' )],
	    [ new RegExp( '(hive)$',                'gi' )],
	    [ new RegExp( '([^aeiouy]|qu)y$',       'gi' )],
	    [ new RegExp( '(x|ch|ss|sh)$',          'gi' )],
	    [ new RegExp( '(matr|vert|ind)ix|ex$',  'gi' )],
	    [ new RegExp( '([m|l])ouse$',           'gi' )],
	    [ new RegExp( '^foot$',                 'gi' )],
	    [ new RegExp( '^tooth$',                'gi' )],
	    [ new RegExp( '^goose$',                'gi' )],
	    [ new RegExp( '(quiz)$',                'gi' )],

	    // original rule
	    [ new RegExp( '(m)en$', 'gi' ),                                                       '$1an' ],
	    [ new RegExp( '(pe)ople$', 'gi' ),                                                    '$1rson' ],
	    [ new RegExp( '(child)ren$', 'gi' ),                                                  '$1' ],
	    [ new RegExp( '([ti])a$', 'gi' ),                                                     '$1um' ],
	    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ), '$1$2sis' ],
	    [ new RegExp( '(hive)s$', 'gi' ),                                                     '$1' ],
	    [ new RegExp( '(tive)s$', 'gi' ),                                                     '$1' ],
	    [ new RegExp( '(curve)s$', 'gi' ),                                                    '$1' ],
	    [ new RegExp( '([lr])ves$', 'gi' ),                                                   '$1f' ],
	    [ new RegExp( '([^fo])ves$', 'gi' ),                                                  '$1fe' ],
	    [ new RegExp( '(m)ovies$', 'gi' ),                                                    '$1ovie' ],
	    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' ),                                           '$1y' ],
	    [ new RegExp( '(s)eries$', 'gi' ),                                                    '$1eries' ],
	    [ new RegExp( '(x|ch|ss|sh)es$', 'gi' ),                                              '$1' ],
	    [ new RegExp( '([m|l])ice$', 'gi' ),                                                  '$1ouse' ],
	    [ new RegExp( '(bus)es$', 'gi' ),                                                     '$1' ],
	    [ new RegExp( '(o)es$', 'gi' ),                                                       '$1' ],
	    [ new RegExp( '(shoe)s$', 'gi' ),                                                     '$1' ],
	    [ new RegExp( '(cris|ax|test)es$', 'gi' ),                                            '$1is' ],
	    [ new RegExp( '(octop|vir)i$', 'gi' ),                                                '$1us' ],
	    [ new RegExp( '(alias|status)es$', 'gi' ),                                            '$1' ],
	    [ new RegExp( '^(ox)en', 'gi' ),                                                      '$1' ],
	    [ new RegExp( '(vert|ind)ices$', 'gi' ),                                              '$1ex' ],
	    [ new RegExp( '(matr)ices$', 'gi' ),                                                  '$1ix' ],
	    [ new RegExp( '^feet$', 'gi' ),                                                       'foot' ],
	    [ new RegExp( '^teeth$', 'gi' ),                                                      'tooth' ],
	    [ new RegExp( '^geese$', 'gi' ),                                                      'goose' ],
	    [ new RegExp( '(quiz)zes$', 'gi' ),                                                   '$1' ],
	    [ new RegExp( 'ss$', 'gi' ),                                                          'ss' ],
	    [ new RegExp( 's$', 'gi' ),                                                           '' ]
	  ];

	  /**
	   * @description This is a list of words that should not be capitalized for title case.
	   * @private
	   */
	  var non_titlecased_words = [
	    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
	    'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
	  ];

	  /**
	   * @description These are regular expressions used for converting between String formats.
	   * @private
	   */
	  var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
	  var underbar          = new RegExp( '_', 'g' );
	  var space_or_underbar = new RegExp( '[\ _]', 'g' );
	  var uppercase         = new RegExp( '([A-Z])', 'g' );
	  var underbar_prefix   = new RegExp( '^_' );

	  var inflector = {

	  /**
	   * A helper method that applies rules based replacement to a String.
	   * @private
	   * @function
	   * @param {String} str String to modify and return based on the passed rules.
	   * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
	   * @param {Array: [String]} skip Strings to skip if they match
	   * @param {String} override String to return as though this method succeeded (used to conform to APIs)
	   * @returns {String} Return passed String modified by passed rules.
	   * @example
	   *
	   *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
	   */
	    _apply_rules : function ( str, rules, skip, override ){
	      if( override ){
	        str = override;
	      }else{
	        var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

	        if( !ignore ){
	          var i = 0;
	          var j = rules.length;

	          for( ; i < j; i++ ){
	            if( str.match( rules[ i ][ 0 ])){
	              if( rules[ i ][ 1 ] !== undefined ){
	                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
	              }
	              break;
	            }
	          }
	        }
	      }

	      return str;
	    },



	  /**
	   * This lets us detect if an Array contains a given element.
	   * @public
	   * @function
	   * @param {Array} arr The subject array.
	   * @param {Object} item Object to locate in the Array.
	   * @param {Number} from_index Starts checking from this position in the Array.(optional)
	   * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
	   * @returns {Number} Return index position in the Array of the passed item.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
	   *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
	   */
	    indexOf : function ( arr, item, from_index, compare_func ){
	      if( !from_index ){
	        from_index = -1;
	      }

	      var index = -1;
	      var i     = from_index;
	      var j     = arr.length;

	      for( ; i < j; i++ ){
	        if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
	          index = i;
	          break;
	        }
	      }

	      return index;
	    },



	  /**
	   * This function adds pluralization support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {String} plural Overrides normal output with said String.(optional)
	   * @returns {String} Singular English language nouns are returned in plural form.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.pluralize( 'person' ); // === 'people'
	   *     inflection.pluralize( 'octopus' ); // === 'octopi'
	   *     inflection.pluralize( 'Hat' ); // === 'Hats'
	   *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
	   */
	    pluralize : function ( str, plural ){
	      return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
	    },



	  /**
	   * This function adds singularization support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {String} singular Overrides normal output with said String.(optional)
	   * @returns {String} Plural English language nouns are returned in singular form.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.singularize( 'people' ); // === 'person'
	   *     inflection.singularize( 'octopi' ); // === 'octopus'
	   *     inflection.singularize( 'Hats' ); // === 'Hat'
	   *     inflection.singularize( 'guys', 'person' ); // === 'person'
	   */
	    singularize : function ( str, singular ){
	      return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
	    },


	  /**
	   * This function will pluralize or singularlize a String appropriately based on an integer value
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {Number} count The number to base pluralization off of.
	   * @param {String} singular Overrides normal output with said String.(optional)
	   * @param {String} plural Overrides normal output with said String.(optional)
	   * @returns {String} English language nouns are returned in the plural or singular form based on the count.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.inflect( 'people' 1 ); // === 'person'
	   *     inflection.inflect( 'octopi' 1 ); // === 'octopus'
	   *     inflection.inflect( 'Hats' 1 ); // === 'Hat'
	   *     inflection.inflect( 'guys', 1 , 'person' ); // === 'person'
	   *     inflection.inflect( 'person', 2 ); // === 'people'
	   *     inflection.inflect( 'octopus', 2 ); // === 'octopi'
	   *     inflection.inflect( 'Hat', 2 ); // === 'Hats'
	   *     inflection.inflect( 'person', 2, null, 'guys' ); // === 'guys'
	   */
	    inflect : function ( str, count, singular, plural ){
	      count = parseInt( count, 10 );

	      if( isNaN( count )) return str;

	      if( count === 0 || count > 1 ){
	        return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
	      }else{
	        return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
	      }
	    },



	  /**
	   * This function adds camelization support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
	   *                                 Passing true will lowercase it.
	   * @returns {String} Lower case underscored words will be returned in camel case.
	   *                  additionally '/' is translated to '::'
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
	   *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
	   */
	    camelize : function ( str, low_first_letter ){
	      var str_path = str.split( '/' );
	      var i        = 0;
	      var j        = str_path.length;
	      var str_arr, init_x, k, l, first;

	      for( ; i < j; i++ ){
	        str_arr = str_path[ i ].split( '_' );
	        k       = 0;
	        l       = str_arr.length;

	        for( ; k < l; k++ ){
	          if( k !== 0 ){
	            str_arr[ k ] = str_arr[ k ].toLowerCase();
	          }

	          first = str_arr[ k ].charAt( 0 );
	          first = low_first_letter && i === 0 && k === 0
	            ? first.toLowerCase() : first.toUpperCase();
	          str_arr[ k ] = first + str_arr[ k ].substring( 1 );
	        }

	        str_path[ i ] = str_arr.join( '' );
	      }

	      return str_path.join( '::' );
	    },



	  /**
	   * This function adds underscore support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
	   *                  Passing true will return as entered.
	   * @returns {String} Camel cased words are returned as lower cased and underscored.
	   *                  additionally '::' is translated to '/'.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
	   *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
	   *     inflection.underscore( 'MP', true ); // === 'MP'
	   */
	    underscore : function ( str, all_upper_case ){
	      if( all_upper_case && str === str.toUpperCase()) return str;

	      var str_path = str.split( '::' );
	      var i        = 0;
	      var j        = str_path.length;

	      for( ; i < j; i++ ){
	        str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
	        str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
	      }

	      return str_path.join( '/' ).toLowerCase();
	    },



	  /**
	   * This function adds humanize support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
	   *                                 Passing true will lowercase it.
	   * @returns {String} Lower case underscored words will be returned in humanized form.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.humanize( 'message_properties' ); // === 'Message properties'
	   *     inflection.humanize( 'message_properties', true ); // === 'message properties'
	   */
	    humanize : function ( str, low_first_letter ){
	      str = str.toLowerCase();
	      str = str.replace( id_suffix, '' );
	      str = str.replace( underbar, ' ' );

	      if( !low_first_letter ){
	        str = inflector.capitalize( str );
	      }

	      return str;
	    },



	  /**
	   * This function adds capitalization support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @returns {String} All characters will be lower case and the first will be upper.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
	   *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
	   */
	    capitalize : function ( str ){
	      str = str.toLowerCase();

	      return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
	    },



	  /**
	   * This function adds dasherization support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @returns {String} Replaces all spaces or underbars with dashes.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
	   *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
	   */
	    dasherize : function ( str ){
	      return str.replace( space_or_underbar, '-' );
	    },



	  /**
	   * This function adds titleize support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @returns {String} Capitalizes words as you would for a book title.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
	   *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
	   */
	    titleize : function ( str ){
	      str         = str.toLowerCase().replace( underbar, ' ' );
	      var str_arr = str.split( ' ' );
	      var i       = 0;
	      var j       = str_arr.length;
	      var d, k, l;

	      for( ; i < j; i++ ){
	        d = str_arr[ i ].split( '-' );
	        k = 0;
	        l = d.length;

	        for( ; k < l; k++){
	          if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
	            d[ k ] = inflector.capitalize( d[ k ]);
	          }
	        }

	        str_arr[ i ] = d.join( '-' );
	      }

	      str = str_arr.join( ' ' );
	      str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

	      return str;
	    },



	  /**
	   * This function adds demodulize support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @returns {String} Removes module names leaving only class names.(Ruby style)
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
	   */
	    demodulize : function ( str ){
	      var str_arr = str.split( '::' );

	      return str_arr[ str_arr.length - 1 ];
	    },



	  /**
	   * This function adds tableize support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @returns {String} Return camel cased words into their underscored plural form.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
	   */
	    tableize : function ( str ){
	      str = inflector.underscore( str );
	      str = inflector.pluralize( str );

	      return str;
	    },



	  /**
	   * This function adds classification support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @returns {String} Underscored plural nouns become the camel cased singular form.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
	   */
	    classify : function ( str ){
	      str = inflector.camelize( str );
	      str = inflector.singularize( str );

	      return str;
	    },



	  /**
	   * This function adds foreign key support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
	                                 you can pass true to skip it.(optional)
	   * @returns {String} Underscored plural nouns become the camel cased singular form.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
	   *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
	   */
	    foreign_key : function ( str, drop_id_ubar ){
	      str = inflector.demodulize( str );
	      str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';

	      return str;
	    },



	  /**
	   * This function adds ordinalize support to every String object.
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @returns {String} Return all found numbers their sequence like '22nd'.
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
	   */
	    ordinalize : function ( str ){
	      var str_arr = str.split( ' ' );
	      var i       = 0;
	      var j       = str_arr.length;

	      for( ; i < j; i++ ){
	        var k = parseInt( str_arr[ i ], 10 );

	        if( !isNaN( k )){
	          var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
	          var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
	          var suf = 'th';

	          if( ltd != '11' && ltd != '12' && ltd != '13' ){
	            if( ld === '1' ){
	              suf = 'st';
	            }else if( ld === '2' ){
	              suf = 'nd';
	            }else if( ld === '3' ){
	              suf = 'rd';
	            }
	          }

	          str_arr[ i ] += suf;
	        }
	      }

	      return str_arr.join( ' ' );
	    },

	  /**
	   * This function performs multiple inflection methods on a string
	   * @public
	   * @function
	   * @param {String} str The subject string.
	   * @param {Array} arr An array of inflection methods.
	   * @returns {String}
	   * @example
	   *
	   *     var inflection = require( 'inflection' );
	   *
	   *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
	   */
	    transform : function ( str, arr ){
	      var i = 0;
	      var j = arr.length;

	      for( ;i < j; i++ ){
	        var method = arr[ i ];

	        if( this.hasOwnProperty( method )){
	          str = this[ method ]( str );
	        }
	      }

	      return str;
	    }
	  };

	/**
	 * @public
	 */
	  inflector.version = '1.4.2';

	  return inflector;
	}));


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var jsonlint=function(){var a=!0,b=!1,c={},d=function(){var a={trace:function(){},yy:{},symbols_:{error:2,JSONString:3,STRING:4,JSONNumber:5,NUMBER:6,JSONNullLiteral:7,NULL:8,JSONBooleanLiteral:9,TRUE:10,FALSE:11,JSONText:12,JSONValue:13,EOF:14,JSONObject:15,JSONArray:16,"{":17,"}":18,JSONMemberList:19,JSONMember:20,":":21,",":22,"[":23,"]":24,JSONElementList:25,$accept:0,$end:1},terminals_:{2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},productions_:[0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],performAction:function(b,c,d,e,f,g,h){var i=g.length-1;switch(f){case 1:this.$=b.replace(/\\(\\|")/g,"$1").replace(/\\n/g,"\n").replace(/\\r/g,"\r").replace(/\\t/g,"	").replace(/\\v/g,"").replace(/\\f/g,"\f").replace(/\\b/g,"\b");break;case 2:this.$=Number(b);break;case 3:this.$=null;break;case 4:this.$=!0;break;case 5:this.$=!1;break;case 6:return this.$=g[i-1];case 13:this.$={};break;case 14:this.$=g[i-1];break;case 15:this.$=[g[i-2],g[i]];break;case 16:this.$={},this.$[g[i][0]]=g[i][1];break;case 17:this.$=g[i-2],g[i-2][g[i][0]]=g[i][1];break;case 18:this.$=[];break;case 19:this.$=g[i-1];break;case 20:this.$=[g[i]];break;case 21:this.$=g[i-2],g[i-2].push(g[i])}},table:[{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],defaultActions:{16:[2,6]},parseError:function(b,c){throw new Error(b)},parse:function(b){function o(a){d.length=d.length-2*a,e.length=e.length-a,f.length=f.length-a}function p(){var a;return a=c.lexer.lex()||1,typeof a!="number"&&(a=c.symbols_[a]||a),a}var c=this,d=[0],e=[null],f=[],g=this.table,h="",i=0,j=0,k=0,l=2,m=1;this.lexer.setInput(b),this.lexer.yy=this.yy,this.yy.lexer=this.lexer,typeof this.lexer.yylloc=="undefined"&&(this.lexer.yylloc={});var n=this.lexer.yylloc;f.push(n),typeof this.yy.parseError=="function"&&(this.parseError=this.yy.parseError);var q,r,s,t,u,v,w={},x,y,z,A;for(;;){s=d[d.length-1],this.defaultActions[s]?t=this.defaultActions[s]:(q==null&&(q=p()),t=g[s]&&g[s][q]);if(typeof t=="undefined"||!t.length||!t[0]){if(!k){A=[];for(x in g[s])this.terminals_[x]&&x>2&&A.push("'"+this.terminals_[x]+"'");var B="";this.lexer.showPosition?B="Parse error on line "+(i+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+A.join(", ")+", got '"+this.terminals_[q]+"'":B="Parse error on line "+(i+1)+": Unexpected "+(q==1?"end of input":"'"+(this.terminals_[q]||q)+"'"),this.parseError(B,{text:this.lexer.match,token:this.terminals_[q]||q,line:this.lexer.yylineno,loc:n,expected:A})}if(k==3){if(q==m)throw new Error(B||"Parsing halted.");j=this.lexer.yyleng,h=this.lexer.yytext,i=this.lexer.yylineno,n=this.lexer.yylloc,q=p()}for(;;){if(l.toString()in g[s])break;if(s==0)throw new Error(B||"Parsing halted.");o(1),s=d[d.length-1]}r=q,q=l,s=d[d.length-1],t=g[s]&&g[s][l],k=3}if(t[0]instanceof Array&&t.length>1)throw new Error("Parse Error: multiple actions possible at state: "+s+", token: "+q);switch(t[0]){case 1:d.push(q),e.push(this.lexer.yytext),f.push(this.lexer.yylloc),d.push(t[1]),q=null,r?(q=r,r=null):(j=this.lexer.yyleng,h=this.lexer.yytext,i=this.lexer.yylineno,n=this.lexer.yylloc,k>0&&k--);break;case 2:y=this.productions_[t[1]][1],w.$=e[e.length-y],w._$={first_line:f[f.length-(y||1)].first_line,last_line:f[f.length-1].last_line,first_column:f[f.length-(y||1)].first_column,last_column:f[f.length-1].last_column},v=this.performAction.call(w,h,j,i,this.yy,t[1],e,f);if(typeof v!="undefined")return v;y&&(d=d.slice(0,-1*y*2),e=e.slice(0,-1*y),f=f.slice(0,-1*y)),d.push(this.productions_[t[1]][0]),e.push(w.$),f.push(w._$),z=g[d[d.length-2]][d[d.length-1]],d.push(z);break;case 3:return!0}}return!0}},b=function(){var a={EOF:1,parseError:function(b,c){if(!this.yy.parseError)throw new Error(b);this.yy.parseError(b,c)},setInput:function(a){return this._input=a,this._more=this._less=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this},input:function(){var a=this._input[0];this.yytext+=a,this.yyleng++,this.match+=a,this.matched+=a;var b=a.match(/\n/);return b&&this.yylineno++,this._input=this._input.slice(1),a},unput:function(a){return this._input=a+this._input,this},more:function(){return this._more=!0,this},less:function(a){this._input=this.match.slice(a)+this._input},pastInput:function(){var a=this.matched.substr(0,this.matched.length-this.match.length);return(a.length>20?"...":"")+a.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var a=this.match;return a.length<20&&(a+=this._input.substr(0,20-a.length)),(a.substr(0,20)+(a.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var a=this.pastInput(),b=(new Array(a.length+1)).join("-");return a+this.upcomingInput()+"\n"+b+"^"},next:function(){if(this.done)return this.EOF;this._input||(this.done=!0);var a,b,c,d,e,f;this._more||(this.yytext="",this.match="");var g=this._currentRules();for(var h=0;h<g.length;h++){c=this._input.match(this.rules[g[h]]);if(c&&(!b||c[0].length>b[0].length)){b=c,d=h;if(!this.options.flex)break}}if(b){f=b[0].match(/\n.*/g),f&&(this.yylineno+=f.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:f?f[f.length-1].length-1:this.yylloc.last_column+b[0].length},this.yytext+=b[0],this.match+=b[0],this.yyleng=this.yytext.length,this._more=!1,this._input=this._input.slice(b[0].length),this.matched+=b[0],a=this.performAction.call(this,this.yy,this,g[d],this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1);if(a)return a;return}if(this._input==="")return this.EOF;this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var b=this.next();return typeof b!="undefined"?b:this.lex()},begin:function(b){this.conditionStack.push(b)},popState:function(){return this.conditionStack.pop()},_currentRules:function(){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules},topState:function(){return this.conditionStack[this.conditionStack.length-2]},pushState:function(b){this.begin(b)}};return a.options={},a.performAction=function(b,c,d,e){var f=e;switch(d){case 0:break;case 1:return 6;case 2:return c.yytext=c.yytext.substr(1,c.yyleng-2),4;case 3:return 17;case 4:return 18;case 5:return 23;case 6:return 24;case 7:return 22;case 8:return 21;case 9:return 10;case 10:return 11;case 11:return 8;case 12:return 14;case 13:return"INVALID"}},a.rules=[/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/],a.conditions={INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13],inclusive:!0}},a}();return a.lexer=b,a}();return typeof a!="undefined"&&typeof c!="undefined"&&(c.parser=d,c.parse=function(){return d.parse.apply(d,arguments)},c.main=function(d){if(!d[1])throw new Error("Usage: "+d[0]+" FILE");if(typeof process!="undefined")var e=a("fs").readFileSync(a("path").join(process.cwd(),d[1]),"utf8");else var f=a("file").path(a("file").cwd()),e=f.join(d[1]).read({charset:"utf-8"});return c.parser.parse(e)},typeof b!="undefined"&&a.main===b&&c.main(typeof process!="undefined"?process.argv.slice(1):a("system").args)),c}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _MenuMenu = __webpack_require__(19);

	var _MenuMenu2 = _interopRequireDefault(_MenuMenu);

	var _Collection = __webpack_require__(14);

	var _Collection2 = _interopRequireDefault(_Collection);

	var _Dashboard = __webpack_require__(15);

	var _Dashboard2 = _interopRequireDefault(_Dashboard);

	var _UtilsOrderElement = __webpack_require__(22);

	var _UtilsOrderElement2 = _interopRequireDefault(_UtilsOrderElement);

	var Application = (function () {
	    function Application() {
	        var title = arguments.length <= 0 || arguments[0] === undefined ? 'ng-admin' : arguments[0];
	        var debug = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        _classCallCheck(this, Application);

	        this._baseApiUrl = '';
	        this._customTemplate = function (viewName) {};
	        this._title = title;
	        this._menu = null;
	        this._dashboard = null;
	        this._layout = false;
	        this._header = false;
	        this._entities = [];
	        this._errorMessage = this.defaultErrorMessage;
	        this._debug = debug;
	    }

	    _createClass(Application, [{
	        key: 'defaultErrorMessage',
	        value: function defaultErrorMessage(response) {
	            var body = response.data;

	            if (typeof body === 'object') {
	                body = JSON.stringify(body);
	            }

	            return 'Oops, an error occured : (code: ' + response.status + ') ' + body;
	        }
	    }, {
	        key: 'getViewsOfType',
	        value: function getViewsOfType(type) {
	            return _UtilsOrderElement2['default'].order(this.entities.map(function (entity) {
	                return entity.views[type];
	            }).filter(function (view) {
	                return view.enabled;
	            }));
	        }
	    }, {
	        key: 'getRouteFor',
	        value: function getRouteFor(entity, viewUrl, viewType, identifierValue, identifierName) {
	            var baseApiUrl = entity.baseApiUrl() || this.baseApiUrl(),
	                url = viewUrl || entity.getUrl(viewType, identifierValue, identifierName);

	            // If the view or the entity don't define the url, retrieve it from the baseURL of the entity or the app
	            if (!url) {
	                url = baseApiUrl + encodeURIComponent(entity.name());
	                if (identifierValue != null) {
	                    url += '/' + encodeURIComponent(identifierValue);
	                }
	            } else if (!/^(?:[a-z]+:)?\/\//.test(url)) {
	                // Add baseUrl for relative URL
	                url = baseApiUrl + url;
	            }

	            return url;
	        }
	    }, {
	        key: 'debug',
	        value: function debug(_debug) {
	            if (!arguments.length) return this._debug;
	            this._debug = _debug;
	            return this;
	        }
	    }, {
	        key: 'layout',
	        value: function layout(_layout) {
	            if (!arguments.length) return this._layout;
	            this._layout = _layout;
	            return this;
	        }
	    }, {
	        key: 'header',
	        value: function header(_header) {
	            if (!arguments.length) return this._header;
	            this._header = _header;
	            return this;
	        }
	    }, {
	        key: 'title',
	        value: function title(_title) {
	            if (!arguments.length) return this._title;
	            this._title = _title;
	            return this;
	        }

	        /**
	         * Getter/Setter for the main application menu
	         *
	         * If the getter is called first, it will return a menu based on entities.
	         *
	         *     application.addEntity(new Entity('posts'));
	         *     application.addEntity(new Entity('comments'));
	         *     application.menu(); // Menu { children: [ Menu { title: "Posts" }, Menu { title: "Comments" } ]}
	         *
	         * If the setter is called first, all subsequent calls to the getter will return the set menu.
	         *
	         *     application.addEntity(new Entity('posts'));
	         *     application.addEntity(new Entity('comments'));
	         *     application.menu(new Menu().addChild(new Menu().title('Foo')));
	         *     application.menu(); // Menu { children: [ Menu { title: "Foo" } ]}
	         *
	         * @see Menu
	         */
	    }, {
	        key: 'menu',
	        value: function menu(_menu) {
	            if (!arguments.length) {
	                if (!this._menu) {
	                    this._menu = this.buildMenuFromEntities();
	                }
	                return this._menu;
	            }

	            this._menu = _menu;
	            return this;
	        }
	    }, {
	        key: 'buildMenuFromEntities',
	        value: function buildMenuFromEntities() {
	            return new _MenuMenu2['default']().children(this.entities.filter(function (entity) {
	                return entity.menuView().enabled;
	            }).sort(function (e1, e2) {
	                return e1.menuView().order() - e2.menuView().order();
	            }).map(function (entity) {
	                return new _MenuMenu2['default']().populateFromEntity(entity);
	            }));
	        }
	    }, {
	        key: 'dashboard',
	        value: function dashboard(_dashboard) {
	            if (!arguments.length) {
	                if (!this._dashboard) {
	                    this._dashboard = this.buildDashboardFromEntities();
	                }
	                return this._dashboard;
	            }
	            this._dashboard = _dashboard;
	            return this;
	        }
	    }, {
	        key: 'buildDashboardFromEntities',
	        value: function buildDashboardFromEntities() {
	            var dashboard = new _Dashboard2['default']();
	            this.entities.filter(function (entity) {
	                return entity.dashboardView().enabled;
	            }).map(function (entity) {
	                dashboard.addCollection(entity.dashboardView()); // yep, a collection is a ListView, and so is a DashboardView - forgive this duck typing for BC sake
	            });
	            if (!dashboard.hasCollections()) {
	                // still no collection from dashboardViews, let's use listViews instead
	                this.entities.filter(function (entity) {
	                    return entity.listView().enabled;
	                }).map(function (entity, index) {
	                    var collection = new _Collection2['default']();
	                    var listView = entity.listView();
	                    collection.setEntity(entity);
	                    collection.perPage(listView.perPage());
	                    collection.sortField(listView.sortField());
	                    collection.sortDir(listView.sortDir());
	                    collection.order(index);
	                    // use only the first 3 cols
	                    collection.fields(listView.fields().filter(function (el, index) {
	                        return index < 3;
	                    }));
	                    dashboard.addCollection(collection);
	                });
	            }
	            return dashboard;
	        }
	    }, {
	        key: 'customTemplate',
	        value: function customTemplate(_customTemplate) {
	            if (!arguments.length) return this._customTemplate;
	            this._customTemplate = _customTemplate;
	            return this;
	        }
	    }, {
	        key: 'baseApiUrl',
	        value: function baseApiUrl(url) {
	            if (!arguments.length) return this._baseApiUrl;
	            this._baseApiUrl = url;
	            return this;
	        }
	    }, {
	        key: 'addEntity',
	        value: function addEntity(entity) {
	            if (!entity) {
	                throw new Error("No entity given");
	            }

	            this._entities.push(entity);

	            return this;
	        }
	    }, {
	        key: 'getEntity',
	        value: function getEntity(entityName) {
	            var foundEntity = this._entities.filter(function (e) {
	                return e.name() === entityName;
	            })[0];
	            if (!foundEntity) {
	                throw new Error('Unable to find entity "' + entityName + '"');
	            }

	            return foundEntity;
	        }
	    }, {
	        key: 'hasEntity',
	        value: function hasEntity(fieldName) {
	            return !!this._entities.filter(function (f) {
	                return f.name() === fieldName;
	            }).length;
	        }
	    }, {
	        key: 'getViewByEntityAndType',
	        value: function getViewByEntityAndType(entityName, type) {
	            return this._entities.filter(function (e) {
	                return e.name() === entityName;
	            })[0].views[type];
	        }
	    }, {
	        key: 'getErrorMessage',
	        value: function getErrorMessage(response) {
	            if (typeof this._errorMessage === 'function') {
	                return this._errorMessage(response);
	            }

	            return this._errorMessage;
	        }
	    }, {
	        key: 'errorMessage',
	        value: function errorMessage(_errorMessage) {
	            if (!arguments.length) return this._errorMessage;
	            this._errorMessage = _errorMessage;
	            return this;
	        }
	    }, {
	        key: 'getErrorMessageFor',
	        value: function getErrorMessageFor(view, response) {
	            return view.getErrorMessage(response) || view.getEntity().getErrorMessage(response) || this.getErrorMessage(response);
	        }
	    }, {
	        key: 'getEntityNames',
	        value: function getEntityNames() {
	            return this.entities.map(function (f) {
	                return f.name();
	            });
	        }
	    }, {
	        key: 'entities',
	        get: function get() {
	            return this._entities;
	        }
	    }]);

	    return Application;
	})();

	exports['default'] = Application;
	module.exports = exports['default'];
	//# sourceMappingURL=Application.js.map

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _Application = __webpack_require__(160);

	var _Application2 = _interopRequireDefault(_Application);

	var _EntityEntity = __webpack_require__(7);

	var _EntityEntity2 = _interopRequireDefault(_EntityEntity);

	var _DataStoreDataStore = __webpack_require__(16);

	var _DataStoreDataStore2 = _interopRequireDefault(_DataStoreDataStore);

	var _UtilsPromisesResolver = __webpack_require__(178);

	var _UtilsPromisesResolver2 = _interopRequireDefault(_UtilsPromisesResolver);

	var _QueriesReadQueries = __webpack_require__(176);

	var _QueriesReadQueries2 = _interopRequireDefault(_QueriesReadQueries);

	var _QueriesWriteQueries = __webpack_require__(177);

	var _QueriesWriteQueries2 = _interopRequireDefault(_QueriesWriteQueries);

	var _FieldField = __webpack_require__(1);

	var _FieldField2 = _interopRequireDefault(_FieldField);

	var _FieldBooleanField = __webpack_require__(162);

	var _FieldBooleanField2 = _interopRequireDefault(_FieldBooleanField);

	var _FieldChoiceField = __webpack_require__(8);

	var _FieldChoiceField2 = _interopRequireDefault(_FieldChoiceField);

	var _FieldChoicesField = __webpack_require__(163);

	var _FieldChoicesField2 = _interopRequireDefault(_FieldChoicesField);

	var _FieldDateField = __webpack_require__(17);

	var _FieldDateField2 = _interopRequireDefault(_FieldDateField);

	var _FieldDateTimeField = __webpack_require__(164);

	var _FieldDateTimeField2 = _interopRequireDefault(_FieldDateTimeField);

	var _FieldEmailField = __webpack_require__(165);

	var _FieldEmailField2 = _interopRequireDefault(_FieldEmailField);

	var _FieldEmbeddedListField = __webpack_require__(166);

	var _FieldEmbeddedListField2 = _interopRequireDefault(_FieldEmbeddedListField);

	var _FieldFloatFieldJs = __webpack_require__(168);

	var _FieldFloatFieldJs2 = _interopRequireDefault(_FieldFloatFieldJs);

	var _FieldFileField = __webpack_require__(167);

	var _FieldFileField2 = _interopRequireDefault(_FieldFileField);

	var _FieldJsonField = __webpack_require__(169);

	var _FieldJsonField2 = _interopRequireDefault(_FieldJsonField);

	var _FieldNumberField = __webpack_require__(18);

	var _FieldNumberField2 = _interopRequireDefault(_FieldNumberField);

	var _FieldPasswordField = __webpack_require__(170);

	var _FieldPasswordField2 = _interopRequireDefault(_FieldPasswordField);

	var _FieldReferenceField = __webpack_require__(9);

	var _FieldReferenceField2 = _interopRequireDefault(_FieldReferenceField);

	var _FieldReferencedListField = __webpack_require__(172);

	var _FieldReferencedListField2 = _interopRequireDefault(_FieldReferencedListField);

	var _FieldReferenceManyField = __webpack_require__(171);

	var _FieldReferenceManyField2 = _interopRequireDefault(_FieldReferenceManyField);

	var _FieldTemplateField = __webpack_require__(173);

	var _FieldTemplateField2 = _interopRequireDefault(_FieldTemplateField);

	var _FieldTextField = __webpack_require__(174);

	var _FieldTextField2 = _interopRequireDefault(_FieldTextField);

	var _FieldWysiwygField = __webpack_require__(175);

	var _FieldWysiwygField2 = _interopRequireDefault(_FieldWysiwygField);

	var _MenuMenu = __webpack_require__(19);

	var _MenuMenu2 = _interopRequireDefault(_MenuMenu);

	var _Collection = __webpack_require__(14);

	var _Collection2 = _interopRequireDefault(_Collection);

	var _Dashboard = __webpack_require__(15);

	var _Dashboard2 = _interopRequireDefault(_Dashboard);

	var _Entry = __webpack_require__(4);

	var _Entry2 = _interopRequireDefault(_Entry);

	var Factory = (function () {
	    function Factory() {
	        _classCallCheck(this, Factory);

	        this._fieldTypes = [];
	        this._init();
	    }

	    _createClass(Factory, [{
	        key: "application",
	        value: function application(name, debug) {
	            return new _Application2["default"](name, debug);
	        }
	    }, {
	        key: "entity",
	        value: function entity(name) {
	            return new _EntityEntity2["default"](name);
	        }
	    }, {
	        key: "field",
	        value: function field(name, type) {
	            type = type || 'string';

	            if (!(type in this._fieldTypes)) {
	                throw new Error("Unknown field type \"" + type + "\".");
	            }

	            return new this._fieldTypes[type](name);
	        }
	    }, {
	        key: "registerFieldType",
	        value: function registerFieldType(name, constructor) {
	            this._fieldTypes[name] = constructor;
	        }
	    }, {
	        key: "getFieldConstructor",
	        value: function getFieldConstructor(name) {
	            return this._fieldTypes[name];
	        }
	    }, {
	        key: "menu",
	        value: function menu(entity) {
	            var menu = new _MenuMenu2["default"]();
	            if (entity) {
	                menu.populateFromEntity(entity);
	            }
	            return menu;
	        }
	    }, {
	        key: "dashboard",
	        value: function dashboard() {
	            return new _Dashboard2["default"]();
	        }
	    }, {
	        key: "collection",
	        value: function collection(entity) {
	            var collection = new _Collection2["default"]();
	            if (entity) {
	                collection.setEntity(entity);
	            }
	            return collection;
	        }
	    }, {
	        key: "getEntryConstructor",
	        value: function getEntryConstructor() {
	            return _Entry2["default"];
	        }
	    }, {
	        key: "getDataStore",
	        value: function getDataStore() {
	            return new _DataStoreDataStore2["default"]();
	        }
	    }, {
	        key: "getReadQueries",
	        value: function getReadQueries(RestWrapper, PromisesResolver, Application) {
	            return new _QueriesReadQueries2["default"](RestWrapper, PromisesResolver, Application);
	        }
	    }, {
	        key: "getWriteQueries",
	        value: function getWriteQueries(RestWrapper, PromisesResolver, Application) {
	            return new _QueriesWriteQueries2["default"](RestWrapper, PromisesResolver, Application);
	        }
	    }, {
	        key: "getPromisesResolver",
	        value: function getPromisesResolver() {
	            return _UtilsPromisesResolver2["default"];
	        }
	    }, {
	        key: "_init",
	        value: function _init() {
	            this.registerFieldType('boolean', _FieldBooleanField2["default"]);
	            this.registerFieldType('choice', _FieldChoiceField2["default"]);
	            this.registerFieldType('choices', _FieldChoicesField2["default"]);
	            this.registerFieldType('date', _FieldDateField2["default"]);
	            this.registerFieldType('datetime', _FieldDateTimeField2["default"]);
	            this.registerFieldType('email', _FieldEmailField2["default"]);
	            this.registerFieldType('embedded_list', _FieldEmbeddedListField2["default"]);
	            this.registerFieldType('float', _FieldFloatFieldJs2["default"]);
	            this.registerFieldType('string', _FieldField2["default"]);
	            this.registerFieldType('file', _FieldFileField2["default"]);
	            this.registerFieldType('json', _FieldJsonField2["default"]);
	            this.registerFieldType('number', _FieldNumberField2["default"]);
	            this.registerFieldType('password', _FieldPasswordField2["default"]);
	            this.registerFieldType('reference', _FieldReferenceField2["default"]);
	            this.registerFieldType('reference_many', _FieldReferenceManyField2["default"]);
	            this.registerFieldType('referenced_list', _FieldReferencedListField2["default"]);
	            this.registerFieldType('template', _FieldTemplateField2["default"]);
	            this.registerFieldType('text', _FieldTextField2["default"]);
	            this.registerFieldType('wysiwyg', _FieldWysiwygField2["default"]);
	        }
	    }]);

	    return Factory;
	})();

	exports["default"] = Factory;
	module.exports = exports["default"];
	//# sourceMappingURL=Factory.js.map

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ChoiceField2 = __webpack_require__(8);

	var _ChoiceField3 = _interopRequireDefault(_ChoiceField2);

	var BooleanField = (function (_ChoiceField) {
	    _inherits(BooleanField, _ChoiceField);

	    function BooleanField(name) {
	        _classCallCheck(this, BooleanField);

	        _get(Object.getPrototypeOf(BooleanField.prototype), "constructor", this).call(this, name);
	        this._type = "boolean";
	        this._choices = [{ value: null, label: 'undefined' }, { value: true, label: 'true' }, { value: false, label: 'false' }];
	        this._filterChoices = [{ value: true, label: 'true' }, { value: false, label: 'false' }];
	    }

	    _createClass(BooleanField, [{
	        key: "filterChoices",
	        value: function filterChoices(_filterChoices) {
	            if (!arguments.length) return this._filterChoices;
	            this._filterChoices = _filterChoices;

	            return this;
	        }
	    }]);

	    return BooleanField;
	})(_ChoiceField3["default"]);

	exports["default"] = BooleanField;
	module.exports = exports["default"];
	//# sourceMappingURL=BooleanField.js.map

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ChoiceField2 = __webpack_require__(8);

	var _ChoiceField3 = _interopRequireDefault(_ChoiceField2);

	var ChoicesField = (function (_ChoiceField) {
	    _inherits(ChoicesField, _ChoiceField);

	    function ChoicesField(name) {
	        _classCallCheck(this, ChoicesField);

	        _get(Object.getPrototypeOf(ChoicesField.prototype), "constructor", this).call(this, name);
	        this._type = "choices";
	    }

	    return ChoicesField;
	})(_ChoiceField3["default"]);

	exports["default"] = ChoicesField;
	module.exports = exports["default"];
	//# sourceMappingURL=ChoicesField.js.map

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _DateField2 = __webpack_require__(17);

	var _DateField3 = _interopRequireDefault(_DateField2);

	var DateTimeField = (function (_DateField) {
	    _inherits(DateTimeField, _DateField);

	    function DateTimeField(name) {
	        _classCallCheck(this, DateTimeField);

	        _get(Object.getPrototypeOf(DateTimeField.prototype), "constructor", this).call(this, name);

	        this._format = null;
	        this._parse = function (date) {
	            return date;
	        };

	        this._type = 'datetime';
	    }

	    return DateTimeField;
	})(_DateField3["default"]);

	exports["default"] = DateTimeField;
	module.exports = exports["default"];
	//# sourceMappingURL=DateTimeField.js.map

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var EmailField = (function (_Field) {
	    _inherits(EmailField, _Field);

	    function EmailField(name) {
	        _classCallCheck(this, EmailField);

	        _get(Object.getPrototypeOf(EmailField.prototype), "constructor", this).call(this, name);
	        this._type = "email";
	    }

	    return EmailField;
	})(_Field3["default"]);

	exports["default"] = EmailField;
	module.exports = exports["default"];
	//# sourceMappingURL=EmailField.js.map

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var _EntityEntity = __webpack_require__(7);

	var _EntityEntity2 = _interopRequireDefault(_EntityEntity);

	/**
	 * Map an embedded list in the entry
	 *
	 * @example
	 *
	 *     {
	 *        id: 123,
	 *        title: "hello, world",
	 *        comments: [
	 *          { date: "2015-09-30", author: "John Doe", body: "Lorem Ipsum" },
	 *          { date: "2015-10-02", author: "Jane Doe", body: "Sic dolor amet" }
	 *        ]
	 *     }
	 *
	 *     let commentsField = new EmbeddedListField('comments')
	 *        .targetFields([
	 *          new DateField('date'),
	 *          new StringField('author'),
	 *          new StringField('body')
	 *        ])
	 */

	var EmbeddedListField = (function (_Field) {
	    _inherits(EmbeddedListField, _Field);

	    function EmbeddedListField(name) {
	        _classCallCheck(this, EmbeddedListField);

	        _get(Object.getPrototypeOf(EmbeddedListField.prototype), "constructor", this).call(this, name);
	        this._type = 'embedded_list';
	        this._flattenable = false;
	        this._targetEntity = new _EntityEntity2["default"](); // link to an empty entity by default
	        this._targetFields = [];
	        this._sortField = null;
	        this._sortDir = null;
	        this._permanentFilters = null;
	        this._listActions = [];
	    }

	    /**
	     * Optionally set the target Entity
	     *
	     * Useful if the embedded entries can be edited in standalone
	     */

	    _createClass(EmbeddedListField, [{
	        key: "targetEntity",
	        value: function targetEntity(entity) {
	            if (!arguments.length) {
	                return this._targetEntity;
	            }
	            this._targetEntity = entity;

	            return this;
	        }

	        /**
	         * List the fields to map in the embedded entries
	         *
	         * @example
	         *
	         *     embeddedListField.targetFields([
	         *       new DateField('date'),
	         *       new StringField('author'),
	         *       new StringField('body')
	         *     ])
	         */
	    }, {
	        key: "targetFields",
	        value: function targetFields(value) {
	            if (!arguments.length) return this._targetFields;
	            this._targetFields = value;

	            return this;
	        }

	        /**
	         * Name of the field used for sorting.
	         *
	         * @param string
	         */
	    }, {
	        key: "sortField",
	        value: function sortField() {
	            if (arguments.length) {
	                this._sortField = arguments[0];
	                return this;
	            }

	            return this._sortField ? this._sortField : this.targetEntity().identifier().name();
	        }

	        /**
	         * Direction used for sorting.
	         *
	         * @param String either 'ASC' or 'DESC'
	         */
	    }, {
	        key: "sortDir",
	        value: function sortDir() {
	            if (arguments.length) {
	                this._sortDir = arguments[0];
	                return this;
	            }

	            return this._sortDir;
	        }
	    }, {
	        key: "listActions",
	        value: function listActions(actions) {
	            if (!arguments.length) {
	                return this._listActions;
	            }

	            this._listActions = actions;

	            return this;
	        }

	        /**
	         * Define permanent filters to be added to the REST API calls
	         *
	         *     nga.field('post_id', 'reference').permanentFilters({
	         *        published: true
	         *     });
	         *     // related API call will be /posts/:id?published=true
	         *
	         * @param {Object} filters list of filters to apply to the call
	         */
	    }, {
	        key: "permanentFilters",
	        value: function permanentFilters(filters) {
	            if (!arguments.length) {
	                return this._permanentFilters;
	            }

	            this._permanentFilters = filters;

	            return this;
	        }
	    }]);

	    return EmbeddedListField;
	})(_Field3["default"]);

	exports["default"] = EmbeddedListField;
	module.exports = exports["default"];
	//# sourceMappingURL=EmbeddedListField.js.map

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var FileField = (function (_Field) {
	    _inherits(FileField, _Field);

	    function FileField(name) {
	        _classCallCheck(this, FileField);

	        _get(Object.getPrototypeOf(FileField.prototype), "constructor", this).call(this, name);
	        this._type = "file";
	        this._uploadInformation = {
	            url: '/upload',
	            accept: '*'
	        };
	    }

	    _createClass(FileField, [{
	        key: "uploadInformation",
	        value: function uploadInformation(information) {
	            if (!arguments.length) return this._uploadInformation;
	            this._uploadInformation = information;
	            return this;
	        }
	    }]);

	    return FileField;
	})(_Field3["default"]);

	exports["default"] = FileField;
	module.exports = exports["default"];
	//# sourceMappingURL=FileField.js.map

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _NumberField2 = __webpack_require__(18);

	var _NumberField3 = _interopRequireDefault(_NumberField2);

	var FloatField = (function (_NumberField) {
	    _inherits(FloatField, _NumberField);

	    function FloatField(name) {
	        _classCallCheck(this, FloatField);

	        _get(Object.getPrototypeOf(FloatField.prototype), 'constructor', this).call(this, name);
	        this._type = 'float';
	        this._format = '0.000';
	    }

	    return FloatField;
	})(_NumberField3['default']);

	exports['default'] = FloatField;
	module.exports = exports['default'];
	//# sourceMappingURL=FloatField.js.map

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var JsonField = (function (_Field) {
	    _inherits(JsonField, _Field);

	    function JsonField(name) {
	        _classCallCheck(this, JsonField);

	        _get(Object.getPrototypeOf(JsonField.prototype), "constructor", this).call(this, name);
	        this._type = "json";
	        this._flattenable = false;
	    }

	    return JsonField;
	})(_Field3["default"]);

	exports["default"] = JsonField;
	module.exports = exports["default"];
	//# sourceMappingURL=JsonField.js.map

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var PasswordField = (function (_Field) {
	    _inherits(PasswordField, _Field);

	    function PasswordField(name) {
	        _classCallCheck(this, PasswordField);

	        _get(Object.getPrototypeOf(PasswordField.prototype), "constructor", this).call(this, name);
	        this._type = "password";
	    }

	    return PasswordField;
	})(_Field3["default"]);

	exports["default"] = PasswordField;
	module.exports = exports["default"];
	//# sourceMappingURL=PasswordField.js.map

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ReferenceField2 = __webpack_require__(9);

	var _ReferenceField3 = _interopRequireDefault(_ReferenceField2);

	var ReferenceManyField = (function (_ReferenceField) {
	    _inherits(ReferenceManyField, _ReferenceField);

	    function ReferenceManyField(name) {
	        _classCallCheck(this, ReferenceManyField);

	        _get(Object.getPrototypeOf(ReferenceManyField.prototype), "constructor", this).call(this, name);
	        this._type = 'reference_many';
	    }

	    return ReferenceManyField;
	})(_ReferenceField3["default"]);

	exports["default"] = ReferenceManyField;
	module.exports = exports["default"];
	//# sourceMappingURL=ReferenceManyField.js.map

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ReferenceField2 = __webpack_require__(9);

	var _ReferenceField3 = _interopRequireDefault(_ReferenceField2);

	var _UtilsReferenceExtractor = __webpack_require__(10);

	var _UtilsReferenceExtractor2 = _interopRequireDefault(_UtilsReferenceExtractor);

	var ReferencedListField = (function (_ReferenceField) {
	    _inherits(ReferencedListField, _ReferenceField);

	    function ReferencedListField(name) {
	        _classCallCheck(this, ReferencedListField);

	        _get(Object.getPrototypeOf(ReferencedListField.prototype), 'constructor', this).call(this, name);
	        this._type = 'referenced_list';
	        this._targetReferenceField = null;
	        this._targetFields = [];
	        this._detailLink = false;
	        this._listActions = [];
	        this._entryCssClasses = null;
	    }

	    _createClass(ReferencedListField, [{
	        key: 'targetReferenceField',
	        value: function targetReferenceField(value) {
	            if (!arguments.length) return this._targetReferenceField;
	            this._targetReferenceField = value;
	            return this;
	        }
	    }, {
	        key: 'targetFields',
	        value: function targetFields(value) {
	            if (!arguments.length) return this._targetFields;
	            this._targetFields = value;

	            return this;
	        }
	    }, {
	        key: 'getGridColumns',
	        value: function getGridColumns() {
	            var columns = [];
	            for (var i = 0, l = this._targetFields.length; i < l; i++) {
	                var field = this._targetFields[i];
	                columns.push({
	                    field: field,
	                    label: field.label()
	                });
	            }

	            return columns;
	        }
	    }, {
	        key: 'getSortFieldName',
	        value: function getSortFieldName() {
	            if (!this.sortField()) {
	                return null;
	            }

	            return this._targetEntity.name() + '_ListView.' + this.sortField();
	        }
	    }, {
	        key: 'listActions',
	        value: function listActions(actions) {
	            if (!arguments.length) {
	                return this._listActions;
	            }

	            this._listActions = actions;

	            return this;
	        }
	    }, {
	        key: 'entryCssClasses',
	        value: function entryCssClasses(classes) {
	            if (!arguments.length) {
	                return this._entryCssClasses;
	            }

	            this._entryCssClasses = classes;

	            return this;
	        }
	    }, {
	        key: 'getReferences',
	        value: function getReferences(withRemoteComplete) {
	            return _UtilsReferenceExtractor2['default'].getReferences(this._targetFields, withRemoteComplete);
	        }
	    }, {
	        key: 'getNonOptimizedReferences',
	        value: function getNonOptimizedReferences(withRemoteComplete) {
	            return _UtilsReferenceExtractor2['default'].getNonOptimizedReferences(this._targetFields, withRemoteComplete);
	        }
	    }, {
	        key: 'getOptimizedReferences',
	        value: function getOptimizedReferences(withRemoteComplete) {
	            return _UtilsReferenceExtractor2['default'].getOptimizedReferences(this._targetFields, withRemoteComplete);
	        }
	    }]);

	    return ReferencedListField;
	})(_ReferenceField3['default']);

	exports['default'] = ReferencedListField;
	module.exports = exports['default'];
	//# sourceMappingURL=ReferencedListField.js.map

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var TemplateField = (function (_Field) {
	    _inherits(TemplateField, _Field);

	    function TemplateField(name) {
	        _classCallCheck(this, TemplateField);

	        _get(Object.getPrototypeOf(TemplateField.prototype), "constructor", this).call(this, name);
	        this._type = "template";
	        this._flattenable = false;
	    }

	    return TemplateField;
	})(_Field3["default"]);

	exports["default"] = TemplateField;
	module.exports = exports["default"];
	//# sourceMappingURL=TemplateField.js.map

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var TextField = (function (_Field) {
	    _inherits(TextField, _Field);

	    function TextField(name) {
	        _classCallCheck(this, TextField);

	        _get(Object.getPrototypeOf(TextField.prototype), "constructor", this).call(this, name);
	        this._type = "text";
	    }

	    return TextField;
	})(_Field3["default"]);

	exports["default"] = TextField;
	module.exports = exports["default"];
	//# sourceMappingURL=TextField.js.map

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Field2 = __webpack_require__(1);

	var _Field3 = _interopRequireDefault(_Field2);

	var WysiwygField = (function (_Field) {
	    _inherits(WysiwygField, _Field);

	    function WysiwygField(name) {
	        _classCallCheck(this, WysiwygField);

	        _get(Object.getPrototypeOf(WysiwygField.prototype), "constructor", this).call(this, name);
	        this._type = "wysiwyg";
	        this._stripTags = false;
	        this._sanitize = true;
	    }

	    _createClass(WysiwygField, [{
	        key: "stripTags",
	        value: function stripTags(value) {
	            if (!arguments.length) return this._stripTags;
	            this._stripTags = value;
	            return this;
	        }
	    }, {
	        key: "sanitize",
	        value: function sanitize(value) {
	            if (!arguments.length) return this._sanitize;
	            this._sanitize = value;
	            return this;
	        }
	    }]);

	    return WysiwygField;
	})(_Field3["default"]);

	exports["default"] = WysiwygField;
	module.exports = exports["default"];
	//# sourceMappingURL=WysiwygField.js.map

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Queries2 = __webpack_require__(20);

	var _Queries3 = _interopRequireDefault(_Queries2);

	var _UtilsReferenceExtractor = __webpack_require__(10);

	var _UtilsReferenceExtractor2 = _interopRequireDefault(_UtilsReferenceExtractor);

	var ReadQueries = (function (_Queries) {
	    _inherits(ReadQueries, _Queries);

	    function ReadQueries() {
	        _classCallCheck(this, ReadQueries);

	        _get(Object.getPrototypeOf(ReadQueries.prototype), 'constructor', this).apply(this, arguments);
	    }

	    _createClass(ReadQueries, [{
	        key: 'getOne',

	        /**
	         * Get one entity
	         *
	         * @param {Entity}   entity
	         * @param {String}   viewType
	         * @param {mixed}    identifierValue
	         * @param {String}   identifierName
	         * @param {String}   url
	         *
	         * @returns {promise} (list of fields (with their values if set) & the entity name, label & id-
	         */
	        value: function getOne(entity, viewType, identifierValue, identifierName, url) {
	            return this._restWrapper.getOne(entity.name(), this._application.getRouteFor(entity, url, viewType, identifierValue, identifierName), entity.retrieveMethod());
	        }

	        /**
	         * Return the list of all object of entityName type
	         * Get all the object from the API
	         *
	         * @param {ListView} view                the view associated to the entity
	         * @param {Number}   page                the page number
	         * @param {Object}   filterValues        searchQuery to filter elements
	         * @param {String}   sortField           the field to be sorted ex: entity.fieldName
	         * @param {String}   sortDir             the direction of the sort
	         *
	         * @returns {promise} the entity config & the list of objects
	         */
	    }, {
	        key: 'getAll',
	        value: function getAll(view, page, filterValues, sortField, sortDir) {
	            page = page || 1;
	            filterValues = filterValues || {};
	            var url = view.getUrl();

	            if (sortField && sortField.split('.')[0] === view.name()) {
	                sortField = sortField;
	                sortDir = sortDir;
	            } else {
	                sortField = view.getSortFieldName();
	                sortDir = view.sortDir();
	            }

	            var allFilterValues = {};
	            var permanentFilters = view.permanentFilters();
	            Object.keys(filterValues).forEach(function (key) {
	                allFilterValues[key] = filterValues[key];
	            });
	            Object.keys(permanentFilters).forEach(function (key) {
	                allFilterValues[key] = permanentFilters[key];
	            });

	            return this.getRawValues(view.entity, view.name(), view.type, page, view.perPage(), allFilterValues, view.filters(), sortField, sortDir, url).then(function (values) {
	                return {
	                    data: values.data,
	                    totalItems: values.totalCount || values.headers('X-Total-Count') || values.data.length
	                };
	            });
	        }

	        /**
	         * Return the list of all object of entityName type
	         * Get all the object from the API
	         *
	         * @param {Entity}   entity
	         * @param {String}   viewName
	         * @param {String}   viewType
	         * @param {Number}   page
	         * @param {Number}   perPage
	         * @param {Object}   filterValues
	         * @param {Object}   filterFields
	         * @param {String}   sortField
	         * @param {String}   sortDir
	         * @param {String}   url
	         *
	         * @returns {promise} the entity config & the list of objects
	         */
	    }, {
	        key: 'getRawValues',
	        value: function getRawValues(entity, viewName, viewType, page, perPage, filterValues, filterFields, sortField, sortDir, url) {
	            var params = {};

	            // Compute pagination
	            if (page !== -1) {
	                params._page = typeof page === 'undefined' ? 1 : parseInt(page, 10);
	                params._perPage = perPage;
	            }

	            // Compute sorting
	            if (sortField && sortField.split('.')[0] === viewName) {
	                params._sortField = sortField.substr(sortField.indexOf('.') + 1);
	                params._sortDir = sortDir;
	            }

	            // Compute filtering
	            if (filterValues && Object.keys(filterValues).length !== 0) {
	                (function () {
	                    params._filters = {};
	                    var filterName = undefined,
	                        mappedValue = undefined;
	                    for (filterName in filterValues) {
	                        if (filterFields.hasOwnProperty(filterName) && filterFields[filterName].hasMaps()) {
	                            mappedValue = filterFields[filterName].getMappedValue(filterValues[filterName]);
	                            Object.keys(mappedValue).forEach(function (key) {
	                                params._filters[key] = mappedValue[key];
	                            });
	                            continue;
	                        }

	                        // It's weird to not map, but why not.
	                        params._filters[filterName] = filterValues[filterName];
	                    }
	                })();
	            }

	            // Get grid data
	            return this._restWrapper.getList(params, entity.name(), this._application.getRouteFor(entity, url, viewType), entity.retrieveMethod());
	        }
	    }, {
	        key: 'getReferenceData',
	        value: function getReferenceData(references, rawValues) {
	            var nonOptimizedReferencedData = this.getFilteredReferenceData(_UtilsReferenceExtractor2['default'].getNonOptimizedReferences(references), rawValues);
	            var optimizedReferencedData = this.getOptimizedReferenceData(_UtilsReferenceExtractor2['default'].getOptimizedReferences(references), rawValues);
	            return Promise.all([nonOptimizedReferencedData, optimizedReferencedData]).then(function (results) {
	                var data = {};
	                var name = undefined;
	                for (name in results[0]) {
	                    data[name] = results[0][name];
	                }
	                for (name in results[1]) {
	                    data[name] = results[1][name];
	                }
	                return data;
	            });
	        }

	        /**
	         * Returns all References for an entity with associated values [{targetEntity.identifier: targetLabel}, ...]
	         * by calling the API for each entries
	         *
	         * @param {ReferenceField} references A hash of Reference and ReferenceMany objects
	         * @param {Array} rawValues
	         *
	         * @returns {Promise}
	         */
	    }, {
	        key: 'getFilteredReferenceData',
	        value: function getFilteredReferenceData(references, rawValues) {
	            if (!references || !Object.keys(references).length) {
	                return this._promisesResolver.empty({});
	            }

	            var getOne = this.getOne.bind(this),
	                calls = [];

	            for (var i in references) {
	                var reference = references[i],
	                    targetEntity = reference.targetEntity(),
	                    identifiers = reference.getIdentifierValues(rawValues);

	                for (var k in identifiers) {
	                    calls.push(getOne(targetEntity, 'listView', identifiers[k], reference.name()));
	                }
	            }

	            return this.fillFilteredReferencedData(calls, references, rawValues);
	        }

	        /**
	         * Returns all References for an entity with associated values [{targetEntity.identifier: targetLabel}, ...]
	         * by calling the API once
	         *
	         * @param {[ReferenceField]} references A hash of Reference and ReferenceMany objects
	         * @param {Array} rawValues
	         *
	         * @returns {Promise}
	         */
	    }, {
	        key: 'getOptimizedReferenceData',
	        value: function getOptimizedReferenceData(references, rawValues) {
	            if (!references || !Object.keys(references).length) {
	                return this._promisesResolver.empty({});
	            }

	            var getRawValues = this.getRawValues.bind(this),
	                calls = [];

	            for (var i in references) {
	                var reference = references[i],
	                    targetEntity = reference.targetEntity(),
	                    identifiers = reference.getIdentifierValues(rawValues);

	                // Check if we should retrieve values with 1 or multiple requests
	                var singleCallFilters = reference.getSingleApiCall(identifiers);
	                calls.push(getRawValues(targetEntity, targetEntity.name() + '_ListView', 'listView', 1, reference.perPage(), singleCallFilters, {}, reference.sortField(), reference.sortDir()));
	            }

	            return this.fillOptimizedReferencedData(calls, references);
	        }

	        /**
	         * Returns all References for an entity with associated values [{targetEntity.identifier: targetLabel}, ...]
	         * without filters on an entity
	         *
	         * @param {[ReferenceField]} references A hash of Reference and ReferenceMany objects
	         *
	         * @returns {Promise}
	         */
	    }, {
	        key: 'getAllReferencedData',
	        value: function getAllReferencedData(references, search) {
	            if (!references || !Object.keys(references).length) {
	                return this._promisesResolver.empty({});
	            }

	            var calls = [],
	                getRawValues = this.getRawValues.bind(this);

	            var _loop = function (i) {
	                var reference = references[i];
	                var targetEntity = reference.targetEntity();

	                var permanentFilters = reference.permanentFilters();
	                var filterValues = permanentFilters || {};

	                if (typeof permanentFilters === 'function') {
	                    console.warn('Reference.permanentFilters() called with a function is deprecated. Use the searchQuery option for remoteComplete() instead');
	                    filterValues = permanentFilters(search);
	                }

	                if (search) {
	                    // remote complete situation
	                    var options = reference.remoteCompleteOptions();
	                    if (options.searchQuery) {
	                        (function () {
	                            var filterValuesFromRemoteComplete = options.searchQuery(search);
	                            Object.keys(filterValuesFromRemoteComplete).forEach(function (key) {
	                                filterValues[key] = filterValuesFromRemoteComplete[key];
	                            });
	                        })();
	                    } else {
	                        // by default, filter the list by the referenceField name
	                        filterValues[reference.targetField().name()] = search;
	                    }
	                }

	                var filterFields = {};
	                filterFields[reference.name()] = reference;

	                calls.push(getRawValues(targetEntity, targetEntity.name() + '_ListView', 'listView', 1, reference.perPage(), filterValues, filterFields, reference.getSortFieldName(), reference.sortDir()));
	            };

	            for (var i in references) {
	                _loop(i);
	            }

	            return this.fillOptimizedReferencedData(calls, references);
	        }

	        /**
	         * Fill all reference entries to return [{targetEntity.identifier: targetLabel}, ...]
	         *
	         * @param {[Promise]} apiCalls
	         * @param {[Reference]} references
	         * @returns {Promise}
	         */
	    }, {
	        key: 'fillOptimizedReferencedData',
	        value: function fillOptimizedReferencedData(apiCalls, references) {
	            return this._promisesResolver.allEvenFailed(apiCalls).then(function (responses) {
	                if (responses.length === 0) {
	                    return {};
	                }

	                var referencedData = {},
	                    i = 0;

	                for (var j in references) {
	                    var reference = references[j],
	                        response = responses[i++];

	                    // Retrieve entries depending on 1 or many request was done
	                    if (response.status == 'error') {
	                        // the response failed
	                        continue;
	                    }

	                    referencedData[reference.name()] = response.result.data;
	                }

	                return referencedData;
	            });
	        }

	        /**
	         * Fill all reference entries to return [{targetEntity.identifier: targetLabel}, ...]
	         *
	         * @param {[Promise]} apiCalls
	         * @param {[Reference]} references
	         * @param {[Object]} rawValues
	         * @returns {Promise}
	         */
	    }, {
	        key: 'fillFilteredReferencedData',
	        value: function fillFilteredReferencedData(apiCalls, references, rawValues) {
	            return this._promisesResolver.allEvenFailed(apiCalls).then(function (responses) {
	                if (responses.length === 0) {
	                    return {};
	                }

	                var referencedData = {},
	                    response = undefined,
	                    i = 0;

	                for (var j in references) {
	                    var data = [],
	                        reference = references[j],
	                        identifiers = reference.getIdentifierValues(rawValues);

	                    for (var k in identifiers) {
	                        response = responses[i++];
	                        if (response.status == 'error') {
	                            // one of the responses failed
	                            continue;
	                        }
	                        data.push(response.result);
	                    }

	                    if (!data.length) {
	                        continue;
	                    }

	                    referencedData[reference.name()] = data;
	                }

	                return referencedData;
	            });
	        }

	        /**
	         * Returns all ReferencedList for an entity for associated values [{targetEntity.identifier: [targetFields, ...]}}
	         *
	         * @param {View}   referencedLists
	         * @param {String} sortField
	         * @param {String} sortDir
	         * @param {*} entityId
	         *
	         * @returns {promise}
	         */
	    }, {
	        key: 'getReferencedListData',
	        value: function getReferencedListData(referencedLists, sortField, sortDir, entityId) {
	            var getRawValues = this.getRawValues.bind(this),
	                calls = [];

	            var _loop2 = function (i) {
	                var referencedList = referencedLists[i],
	                    targetEntity = referencedList.targetEntity(),
	                    viewName = referencedList.datagridName(),
	                    currentSortField = referencedList.getSortFieldName(),
	                    currentSortDir = referencedList.sortDir(),
	                    filter = {};

	                if (sortField && sortField.split('.')[0] === viewName) {
	                    currentSortField = sortField;
	                    currentSortDir = sortDir || 'ASC';
	                }

	                var permanentFilters = referencedList.permanentFilters() || {};
	                Object.keys(permanentFilters).forEach(function (key) {
	                    filter[key] = permanentFilters[key];
	                });
	                filter[referencedList.targetReferenceField()] = entityId;

	                calls.push(getRawValues(targetEntity, viewName, 'listView', 1, referencedList.perPage(), filter, {}, currentSortField, currentSortDir));
	            };

	            for (var i in referencedLists) {
	                _loop2(i);
	            }

	            return this._promisesResolver.allEvenFailed(calls).then(function (responses) {
	                var j = 0,
	                    entries = {};

	                for (var i in referencedLists) {
	                    var response = responses[j++];
	                    if (response.status == 'error') {
	                        // If a response fail, skip it
	                        continue;
	                    }

	                    entries[i] = response.result.data;
	                }

	                return entries;
	            });
	        }
	    }, {
	        key: 'getRecordsByIds',
	        value: function getRecordsByIds(entity, ids) {
	            var _this = this;

	            if (!ids || !ids.length) {
	                return this._promisesResolver.empty();
	            }

	            var calls = ids.map(function (id) {
	                return _this.getOne(entity, 'listView', id, entity.identifier().name());
	            });

	            return this._promisesResolver.allEvenFailed(calls).then(function (responses) {
	                return responses.filter(function (r) {
	                    return r.status != 'error';
	                }).map(function (r) {
	                    return r.result;
	                });
	            });
	        }
	    }]);

	    return ReadQueries;
	})(_Queries3['default']);

	exports['default'] = ReadQueries;
	module.exports = exports['default'];
	//# sourceMappingURL=ReadQueries.js.map

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Queries2 = __webpack_require__(20);

	var _Queries3 = _interopRequireDefault(_Queries2);

	var WriteQueries = (function (_Queries) {
	    _inherits(WriteQueries, _Queries);

	    function WriteQueries() {
	        _classCallCheck(this, WriteQueries);

	        _get(Object.getPrototypeOf(WriteQueries.prototype), 'constructor', this).apply(this, arguments);
	    }

	    _createClass(WriteQueries, [{
	        key: 'createOne',

	        /**
	         * Create a new entity
	         * Post the data to the API to create the new object
	         *
	         * @param {View}   view      the formView related to the entity
	         * @param {Object} rawEntity the entity's object
	         *
	         * @returns {promise}  the new object
	         */
	        value: function createOne(view, rawEntity) {
	            return this._restWrapper.createOne(rawEntity, view.entity.name(), this._application.getRouteFor(view.entity, view.getUrl(), view.type), view.entity.createMethod());
	        }

	        /**
	         * Update an entity
	         * Put the data to the API to create the new object
	         *
	         * @param {View}   view             the formView related to the entity
	         * @param {Object} rawEntity        the entity's object
	         * @param {String} originEntityId   if entity identifier is modified
	         *
	         * @returns {promise} the updated object
	         */
	    }, {
	        key: 'updateOne',
	        value: function updateOne(view, rawEntity, originEntityId) {
	            var entityId = originEntityId || rawEntity[view.entity.identifier().name()];

	            // Update element data
	            return this._restWrapper.updateOne(rawEntity, view.entity.name(), this._application.getRouteFor(view.entity, view.getUrl(entityId), view.type, entityId, view.identifier()), view.entity.updateMethod());
	        }

	        /**
	         * Delete an entity
	         * Delete the data to the API
	         *
	         * @param {String} view     the formView related to the entity
	         * @param {*}      entityId the entity's id
	         *
	         * @returns {promise}
	         */
	    }, {
	        key: 'deleteOne',
	        value: function deleteOne(view, entityId) {
	            return this._restWrapper.deleteOne(view.entity.name(), this._application.getRouteFor(view.entity, view.getUrl(entityId), view.type, entityId, view.identifier()), view.entity.deleteMethod());
	        }

	        /**
	         * Delete a batch of entity
	         * Delete the data to the API
	         *
	         * @param {String} view     the formView related to the entity
	         * @param {*}      entityIds the entities ids
	         *
	         * @returns {promise}
	         */
	    }, {
	        key: 'batchDelete',
	        value: function batchDelete(view, entityIds) {
	            var deleteOne = this.deleteOne.bind(this);
	            var promises = entityIds.map(function (id) {
	                return deleteOne(view, id);
	            });

	            return this._promisesResolver.allEvenFailed(promises);
	        }
	    }]);

	    return WriteQueries;
	})(_Queries3['default']);

	exports['default'] = WriteQueries;
	module.exports = exports['default'];
	//# sourceMappingURL=WriteQueries.js.map

/***/ },
/* 178 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var PromisesResolver = (function () {
	    function PromisesResolver() {
	        _classCallCheck(this, PromisesResolver);
	    }

	    _createClass(PromisesResolver, null, [{
	        key: 'empty',
	        value: function empty(value) {
	            return new Promise(function (resolve) {
	                resolve(value);
	            });
	        }
	    }, {
	        key: 'allEvenFailed',
	        value: function allEvenFailed(promises) {
	            if (!Array.isArray(promises)) {
	                throw Error('allEvenFailed can only handle an array of promises');
	            }

	            return new Promise(function (resolve, reject) {
	                if (promises.length === 0) {
	                    return resolve([]);
	                }

	                var states = [],
	                    results = [];

	                promises.forEach(function (promise, key) {
	                    states[key] = false; // promises are not resolved by default
	                });

	                promises.forEach(function (promise, key) {
	                    function resolveState(result) {
	                        states[key] = true;
	                        results[key] = result; // result may be an error
	                        for (var i in states) {
	                            if (!states[i]) {
	                                return;
	                            }
	                        }

	                        resolve(results);
	                    }

	                    function resolveSuccess(result) {
	                        return resolveState({ status: 'success', result: result });
	                    }

	                    function resolveError(result) {
	                        return resolveState({ status: 'error', error: result });
	                    }

	                    // whether the promise ends with success or error, consider it done
	                    promise.then(resolveSuccess, resolveError);
	                });
	            });
	        }
	    }]);

	    return PromisesResolver;
	})();

	exports['default'] = PromisesResolver;
	module.exports = exports['default'];
	//# sourceMappingURL=PromisesResolver.js.map

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _View2 = __webpack_require__(5);

	var _View3 = _interopRequireDefault(_View2);

	var BatchDeleteView = (function (_View) {
	    _inherits(BatchDeleteView, _View);

	    function BatchDeleteView(name) {
	        _classCallCheck(this, BatchDeleteView);

	        _get(Object.getPrototypeOf(BatchDeleteView.prototype), 'constructor', this).call(this, name);

	        this._type = 'BatchDeleteView';
	        this._enabled = true;
	    }

	    return BatchDeleteView;
	})(_View3['default']);

	exports['default'] = BatchDeleteView;
	module.exports = exports['default'];
	//# sourceMappingURL=BatchDeleteView.js.map

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _View2 = __webpack_require__(5);

	var _View3 = _interopRequireDefault(_View2);

	var CreateView = (function (_View) {
	    _inherits(CreateView, _View);

	    function CreateView(name) {
	        _classCallCheck(this, CreateView);

	        _get(Object.getPrototypeOf(CreateView.prototype), 'constructor', this).call(this, name);
	        this._type = 'CreateView';
	        this._submitCreationSuccess = null;
	        this._submitCreationError = null;
	    }

	    /**
	     * Add a function to be executed after the creation succeeds.
	     *
	     * This is the ideal place to use the response to update the entry, or
	     * redirect to another view.
	     *
	     * If the function returns false, the default execution workflow is stopped.
	     * This means that the function must provide a custom workflow.
	     *
	     * If the function throws an exception, the onSubmitError callback will
	     * execute.
	     *
	     * The syntax depends on the framework calling the function.
	     *
	     * With ng-admin, the function can be an angular injectable, listing
	     * required dependencies in an array. Among other, the function can receive
	     * the following services:
	     *  - $event: the form submission event
	     *  - entry: the current Entry instance
	     *  - entity: the current entity
	     *  - form: the form object (for form validation and errors)
	     *  - progression: the controller for the loading indicator
	     *  - notification: the controller for top notifications
	     *
	     * The function can be asynchronous, in which case it should return
	     * a Promise.
	     *
	     * @example
	     *
	     *     post.creationView().onSubmitSuccess(['progression', 'notification', '$state', 'entry', 'entity', function(progression, notification, $state, entry, entity) {
	     *         // stop the progress bar
	     *         progression.done();
	     *         // add a notification
	     *         notification.log(`Element #${entry._identifierValue} successfully created.`, { addnCls: 'humane-flatty-success' });
	     *         // redirect to the list view
	     *         $state.go($state.get('list'), { entity: entity.name() });
	     *         // cancel the default action (redirect to the edition view)
	     *         return false;
	     *      }])
	     *
	     */

	    _createClass(CreateView, [{
	        key: 'onSubmitSuccess',
	        value: function onSubmitSuccess(_onSubmitSuccess) {
	            if (!arguments.length) return this._onSubmitSuccess;
	            this._onSubmitSuccess = _onSubmitSuccess;
	            return this;
	        }

	        /**
	         * Add a function to be executed after the creation request receives a
	         * failed http response from the server.
	         *
	         * This is the ideal place to use the response to update the entry, display
	         * server-side validation error, or redirect to another view.
	         *
	         * If the function returns false, the default execution workflow is stopped.
	         * This means that the function must provide a custom workflow.
	         *
	         * The syntax depends on the framework calling the function.
	         *
	         * With ng-admin, the function can be an angular injectable, listing
	         * required dependencies in an array. Among other, the function can receive
	         * the following services:
	         *  - $event: the form submission event
	         *  - error: the response from the server
	         *  - errorMessage: the error message based on the response
	         *  - entry: the current Entry instance
	         *  - entity: the current entity
	         *  - form: the form object (for form validation and errors)
	         *  - progression: the controller for the loading indicator
	         *  - notification: the controller for top notifications
	         *
	         * The function can be asynchronous, in which case it should return
	         * a Promise.
	         *
	         * @example
	         *
	         *     post.creationView().onSubmitError(['error', 'form', 'progression', 'notification', function(error, form, progression, notification) {
	         *         // mark fields based on errors from the response
	         *         error.violations.forEach(violation => {
	         *             if (form[violation.propertyPath]) {
	         *                 form[violation.propertyPath].$valid = false;
	         *             }
	         *         });
	         *         // stop the progress bar
	         *         progression.done();
	         *         // add a notification
	         *         notification.log(`Some values are invalid, see details in the form`, { addnCls: 'humane-flatty-error' });
	         *         // cancel the default action (default error messages)
	         *         return false;
	         *     }]);
	         */
	    }, {
	        key: 'onSubmitError',
	        value: function onSubmitError(_onSubmitError) {
	            if (!arguments.length) return this._onSubmitError;
	            this._onSubmitError = _onSubmitError;
	            return this;
	        }
	    }]);

	    return CreateView;
	})(_View3['default']);

	exports['default'] = CreateView;
	module.exports = exports['default'];
	//# sourceMappingURL=CreateView.js.map

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ListView2 = __webpack_require__(6);

	var _ListView3 = _interopRequireDefault(_ListView2);

	var DashboardView = (function (_ListView) {
	    _inherits(DashboardView, _ListView);

	    function DashboardView() {
	        _classCallCheck(this, DashboardView);

	        _get(Object.getPrototypeOf(DashboardView.prototype), 'constructor', this).apply(this, arguments);
	    }

	    _createClass(DashboardView, [{
	        key: 'setEntity',
	        value: function setEntity(entity) {
	            this.entity = entity;
	            if (!this._name) {
	                this._name = entity.name();
	            }
	            return this;
	        }
	    }]);

	    return DashboardView;
	})(_ListView3['default']);

	exports['default'] = DashboardView;
	module.exports = exports['default'];
	//# sourceMappingURL=DashboardView.js.map

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _View2 = __webpack_require__(5);

	var _View3 = _interopRequireDefault(_View2);

	var DeleteView = (function (_View) {
	    _inherits(DeleteView, _View);

	    function DeleteView(name) {
	        _classCallCheck(this, DeleteView);

	        _get(Object.getPrototypeOf(DeleteView.prototype), 'constructor', this).call(this, name);
	        this._type = 'DeleteView';
	        this._enabled = true;
	    }

	    return DeleteView;
	})(_View3['default']);

	exports['default'] = DeleteView;
	module.exports = exports['default'];
	//# sourceMappingURL=DeleteView.js.map

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _View2 = __webpack_require__(5);

	var _View3 = _interopRequireDefault(_View2);

	var EditView = (function (_View) {
	    _inherits(EditView, _View);

	    function EditView(name) {
	        _classCallCheck(this, EditView);

	        _get(Object.getPrototypeOf(EditView.prototype), 'constructor', this).call(this, name);
	        this._type = 'EditView';
	        this._submitCreationSuccess = null;
	        this._submitCreationError = null;
	    }

	    /**
	     * Add a function to be executed after the update succeeds.
	     *
	     * This is the ideal place to use the response to update the entry, or
	     * redirect to another view.
	     *
	     * If the function returns false, the default execution workflow is stopped.
	     * This means that the function must provide a custom workflow.
	     *
	     * If the function throws an exception, the onSubmitError callback will
	     * execute.
	     *
	     * The syntax depends on the framework calling the function.
	     *
	     * With ng-admin, the function can be an angular injectable, listing
	     * required dependencies in an array. Among other, the function can receive
	     * the following services:
	     *  - $event: the form submission event
	     *  - entry: the current Entry instance
	     *  - entity: the current entity
	     *  - form: the form object (for form validation and errors)
	     *  - progression: the controller for the loading indicator
	     *  - notification: the controller for top notifications
	     *
	     * The function can be asynchronous, in which case it should return
	     * a Promise.
	     *
	     * @example
	     *
	     *     post.editionView().onSubmitSuccess(['progression', 'notification', '$state', 'entry', 'entity', function(progression, notification, $state, entry, entity) {
	     *         // stop the progress bar
	     *         progression.done();
	     *         // add a notification
	     *         notification.log(`Element #${entry._identifierValue} successfully edited.`, { addnCls: 'humane-flatty-success' });
	     *         // redirect to the list view
	     *         $state.go($state.get('list'), { entity: entity.name() });
	     *         // cancel the default action (redirect to the edition view)
	     *         return false;
	     *      }])
	     */

	    _createClass(EditView, [{
	        key: 'onSubmitSuccess',
	        value: function onSubmitSuccess(_onSubmitSuccess) {
	            if (!arguments.length) return this._onSubmitSuccess;
	            this._onSubmitSuccess = _onSubmitSuccess;
	            return this;
	        }

	        /**
	         * Add a function to be executed after the update request receives a failed
	         * http response from the server.
	         *
	         * This is the ideal place to use the response to update the entry, display
	         * server-side validation error, or redirect to another view.
	         *
	         * If the function returns false, the default execution workflow is stopped.
	         * This means that the function must provide a custom workflow.
	         *
	         * The syntax depends on the framework calling the function.
	         *
	         * With ng-admin, the function can be an angular injectable, listing
	         * required dependencies in an array. Among other, the function can receive
	         * the following services:
	         *  - $event: the form submission event
	         *  - error: the response from the server
	         *  - errorMessage: the error message based on the response
	         *  - entry: the current Entry instance
	         *  - entity: the current entity
	         *  - form: the form object (for form validation and errors)
	         *  - progression: the controller for the loading indicator
	         *  - notification: the controller for top notifications
	         *
	         * The function can be asynchronous, in which case it should return
	         * a Promise.
	         *
	         * @example
	         *
	         *     post.editionView().onSubmitError(['error', 'form', 'progression', 'notification', function(error, form, progression, notification) {
	         *         // mark fields based on errors from the response
	         *         error.violations.forEach(violation => {
	         *             if (form[violation.propertyPath]) {
	         *                 form[violation.propertyPath].$valid = false;
	         *             }
	         *         });
	         *         // stop the progress bar
	         *         progression.done();
	         *         // add a notification
	         *         notification.log(`Some values are invalid, see details in the form`, { addnCls: 'humane-flatty-error' });
	         *         // cancel the default action (default error messages)
	         *         return false;
	         *     }]);
	         */
	    }, {
	        key: 'onSubmitError',
	        value: function onSubmitError(_onSubmitError) {
	            if (!arguments.length) return this._onSubmitError;
	            this._onSubmitError = _onSubmitError;
	            return this;
	        }
	    }]);

	    return EditView;
	})(_View3['default']);

	exports['default'] = EditView;
	module.exports = exports['default'];
	//# sourceMappingURL=EditView.js.map

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ListView2 = __webpack_require__(6);

	var _ListView3 = _interopRequireDefault(_ListView2);

	var ExportView = (function (_ListView) {
	    _inherits(ExportView, _ListView);

	    function ExportView(name) {
	        _classCallCheck(this, ExportView);

	        _get(Object.getPrototypeOf(ExportView.prototype), 'constructor', this).call(this, name);
	        this._fields = [];
	        this._type = 'ExportView';
	    }

	    return ExportView;
	})(_ListView3['default']);

	exports['default'] = ExportView;
	module.exports = exports['default'];
	//# sourceMappingURL=ExportView.js.map

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _View2 = __webpack_require__(5);

	var _View3 = _interopRequireDefault(_View2);

	var MenuView = (function (_View) {
	    _inherits(MenuView, _View);

	    function MenuView(name) {
	        _classCallCheck(this, MenuView);

	        _get(Object.getPrototypeOf(MenuView.prototype), 'constructor', this).call(this, name);
	        this._type = 'MenuView';
	        this._icon = null;
	    }

	    _createClass(MenuView, [{
	        key: 'icon',
	        value: function icon() {
	            if (arguments.length) {
	                console.warn('entity.menuView() is deprecated. Please use the Menu class instead');
	                this._icon = arguments[0];
	                return this;
	            }

	            if (this._icon === null) {
	                return '<span class="glyphicon glyphicon-list"></span>';
	            }

	            return this._icon;
	        }
	    }, {
	        key: 'enabled',
	        get: function get() {
	            return this._enabled || this.entity.views['ListView'].enabled;
	        }
	    }]);

	    return MenuView;
	})(_View3['default']);

	exports['default'] = MenuView;
	module.exports = exports['default'];
	//# sourceMappingURL=MenuView.js.map

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _View2 = __webpack_require__(5);

	var _View3 = _interopRequireDefault(_View2);

	var ShowView = (function (_View) {
	    _inherits(ShowView, _View);

	    function ShowView(name) {
	        _classCallCheck(this, ShowView);

	        _get(Object.getPrototypeOf(ShowView.prototype), 'constructor', this).call(this, name);
	        this._type = 'ShowView';
	    }

	    return ShowView;
	})(_View3['default']);

	exports['default'] = ShowView;
	module.exports = exports['default'];
	//# sourceMappingURL=ShowView.js.map

/***/ },
/* 187 */
/***/ function(module, exports) {

	/**!
	 * AngularJS file upload directives and services. Supoorts: file upload/drop/paste, resume, cancel/abort,
	 * progress, resize, thumbnail, preview, validation and CORS
	 * FileAPI Flash shim for old browsers not supporting FormData
	 * @author  Danial  <danial.farid@gmail.com>
	 * @version 7.3.9
	 */

	(function () {
	  /** @namespace FileAPI.noContentTimeout */

	  function patchXHR(fnName, newFn) {
	    window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);
	  }

	  function redefineProp(xhr, prop, fn) {
	    try {
	      Object.defineProperty(xhr, prop, {get: fn});
	    } catch (e) {/*ignore*/
	    }
	  }

	  if (!window.FileAPI) {
	    window.FileAPI = {};
	  }

	  FileAPI.shouldLoad = (window.XMLHttpRequest && !window.FormData) || FileAPI.forceLoad;
	  if (FileAPI.shouldLoad) {
	    var initializeUploadListener = function (xhr) {
	      if (!xhr.__listeners) {
	        if (!xhr.upload) xhr.upload = {};
	        xhr.__listeners = [];
	        var origAddEventListener = xhr.upload.addEventListener;
	        xhr.upload.addEventListener = function (t, fn) {
	          xhr.__listeners[t] = fn;
	          if (origAddEventListener) origAddEventListener.apply(this, arguments);
	        };
	      }
	    };

	    patchXHR('open', function (orig) {
	      return function (m, url, b) {
	        initializeUploadListener(this);
	        this.__url = url;
	        try {
	          orig.apply(this, [m, url, b]);
	        } catch (e) {
	          if (e.message.indexOf('Access is denied') > -1) {
	            this.__origError = e;
	            orig.apply(this, [m, '_fix_for_ie_crossdomain__', b]);
	          }
	        }
	      };
	    });

	    patchXHR('getResponseHeader', function (orig) {
	      return function (h) {
	        return this.__fileApiXHR && this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(h) : (orig == null ? null : orig.apply(this, [h]));
	      };
	    });

	    patchXHR('getAllResponseHeaders', function (orig) {
	      return function () {
	        return this.__fileApiXHR && this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : (orig == null ? null : orig.apply(this));
	      };
	    });

	    patchXHR('abort', function (orig) {
	      return function () {
	        return this.__fileApiXHR && this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : (orig == null ? null : orig.apply(this));
	      };
	    });

	    patchXHR('setRequestHeader', function (orig) {
	      return function (header, value) {
	        if (header === '__setXHR_') {
	          initializeUploadListener(this);
	          var val = value(this);
	          // fix for angular < 1.2.0
	          if (val instanceof Function) {
	            val(this);
	          }
	        } else {
	          this.__requestHeaders = this.__requestHeaders || {};
	          this.__requestHeaders[header] = value;
	          orig.apply(this, arguments);
	        }
	      };
	    });

	    patchXHR('send', function (orig) {
	      return function () {
	        var xhr = this;
	        if (arguments[0] && arguments[0].__isFileAPIShim) {
	          var formData = arguments[0];
	          var config = {
	            url: xhr.__url,
	            jsonp: false, //removes the callback form param
	            cache: true, //removes the ?fileapiXXX in the url
	            complete: function (err, fileApiXHR) {
	              if (err && angular.isString(err) && err.indexOf('#2174') !== -1) {
	                // this error seems to be fine the file is being uploaded properly.
	                err = null;
	              }
	              xhr.__completed = true;
	              if (!err && xhr.__listeners.load)
	                xhr.__listeners.load({
	                  type: 'load',
	                  loaded: xhr.__loaded,
	                  total: xhr.__total,
	                  target: xhr,
	                  lengthComputable: true
	                });
	              if (!err && xhr.__listeners.loadend)
	                xhr.__listeners.loadend({
	                  type: 'loadend',
	                  loaded: xhr.__loaded,
	                  total: xhr.__total,
	                  target: xhr,
	                  lengthComputable: true
	                });
	              if (err === 'abort' && xhr.__listeners.abort)
	                xhr.__listeners.abort({
	                  type: 'abort',
	                  loaded: xhr.__loaded,
	                  total: xhr.__total,
	                  target: xhr,
	                  lengthComputable: true
	                });
	              if (fileApiXHR.status !== undefined) redefineProp(xhr, 'status', function () {
	                return (fileApiXHR.status === 0 && err && err !== 'abort') ? 500 : fileApiXHR.status;
	              });
	              if (fileApiXHR.statusText !== undefined) redefineProp(xhr, 'statusText', function () {
	                return fileApiXHR.statusText;
	              });
	              redefineProp(xhr, 'readyState', function () {
	                return 4;
	              });
	              if (fileApiXHR.response !== undefined) redefineProp(xhr, 'response', function () {
	                return fileApiXHR.response;
	              });
	              var resp = fileApiXHR.responseText || (err && fileApiXHR.status === 0 && err !== 'abort' ? err : undefined);
	              redefineProp(xhr, 'responseText', function () {
	                return resp;
	              });
	              redefineProp(xhr, 'response', function () {
	                return resp;
	              });
	              if (err) redefineProp(xhr, 'err', function () {
	                return err;
	              });
	              xhr.__fileApiXHR = fileApiXHR;
	              if (xhr.onreadystatechange) xhr.onreadystatechange();
	              if (xhr.onload) xhr.onload();
	            },
	            progress: function (e) {
	              e.target = xhr;
	              if (xhr.__listeners.progress) xhr.__listeners.progress(e);
	              xhr.__total = e.total;
	              xhr.__loaded = e.loaded;
	              if (e.total === e.loaded) {
	                // fix flash issue that doesn't call complete if there is no response text from the server
	                var _this = this;
	                setTimeout(function () {
	                  if (!xhr.__completed) {
	                    xhr.getAllResponseHeaders = function () {
	                    };
	                    _this.complete(null, {status: 204, statusText: 'No Content'});
	                  }
	                }, FileAPI.noContentTimeout || 10000);
	              }
	            },
	            headers: xhr.__requestHeaders
	          };
	          config.data = {};
	          config.files = {};
	          for (var i = 0; i < formData.data.length; i++) {
	            var item = formData.data[i];
	            if (item.val != null && item.val.name != null && item.val.size != null && item.val.type != null) {
	              config.files[item.key] = item.val;
	            } else {
	              config.data[item.key] = item.val;
	            }
	          }

	          setTimeout(function () {
	            if (!FileAPI.hasFlash) {
	              throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
	            }
	            xhr.__fileApiXHR = FileAPI.upload(config);
	          }, 1);
	        } else {
	          if (this.__origError) {
	            throw this.__origError;
	          }
	          orig.apply(xhr, arguments);
	        }
	      };
	    });
	    window.XMLHttpRequest.__isFileAPIShim = true;
	    window.FormData = FormData = function () {
	      return {
	        append: function (key, val, name) {
	          if (val.__isFileAPIBlobShim) {
	            val = val.data[0];
	          }
	          this.data.push({
	            key: key,
	            val: val,
	            name: name
	          });
	        },
	        data: [],
	        __isFileAPIShim: true
	      };
	    };

	    window.Blob = Blob = function (b) {
	      return {
	        data: b,
	        __isFileAPIBlobShim: true
	      };
	    };
	  }

	})();

	(function () {
	  /** @namespace FileAPI.forceLoad */
	  /** @namespace window.FileAPI.jsUrl */
	  /** @namespace window.FileAPI.jsPath */

	  function isInputTypeFile(elem) {
	    return elem[0].tagName.toLowerCase() === 'input' && elem.attr('type') && elem.attr('type').toLowerCase() === 'file';
	  }

	  function hasFlash() {
	    try {
	      var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
	      if (fo) return true;
	    } catch (e) {
	      if (navigator.mimeTypes['application/x-shockwave-flash'] !== undefined) return true;
	    }
	    return false;
	  }

	  function getOffset(obj) {
	    var left = 0, top = 0;

	    if (window.jQuery) {
	      return jQuery(obj).offset();
	    }

	    if (obj.offsetParent) {
	      do {
	        left += (obj.offsetLeft - obj.scrollLeft);
	        top += (obj.offsetTop - obj.scrollTop);
	        obj = obj.offsetParent;
	      } while (obj);
	    }
	    return {
	      left: left,
	      top: top
	    };
	  }

	  if (FileAPI.shouldLoad) {

	    //load FileAPI
	    if (FileAPI.forceLoad) {
	      FileAPI.html5 = false;
	    }

	    if (!FileAPI.upload) {
	      var jsUrl, basePath, script = document.createElement('script'), allScripts = document.getElementsByTagName('script'), i, index, src;
	      if (window.FileAPI.jsUrl) {
	        jsUrl = window.FileAPI.jsUrl;
	      } else if (window.FileAPI.jsPath) {
	        basePath = window.FileAPI.jsPath;
	      } else {
	        for (i = 0; i < allScripts.length; i++) {
	          src = allScripts[i].src;
	          index = src.search(/\/ng\-file\-upload[\-a-zA-z0-9\.]*\.js/);
	          if (index > -1) {
	            basePath = src.substring(0, index + 1);
	            break;
	          }
	        }
	      }

	      if (FileAPI.staticPath == null) FileAPI.staticPath = basePath;
	      script.setAttribute('src', jsUrl || basePath + 'FileAPI.min.js');
	      document.getElementsByTagName('head')[0].appendChild(script);

	      FileAPI.hasFlash = hasFlash();
	    }

	    FileAPI.ngfFixIE = function (elem, fileElem, changeFn) {
	      if (!hasFlash()) {
	        throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
	      }
	      var fixInputStyle = function () {
	        if (elem.attr('disabled')) {
	          if (fileElem) fileElem.removeClass('js-fileapi-wrapper');
	        } else {
	          if (!fileElem.attr('__ngf_flash_')) {
	            fileElem.unbind('change');
	            fileElem.unbind('click');
	            fileElem.bind('change', function (evt) {
	              fileApiChangeFn.apply(this, [evt]);
	              changeFn.apply(this, [evt]);
	            });
	            fileElem.attr('__ngf_flash_', 'true');
	          }
	          fileElem.addClass('js-fileapi-wrapper');
	          if (!isInputTypeFile(elem)) {
	            fileElem.css('position', 'absolute')
	              .css('top', getOffset(elem[0]).top + 'px').css('left', getOffset(elem[0]).left + 'px')
	              .css('width', elem[0].offsetWidth + 'px').css('height', elem[0].offsetHeight + 'px')
	              .css('filter', 'alpha(opacity=0)').css('display', elem.css('display'))
	              .css('overflow', 'hidden').css('z-index', '900000')
	              .css('visibility', 'visible');
	          }
	        }
	      };

	      elem.bind('mouseenter', fixInputStyle);

	      var fileApiChangeFn = function (evt) {
	        var files = FileAPI.getFiles(evt);
	        //just a double check for #233
	        for (var i = 0; i < files.length; i++) {
	          if (files[i].size === undefined) files[i].size = 0;
	          if (files[i].name === undefined) files[i].name = 'file';
	          if (files[i].type === undefined) files[i].type = 'undefined';
	        }
	        if (!evt.target) {
	          evt.target = {};
	        }
	        evt.target.files = files;
	        // if evt.target.files is not writable use helper field
	        if (evt.target.files !== files) {
	          evt.__files_ = files;
	        }
	        (evt.__files_ || evt.target.files).item = function (i) {
	          return (evt.__files_ || evt.target.files)[i] || null;
	        };
	      };
	    };

	    FileAPI.disableFileInput = function (elem, disable) {
	      if (disable) {
	        elem.removeClass('js-fileapi-wrapper');
	      } else {
	        elem.addClass('js-fileapi-wrapper');
	      }
	    };
	  }
	})();

	if (!window.FileReader) {
	  window.FileReader = function () {
	    var _this = this, loadStarted = false;
	    this.listeners = {};
	    this.addEventListener = function (type, fn) {
	      _this.listeners[type] = _this.listeners[type] || [];
	      _this.listeners[type].push(fn);
	    };
	    this.removeEventListener = function (type, fn) {
	      if (_this.listeners[type]) _this.listeners[type].splice(_this.listeners[type].indexOf(fn), 1);
	    };
	    this.dispatchEvent = function (evt) {
	      var list = _this.listeners[evt.type];
	      if (list) {
	        for (var i = 0; i < list.length; i++) {
	          list[i].call(_this, evt);
	        }
	      }
	    };
	    this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null;

	    var constructEvent = function (type, evt) {
	      var e = {type: type, target: _this, loaded: evt.loaded, total: evt.total, error: evt.error};
	      if (evt.result != null) e.target.result = evt.result;
	      return e;
	    };
	    var listener = function (evt) {
	      if (!loadStarted) {
	        loadStarted = true;
	        if (_this.onloadstart) _this.onloadstart(constructEvent('loadstart', evt));
	      }
	      var e;
	      if (evt.type === 'load') {
	        if (_this.onloadend) _this.onloadend(constructEvent('loadend', evt));
	        e = constructEvent('load', evt);
	        if (_this.onload) _this.onload(e);
	        _this.dispatchEvent(e);
	      } else if (evt.type === 'progress') {
	        e = constructEvent('progress', evt);
	        if (_this.onprogress) _this.onprogress(e);
	        _this.dispatchEvent(e);
	      } else {
	        e = constructEvent('error', evt);
	        if (_this.onerror) _this.onerror(e);
	        _this.dispatchEvent(e);
	      }
	    };
	    this.readAsArrayBuffer = function (file) {
	      FileAPI.readAsBinaryString(file, listener);
	    };
	    this.readAsBinaryString = function (file) {
	      FileAPI.readAsBinaryString(file, listener);
	    };
	    this.readAsDataURL = function (file) {
	      FileAPI.readAsDataURL(file, listener);
	    };
	    this.readAsText = function (file) {
	      FileAPI.readAsText(file, listener);
	    };
	  };
	}

	/**!
	 * AngularJS file upload directives and services. Supoorts: file upload/drop/paste, resume, cancel/abort,
	 * progress, resize, thumbnail, preview, validation and CORS
	 * @author  Danial  <danial.farid@gmail.com>
	 * @version 7.3.9
	 */

	if (window.XMLHttpRequest && !(window.FileAPI && FileAPI.shouldLoad)) {
	  window.XMLHttpRequest.prototype.setRequestHeader = (function (orig) {
	    return function (header, value) {
	      if (header === '__setXHR_') {
	        var val = value(this);
	        // fix for angular < 1.2.0
	        if (val instanceof Function) {
	          val(this);
	        }
	      } else {
	        orig.apply(this, arguments);
	      }
	    };
	  })(window.XMLHttpRequest.prototype.setRequestHeader);
	}

	var ngFileUpload = angular.module('ngFileUpload', []);

	ngFileUpload.version = '7.3.9';

	ngFileUpload.service('UploadBase', ['$http', '$q', '$timeout', function ($http, $q, $timeout) {
	  var upload = this;

	  this.isResumeSupported = function () {
	    return window.Blob && new Blob().slice;
	  };

	  var resumeSupported = this.isResumeSupported();

	  function sendHttp(config) {
	    config.method = config.method || 'POST';
	    config.headers = config.headers || {};

	    var deferred = config._deferred = config._deferred || $q.defer();
	    var promise = deferred.promise;

	    function notifyProgress(e) {
	      if (deferred.notify) {
	        deferred.notify(e);
	      }
	      if (promise.progressFunc) {
	        $timeout(function () {
	          promise.progressFunc(e);
	        });
	      }
	    }

	    function getNotifyEvent(n) {
	      if (config._start != null && resumeSupported) {
	        return {
	          loaded: n.loaded + config._start, total: config._file.size, type: n.type, config: config,
	          lengthComputable: true, target: n.target
	        };
	      } else {
	        return n;
	      }
	    }

	    config.headers.__setXHR_ = function () {
	      return function (xhr) {
	        if (!xhr) return;
	        config.__XHR = xhr;
	        if (config.xhrFn) config.xhrFn(xhr);
	        xhr.upload.addEventListener('progress', function (e) {
	          e.config = config;
	          notifyProgress(getNotifyEvent(e));
	        }, false);
	        //fix for firefox not firing upload progress end, also IE8-9
	        xhr.upload.addEventListener('load', function (e) {
	          if (e.lengthComputable) {
	            e.config = config;
	            notifyProgress(getNotifyEvent(e));
	          }
	        }, false);
	      };
	    };

	    function uploadWithAngular() {
	      $http(config).then(function (r) {
	        if (resumeSupported && config._chunkSize && !config._finished) {
	          notifyProgress({loaded: config._end, total: config._file.size, config: config, type: 'progress'});
	          upload.upload(config);
	        } else {
	          if (config._finished) delete config._finished;
	          deferred.resolve(r);
	        }
	      }, function (e) {
	        deferred.reject(e);
	      }, function (n) {
	        deferred.notify(n);
	      });
	    }

	    if (!resumeSupported) {
	      uploadWithAngular();
	    } else if (config._chunkSize && config._end && !config._finished) {
	      config._start = config._end;
	      config._end += config._chunkSize;
	      uploadWithAngular();
	    } else if (config.resumeSizeUrl) {
	      $http.get(config.resumeSizeUrl).then(function (resp) {
	        if (config.resumeSizeResponseReader) {
	          config._start = config.resumeSizeResponseReader(resp.data);
	        } else {
	          config._start = parseInt((resp.data.size == null ? resp.data : resp.data.size).toString());
	        }
	        if (config._chunkSize) {
	          config._end = config._start + config._chunkSize;
	        }
	        uploadWithAngular();
	      }, function (e) {
	        throw e;
	      });
	    } else if (config.resumeSize) {
	      config.resumeSize().then(function (size) {
	        config._start = size;
	        uploadWithAngular();
	      }, function (e) {
	        throw e;
	      });
	    } else {
	      uploadWithAngular();
	    }


	    promise.success = function (fn) {
	      promise.then(function (response) {
	        fn(response.data, response.status, response.headers, config);
	      });
	      return promise;
	    };

	    promise.error = function (fn) {
	      promise.then(null, function (response) {
	        fn(response.data, response.status, response.headers, config);
	      });
	      return promise;
	    };

	    promise.progress = function (fn) {
	      promise.progressFunc = fn;
	      promise.then(null, null, function (n) {
	        fn(n);
	      });
	      return promise;
	    };
	    promise.abort = promise.pause = function () {
	      if (config.__XHR) {
	        $timeout(function () {
	          config.__XHR.abort();
	        });
	      }
	      return promise;
	    };
	    promise.xhr = function (fn) {
	      config.xhrFn = (function (origXhrFn) {
	        return function () {
	          if (origXhrFn) origXhrFn.apply(promise, arguments);
	          fn.apply(promise, arguments);
	        };
	      })(config.xhrFn);
	      return promise;
	    };

	    return promise;
	  }

	  this.upload = function (config) {
	    function addFieldToFormData(formData, val, key) {
	      if (val !== undefined) {
	        if (angular.isDate(val)) {
	          val = val.toISOString();
	        }
	        if (angular.isString(val)) {
	          formData.append(key, val);
	        } else if (config.sendFieldsAs === 'form') {
	          if (angular.isObject(val)) {
	            for (var k in val) {
	              if (val.hasOwnProperty(k)) {
	                addFieldToFormData(formData, val[k], key + '[' + k + ']');
	              }
	            }
	          } else {
	            formData.append(key, val);
	          }
	        } else {
	          val = angular.isString(val) ? val : angular.toJson(val);
	          if (config.sendFieldsAs === 'json-blob') {
	            formData.append(key, new Blob([val], {type: 'application/json'}));
	          } else {
	            formData.append(key, val);
	          }
	        }
	      }
	    }

	    function isFile(file) {
	      return file instanceof Blob || (file.flashId && file.name && file.size);
	    }

	    function addFileToFormData(formData, file, key) {
	      if (isFile(file)) {
	        config._file = config._file || file;
	        if (config._start != null && resumeSupported) {
	          if (config._end && config._end >= file.size) {
	            config._finished = true;
	            config._end = file.size;
	          }
	          var slice = file.slice(config._start, config._end || file.size);
	          slice.name = file.name;
	          file = slice;
	          if (config._chunkSize) {
	            formData.append('chunkSize', config._end - config._start);
	            formData.append('chunkNumber', Math.floor(config._start / config._chunkSize));
	            formData.append('totalSize', config._file.size);
	          }
	        }
	        formData.append(key, file, file.fileName || file.name);
	      } else if (angular.isObject(file)) {
	        for (var k in file) {
	          if (file.hasOwnProperty(k)) {
	            var split = k.split(',');
	            if (split[1]) {
	              file[k].fileName = split[1].replace(/^\s+|\s+$/g, '');
	            }
	            addFileToFormData(formData, file[k], split[0]);
	          }
	        }
	      } else {
	        throw 'Expected file object in Upload.upload file option: ' + file.toString();
	      }
	    }

	    config._chunkSize = upload.translateScalars(config.resumeChunkSize);
	    config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

	    config.headers = config.headers || {};
	    config.headers['Content-Type'] = undefined;
	    config.transformRequest = config.transformRequest ?
	      (angular.isArray(config.transformRequest) ?
	        config.transformRequest : [config.transformRequest]) : [];
	    config.transformRequest.push(function (data) {
	      var formData = new FormData(), allFields = {}, key;
	      for (key in config.fields) {
	        if (config.fields.hasOwnProperty(key)) {
	          allFields[key] = config.fields[key];
	        }
	      }
	      if (data) allFields.data = data;
	      for (key in allFields) {
	        if (allFields.hasOwnProperty(key)) {
	          var val = allFields[key];
	          if (config.formDataAppender) {
	            config.formDataAppender(formData, key, val);
	          } else {
	            addFieldToFormData(formData, val, key);
	          }
	        }
	      }

	      if (config.file != null) {
	        if (angular.isArray(config.file)) {
	          for (var i = 0; i < config.file.length; i++) {
	            addFileToFormData(formData, config.file[i], 'file');
	          }
	        } else {
	          addFileToFormData(formData, config.file, 'file');
	        }
	      }
	      return formData;
	    });

	    return sendHttp(config);
	  };

	  this.http = function (config) {
	    config.transformRequest = config.transformRequest || function (data) {
	        if ((window.ArrayBuffer && data instanceof window.ArrayBuffer) || data instanceof Blob) {
	          return data;
	        }
	        return $http.defaults.transformRequest[0].apply(this, arguments);
	      };
	    config._chunkSize = upload.translateScalars(config.resumeChunkSize);
	    config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

	    return sendHttp(config);
	  };

	  this.translateScalars = function (str) {
	    if (angular.isString(str)) {
	      if (str.search(/kb/i) === str.length - 2) {
	        return parseFloat(str.substring(0, str.length - 2) * 1000);
	      } else if (str.search(/mb/i) === str.length - 2) {
	        return parseFloat(str.substring(0, str.length - 2) * 1000000);
	      } else if (str.search(/gb/i) === str.length - 2) {
	        return parseFloat(str.substring(0, str.length - 2) * 1000000000);
	      } else if (str.search(/b/i) === str.length - 1) {
	        return parseFloat(str.substring(0, str.length - 1));
	      } else if (str.search(/s/i) === str.length - 1) {
	        return parseFloat(str.substring(0, str.length - 1));
	      } else if (str.search(/m/i) === str.length - 1) {
	        return parseFloat(str.substring(0, str.length - 1) * 60);
	      } else if (str.search(/h/i) === str.length - 1) {
	        return parseFloat(str.substring(0, str.length - 1) * 3600);
	      }
	    }
	    return str;
	  };

	  this.setDefaults = function (defaults) {
	    this.defaults = defaults || {};
	  };

	  this.defaults = {};
	  this.version = ngFileUpload.version;
	}

	]);

	ngFileUpload.service('Upload', ['$parse', '$timeout', '$compile', 'UploadResize', function ($parse, $timeout, $compile, UploadResize) {
	  var upload = UploadResize;
	  upload.getAttrWithDefaults = function (attr, name) {
	    return attr[name] != null ? attr[name] :
	      (upload.defaults[name] == null ?
	        upload.defaults[name] : upload.defaults[name].toString());
	  };

	  upload.attrGetter = function (name, attr, scope, params) {
	    if (scope) {
	      try {
	        if (params) {
	          return $parse(this.getAttrWithDefaults(attr, name))(scope, params);
	        } else {
	          return $parse(this.getAttrWithDefaults(attr, name))(scope);
	        }
	      } catch (e) {
	        // hangle string value without single qoute
	        if (name.search(/min|max|pattern/i)) {
	          return this.getAttrWithDefaults(attr, name);
	        } else {
	          throw e;
	        }
	      }
	    } else {
	      return this.getAttrWithDefaults(attr, name);
	    }
	  };

	  upload.updateModel = function (ngModel, attr, scope, fileChange, files, evt, noDelay) {
	    var newFiles = files, dupFiles = [];

	    function update() {
	      var file = files && files.length ? files[0] : null;
	      if (ngModel) {
	        var singleModel = !upload.attrGetter('ngfMultiple', attr, scope) && !upload.attrGetter('multiple', attr) && !keep;
	        $parse(upload.attrGetter('ngModel', attr)).assign(scope, singleModel ? file : files);
	      }
	      var ngfModel = upload.attrGetter('ngfModel', attr);
	      if (ngfModel) {
	        $parse(ngfModel).assign(scope, files);
	      }

	      if (fileChange) {
	        $parse(fileChange)(scope, {
	          $files: files,
	          $file: file,
	          $newFiles: newFiles,
	          $duplicateFiles: dupFiles,
	          $event: evt
	        });
	      }
	      // scope apply changes
	      $timeout(function () {
	      });
	    }

	    var prevFiles = ((ngModel && ngModel.$modelValue) || attr.$$ngfPrevFiles || []).slice(0);

	    var keep = upload.attrGetter('ngfKeep', attr, scope);
	    if (keep === true) {
	      if (!files || !files.length) return;

	      var hasNew = false;

	      if (upload.attrGetter('ngfKeepDistinct', attr, scope) === true) {
	        var len = prevFiles.length;
	        for (var i = 0; i < files.length; i++) {
	          for (var j = 0; j < len; j++) {
	            if (files[i].name === prevFiles[j].name) {
	              dupFiles.push(files[i]);
	              break;
	            }
	          }
	          if (j === len) {
	            prevFiles.push(files[i]);
	            hasNew = true;
	          }
	        }
	        if (!hasNew) return;
	        files = prevFiles;
	      } else {
	        files = prevFiles.concat(files);
	      }
	    }

	    attr.$$ngfPrevFiles = files;

	    function resize(files, callback) {
	      var param = upload.attrGetter('ngfResize', attr, scope);
	      if (!param || !upload.isResizeSupported()) return callback();
	      var count = files.length;
	      var checkCallback = function () {
	        count--;
	        if (count === 0) callback();
	      };
	      var success = function (index) {
	        return function (resizedFile) {
	          files.splice(index, 1, resizedFile);
	          checkCallback();
	        };
	      };
	      var error = function (f) {
	        return function (e) {
	          checkCallback();
	          f.$error = 'resize';
	          f.$errorParam = (e ? (e.message ? e.message : e) + ': ' : '') + (f && f.name);
	        };
	      };
	      for (var i = 0; i < files.length; i++) {
	        var f = files[i];
	        if (!f.$error && f.type.indexOf('image') === 0) {
	          upload.resize(f, param.width, param.height, param.quality).then(success(i), error(f));
	        } else {
	          checkCallback();
	        }
	      }
	    }

	    if (noDelay) {
	      update();
	    } else if (upload.validate(files, ngModel, attr, scope, upload.attrGetter('ngfValidateLater', attr), function () {
	        resize(files, function () {
	          $timeout(function () {
	            update();
	          });
	        });
	      }));

	    // cleaning object url memories
	    var l = prevFiles.length;
	    while (l--) {
	      var prevFile = prevFiles[l];
	      if (window.URL && prevFile.blobUrl) {
	        URL.revokeObjectURL(prevFile.blobUrl);
	        delete prevFile.blobUrl;
	      }
	    }
	  };

	  return upload;
	}]);

	ngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile', 'Upload', function ($parse, $timeout, $compile, Upload) {
	  var generatedElems = [];

	  function isDelayedClickSupported(ua) {
	    // fix for android native browser < 4.4 and safari windows
	    var m = ua.match(/Android[^\d]*(\d+)\.(\d+)/);
	    if (m && m.length > 2) {
	      var v = Upload.defaults.androidFixMinorVersion || 4;
	      return parseInt(m[1]) < 4 || (parseInt(m[1]) === v && parseInt(m[2]) < v);
	    }

	    // safari on windows
	    return ua.indexOf('Chrome') === -1 && /.*Windows.*Safari.*/.test(ua);
	  }

	  function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {
	    /** @namespace attr.ngfSelect */
	    /** @namespace attr.ngfChange */
	    /** @namespace attr.ngModel */
	    /** @namespace attr.ngfModel */
	    /** @namespace attr.ngfMultiple */
	    /** @namespace attr.ngfCapture */
	    /** @namespace attr.ngfValidate */
	    /** @namespace attr.ngfKeep */
	    /** @namespace attr.ngfKeepDistinct */
	    var attrGetter = function (name, scope) {
	      return upload.attrGetter(name, attr, scope);
	    };

	    function isInputTypeFile() {
	      return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';
	    }

	    function fileChangeAttr() {
	      return attrGetter('ngfChange') || attrGetter('ngfSelect');
	    }

	    function changeFn(evt) {
	      var fileList = evt.__files_ || (evt.target && evt.target.files), files = [];
	      for (var i = 0; i < fileList.length; i++) {
	        files.push(fileList[i]);
	      }
	      upload.updateModel(ngModel, attr, scope, fileChangeAttr(), files.length ? files : null, evt);
	    }

	    var unwatches = [];
	    unwatches.push(scope.$watch(attrGetter('ngfMultiple'), function () {
	      fileElem.attr('multiple', attrGetter('ngfMultiple', scope));
	    }));
	    unwatches.push(scope.$watch(attrGetter('ngfCapture'), function () {
	      fileElem.attr('capture', attrGetter('ngfCapture', scope));
	    }));
	    attr.$observe('accept', function () {
	      fileElem.attr('accept', attrGetter('accept'));
	    });
	    unwatches.push(function () {
	      if (attr.$$observers) delete attr.$$observers.accept;
	    });
	    function bindAttrToFileInput(fileElem) {
	      if (elem !== fileElem) {
	        for (var i = 0; i < elem[0].attributes.length; i++) {
	          var attribute = elem[0].attributes[i];
	          if (attribute.name !== 'type' && attribute.name !== 'class' &&
	            attribute.name !== 'id' && attribute.name !== 'style') {
	            if (attribute.value == null || attribute.value === '') {
	              if (attribute.name === 'required') attribute.value = 'required';
	              if (attribute.name === 'multiple') attribute.value = 'multiple';
	            }
	            fileElem.attr(attribute.name, attribute.value);
	          }
	        }
	      }
	    }

	    function createFileInput() {
	      if (isInputTypeFile()) {
	        return elem;
	      }

	      var fileElem = angular.element('<input type="file">');
	      bindAttrToFileInput(fileElem);

	      fileElem.css('visibility', 'hidden').css('position', 'absolute').css('overflow', 'hidden')
	        .css('width', '0px').css('height', '0px').css('border', 'none')
	        .css('margin', '0px').css('padding', '0px').attr('tabindex', '-1');
	      generatedElems.push({el: elem, ref: fileElem});
	      document.body.appendChild(fileElem[0]);

	      return fileElem;
	    }

	    var initialTouchStartY = 0;

	    function clickHandler(evt) {
	      if (elem.attr('disabled') || attrGetter('ngfSelectDisabled', scope)) return false;

	      var r = handleTouch(evt);
	      if (r != null) return r;

	      resetModel(evt);

	      if (isDelayedClickSupported(navigator.userAgent)) {
	        setTimeout(function () {
	          fileElem[0].click();
	        }, 0);
	      } else {
	        fileElem[0].click();
	      }

	      return false;
	    }

	    function handleTouch(evt) {
	      var touches = evt.changedTouches || (evt.originalEvent && evt.originalEvent.changedTouches);
	      if (evt.type === 'touchstart') {
	        initialTouchStartY = touches ? touches[0].clientY : 0;
	        return true; // don't block event default
	      } else {
	        evt.stopPropagation();
	        evt.preventDefault();

	        // prevent scroll from triggering event
	        if (evt.type === 'touchend') {
	          var currentLocation = touches ? touches[0].clientY : 0;
	          if (Math.abs(currentLocation - initialTouchStartY) > 20) return false;
	        }
	      }
	    }

	    var fileElem = elem;

	    function resetModel(evt) {
	      if (fileElem.val()) {
	        fileElem.val(null);
	        upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, true);
	      }
	    }

	    if (!isInputTypeFile()) {
	      fileElem = createFileInput();
	    }
	    fileElem.bind('change', changeFn);

	    if (!isInputTypeFile()) {
	      elem.bind('click touchstart touchend', clickHandler);
	    } else {
	      elem.bind('click', resetModel);
	    }

	    upload.registerValidators(ngModel, fileElem, attr, scope);

	    function ie10SameFileSelectFix(evt) {
	      if (fileElem && !fileElem.attr('__ngf_ie10_Fix_')) {
	        if (!fileElem[0].parentNode) {
	          fileElem = null;
	          return;
	        }
	        evt.preventDefault();
	        evt.stopPropagation();
	        fileElem.unbind('click');
	        var clone = fileElem.clone();
	        fileElem.replaceWith(clone);
	        fileElem = clone;
	        fileElem.attr('__ngf_ie10_Fix_', 'true');
	        fileElem.bind('change', changeFn);
	        fileElem.bind('click', ie10SameFileSelectFix);
	        fileElem[0].click();
	        return false;
	      } else {
	        fileElem.removeAttr('__ngf_ie10_Fix_');
	      }
	    }

	    if (navigator.appVersion.indexOf('MSIE 10') !== -1) {
	      fileElem.bind('click', ie10SameFileSelectFix);
	    }

	    scope.$on('$destroy', function () {
	      if (!isInputTypeFile()) fileElem.remove();
	      angular.forEach(unwatches, function (unwatch) {
	        unwatch();
	      });
	    });

	    $timeout(function () {
	      for (var i = 0; i < generatedElems.length; i++) {
	        var g = generatedElems[i];
	        if (!document.body.contains(g.el[0])) {
	          generatedElems.splice(i, 1);
	          g.ref.remove();
	        }
	      }
	    });

	    if (window.FileAPI && window.FileAPI.ngfFixIE) {
	      window.FileAPI.ngfFixIE(elem, fileElem, changeFn);
	    }
	  }

	  return {
	    restrict: 'AEC',
	    require: '?ngModel',
	    link: function (scope, elem, attr, ngModel) {
	      linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);
	    }
	  };
	}]);

	(function () {

	  ngFileUpload.service('UploadDataUrl', ['UploadBase', '$timeout', '$q', function (UploadBase, $timeout, $q) {
	    var upload = UploadBase;
	    upload.dataUrl = function (file, disallowObjectUrl) {
	      if ((disallowObjectUrl && file.dataUrl != null) || (!disallowObjectUrl && file.blobUrl != null)) {
	        var d = $q.defer();
	        $timeout(function () {
	          d.resolve(disallowObjectUrl ? file.dataUrl : file.blobUrl);
	        });
	        return d.promise;
	      }
	      var p = disallowObjectUrl ? file.$ngfDataUrlPromise : file.$ngfBlobUrlPromise;
	      if (p) return p;

	      var deferred = $q.defer();
	      $timeout(function () {
	        if (window.FileReader && file &&
	          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) &&
	          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {
	          //prefer URL.createObjectURL for handling refrences to files of all sizes
	          //since it doesn´t build a large string in memory
	          var URL = window.URL || window.webkitURL;
	          if (URL && URL.createObjectURL && !disallowObjectUrl) {
	            var url;
	            try {
	              url = URL.createObjectURL(file);
	            } catch (e) {
	              $timeout(function () {
	                file.blobUrl = '';
	                deferred.reject();
	              });
	              return;
	            }
	            $timeout(function () {
	              file.blobUrl = url;
	              if (url) deferred.resolve(url);
	            });
	          } else {
	            var fileReader = new FileReader();
	            fileReader.onload = function (e) {
	              $timeout(function () {
	                file.dataUrl = e.target.result;
	                deferred.resolve(e.target.result);
	              });
	            };
	            fileReader.onerror = function () {
	              $timeout(function () {
	                file.dataUrl = '';
	                deferred.reject();
	              });
	            };
	            fileReader.readAsDataURL(file);
	          }
	        } else {
	          $timeout(function () {
	            file[disallowObjectUrl ? 'dataUrl' : 'blobUrl'] = '';
	            deferred.reject();
	          });
	        }
	      });

	      if (disallowObjectUrl) {
	        p = file.$ngfDataUrlPromise = deferred.promise;
	      } else {
	        p = file.$ngfBlobUrlPromise = deferred.promise;
	      }
	      p['finally'](function () {
	        delete file[disallowObjectUrl ? '$ngfDataUrlPromise' : '$ngfBlobUrlPromise'];
	      });
	      return p;
	    };
	    return upload;
	  }]);

	  function getTagType(el) {
	    if (el.tagName.toLowerCase() === 'img') return 'image';
	    if (el.tagName.toLowerCase() === 'audio') return 'audio';
	    if (el.tagName.toLowerCase() === 'video') return 'video';
	    return /./;
	  }

	  var style = angular.element('<style>.ngf-hide{display:none !important}</style>');
	  document.getElementsByTagName('head')[0].appendChild(style[0]);

	  function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {
	    function constructDataUrl(file) {
	      var disallowObjectUrl = Upload.attrGetter('ngfNoObjectUrl', attr, scope);
	      Upload.dataUrl(file, disallowObjectUrl)['finally'](function () {
	        $timeout(function () {
	          var src = (disallowObjectUrl ? file.dataUrl : file.blobUrl) || file.dataUrl;
	          if (isBackground) {
	            elem.css('background-image', 'url(\'' + (src || '') + '\')');
	          } else {
	            elem.attr('src', src);
	          }
	          if (src) {
	            elem.removeClass('ngf-hide');
	          } else {
	            elem.addClass('ngf-hide');
	          }
	        });
	      });
	    }

	    $timeout(function () {
	      var unwatch = scope.$watch(attr[directiveName], function (file) {
	        var size = resizeParams;
	        if (directiveName === 'ngfThumbnail') {
	          if (!size) {
	            size = {width: elem[0].clientWidth, height: elem[0].clientHeight};
	          }
	          if (size.width === 0 && window.getComputedStyle) {
	            var style = getComputedStyle(elem[0]);
	            size = {width: parseInt(style.width.slice(0, -2)),
	              height: parseInt(style.height.slice(0, -2))};
	          }
	        }

	        if (angular.isString(file)) {
	          elem.removeClass('ngf-hide');
	          if (isBackground) {
	            return elem.css('background-image', 'url(\'' + file + '\')');
	          } else {
	            return elem.attr('src', file);
	          }
	        }
	        if (file && file.type && file.type.search(getTagType(elem[0])) === 0 &&
	          (!isBackground || file.type.indexOf('image') === 0)) {
	          if (size && Upload.isResizeSupported()) {
	            Upload.resize(file, size.width, size.height, size.quality).then(
	              function (f) {
	                constructDataUrl(f);
	              }, function (e) {
	                throw e;
	              }
	            );
	          } else {
	            constructDataUrl(file);
	          }
	        } else {
	          elem.addClass('ngf-hide');
	        }
	      });

	      scope.$on('$destroy', function () {
	        unwatch();
	      });
	    });
	  }


	  /** @namespace attr.ngfSrc */
	  /** @namespace attr.ngfNoObjectUrl */
	  ngFileUpload.directive('ngfSrc', ['Upload', '$timeout', function (Upload, $timeout) {
	    return {
	      restrict: 'AE',
	      link: function (scope, elem, attr) {
	        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfSrc',
	          Upload.attrGetter('ngfResize', attr, scope), false);
	      }
	    };
	  }]);

	  /** @namespace attr.ngfBackground */
	  /** @namespace attr.ngfNoObjectUrl */
	  ngFileUpload.directive('ngfBackground', ['Upload', '$timeout', function (Upload, $timeout) {
	    return {
	      restrict: 'AE',
	      link: function (scope, elem, attr) {
	        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfBackground',
	          Upload.attrGetter('ngfResize', attr, scope), true);
	      }
	    };
	  }]);

	  /** @namespace attr.ngfThumbnail */
	  /** @namespace attr.ngfAsBackground */
	  /** @namespace attr.ngfSize */
	  /** @namespace attr.ngfNoObjectUrl */
	  ngFileUpload.directive('ngfThumbnail', ['Upload', '$timeout', function (Upload, $timeout) {
	    return {
	      restrict: 'AE',
	      link: function (scope, elem, attr) {
	        var size = Upload.attrGetter('ngfSize', attr, scope);
	        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfThumbnail', size,
	          Upload.attrGetter('ngfAsBackground', attr, scope));
	      }
	    };
	  }]);

	  //ngFileUpload.config(['$compileProvider', function ($compileProvider) {
	  //  if ($compileProvider.imgSrcSanitizationWhitelist) $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/);
	  //  if ($compileProvider.aHrefSanitizationWhitelist) $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/);
	  //}]);
	  //
	  //ngFileUpload.filter('ngfDataUrl', ['UploadDataUrl', '$sce', function (UploadDataUrl, $sce) {
	  //  return function (file, disallowObjectUrl) {
	  //    if (angular.isString(file)) {
	  //      return $sce.trustAsResourceUrl(file);
	  //    }
	  //    if (file && !file.dataUrl) {
	  //      if (file.dataUrl === undefined && angular.isObject(file)) {
	  //        file.dataUrl = null;
	  //        UploadDataUrl.dataUrl(file, disallowObjectUrl);
	  //      }
	  //      return '';
	  //    }
	  //    return (file && file.dataUrl ? $sce.trustAsResourceUrl(file.dataUrl) : file) || '';
	  //  };
	  //}]);

	})();

	ngFileUpload.service('UploadValidate', ['UploadDataUrl', '$q', '$timeout', function (UploadDataUrl, $q, $timeout) {
	  var upload = UploadDataUrl;

	  function globStringToRegex(str) {
	    var regexp = '', excludes = [];
	    if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {
	      regexp = str.substring(1, str.length - 1);
	    } else {
	      var split = str.split(',');
	      if (split.length > 1) {
	        for (var i = 0; i < split.length; i++) {
	          var r = globStringToRegex(split[i]);
	          if (r.regexp) {
	            regexp += '(' + r.regexp + ')';
	            if (i < split.length - 1) {
	              regexp += '|';
	            }
	          } else {
	            excludes = excludes.concat(r.excludes);
	          }
	        }
	      } else {
	        if (str.indexOf('!') === 0) {
	          excludes.push('^((?!' + globStringToRegex(str.substring(1)).regexp + ').)*$');
	        } else {
	          if (str.indexOf('.') === 0) {
	            str = '*' + str;
	          }
	          regexp = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]', 'g'), '\\$&') + '$';
	          regexp = regexp.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
	        }
	      }
	    }
	    return {regexp: regexp, excludes: excludes};
	  }

	  upload.registerValidators = function (ngModel, elem, attr, scope) {
	    if (!ngModel) return;

	    ngModel.$ngfValidations = [];
	    function setValidities(ngModel) {
	      angular.forEach(ngModel.$ngfValidations, function (validation) {
	        ngModel.$setValidity(validation.name, validation.valid);
	      });
	    }

	    ngModel.$formatters.push(function (val) {
	      if (upload.attrGetter('ngfValidateLater', attr, scope) || !ngModel.$$ngfValidated) {
	        upload.validate(val, ngModel, attr, scope, false, function () {
	          setValidities(ngModel);
	          ngModel.$$ngfValidated = false;
	        });
	        if (val && val.length === 0) {
	          val = null;
	        }
	        if (elem && (val == null || val.length === 0)) {
	          if (elem.val()) {
	            elem.val(null);
	          }
	        }
	      } else {
	        setValidities(ngModel);
	        ngModel.$$ngfValidated = false;
	      }
	      return val;
	    });
	  };

	  upload.validatePattern = function (file, val) {
	    if (!val) {
	      return true;
	    }
	    var pattern = globStringToRegex(val), valid = true;
	    if (pattern.regexp && pattern.regexp.length) {
	      var regexp = new RegExp(pattern.regexp, 'i');
	      valid = (file.type != null && regexp.test(file.type)) ||
	        (file.name != null && regexp.test(file.name));
	    }
	    var len = pattern.excludes.length;
	    while (len--) {
	      var exclude = new RegExp(pattern.excludes[len], 'i');
	      valid = valid && (file.type == null || exclude.test(file.type)) &&
	        (file.name == null || exclude.test(file.name));
	    }
	    return valid;
	  };

	  upload.validate = function (files, ngModel, attr, scope, later, callback) {
	    ngModel = ngModel || {};
	    ngModel.$ngfValidations = ngModel.$ngfValidations || [];

	    angular.forEach(ngModel.$ngfValidations, function (v) {
	      v.valid = true;
	    });

	    var attrGetter = function (name, params) {
	      return upload.attrGetter(name, attr, scope, params);
	    };

	    if (later) {
	      callback.call(ngModel);
	      return;
	    }
	    ngModel.$$ngfValidated = true;

	    if (files == null || files.length === 0) {
	      callback.call(ngModel);
	      return;
	    }

	    files = files.length === undefined ? [files] : files.slice(0);

	    function validateSync(name, validatorVal, fn) {
	      if (files) {
	        var dName = 'ngf' + name[0].toUpperCase() + name.substr(1);
	        var i = files.length, valid = null;

	        while (i--) {
	          var file = files[i];
	          var val = attrGetter(dName, {'$file': file});
	          if (val == null) {
	            val = validatorVal(attrGetter('ngfValidate') || {});
	            valid = valid == null ? true : valid;
	          }
	          if (val != null) {
	            if (!fn(file, val)) {
	              file.$error = name;
	              file.$errorParam = val;
	              files.splice(i, 1);
	              valid = false;
	            }
	          }
	        }
	        if (valid !== null) {
	          ngModel.$ngfValidations.push({name: name, valid: valid});
	        }
	      }
	    }

	    validateSync('pattern', function (cons) {
	      return cons.pattern;
	    }, upload.validatePattern);
	    validateSync('minSize', function (cons) {
	      return cons.size && cons.size.min;
	    }, function (file, val) {
	      return file.size >= upload.translateScalars(val);
	    });
	    validateSync('maxSize', function (cons) {
	      return cons.size && cons.size.max;
	    }, function (file, val) {
	      return file.size <= upload.translateScalars(val);
	    });

	    validateSync('validateFn', function () {
	      return null;
	    }, function (file, r) {
	      return r === true || r === null || r === '';
	    });

	    if (!files.length) {
	      callback.call(ngModel, ngModel.$ngfValidations);
	      return;
	    }

	    var pendings = 0;

	    function validateAsync(name, validatorVal, type, asyncFn, fn) {
	      if (files) {
	        var thisPendings = 0, hasError = false, dName = 'ngf' + name[0].toUpperCase() + name.substr(1);
	        files = files.length === undefined ? [files] : files;
	        angular.forEach(files, function (file) {
	          if (file.type.search(type) !== 0) {
	            return true;
	          }
	          var val = attrGetter(dName, {'$file': file}) || validatorVal(attrGetter('ngfValidate', {'$file': file}) || {});
	          if (val) {
	            pendings++;
	            thisPendings++;
	            asyncFn(file, val).then(function (d) {
	              if (!fn(d, val)) {
	                file.$error = name;
	                file.$errorParam = val;
	                hasError = true;
	              }
	            }, function () {
	              if (attrGetter('ngfValidateForce', {'$file': file})) {
	                file.$error = name;
	                file.$errorParam = val;
	                hasError = true;
	              }
	            })['finally'](function () {
	              pendings--;
	              thisPendings--;
	              if (!thisPendings) {
	                ngModel.$ngfValidations.push({name: name, valid: !hasError});
	              }
	              if (!pendings) {
	                callback.call(ngModel, ngModel.$ngfValidations);
	              }
	            });
	          }
	        });
	      }
	    }

	    validateAsync('maxHeight', function (cons) {
	      return cons.height && cons.height.max;
	    }, /image/, this.imageDimensions, function (d, val) {
	      return d.height <= val;
	    });
	    validateAsync('minHeight', function (cons) {
	      return cons.height && cons.height.min;
	    }, /image/, this.imageDimensions, function (d, val) {
	      return d.height >= val;
	    });
	    validateAsync('maxWidth', function (cons) {
	      return cons.width && cons.width.max;
	    }, /image/, this.imageDimensions, function (d, val) {
	      return d.width <= val;
	    });
	    validateAsync('minWidth', function (cons) {
	      return cons.width && cons.width.min;
	    }, /image/, this.imageDimensions, function (d, val) {
	      return d.width >= val;
	    });
	    validateAsync('ratio', function (cons) {
	      return cons.ratio;
	    }, /image/, this.imageDimensions, function (d, val) {
	      var split = val.toString().split(','), valid = false;

	      for (var i = 0; i < split.length; i++) {
	        var r = split[i], xIndex = r.search(/x/i);
	        if (xIndex > -1) {
	          r = parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1));
	        } else {
	          r = parseFloat(r);
	        }
	        if (Math.abs((d.width / d.height) - r) < 0.0001) {
	          valid = true;
	        }
	      }
	      return valid;
	    });
	    validateAsync('maxDuration', function (cons) {
	      return cons.duration && cons.duration.max;
	    }, /audio|video/, this.mediaDuration, function (d, val) {
	      return d <= upload.translateScalars(val);
	    });
	    validateAsync('minDuration', function (cons) {
	      return cons.duration && cons.duration.min;
	    }, /audio|video/, this.mediaDuration, function (d, val) {
	      return d >= upload.translateScalars(val);
	    });

	    validateAsync('validateAsyncFn', function () {
	      return null;
	    }, /./, function (file, val) {
	      return val;
	    }, function (r) {
	      return r === true || r === null || r === '';
	    });

	    if (!pendings) {
	      callback.call(ngModel, ngModel.$ngfValidations);
	    }
	  };

	  upload.imageDimensions = function (file) {
	    if (file.width && file.height) {
	      var d = $q.defer();
	      $timeout(function () {
	        d.resolve({width: file.width, height: file.height});
	      });
	      return d.promise;
	    }
	    if (file.$ngfDimensionPromise) return file.$ngfDimensionPromise;

	    var deferred = $q.defer();
	    $timeout(function () {
	      if (file.type.indexOf('image') !== 0) {
	        deferred.reject('not image');
	        return;
	      }
	      upload.dataUrl(file).then(function (dataUrl) {
	        var img = angular.element('<img>').attr('src', dataUrl).css('visibility', 'hidden').css('position', 'fixed');

	        function success() {
	          var width = img[0].clientWidth;
	          var height = img[0].clientHeight;
	          img.remove();
	          file.width = width;
	          file.height = height;
	          deferred.resolve({width: width, height: height});
	        }

	        function error() {
	          img.remove();
	          deferred.reject('load error');
	        }

	        img.on('load', success);
	        img.on('error', error);
	        var count = 0;

	        function checkLoadError() {
	          $timeout(function () {
	            if (img[0].parentNode) {
	              if (img[0].clientWidth) {
	                success();
	              } else if (count > 10) {
	                error();
	              } else {
	                checkLoadError();
	              }
	            }
	          }, 1000);
	        }

	        checkLoadError();

	        angular.element(document.getElementsByTagName('body')[0]).append(img);
	      }, function () {
	        deferred.reject('load error');
	      });
	    });

	    file.$ngfDimensionPromise = deferred.promise;
	    file.$ngfDimensionPromise['finally'](function () {
	      delete file.$ngfDimensionPromise;
	    });
	    return file.$ngfDimensionPromise;
	  };

	  upload.mediaDuration = function (file) {
	    if (file.duration) {
	      var d = $q.defer();
	      $timeout(function () {
	        d.resolve(file.duration);
	      });
	      return d.promise;
	    }
	    if (file.$ngfDurationPromise) return file.$ngfDurationPromise;

	    var deferred = $q.defer();
	    $timeout(function () {
	      if (file.type.indexOf('audio') !== 0 && file.type.indexOf('video') !== 0) {
	        deferred.reject('not media');
	        return;
	      }
	      upload.dataUrl(file).then(function (dataUrl) {
	        var el = angular.element(file.type.indexOf('audio') === 0 ? '<audio>' : '<video>')
	          .attr('src', dataUrl).css('visibility', 'none').css('position', 'fixed');

	        function success() {
	          var duration = el[0].duration;
	          file.duration = duration;
	          el.remove();
	          deferred.resolve(duration);
	        }

	        function error() {
	          el.remove();
	          deferred.reject('load error');
	        }

	        el.on('loadedmetadata', success);
	        el.on('error', error);
	        var count = 0;

	        function checkLoadError() {
	          $timeout(function () {
	            if (el[0].parentNode) {
	              if (el[0].duration) {
	                success();
	              } else if (count > 10) {
	                error();
	              } else {
	                checkLoadError();
	              }
	            }
	          }, 1000);
	        }

	        checkLoadError();

	        angular.element(document.body).append(el);
	      }, function () {
	        deferred.reject('load error');
	      });
	    });

	    file.$ngfDurationPromise = deferred.promise;
	    file.$ngfDurationPromise['finally'](function () {
	      delete file.$ngfDurationPromise;
	    });
	    return file.$ngfDurationPromise;
	  };
	  return upload;
	}
	]);

	// source: Source: https://github.com/romelgomez/angular-firebase-image-upload/blob/master/app/scripts/fileUpload.js#L89

	ngFileUpload.service('UploadResize', ['UploadValidate', '$q', '$timeout', function (UploadValidate, $q, $timeout) {
	  var upload = UploadValidate;

	  /**
	   * Conserve aspect ratio of the original region. Useful when shrinking/enlarging
	   * images to fit into a certain area.
	   * Source:  http://stackoverflow.com/a/14731922
	   *
	   * @param {Number} srcWidth Source area width
	   * @param {Number} srcHeight Source area height
	   * @param {Number} maxWidth Nestable area maximum available width
	   * @param {Number} maxHeight Nestable area maximum available height
	   * @return {Object} { width, height }
	   */
	  var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight) {
	    var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
	    return {width: srcWidth * ratio, height: srcHeight * ratio};
	  };

	  /**
	   Reduce imagen size and quality.
	   @param {String} imagen is a base64 string
	   @param {Number} width
	   @param {Number} height
	   @param {Number} quality from 0.1 to 1.0
	   @return Promise.<String>
	   **/
	  var resize = function (imagen, width, height, quality, type) {
	    var deferred = $q.defer();
	    var canvasElement = document.createElement('canvas');
	    var imagenElement = document.createElement('img');
	    if (width === 0) {
	      width = imagenElement.width;
	      height = imagenElement.height;
	    }
	    imagenElement.onload = function () {
	      try {
	        var dimensions = calculateAspectRatioFit(imagenElement.width, imagenElement.height, width, height);
	        canvasElement.width = dimensions.width;
	        canvasElement.height = dimensions.height;
	        var context = canvasElement.getContext('2d');
	        context.drawImage(imagenElement, 0, 0, dimensions.width, dimensions.height);
	        deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 1.0));
	      } catch(e) {
	        deferred.reject(e);
	      }
	    };
	    imagenElement.onerror = function () {
	      deferred.reject();
	    };
	    imagenElement.src = imagen;
	    return deferred.promise;
	  };

	  var dataURLtoBlob = function (dataurl) {
	    var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
	      bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
	    while (n--) {
	      u8arr[n] = bstr.charCodeAt(n);
	    }
	    return new Blob([u8arr], {type: mime});
	  };

	  upload.isResizeSupported = function() {
	    var elem = document.createElement('canvas');
	    return window.atob && elem.getContext && elem.getContext('2d');
	  };

	  upload.resize = function (file, width, height, quality) {
	    var deferred = $q.defer();
	    if (file.type.indexOf('image') !== 0) {
	      $timeout(function() {deferred.resolve('Only images are allowed for resizing!');});
	      return deferred.promise;
	    }

	    upload.dataUrl(file, true).then(function (url) {
	      resize(url, width, height, quality, file.type).then(function (dataUrl) {
	        var blob= dataURLtoBlob(dataUrl);
	        blob.name = file.name;
	        deferred.resolve(blob);
	      }, function () {
	        deferred.reject();
	      });
	    }, function () {
	      deferred.reject();
	    });
	    return deferred.promise;
	  };

	  return upload;
	}]);

	(function () {
	  ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$location', 'Upload',
	    function ($parse, $timeout, $location, Upload) {
	      return {
	        restrict: 'AEC',
	        require: '?ngModel',
	        link: function (scope, elem, attr, ngModel) {
	          linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $location, Upload);
	        }
	      };
	    }]);

	  ngFileUpload.directive('ngfNoFileDrop', function () {
	    return function (scope, elem) {
	      if (dropAvailable()) elem.css('display', 'none');
	    };
	  });

	  ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', 'Upload', function ($parse, $timeout, Upload) {
	    return function (scope, elem, attr) {
	      if (dropAvailable()) {
	        var model = $parse(Upload.attrGetter('ngfDropAvailable', attr));
	        $timeout(function () {
	          model(scope);
	          if (model.assign) {
	            model.assign(scope, true);
	          }
	        });
	      }
	    };
	  }]);

	  function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $location, upload) {
	    var available = dropAvailable();

	    var attrGetter = function (name, scope, params) {
	      return upload.attrGetter(name, attr, scope, params);
	    };

	    if (attrGetter('dropAvailable')) {
	      $timeout(function () {
	        if (scope[attrGetter('dropAvailable')]) {
	          scope[attrGetter('dropAvailable')].value = available;
	        } else {
	          scope[attrGetter('dropAvailable')] = available;
	        }
	      });
	    }
	    if (!available) {
	      if (attrGetter('ngfHideOnDropNotAvailable', scope) === true) {
	        elem.css('display', 'none');
	      }
	      return;
	    }

	    function isDisabled() {
	      return elem.attr('disabled') || attrGetter('ngfDropDisabled', scope);
	    }

	    upload.registerValidators(ngModel, null, attr, scope);

	    var leaveTimeout = null;
	    var stopPropagation = $parse(attrGetter('ngfStopPropagation'));
	    var dragOverDelay = 1;
	    var actualDragOverClass;

	    elem[0].addEventListener('dragover', function (evt) {
	      if (isDisabled()) return;
	      evt.preventDefault();
	      if (stopPropagation(scope)) evt.stopPropagation();
	      // handling dragover events from the Chrome download bar
	      if (navigator.userAgent.indexOf('Chrome') > -1) {
	        var b = evt.dataTransfer.effectAllowed;
	        evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
	      }
	      $timeout.cancel(leaveTimeout);
	      if (!actualDragOverClass) {
	        actualDragOverClass = 'C';
	        calculateDragOverClass(scope, attr, evt, function (clazz) {
	          actualDragOverClass = clazz;
	          elem.addClass(actualDragOverClass);
	        });
	      }
	    }, false);
	    elem[0].addEventListener('dragenter', function (evt) {
	      if (isDisabled()) return;
	      evt.preventDefault();
	      if (stopPropagation(scope)) evt.stopPropagation();
	    }, false);
	    elem[0].addEventListener('dragleave', function () {
	      if (isDisabled()) return;
	      leaveTimeout = $timeout(function () {
	        if (actualDragOverClass) elem.removeClass(actualDragOverClass);
	        actualDragOverClass = null;
	      }, dragOverDelay || 1);
	    }, false);
	    elem[0].addEventListener('drop', function (evt) {
	      if (isDisabled()) return;
	      evt.preventDefault();
	      if (stopPropagation(scope)) evt.stopPropagation();
	      if (actualDragOverClass) elem.removeClass(actualDragOverClass);
	      actualDragOverClass = null;
	      extractFiles(evt, function (files) {
	          upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);
	        }, attrGetter('ngfAllowDir', scope) !== false,
	        attrGetter('multiple') || attrGetter('ngfMultiple', scope));
	    }, false);
	    elem[0].addEventListener('paste', function (evt) {
	      if (isDisabled()) return;
	      var files = [];
	      var clipboard = evt.clipboardData || evt.originalEvent.clipboardData;
	      if (clipboard && clipboard.items) {
	        for (var k = 0; k < clipboard.items.length; k++) {
	          if (clipboard.items[k].type.indexOf('image') !== -1) {
	            files.push(clipboard.items[k].getAsFile());
	          }
	        }
	        upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);
	      }
	    }, false);

	    function calculateDragOverClass(scope, attr, evt, callback) {
	      var clazz = attrGetter('ngfDragOverClass', scope, {$event: evt}),
	        dClass = attrGetter('ngfDragOverClass') || 'dragover';
	      if (angular.isString(clazz)) {
	        callback(clazz);
	        return;
	      }
	      if (clazz) {
	        if (clazz.delay) dragOverDelay = clazz.delay;
	        if (clazz.accept || clazz.reject) {
	          var items = evt.dataTransfer.items;
	          if (items != null) {
	            var pattern = attrGetter('ngfPattern', scope, {$event: evt});
	            for (var i = 0; i < items.length; i++) {
	              if (items[i].kind === 'file' || items[i].kind === '') {
	                if (!upload.validatePattern(items[i], pattern)) {
	                  dClass = clazz.reject;
	                  break;
	                } else {
	                  dClass = clazz.accept;
	                }
	              }
	            }
	          }
	        }
	      }
	      callback(dClass);
	    }

	    function extractFiles(evt, callback, allowDir, multiple) {
	      var files = [], processing = 0;

	      function traverseFileTree(files, entry, path) {
	        if (entry != null) {
	          if (entry.isDirectory) {
	            var filePath = (path || '') + entry.name;
	            files.push({name: entry.name, type: 'directory', path: filePath});
	            var dirReader = entry.createReader();
	            var entries = [];
	            processing++;
	            var readEntries = function () {
	              dirReader.readEntries(function (results) {
	                try {
	                  if (!results.length) {
	                    for (var i = 0; i < entries.length; i++) {
	                      traverseFileTree(files, entries[i], (path ? path : '') + entry.name + '/');
	                    }
	                    processing--;
	                  } else {
	                    entries = entries.concat(Array.prototype.slice.call(results || [], 0));
	                    readEntries();
	                  }
	                } catch (e) {
	                  processing--;
	                  console.error(e);
	                }
	              }, function () {
	                processing--;
	              });
	            };
	            readEntries();
	          } else {
	            processing++;
	            entry.file(function (file) {
	              try {
	                processing--;
	                file.path = (path ? path : '') + file.name;
	                files.push(file);
	              } catch (e) {
	                processing--;
	                console.error(e);
	              }
	            }, function () {
	              processing--;
	            });
	          }
	        }
	      }

	      var items = evt.dataTransfer.items;

	      if (items && items.length > 0 && $location.protocol() !== 'file') {
	        for (var i = 0; i < items.length; i++) {
	          if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
	            var entry = items[i].webkitGetAsEntry();
	            if (entry.isDirectory && !allowDir) {
	              continue;
	            }
	            if (entry != null) {
	              traverseFileTree(files, entry);
	            }
	          } else {
	            var f = items[i].getAsFile();
	            if (f != null) files.push(f);
	          }
	          if (!multiple && files.length > 0) break;
	        }
	      } else {
	        var fileList = evt.dataTransfer.files;
	        if (fileList != null) {
	          for (var j = 0; j < fileList.length; j++) {
	            files.push(fileList.item(j));
	            if (!multiple && files.length > 0) {
	              break;
	            }
	          }
	        }
	      }
	      var delays = 0;
	      (function waitForProcess(delay) {
	        $timeout(function () {
	          if (!processing) {
	            if (!multiple && files.length > 1) {
	              i = 0;
	              while (files[i].type === 'directory') i++;
	              files = [files[i]];
	            }
	            callback(files);
	          } else {
	            if (delays++ * 10 < 20 * 1000) {
	              waitForProcess(10);
	            }
	          }
	        }, delay || 0);
	      })();
	    }
	  }

	  function dropAvailable() {
	    var div = document.createElement('div');
	    return ('draggable' in div) && ('ondrop' in div) && !/Edge\/12./i.test(navigator.userAgent);
	  }

	})();


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(187);
	module.exports = 'ngFileUpload';

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function() {
	    var inflection = window && window.inflection ? window.inflection : __webpack_require__(158);
	    var angular = window && window.angular ? window.angular : __webpack_require__(3);
	    var app = angular.module('ngInflection', []);

	    function wrap(op) {
	    	return function() {
		        return function(inp) {
		            if (inp) {
		                return inflection[op].apply(this, arguments);
		            }
		        };
	    	};
	    }

	    var ops = [
	    	'indexOf',
	    	'pluralize',
	    	'singularize',
	    	'inflect',
	    	'camelize',
	    	'underscore',
	    	'humanize',
	    	'capitalize',
	    	'dasherize',
	    	'titleize',
	    	'demodulize',
	    	'tableize',
	    	'classify',
	    	'foreign_key',
	    	'ordinalize'
	    ];

	    for (var i in ops) {
	    	app.filter(ops[i], wrap(ops[i]));
	    }

	    app.filter('transform', function () {
			return function(string,arr) {
				if (string && arr) {
					return inflection.transform(string, arr);
				}
			};
		});
	};

	module.exports();

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
	 * @license MIT */

	;(function(root, factory) {

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    root.NProgress = factory();
	  }

	})(this, function() {
	  var NProgress = {};

	  NProgress.version = '0.2.0';

	  var Settings = NProgress.settings = {
	    minimum: 0.08,
	    easing: 'ease',
	    positionUsing: '',
	    speed: 200,
	    trickle: true,
	    trickleRate: 0.02,
	    trickleSpeed: 800,
	    showSpinner: true,
	    barSelector: '[role="bar"]',
	    spinnerSelector: '[role="spinner"]',
	    parent: 'body',
	    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
	  };

	  /**
	   * Updates configuration.
	   *
	   *     NProgress.configure({
	   *       minimum: 0.1
	   *     });
	   */
	  NProgress.configure = function(options) {
	    var key, value;
	    for (key in options) {
	      value = options[key];
	      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
	    }

	    return this;
	  };

	  /**
	   * Last number.
	   */

	  NProgress.status = null;

	  /**
	   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
	   *
	   *     NProgress.set(0.4);
	   *     NProgress.set(1.0);
	   */

	  NProgress.set = function(n) {
	    var started = NProgress.isStarted();

	    n = clamp(n, Settings.minimum, 1);
	    NProgress.status = (n === 1 ? null : n);

	    var progress = NProgress.render(!started),
	        bar      = progress.querySelector(Settings.barSelector),
	        speed    = Settings.speed,
	        ease     = Settings.easing;

	    progress.offsetWidth; /* Repaint */

	    queue(function(next) {
	      // Set positionUsing if it hasn't already been set
	      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

	      // Add transition
	      css(bar, barPositionCSS(n, speed, ease));

	      if (n === 1) {
	        // Fade out
	        css(progress, { 
	          transition: 'none', 
	          opacity: 1 
	        });
	        progress.offsetWidth; /* Repaint */

	        setTimeout(function() {
	          css(progress, { 
	            transition: 'all ' + speed + 'ms linear', 
	            opacity: 0 
	          });
	          setTimeout(function() {
	            NProgress.remove();
	            next();
	          }, speed);
	        }, speed);
	      } else {
	        setTimeout(next, speed);
	      }
	    });

	    return this;
	  };

	  NProgress.isStarted = function() {
	    return typeof NProgress.status === 'number';
	  };

	  /**
	   * Shows the progress bar.
	   * This is the same as setting the status to 0%, except that it doesn't go backwards.
	   *
	   *     NProgress.start();
	   *
	   */
	  NProgress.start = function() {
	    if (!NProgress.status) NProgress.set(0);

	    var work = function() {
	      setTimeout(function() {
	        if (!NProgress.status) return;
	        NProgress.trickle();
	        work();
	      }, Settings.trickleSpeed);
	    };

	    if (Settings.trickle) work();

	    return this;
	  };

	  /**
	   * Hides the progress bar.
	   * This is the *sort of* the same as setting the status to 100%, with the
	   * difference being `done()` makes some placebo effect of some realistic motion.
	   *
	   *     NProgress.done();
	   *
	   * If `true` is passed, it will show the progress bar even if its hidden.
	   *
	   *     NProgress.done(true);
	   */

	  NProgress.done = function(force) {
	    if (!force && !NProgress.status) return this;

	    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
	  };

	  /**
	   * Increments by a random amount.
	   */

	  NProgress.inc = function(amount) {
	    var n = NProgress.status;

	    if (!n) {
	      return NProgress.start();
	    } else {
	      if (typeof amount !== 'number') {
	        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
	      }

	      n = clamp(n + amount, 0, 0.994);
	      return NProgress.set(n);
	    }
	  };

	  NProgress.trickle = function() {
	    return NProgress.inc(Math.random() * Settings.trickleRate);
	  };

	  /**
	   * Waits for all supplied jQuery promises and
	   * increases the progress as the promises resolve.
	   *
	   * @param $promise jQUery Promise
	   */
	  (function() {
	    var initial = 0, current = 0;

	    NProgress.promise = function($promise) {
	      if (!$promise || $promise.state() === "resolved") {
	        return this;
	      }

	      if (current === 0) {
	        NProgress.start();
	      }

	      initial++;
	      current++;

	      $promise.always(function() {
	        current--;
	        if (current === 0) {
	            initial = 0;
	            NProgress.done();
	        } else {
	            NProgress.set((initial - current) / initial);
	        }
	      });

	      return this;
	    };

	  })();

	  /**
	   * (Internal) renders the progress bar markup based on the `template`
	   * setting.
	   */

	  NProgress.render = function(fromStart) {
	    if (NProgress.isRendered()) return document.getElementById('nprogress');

	    addClass(document.documentElement, 'nprogress-busy');
	    
	    var progress = document.createElement('div');
	    progress.id = 'nprogress';
	    progress.innerHTML = Settings.template;

	    var bar      = progress.querySelector(Settings.barSelector),
	        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
	        parent   = document.querySelector(Settings.parent),
	        spinner;
	    
	    css(bar, {
	      transition: 'all 0 linear',
	      transform: 'translate3d(' + perc + '%,0,0)'
	    });

	    if (!Settings.showSpinner) {
	      spinner = progress.querySelector(Settings.spinnerSelector);
	      spinner && removeElement(spinner);
	    }

	    if (parent != document.body) {
	      addClass(parent, 'nprogress-custom-parent');
	    }

	    parent.appendChild(progress);
	    return progress;
	  };

	  /**
	   * Removes the element. Opposite of render().
	   */

	  NProgress.remove = function() {
	    removeClass(document.documentElement, 'nprogress-busy');
	    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
	    var progress = document.getElementById('nprogress');
	    progress && removeElement(progress);
	  };

	  /**
	   * Checks if the progress bar is rendered.
	   */

	  NProgress.isRendered = function() {
	    return !!document.getElementById('nprogress');
	  };

	  /**
	   * Determine which positioning CSS rule to use.
	   */

	  NProgress.getPositioningCSS = function() {
	    // Sniff on document.body.style
	    var bodyStyle = document.body.style;

	    // Sniff prefixes
	    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
	                       ('MozTransform' in bodyStyle) ? 'Moz' :
	                       ('msTransform' in bodyStyle) ? 'ms' :
	                       ('OTransform' in bodyStyle) ? 'O' : '';

	    if (vendorPrefix + 'Perspective' in bodyStyle) {
	      // Modern browsers with 3D support, e.g. Webkit, IE10
	      return 'translate3d';
	    } else if (vendorPrefix + 'Transform' in bodyStyle) {
	      // Browsers without 3D support, e.g. IE9
	      return 'translate';
	    } else {
	      // Browsers without translate() support, e.g. IE7-8
	      return 'margin';
	    }
	  };

	  /**
	   * Helpers
	   */

	  function clamp(n, min, max) {
	    if (n < min) return min;
	    if (n > max) return max;
	    return n;
	  }

	  /**
	   * (Internal) converts a percentage (`0..1`) to a bar translateX
	   * percentage (`-100%..0%`).
	   */

	  function toBarPerc(n) {
	    return (-1 + n) * 100;
	  }


	  /**
	   * (Internal) returns the correct CSS for changing the bar's
	   * position given an n percentage, and speed and ease from Settings
	   */

	  function barPositionCSS(n, speed, ease) {
	    var barCSS;

	    if (Settings.positionUsing === 'translate3d') {
	      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
	    } else if (Settings.positionUsing === 'translate') {
	      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
	    } else {
	      barCSS = { 'margin-left': toBarPerc(n)+'%' };
	    }

	    barCSS.transition = 'all '+speed+'ms '+ease;

	    return barCSS;
	  }

	  /**
	   * (Internal) Queues a function to be executed.
	   */

	  var queue = (function() {
	    var pending = [];
	    
	    function next() {
	      var fn = pending.shift();
	      if (fn) {
	        fn(next);
	      }
	    }

	    return function(fn) {
	      pending.push(fn);
	      if (pending.length == 1) next();
	    };
	  })();

	  /**
	   * (Internal) Applies css properties to an element, similar to the jQuery 
	   * css method.
	   *
	   * While this helper does assist with vendor prefixed property names, it 
	   * does not perform any manipulation of values prior to setting styles.
	   */

	  var css = (function() {
	    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
	        cssProps    = {};

	    function camelCase(string) {
	      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
	        return letter.toUpperCase();
	      });
	    }

	    function getVendorProp(name) {
	      var style = document.body.style;
	      if (name in style) return name;

	      var i = cssPrefixes.length,
	          capName = name.charAt(0).toUpperCase() + name.slice(1),
	          vendorName;
	      while (i--) {
	        vendorName = cssPrefixes[i] + capName;
	        if (vendorName in style) return vendorName;
	      }

	      return name;
	    }

	    function getStyleProp(name) {
	      name = camelCase(name);
	      return cssProps[name] || (cssProps[name] = getVendorProp(name));
	    }

	    function applyCss(element, prop, value) {
	      prop = getStyleProp(prop);
	      element.style[prop] = value;
	    }

	    return function(element, properties) {
	      var args = arguments,
	          prop, 
	          value;

	      if (args.length == 2) {
	        for (prop in properties) {
	          value = properties[prop];
	          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
	        }
	      } else {
	        applyCss(element, args[1], args[2]);
	      }
	    }
	  })();

	  /**
	   * (Internal) Determines if an element or space separated list of class names contains a class name.
	   */

	  function hasClass(element, name) {
	    var list = typeof element == 'string' ? element : classList(element);
	    return list.indexOf(' ' + name + ' ') >= 0;
	  }

	  /**
	   * (Internal) Adds a class to an element.
	   */

	  function addClass(element, name) {
	    var oldList = classList(element),
	        newList = oldList + name;

	    if (hasClass(oldList, name)) return; 

	    // Trim the opening space.
	    element.className = newList.substring(1);
	  }

	  /**
	   * (Internal) Removes a class from an element.
	   */

	  function removeClass(element, name) {
	    var oldList = classList(element),
	        newList;

	    if (!hasClass(element, name)) return;

	    // Replace the class name.
	    newList = oldList.replace(' ' + name + ' ', ' ');

	    // Trim the opening and closing spaces.
	    element.className = newList.substring(1, newList.length - 1);
	  }

	  /**
	   * (Internal) Gets a space separated list of the class names on the element. 
	   * The list is wrapped with a single space on each end to facilitate finding 
	   * matches within the list.
	   */

	  function classList(element) {
	    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
	  }

	  /**
	   * (Internal) Removes an element from the DOM.
	   */

	  function removeElement(element) {
	    element && element.parentNode && element.parentNode.removeChild(element);
	  }

	  return NProgress;
	});



/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
		Papa Parse
		v4.1.2
		https://github.com/mholt/PapaParse
	*/
	(function(global)
	{
		"use strict";

		var IS_WORKER = !global.document && !!global.postMessage,
			IS_PAPA_WORKER = IS_WORKER && /(\?|&)papaworker(=|&|$)/.test(global.location.search),
			LOADED_SYNC = false, AUTO_SCRIPT_PATH;
		var workers = {}, workerIdCounter = 0;

		var Papa = {};

		Papa.parse = CsvToJson;
		Papa.unparse = JsonToCsv;

		Papa.RECORD_SEP = String.fromCharCode(30);
		Papa.UNIT_SEP = String.fromCharCode(31);
		Papa.BYTE_ORDER_MARK = "\ufeff";
		Papa.BAD_DELIMITERS = ["\r", "\n", "\"", Papa.BYTE_ORDER_MARK];
		Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
		Papa.SCRIPT_PATH = null;	// Must be set by your code if you use workers and this lib is loaded asynchronously

		// Configurable chunk sizes for local and remote files, respectively
		Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
		Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
		Papa.DefaultDelimiter = ",";			// Used if not specified and detection fails

		// Exposed for testing and development only
		Papa.Parser = Parser;
		Papa.ParserHandle = ParserHandle;
		Papa.NetworkStreamer = NetworkStreamer;
		Papa.FileStreamer = FileStreamer;
		Papa.StringStreamer = StringStreamer;

		if (typeof module !== 'undefined' && module.exports)
		{
			// Export to Node...
			module.exports = Papa;
		}
		else if (isFunction(global.define) && global.define.amd)
		{
			// Wireup with RequireJS
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return Papa; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else
		{
			// ...or as browser global
			global.Papa = Papa;
		}

		if (global.jQuery)
		{
			var $ = global.jQuery;
			$.fn.parse = function(options)
			{
				var config = options.config || {};
				var queue = [];

				this.each(function(idx)
				{
					var supported = $(this).prop('tagName').toUpperCase() == "INPUT"
									&& $(this).attr('type').toLowerCase() == "file"
									&& global.FileReader;

					if (!supported || !this.files || this.files.length == 0)
						return true;	// continue to next input element

					for (var i = 0; i < this.files.length; i++)
					{
						queue.push({
							file: this.files[i],
							inputElem: this,
							instanceConfig: $.extend({}, config)
						});
					}
				});

				parseNextFile();	// begin parsing
				return this;		// maintains chainability


				function parseNextFile()
				{
					if (queue.length == 0)
					{
						if (isFunction(options.complete))
							options.complete();
						return;
					}

					var f = queue[0];

					if (isFunction(options.before))
					{
						var returned = options.before(f.file, f.inputElem);

						if (typeof returned === 'object')
						{
							if (returned.action == "abort")
							{
								error("AbortError", f.file, f.inputElem, returned.reason);
								return;	// Aborts all queued files immediately
							}
							else if (returned.action == "skip")
							{
								fileComplete();	// parse the next file in the queue, if any
								return;
							}
							else if (typeof returned.config === 'object')
								f.instanceConfig = $.extend(f.instanceConfig, returned.config);
						}
						else if (returned == "skip")
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
					}

					// Wrap up the user's complete callback, if any, so that ours also gets executed
					var userCompleteFunc = f.instanceConfig.complete;
					f.instanceConfig.complete = function(results)
					{
						if (isFunction(userCompleteFunc))
							userCompleteFunc(results, f.file, f.inputElem);
						fileComplete();
					};

					Papa.parse(f.file, f.instanceConfig);
				}

				function error(name, file, elem, reason)
				{
					if (isFunction(options.error))
						options.error({name: name}, file, elem, reason);
				}

				function fileComplete()
				{
					queue.splice(0, 1);
					parseNextFile();
				}
			}
		}


		if (IS_PAPA_WORKER)
		{
			global.onmessage = workerThreadReceivedMessage;
		}
		else if (Papa.WORKERS_SUPPORTED)
		{
			AUTO_SCRIPT_PATH = getScriptPath();

			// Check if the script was loaded synchronously
			if (!document.body)
			{
				// Body doesn't exist yet, must be synchronous
				LOADED_SYNC = true;
			}
			else
			{
				document.addEventListener('DOMContentLoaded', function () {
					LOADED_SYNC = true;
				}, true);
			}
		}




		function CsvToJson(_input, _config)
		{
			_config = _config || {};

			if (_config.worker && Papa.WORKERS_SUPPORTED)
			{
				var w = newWorker();

				w.userStep = _config.step;
				w.userChunk = _config.chunk;
				w.userComplete = _config.complete;
				w.userError = _config.error;

				_config.step = isFunction(_config.step);
				_config.chunk = isFunction(_config.chunk);
				_config.complete = isFunction(_config.complete);
				_config.error = isFunction(_config.error);
				delete _config.worker;	// prevent infinite loop

				w.postMessage({
					input: _input,
					config: _config,
					workerId: w.id
				});

				return;
			}

			var streamer = null;
			if (typeof _input === 'string')
			{
				if (_config.download)
					streamer = new NetworkStreamer(_config);
				else
					streamer = new StringStreamer(_config);
			}
			else if ((global.File && _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
				streamer = new FileStreamer(_config);

			return streamer.stream(_input);
		}






		function JsonToCsv(_input, _config)
		{
			var _output = "";
			var _fields = [];

			// Default configuration

			/** whether to surround every datum with quotes */
			var _quotes = false;

			/** delimiting character */
			var _delimiter = ",";

			/** newline character(s) */
			var _newline = "\r\n";

			unpackConfig();

			if (typeof _input === 'string')
				_input = JSON.parse(_input);

			if (_input instanceof Array)
			{
				if (!_input.length || _input[0] instanceof Array)
					return serialize(null, _input);
				else if (typeof _input[0] === 'object')
					return serialize(objectKeys(_input[0]), _input);
			}
			else if (typeof _input === 'object')
			{
				if (typeof _input.data === 'string')
					_input.data = JSON.parse(_input.data);

				if (_input.data instanceof Array)
				{
					if (!_input.fields)
						_input.fields = _input.data[0] instanceof Array
										? _input.fields
										: objectKeys(_input.data[0]);

					if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
						_input.data = [_input.data];	// handles input like [1,2,3] or ["asdf"]
				}

				return serialize(_input.fields || [], _input.data || []);
			}

			// Default (any valid paths should return before this)
			throw "exception: Unable to serialize unrecognized input";


			function unpackConfig()
			{
				if (typeof _config !== 'object')
					return;

				if (typeof _config.delimiter === 'string'
					&& _config.delimiter.length == 1
					&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)
				{
					_delimiter = _config.delimiter;
				}

				if (typeof _config.quotes === 'boolean'
					|| _config.quotes instanceof Array)
					_quotes = _config.quotes;

				if (typeof _config.newline === 'string')
					_newline = _config.newline;
			}


			/** Turns an object's keys into an array */
			function objectKeys(obj)
			{
				if (typeof obj !== 'object')
					return [];
				var keys = [];
				for (var key in obj)
					keys.push(key);
				return keys;
			}

			/** The double for loop that iterates the data and writes out a CSV string including header row */
			function serialize(fields, data)
			{
				var csv = "";

				if (typeof fields === 'string')
					fields = JSON.parse(fields);
				if (typeof data === 'string')
					data = JSON.parse(data);

				var hasHeader = fields instanceof Array && fields.length > 0;
				var dataKeyedByField = !(data[0] instanceof Array);

				// If there a header row, write it first
				if (hasHeader)
				{
					for (var i = 0; i < fields.length; i++)
					{
						if (i > 0)
							csv += _delimiter;
						csv += safe(fields[i], i);
					}
					if (data.length > 0)
						csv += _newline;
				}

				// Then write out the data
				for (var row = 0; row < data.length; row++)
				{
					var maxCol = hasHeader ? fields.length : data[row].length;

					for (var col = 0; col < maxCol; col++)
					{
						if (col > 0)
							csv += _delimiter;
						var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
						csv += safe(data[row][colIdx], col);
					}

					if (row < data.length - 1)
						csv += _newline;
				}

				return csv;
			}

			/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
			function safe(str, col)
			{
				if (typeof str === "undefined" || str === null)
					return "";

				str = str.toString().replace(/"/g, '""');

				var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
								|| (_quotes instanceof Array && _quotes[col])
								|| hasAny(str, Papa.BAD_DELIMITERS)
								|| str.indexOf(_delimiter) > -1
								|| str.charAt(0) == ' '
								|| str.charAt(str.length - 1) == ' ';

				return needsQuotes ? '"' + str + '"' : str;
			}

			function hasAny(str, substrings)
			{
				for (var i = 0; i < substrings.length; i++)
					if (str.indexOf(substrings[i]) > -1)
						return true;
				return false;
			}
		}

		/** ChunkStreamer is the base prototype for various streamer implementations. */
		function ChunkStreamer(config)
		{
			this._handle = null;
			this._paused = false;
			this._finished = false;
			this._input = null;
			this._baseIndex = 0;
			this._partialLine = "";
			this._rowCount = 0;
			this._start = 0;
			this._nextChunk = null;
			this.isFirstChunk = true;
			this._completeResults = {
				data: [],
				errors: [],
				meta: {}
			};
			replaceConfig.call(this, config);

			this.parseChunk = function(chunk)
			{
				// First chunk pre-processing
				if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))
				{
					var modifiedChunk = this._config.beforeFirstChunk(chunk);
					if (modifiedChunk !== undefined)
						chunk = modifiedChunk;
				}
				this.isFirstChunk = false;

				// Rejoin the line we likely just split in two by chunking the file
				var aggregate = this._partialLine + chunk;
				this._partialLine = "";

				var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
				
				if (this._handle.paused() || this._handle.aborted())
					return;
				
				var lastIndex = results.meta.cursor;
				
				if (!this._finished)
				{
					this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
					this._baseIndex = lastIndex;
				}

				if (results && results.data)
					this._rowCount += results.data.length;

				var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);

				if (IS_PAPA_WORKER)
				{
					global.postMessage({
						results: results,
						workerId: Papa.WORKER_ID,
						finished: finishedIncludingPreview
					});
				}
				else if (isFunction(this._config.chunk))
				{
					this._config.chunk(results, this._handle);
					if (this._paused)
						return;
					results = undefined;
					this._completeResults = undefined;
				}

				if (!this._config.step && !this._config.chunk) {
					this._completeResults.data = this._completeResults.data.concat(results.data);
					this._completeResults.errors = this._completeResults.errors.concat(results.errors);
					this._completeResults.meta = results.meta;
				}

				if (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))
					this._config.complete(this._completeResults);

				if (!finishedIncludingPreview && (!results || !results.meta.paused))
					this._nextChunk();

				return results;
			};

			this._sendError = function(error)
			{
				if (isFunction(this._config.error))
					this._config.error(error);
				else if (IS_PAPA_WORKER && this._config.error)
				{
					global.postMessage({
						workerId: Papa.WORKER_ID,
						error: error,
						finished: false
					});
				}
			};

			function replaceConfig(config)
			{
				// Deep-copy the config so we can edit it
				var configCopy = copy(config);
				configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
				if (!config.step && !config.chunk)
					configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
				this._handle = new ParserHandle(configCopy);
				this._handle.streamer = this;
				this._config = configCopy;	// persist the copy to the caller
			}
		}


		function NetworkStreamer(config)
		{
			config = config || {};
			if (!config.chunkSize)
				config.chunkSize = Papa.RemoteChunkSize;
			ChunkStreamer.call(this, config);

			var xhr;

			if (IS_WORKER)
			{
				this._nextChunk = function()
				{
					this._readChunk();
					this._chunkLoaded();
				};
			}
			else
			{
				this._nextChunk = function()
				{
					this._readChunk();
				};
			}

			this.stream = function(url)
			{
				this._input = url;
				this._nextChunk();	// Starts streaming
			};

			this._readChunk = function()
			{
				if (this._finished)
				{
					this._chunkLoaded();
					return;
				}

				xhr = new XMLHttpRequest();
				
				if (!IS_WORKER)
				{
					xhr.onload = bindFunction(this._chunkLoaded, this);
					xhr.onerror = bindFunction(this._chunkError, this);
				}

				xhr.open("GET", this._input, !IS_WORKER);
				
				if (this._config.chunkSize)
				{
					var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
					xhr.setRequestHeader("Range", "bytes="+this._start+"-"+end);
					xhr.setRequestHeader("If-None-Match", "webkit-no-cache"); // https://bugs.webkit.org/show_bug.cgi?id=82672
				}

				try {
					xhr.send();
				}
				catch (err) {
					this._chunkError(err.message);
				}

				if (IS_WORKER && xhr.status == 0)
					this._chunkError();
				else
					this._start += this._config.chunkSize;
			}

			this._chunkLoaded = function()
			{
				if (xhr.readyState != 4)
					return;

				if (xhr.status < 200 || xhr.status >= 400)
				{
					this._chunkError();
					return;
				}

				this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
				this.parseChunk(xhr.responseText);
			}

			this._chunkError = function(errorMessage)
			{
				var errorText = xhr.statusText || errorMessage;
				this._sendError(errorText);
			}

			function getFileSize(xhr)
			{
				var contentRange = xhr.getResponseHeader("Content-Range");
				return parseInt(contentRange.substr(contentRange.lastIndexOf("/") + 1));
			}
		}
		NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
		NetworkStreamer.prototype.constructor = NetworkStreamer;


		function FileStreamer(config)
		{
			config = config || {};
			if (!config.chunkSize)
				config.chunkSize = Papa.LocalChunkSize;
			ChunkStreamer.call(this, config);

			var reader, slice;

			// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
			// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
			var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105

			this.stream = function(file)
			{
				this._input = file;
				slice = file.slice || file.webkitSlice || file.mozSlice;

				if (usingAsyncReader)
				{
					reader = new FileReader();		// Preferred method of reading files, even in workers
					reader.onload = bindFunction(this._chunkLoaded, this);
					reader.onerror = bindFunction(this._chunkError, this);
				}
				else
					reader = new FileReaderSync();	// Hack for running in a web worker in Firefox

				this._nextChunk();	// Starts streaming
			};

			this._nextChunk = function()
			{
				if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
					this._readChunk();
			}

			this._readChunk = function()
			{
				var input = this._input;
				if (this._config.chunkSize)
				{
					var end = Math.min(this._start + this._config.chunkSize, this._input.size);
					input = slice.call(input, this._start, end);
				}
				var txt = reader.readAsText(input, this._config.encoding);
				if (!usingAsyncReader)
					this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
			}

			this._chunkLoaded = function(event)
			{
				// Very important to increment start each time before handling results
				this._start += this._config.chunkSize;
				this._finished = !this._config.chunkSize || this._start >= this._input.size;
				this.parseChunk(event.target.result);
			}

			this._chunkError = function()
			{
				this._sendError(reader.error);
			}

		}
		FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
		FileStreamer.prototype.constructor = FileStreamer;


		function StringStreamer(config)
		{
			config = config || {};
			ChunkStreamer.call(this, config);

			var string;
			var remaining;
			this.stream = function(s)
			{
				string = s;
				remaining = s;
				return this._nextChunk();
			}
			this._nextChunk = function()
			{
				if (this._finished) return;
				var size = this._config.chunkSize;
				var chunk = size ? remaining.substr(0, size) : remaining;
				remaining = size ? remaining.substr(size) : '';
				this._finished = !remaining;
				return this.parseChunk(chunk);
			}
		}
		StringStreamer.prototype = Object.create(StringStreamer.prototype);
		StringStreamer.prototype.constructor = StringStreamer;



		// Use one ParserHandle per entire CSV file or string
		function ParserHandle(_config)
		{
			// One goal is to minimize the use of regular expressions...
			var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

			var self = this;
			var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
			var _input;				// The input being parsed
			var _parser;			// The core parser being used
			var _paused = false;	// Whether we are paused or not
			var _aborted = false;   // Whether the parser has aborted or not
			var _delimiterError;	// Temporary state between delimiter detection and processing results
			var _fields = [];		// Fields are from the header row of the input, if there is one
			var _results = {		// The last results returned from the parser
				data: [],
				errors: [],
				meta: {}
			};

			if (isFunction(_config.step))
			{
				var userStep = _config.step;
				_config.step = function(results)
				{
					_results = results;

					if (needsHeaderRow())
						processResults();
					else	// only call user's step function after header row
					{
						processResults();

						// It's possbile that this line was empty and there's no row here after all
						if (_results.data.length == 0)
							return;

						_stepCounter += results.data.length;
						if (_config.preview && _stepCounter > _config.preview)
							_parser.abort();
						else
							userStep(_results, self);
					}
				};
			}

			/**
			 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
			 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
			 * when an input comes in multiple chunks, like from a file.
			 */
			this.parse = function(input, baseIndex, ignoreLastRow)
			{
				if (!_config.newline)
					_config.newline = guessLineEndings(input);

				_delimiterError = false;
				if (!_config.delimiter)
				{
					var delimGuess = guessDelimiter(input);
					if (delimGuess.successful)
						_config.delimiter = delimGuess.bestDelimiter;
					else
					{
						_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
						_config.delimiter = Papa.DefaultDelimiter;
					}
					_results.meta.delimiter = _config.delimiter;
				}

				var parserConfig = copy(_config);
				if (_config.preview && _config.header)
					parserConfig.preview++;	// to compensate for header row

				_input = input;
				_parser = new Parser(parserConfig);
				_results = _parser.parse(_input, baseIndex, ignoreLastRow);
				processResults();
				return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
			};

			this.paused = function()
			{
				return _paused;
			};

			this.pause = function()
			{
				_paused = true;
				_parser.abort();
				_input = _input.substr(_parser.getCharIndex());
			};

			this.resume = function()
			{
				_paused = false;
				self.streamer.parseChunk(_input);
			};

			this.aborted = function () {
				return _aborted;
			}

			this.abort = function()
			{
				_aborted = true;
				_parser.abort();
				_results.meta.aborted = true;
				if (isFunction(_config.complete))
					_config.complete(_results);
				_input = "";
			};

			function processResults()
			{
				if (_results && _delimiterError)
				{
					addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '"+Papa.DefaultDelimiter+"'");
					_delimiterError = false;
				}

				if (_config.skipEmptyLines)
				{
					for (var i = 0; i < _results.data.length; i++)
						if (_results.data[i].length == 1 && _results.data[i][0] == "")
							_results.data.splice(i--, 1);
				}

				if (needsHeaderRow())
					fillHeaderFields();

				return applyHeaderAndDynamicTyping();
			}

			function needsHeaderRow()
			{
				return _config.header && _fields.length == 0;
			}

			function fillHeaderFields()
			{
				if (!_results)
					return;
				for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
					for (var j = 0; j < _results.data[i].length; j++)
						_fields.push(_results.data[i][j]);
				_results.data.splice(0, 1);
			}

			function applyHeaderAndDynamicTyping()
			{
				if (!_results || (!_config.header && !_config.dynamicTyping))
					return _results;

				for (var i = 0; i < _results.data.length; i++)
				{
					var row = {};

					for (var j = 0; j < _results.data[i].length; j++)
					{
						if (_config.dynamicTyping)
						{
							var value = _results.data[i][j];
							if (value == "true" || value == "TRUE")
								_results.data[i][j] = true;
							else if (value == "false" || value == "FALSE")
								_results.data[i][j] = false;
							else
								_results.data[i][j] = tryParseFloat(value);
						}

						if (_config.header)
						{
							if (j >= _fields.length)
							{
								if (!row["__parsed_extra"])
									row["__parsed_extra"] = [];
								row["__parsed_extra"].push(_results.data[i][j]);
							}
							else
								row[_fields[j]] = _results.data[i][j];
						}
					}

					if (_config.header)
					{
						_results.data[i] = row;
						if (j > _fields.length)
							addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
						else if (j < _fields.length)
							addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
					}
				}

				if (_config.header && _results.meta)
					_results.meta.fields = _fields;
				return _results;
			}

			function guessDelimiter(input)
			{
				var delimChoices = [",", "\t", "|", ";", Papa.RECORD_SEP, Papa.UNIT_SEP];
				var bestDelim, bestDelta, fieldCountPrevRow;

				for (var i = 0; i < delimChoices.length; i++)
				{
					var delim = delimChoices[i];
					var delta = 0, avgFieldCount = 0;
					fieldCountPrevRow = undefined;

					var preview = new Parser({
						delimiter: delim,
						preview: 10
					}).parse(input);

					for (var j = 0; j < preview.data.length; j++)
					{
						var fieldCount = preview.data[j].length;
						avgFieldCount += fieldCount;

						if (typeof fieldCountPrevRow === 'undefined')
						{
							fieldCountPrevRow = fieldCount;
							continue;
						}
						else if (fieldCount > 1)
						{
							delta += Math.abs(fieldCount - fieldCountPrevRow);
							fieldCountPrevRow = fieldCount;
						}
					}

					if (preview.data.length > 0)
						avgFieldCount /= preview.data.length;

					if ((typeof bestDelta === 'undefined' || delta < bestDelta)
						&& avgFieldCount > 1.99)
					{
						bestDelta = delta;
						bestDelim = delim;
					}
				}

				_config.delimiter = bestDelim;

				return {
					successful: !!bestDelim,
					bestDelimiter: bestDelim
				}
			}

			function guessLineEndings(input)
			{
				input = input.substr(0, 1024*1024);	// max length 1 MB

				var r = input.split('\r');

				if (r.length == 1)
					return '\n';

				var numWithN = 0;
				for (var i = 0; i < r.length; i++)
				{
					if (r[i][0] == '\n')
						numWithN++;
				}

				return numWithN >= r.length / 2 ? '\r\n' : '\r';
			}

			function tryParseFloat(val)
			{
				var isNumber = FLOAT.test(val);
				return isNumber ? parseFloat(val) : val;
			}

			function addError(type, code, msg, row)
			{
				_results.errors.push({
					type: type,
					code: code,
					message: msg,
					row: row
				});
			}
		}





		/** The core parser implements speedy and correct CSV parsing */
		function Parser(config)
		{
			// Unpack the config object
			config = config || {};
			var delim = config.delimiter;
			var newline = config.newline;
			var comments = config.comments;
			var step = config.step;
			var preview = config.preview;
			var fastMode = config.fastMode;

			// Delimiter must be valid
			if (typeof delim !== 'string'
				|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)
				delim = ",";

			// Comment character must be valid
			if (comments === delim)
				throw "Comment character same as delimiter";
			else if (comments === true)
				comments = "#";
			else if (typeof comments !== 'string'
				|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)
				comments = false;

			// Newline must be valid: \r, \n, or \r\n
			if (newline != '\n' && newline != '\r' && newline != '\r\n')
				newline = '\n';

			// We're gonna need these at the Parser scope
			var cursor = 0;
			var aborted = false;

			this.parse = function(input, baseIndex, ignoreLastRow)
			{
				// For some reason, in Chrome, this speeds things up (!?)
				if (typeof input !== 'string')
					throw "Input must be a string";

				// We don't need to compute some of these every time parse() is called,
				// but having them in a more local scope seems to perform better
				var inputLen = input.length,
					delimLen = delim.length,
					newlineLen = newline.length,
					commentsLen = comments.length;
				var stepIsFunction = typeof step === 'function';

				// Establish starting state
				cursor = 0;
				var data = [], errors = [], row = [], lastCursor = 0;

				if (!input)
					return returnable();

				if (fastMode || (fastMode !== false && input.indexOf('"') === -1))
				{
					var rows = input.split(newline);
					for (var i = 0; i < rows.length; i++)
					{
						var row = rows[i];
						cursor += row.length;
						if (i !== rows.length - 1)
							cursor += newline.length;
						else if (ignoreLastRow)
							return returnable();
						if (comments && row.substr(0, commentsLen) == comments)
							continue;
						if (stepIsFunction)
						{
							data = [];
							pushRow(row.split(delim));
							doStep();
							if (aborted)
								return returnable();
						}
						else
							pushRow(row.split(delim));
						if (preview && i >= preview)
						{
							data = data.slice(0, preview);
							return returnable(true);
						}
					}
					return returnable();
				}

				var nextDelim = input.indexOf(delim, cursor);
				var nextNewline = input.indexOf(newline, cursor);

				// Parser loop
				for (;;)
				{
					// Field has opening quote
					if (input[cursor] == '"')
					{
						// Start our search for the closing quote where the cursor is
						var quoteSearch = cursor;

						// Skip the opening quote
						cursor++;

						for (;;)
						{
							// Find closing quote
							var quoteSearch = input.indexOf('"', quoteSearch+1);

							if (quoteSearch === -1)
							{
								if (!ignoreLastRow) {
									// No closing quote... what a pity
									errors.push({
										type: "Quotes",
										code: "MissingQuotes",
										message: "Quoted field unterminated",
										row: data.length,	// row has yet to be inserted
										index: cursor
									});
								}
								return finish();
							}

							if (quoteSearch === inputLen-1)
							{
								// Closing quote at EOF
								var value = input.substring(cursor, quoteSearch).replace(/""/g, '"');
								return finish(value);
							}

							// If this quote is escaped, it's part of the data; skip it
							if (input[quoteSearch+1] == '"')
							{
								quoteSearch++;
								continue;
							}

							if (input[quoteSearch+1] == delim)
							{
								// Closing quote followed by delimiter
								row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
								cursor = quoteSearch + 1 + delimLen;
								nextDelim = input.indexOf(delim, cursor);
								nextNewline = input.indexOf(newline, cursor);
								break;
							}

							if (input.substr(quoteSearch+1, newlineLen) === newline)
							{
								// Closing quote followed by newline
								row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
								saveRow(quoteSearch + 1 + newlineLen);
								nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field

								if (stepIsFunction)
								{
									doStep();
									if (aborted)
										return returnable();
								}
								
								if (preview && data.length >= preview)
									return returnable(true);

								break;
							}
						}

						continue;
					}

					// Comment found at start of new line
					if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)
					{
						if (nextNewline == -1)	// Comment ends at EOF
							return returnable();
						cursor = nextNewline + newlineLen;
						nextNewline = input.indexOf(newline, cursor);
						nextDelim = input.indexOf(delim, cursor);
						continue;
					}

					// Next delimiter comes before next newline, so we've reached end of field
					if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))
					{
						row.push(input.substring(cursor, nextDelim));
						cursor = nextDelim + delimLen;
						nextDelim = input.indexOf(delim, cursor);
						continue;
					}

					// End of row
					if (nextNewline !== -1)
					{
						row.push(input.substring(cursor, nextNewline));
						saveRow(nextNewline + newlineLen);

						if (stepIsFunction)
						{
							doStep();
							if (aborted)
								return returnable();
						}

						if (preview && data.length >= preview)
							return returnable(true);

						continue;
					}

					break;
				}


				return finish();


				function pushRow(row)
				{
					data.push(row);
					lastCursor = cursor;
				}

				/**
				 * Appends the remaining input from cursor to the end into
				 * row, saves the row, calls step, and returns the results.
				 */
				function finish(value)
				{
					if (ignoreLastRow)
						return returnable();
					if (typeof value === 'undefined')
						value = input.substr(cursor);
					row.push(value);
					cursor = inputLen;	// important in case parsing is paused
					pushRow(row);
					if (stepIsFunction)
						doStep();
					return returnable();
				}

				/**
				 * Appends the current row to the results. It sets the cursor
				 * to newCursor and finds the nextNewline. The caller should
				 * take care to execute user's step function and check for
				 * preview and end parsing if necessary.
				 */
				function saveRow(newCursor)
				{
					cursor = newCursor;
					pushRow(row);
					row = [];
					nextNewline = input.indexOf(newline, cursor);
				}

				/** Returns an object with the results, errors, and meta. */
				function returnable(stopped)
				{
					return {
						data: data,
						errors: errors,
						meta: {
							delimiter: delim,
							linebreak: newline,
							aborted: aborted,
							truncated: !!stopped,
							cursor: lastCursor + (baseIndex || 0)
						}
					};
				}

				/** Executes the user's step function and resets data & errors. */
				function doStep()
				{
					step(returnable());
					data = [], errors = [];
				}
			};

			/** Sets the abort flag */
			this.abort = function()
			{
				aborted = true;
			};

			/** Gets the cursor position */
			this.getCharIndex = function()
			{
				return cursor;
			};
		}


		// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code
		// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358
		function getScriptPath()
		{
			var scripts = document.getElementsByTagName('script');
			return scripts.length ? scripts[scripts.length - 1].src : '';
		}

		function newWorker()
		{
			if (!Papa.WORKERS_SUPPORTED)
				return false;
			if (!LOADED_SYNC && Papa.SCRIPT_PATH === null)
				throw new Error(
					'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
					'You need to set Papa.SCRIPT_PATH manually.'
				);
			var workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;
			// Append "papaworker" to the search string to tell papaparse that this is our worker.
			workerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';
			var w = new global.Worker(workerUrl);
			w.onmessage = mainThreadReceivedMessage;
			w.id = workerIdCounter++;
			workers[w.id] = w;
			return w;
		}

		/** Callback when main thread receives a message */
		function mainThreadReceivedMessage(e)
		{
			var msg = e.data;
			var worker = workers[msg.workerId];
			var aborted = false;

			if (msg.error)
				worker.userError(msg.error, msg.file);
			else if (msg.results && msg.results.data)
			{
				var abort = function() {
					aborted = true;
					completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
				};

				var handle = {
					abort: abort,
					pause: notImplemented,
					resume: notImplemented
				};

				if (isFunction(worker.userStep))
				{
					for (var i = 0; i < msg.results.data.length; i++)
					{
						worker.userStep({
							data: [msg.results.data[i]],
							errors: msg.results.errors,
							meta: msg.results.meta
						}, handle);
						if (aborted)
							break;
					}
					delete msg.results;	// free memory ASAP
				}
				else if (isFunction(worker.userChunk))
				{
					worker.userChunk(msg.results, handle, msg.file);
					delete msg.results;
				}
			}

			if (msg.finished && !aborted)
				completeWorker(msg.workerId, msg.results);
		}

		function completeWorker(workerId, results) {
			var worker = workers[workerId];
			if (isFunction(worker.userComplete))
				worker.userComplete(results);
			worker.terminate();
			delete workers[workerId];
		}

		function notImplemented() {
			throw "Not implemented.";
		}

		/** Callback when worker thread receives a message */
		function workerThreadReceivedMessage(e)
		{
			var msg = e.data;

			if (typeof Papa.WORKER_ID === 'undefined' && msg)
				Papa.WORKER_ID = msg.workerId;

			if (typeof msg.input === 'string')
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: Papa.parse(msg.input, msg.config),
					finished: true
				});
			}
			else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
			{
				var results = Papa.parse(msg.input, msg.config);
				if (results)
					global.postMessage({
						workerId: Papa.WORKER_ID,
						results: results,
						finished: true
					});
			}
		}

		/** Makes a deep copy of an array or object (mostly) */
		function copy(obj)
		{
			if (typeof obj !== 'object')
				return obj;
			var cpy = obj instanceof Array ? [] : {};
			for (var key in obj)
				cpy[key] = copy(obj[key]);
			return cpy;
		}

		function bindFunction(f, self)
		{
			return function() { f.apply(self, arguments); };
		}

		function isFunction(func)
		{
			return typeof func === 'function';
		}
	})(typeof window !== 'undefined' ? window : this);


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Selection save and restore module for Rangy.
	 * Saves and restores user selections using marker invisible elements in the DOM.
	 *
	 * Part of Rangy, a cross-browser JavaScript range and selection library
	 * https://github.com/timdown/rangy
	 *
	 * Depends on Rangy core.
	 *
	 * Copyright 2015, Tim Down
	 * Licensed under the MIT license.
	 * Version: 1.3.0
	 * Build date: 10 May 2015
	 */
	(function(factory, root) {
	    if (true) {
	        // AMD. Register as an anonymous module with a dependency on Rangy.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(25)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module != "undefined" && typeof exports == "object") {
	        // Node/CommonJS style
	        module.exports = factory( require("rangy") );
	    } else {
	        // No AMD or CommonJS support so we use the rangy property of root (probably the global variable)
	        factory(root.rangy);
	    }
	})(function(rangy) {
	    rangy.createModule("SaveRestore", ["WrappedRange"], function(api, module) {
	        var dom = api.dom;
	        var removeNode = dom.removeNode;
	        var isDirectionBackward = api.Selection.isDirectionBackward;
	        var markerTextChar = "\ufeff";

	        function gEBI(id, doc) {
	            return (doc || document).getElementById(id);
	        }

	        function insertRangeBoundaryMarker(range, atStart) {
	            var markerId = "selectionBoundary_" + (+new Date()) + "_" + ("" + Math.random()).slice(2);
	            var markerEl;
	            var doc = dom.getDocument(range.startContainer);

	            // Clone the Range and collapse to the appropriate boundary point
	            var boundaryRange = range.cloneRange();
	            boundaryRange.collapse(atStart);

	            // Create the marker element containing a single invisible character using DOM methods and insert it
	            markerEl = doc.createElement("span");
	            markerEl.id = markerId;
	            markerEl.style.lineHeight = "0";
	            markerEl.style.display = "none";
	            markerEl.className = "rangySelectionBoundary";
	            markerEl.appendChild(doc.createTextNode(markerTextChar));

	            boundaryRange.insertNode(markerEl);
	            return markerEl;
	        }

	        function setRangeBoundary(doc, range, markerId, atStart) {
	            var markerEl = gEBI(markerId, doc);
	            if (markerEl) {
	                range[atStart ? "setStartBefore" : "setEndBefore"](markerEl);
	                removeNode(markerEl);
	            } else {
	                module.warn("Marker element has been removed. Cannot restore selection.");
	            }
	        }

	        function compareRanges(r1, r2) {
	            return r2.compareBoundaryPoints(r1.START_TO_START, r1);
	        }

	        function saveRange(range, direction) {
	            var startEl, endEl, doc = api.DomRange.getRangeDocument(range), text = range.toString();
	            var backward = isDirectionBackward(direction);

	            if (range.collapsed) {
	                endEl = insertRangeBoundaryMarker(range, false);
	                return {
	                    document: doc,
	                    markerId: endEl.id,
	                    collapsed: true
	                };
	            } else {
	                endEl = insertRangeBoundaryMarker(range, false);
	                startEl = insertRangeBoundaryMarker(range, true);

	                return {
	                    document: doc,
	                    startMarkerId: startEl.id,
	                    endMarkerId: endEl.id,
	                    collapsed: false,
	                    backward: backward,
	                    toString: function() {
	                        return "original text: '" + text + "', new text: '" + range.toString() + "'";
	                    }
	                };
	            }
	        }

	        function restoreRange(rangeInfo, normalize) {
	            var doc = rangeInfo.document;
	            if (typeof normalize == "undefined") {
	                normalize = true;
	            }
	            var range = api.createRange(doc);
	            if (rangeInfo.collapsed) {
	                var markerEl = gEBI(rangeInfo.markerId, doc);
	                if (markerEl) {
	                    markerEl.style.display = "inline";
	                    var previousNode = markerEl.previousSibling;

	                    // Workaround for issue 17
	                    if (previousNode && previousNode.nodeType == 3) {
	                        removeNode(markerEl);
	                        range.collapseToPoint(previousNode, previousNode.length);
	                    } else {
	                        range.collapseBefore(markerEl);
	                        removeNode(markerEl);
	                    }
	                } else {
	                    module.warn("Marker element has been removed. Cannot restore selection.");
	                }
	            } else {
	                setRangeBoundary(doc, range, rangeInfo.startMarkerId, true);
	                setRangeBoundary(doc, range, rangeInfo.endMarkerId, false);
	            }

	            if (normalize) {
	                range.normalizeBoundaries();
	            }

	            return range;
	        }

	        function saveRanges(ranges, direction) {
	            var rangeInfos = [], range, doc;
	            var backward = isDirectionBackward(direction);

	            // Order the ranges by position within the DOM, latest first, cloning the array to leave the original untouched
	            ranges = ranges.slice(0);
	            ranges.sort(compareRanges);

	            for (var i = 0, len = ranges.length; i < len; ++i) {
	                rangeInfos[i] = saveRange(ranges[i], backward);
	            }

	            // Now that all the markers are in place and DOM manipulation over, adjust each range's boundaries to lie
	            // between its markers
	            for (i = len - 1; i >= 0; --i) {
	                range = ranges[i];
	                doc = api.DomRange.getRangeDocument(range);
	                if (range.collapsed) {
	                    range.collapseAfter(gEBI(rangeInfos[i].markerId, doc));
	                } else {
	                    range.setEndBefore(gEBI(rangeInfos[i].endMarkerId, doc));
	                    range.setStartAfter(gEBI(rangeInfos[i].startMarkerId, doc));
	                }
	            }

	            return rangeInfos;
	        }

	        function saveSelection(win) {
	            if (!api.isSelectionValid(win)) {
	                module.warn("Cannot save selection. This usually happens when the selection is collapsed and the selection document has lost focus.");
	                return null;
	            }
	            var sel = api.getSelection(win);
	            var ranges = sel.getAllRanges();
	            var backward = (ranges.length == 1 && sel.isBackward());

	            var rangeInfos = saveRanges(ranges, backward);

	            // Ensure current selection is unaffected
	            if (backward) {
	                sel.setSingleRange(ranges[0], backward);
	            } else {
	                sel.setRanges(ranges);
	            }

	            return {
	                win: win,
	                rangeInfos: rangeInfos,
	                restored: false
	            };
	        }

	        function restoreRanges(rangeInfos) {
	            var ranges = [];

	            // Ranges are in reverse order of appearance in the DOM. We want to restore earliest first to avoid
	            // normalization affecting previously restored ranges.
	            var rangeCount = rangeInfos.length;

	            for (var i = rangeCount - 1; i >= 0; i--) {
	                ranges[i] = restoreRange(rangeInfos[i], true);
	            }

	            return ranges;
	        }

	        function restoreSelection(savedSelection, preserveDirection) {
	            if (!savedSelection.restored) {
	                var rangeInfos = savedSelection.rangeInfos;
	                var sel = api.getSelection(savedSelection.win);
	                var ranges = restoreRanges(rangeInfos), rangeCount = rangeInfos.length;

	                if (rangeCount == 1 && preserveDirection && api.features.selectionHasExtend && rangeInfos[0].backward) {
	                    sel.removeAllRanges();
	                    sel.addRange(ranges[0], true);
	                } else {
	                    sel.setRanges(ranges);
	                }

	                savedSelection.restored = true;
	            }
	        }

	        function removeMarkerElement(doc, markerId) {
	            var markerEl = gEBI(markerId, doc);
	            if (markerEl) {
	                removeNode(markerEl);
	            }
	        }

	        function removeMarkers(savedSelection) {
	            var rangeInfos = savedSelection.rangeInfos;
	            for (var i = 0, len = rangeInfos.length, rangeInfo; i < len; ++i) {
	                rangeInfo = rangeInfos[i];
	                if (rangeInfo.collapsed) {
	                    removeMarkerElement(savedSelection.doc, rangeInfo.markerId);
	                } else {
	                    removeMarkerElement(savedSelection.doc, rangeInfo.startMarkerId);
	                    removeMarkerElement(savedSelection.doc, rangeInfo.endMarkerId);
	                }
	            }
	        }

	        api.util.extend(api, {
	            saveRange: saveRange,
	            restoreRange: restoreRange,
	            saveRanges: saveRanges,
	            restoreRanges: restoreRanges,
	            saveSelection: saveSelection,
	            restoreSelection: restoreSelection,
	            removeMarkerElement: removeMarkerElement,
	            removeMarkers: removeMarkers
	        });
	    });
	    
	    return rangy;
	}, this);

/***/ },
/* 193 */
/***/ function(module, exports) {

	/**
	 * Restful Resources service for AngularJS apps
	 * @version v1.5.2 - 2016-02-08 * @link https://github.com/mgonto/restangular
	 * @author Martin Gontovnikas <martin@gon.to>
	 * @license MIT License, http://www.opensource.org/licenses/MIT
	 */!function(){var a=angular.module("restangular",[]);a.provider("Restangular",function(){var a={};a.init=function(a,b){function c(a,b,c,d){var e={};return _.each(_.keys(d),function(f){var g=d[f];g.params=_.extend({},g.params,a.defaultRequestParams[g.method.toLowerCase()]),_.isEmpty(g.params)&&delete g.params,a.isSafe(g.method)?e[f]=function(){return b(_.extend(g,{url:c}))}:e[f]=function(a){return b(_.extend(g,{url:c,data:a}))}}),e}a.configuration=b;var d=["get","head","options","trace","getlist"];b.isSafe=function(a){return _.includes(d,a.toLowerCase())};var e=/^https?:\/\//i;b.isAbsoluteUrl=function(a){return _.isUndefined(b.absoluteUrl)||_.isNull(b.absoluteUrl)?a&&e.test(a):b.absoluteUrl},b.absoluteUrl=_.isUndefined(b.absoluteUrl)?!0:b.absoluteUrl,a.setSelfLinkAbsoluteUrl=function(a){b.absoluteUrl=a},b.baseUrl=_.isUndefined(b.baseUrl)?"":b.baseUrl,a.setBaseUrl=function(a){return b.baseUrl=/\/$/.test(a)?a.substring(0,a.length-1):a,this},b.extraFields=b.extraFields||[],a.setExtraFields=function(a){return b.extraFields=a,this},b.defaultHttpFields=b.defaultHttpFields||{},a.setDefaultHttpFields=function(a){return b.defaultHttpFields=a,this},b.withHttpValues=function(a,c){return _.defaults(c,a,b.defaultHttpFields)},b.encodeIds=_.isUndefined(b.encodeIds)?!0:b.encodeIds,a.setEncodeIds=function(a){b.encodeIds=a},b.defaultRequestParams=b.defaultRequestParams||{get:{},post:{},put:{},remove:{},common:{}},a.setDefaultRequestParams=function(a,c){var d=[],e=c||a;return _.isUndefined(c)?d.push("common"):_.isArray(a)?d=a:d.push(a),_.each(d,function(a){b.defaultRequestParams[a]=e}),this},a.requestParams=b.defaultRequestParams,b.defaultHeaders=b.defaultHeaders||{},a.setDefaultHeaders=function(c){return b.defaultHeaders=c,a.defaultHeaders=b.defaultHeaders,this},a.defaultHeaders=b.defaultHeaders,b.methodOverriders=b.methodOverriders||[],a.setMethodOverriders=function(a){var c=_.extend([],a);return b.isOverridenMethod("delete",c)&&c.push("remove"),b.methodOverriders=c,this},b.jsonp=_.isUndefined(b.jsonp)?!1:b.jsonp,a.setJsonp=function(a){b.jsonp=a},b.isOverridenMethod=function(a,c){var d=c||b.methodOverriders;return!_.isUndefined(_.find(d,function(b){return b.toLowerCase()===a.toLowerCase()}))},b.urlCreator=b.urlCreator||"path",a.setUrlCreator=function(a){if(!_.has(b.urlCreatorFactory,a))throw new Error("URL Path selected isn't valid");return b.urlCreator=a,this},b.restangularFields=b.restangularFields||{id:"id",route:"route",parentResource:"parentResource",restangularCollection:"restangularCollection",cannonicalId:"__cannonicalId",etag:"restangularEtag",selfLink:"href",get:"get",getList:"getList",put:"put",post:"post",remove:"remove",head:"head",trace:"trace",options:"options",patch:"patch",getRestangularUrl:"getRestangularUrl",getRequestedUrl:"getRequestedUrl",putElement:"putElement",addRestangularMethod:"addRestangularMethod",getParentList:"getParentList",clone:"clone",ids:"ids",httpConfig:"_$httpConfig",reqParams:"reqParams",one:"one",all:"all",several:"several",oneUrl:"oneUrl",allUrl:"allUrl",customPUT:"customPUT",customPOST:"customPOST",customDELETE:"customDELETE",customGET:"customGET",customGETLIST:"customGETLIST",customOperation:"customOperation",doPUT:"doPUT",doPOST:"doPOST",doDELETE:"doDELETE",doGET:"doGET",doGETLIST:"doGETLIST",fromServer:"fromServer",withConfig:"withConfig",withHttpConfig:"withHttpConfig",singleOne:"singleOne",plain:"plain",save:"save",restangularized:"restangularized"},a.setRestangularFields=function(a){return b.restangularFields=_.extend(b.restangularFields,a),this},b.isRestangularized=function(a){return!!a[b.restangularFields.restangularized]},b.setFieldToElem=function(a,b,c){var d=a.split("."),e=b;return _.each(_.initial(d),function(a){e[a]={},e=e[a]}),e[_.last(d)]=c,this},b.getFieldFromElem=function(a,b){var c=a.split("."),d=b;return _.each(c,function(a){d&&(d=d[a])}),angular.copy(d)},b.setIdToElem=function(a,c){return b.setFieldToElem(b.restangularFields.id,a,c),this},b.getIdFromElem=function(a){return b.getFieldFromElem(b.restangularFields.id,a)},b.isValidId=function(a){return""!==a&&!_.isUndefined(a)&&!_.isNull(a)},b.setUrlToElem=function(a,c){return b.setFieldToElem(b.restangularFields.selfLink,a,c),this},b.getUrlFromElem=function(a){return b.getFieldFromElem(b.restangularFields.selfLink,a)},b.useCannonicalId=_.isUndefined(b.useCannonicalId)?!1:b.useCannonicalId,a.setUseCannonicalId=function(a){return b.useCannonicalId=a,this},b.getCannonicalIdFromElem=function(a){var c=a[b.restangularFields.cannonicalId],d=b.isValidId(c)?c:b.getIdFromElem(a);return d},b.responseInterceptors=b.responseInterceptors||[],b.defaultResponseInterceptor=function(a){return a},b.responseExtractor=function(a,c,d,e,f,g){var h=angular.copy(b.responseInterceptors);h.push(b.defaultResponseInterceptor);var i=a;return _.each(h,function(a){i=a(i,c,d,e,f,g)}),i},a.addResponseInterceptor=function(a){return b.responseInterceptors.push(a),this},b.errorInterceptors=b.errorInterceptors||[],a.addErrorInterceptor=function(a){return b.errorInterceptors.push(a),this},a.setResponseInterceptor=a.addResponseInterceptor,a.setResponseExtractor=a.addResponseInterceptor,a.setErrorInterceptor=a.addErrorInterceptor,b.requestInterceptors=b.requestInterceptors||[],b.defaultInterceptor=function(a,b,c,d,e,f,g){return{element:a,headers:e,params:f,httpConfig:g}},b.fullRequestInterceptor=function(a,c,d,e,f,g,h){var i=angular.copy(b.requestInterceptors),j=b.defaultInterceptor(a,c,d,e,f,g,h);return _.reduce(i,function(a,b){return _.extend(a,b(a.element,c,d,e,a.headers,a.params,a.httpConfig))},j)},a.addRequestInterceptor=function(a){return b.requestInterceptors.push(function(b,c,d,e,f,g,h){return{headers:f,params:g,element:a(b,c,d,e),httpConfig:h}}),this},a.setRequestInterceptor=a.addRequestInterceptor,a.addFullRequestInterceptor=function(a){return b.requestInterceptors.push(a),this},a.setFullRequestInterceptor=a.addFullRequestInterceptor,b.onBeforeElemRestangularized=b.onBeforeElemRestangularized||function(a){return a},a.setOnBeforeElemRestangularized=function(a){return b.onBeforeElemRestangularized=a,this},a.setRestangularizePromiseInterceptor=function(a){return b.restangularizePromiseInterceptor=a,this},b.onElemRestangularized=b.onElemRestangularized||function(a){return a},a.setOnElemRestangularized=function(a){return b.onElemRestangularized=a,this},b.shouldSaveParent=b.shouldSaveParent||function(){return!0},a.setParentless=function(a){return _.isArray(a)?b.shouldSaveParent=function(b){return!_.includes(a,b)}:_.isBoolean(a)&&(b.shouldSaveParent=function(){return!a}),this},b.suffix=_.isUndefined(b.suffix)?null:b.suffix,a.setRequestSuffix=function(a){return b.suffix=a,this},b.transformers=b.transformers||{},a.addElementTransformer=function(c,d,e){var f=null,g=null;2===arguments.length?g=d:(g=e,f=d);var h=b.transformers[c];return h||(h=b.transformers[c]=[]),h.push(function(a,b){return _.isNull(f)||a===f?g(b):b}),a},a.extendCollection=function(b,c){return a.addElementTransformer(b,!0,c)},a.extendModel=function(b,c){return a.addElementTransformer(b,!1,c)},b.transformElem=function(a,c,d,e,f){if(!f&&!b.transformLocalElements&&!a[b.restangularFields.fromServer])return a;var g=b.transformers[d],h=a;return g&&_.each(g,function(a){h=a(c,h)}),b.onElemRestangularized(h,c,d,e)},b.transformLocalElements=_.isUndefined(b.transformLocalElements)?!1:b.transformLocalElements,a.setTransformOnlyServerElements=function(a){b.transformLocalElements=!a},b.fullResponse=_.isUndefined(b.fullResponse)?!1:b.fullResponse,a.setFullResponse=function(a){return b.fullResponse=a,this},b.urlCreatorFactory={};var f=function(){};f.prototype.setConfig=function(a){return this.config=a,this},f.prototype.parentsArray=function(a){for(var b=[];a;)b.push(a),a=a[this.config.restangularFields.parentResource];return b.reverse()},f.prototype.resource=function(a,d,e,f,g,h,i,j){var k=_.defaults(g||{},this.config.defaultRequestParams.common),l=_.defaults(f||{},this.config.defaultHeaders);i&&(b.isSafe(j)?l["If-None-Match"]=i:l["If-Match"]=i);var m=this.base(a);if(h){var n="";/\/$/.test(m)||(n+="/"),n+=h,m+=n}return this.config.suffix&&-1===m.indexOf(this.config.suffix,m.length-this.config.suffix.length)&&!this.config.getUrlFromElem(a)&&(m+=this.config.suffix),a[this.config.restangularFields.httpConfig]=void 0,c(this.config,d,m,{getList:this.config.withHttpValues(e,{method:"GET",params:k,headers:l}),get:this.config.withHttpValues(e,{method:"GET",params:k,headers:l}),jsonp:this.config.withHttpValues(e,{method:"jsonp",params:k,headers:l}),put:this.config.withHttpValues(e,{method:"PUT",params:k,headers:l}),post:this.config.withHttpValues(e,{method:"POST",params:k,headers:l}),remove:this.config.withHttpValues(e,{method:"DELETE",params:k,headers:l}),head:this.config.withHttpValues(e,{method:"HEAD",params:k,headers:l}),trace:this.config.withHttpValues(e,{method:"TRACE",params:k,headers:l}),options:this.config.withHttpValues(e,{method:"OPTIONS",params:k,headers:l}),patch:this.config.withHttpValues(e,{method:"PATCH",params:k,headers:l})})};var g=function(){};g.prototype=new f,g.prototype.normalizeUrl=function(a){var b=/(http[s]?:\/\/)?(.*)?/.exec(a);return b[2]=b[2].replace(/[\\\/]+/g,"/"),"undefined"!=typeof b[1]?b[1]+b[2]:b[2]},g.prototype.base=function(a){var c=this;return _.reduce(this.parentsArray(a),function(a,d){var e,f=c.config.getUrlFromElem(d);if(f){if(c.config.isAbsoluteUrl(f))return f;e=f}else if(e=d[c.config.restangularFields.route],d[c.config.restangularFields.restangularCollection]){var g=d[c.config.restangularFields.ids];g&&(e+="/"+g.join(","))}else{var h;h=c.config.useCannonicalId?c.config.getCannonicalIdFromElem(d):c.config.getIdFromElem(d),b.isValidId(h)&&!d.singleOne&&(e+="/"+(c.config.encodeIds?encodeURIComponent(h):h))}return a=a.replace(/\/$/,"")+"/"+e,c.normalizeUrl(a)},this.config.baseUrl)},g.prototype.fetchUrl=function(a,b){var c=this.base(a);return b&&(c+="/"+b),c},g.prototype.fetchRequestedUrl=function(a,c){function d(a){var b=[];for(var c in a)a.hasOwnProperty(c)&&b.push(c);return b.sort()}function e(a,b,c){for(var e=d(a),f=0;f<e.length;f++)b.call(c,a[e[f]],e[f]);return e}function f(a,b){return encodeURIComponent(a).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,b?"%20":"+")}var g=this.fetchUrl(a,c),h=a[b.restangularFields.reqParams];if(!h)return g+(this.config.suffix||"");var i=[];return e(h,function(a,b){null!==a&&void 0!==a&&(angular.isArray(a)||(a=[a]),angular.forEach(a,function(a){angular.isObject(a)&&(a=angular.toJson(a)),i.push(f(b)+"="+f(a))}))}),g+(this.config.suffix||"")+(-1===g.indexOf("?")?"?":"&")+i.join("&")},b.urlCreatorFactory.path=g};var b={};a.init(this,b),this.$get=["$http","$q",function(c,d){function e(b){function f(a,c,d,e,f){if(c[b.restangularFields.route]=d,c[b.restangularFields.getRestangularUrl]=_.bind(P.fetchUrl,P,c),c[b.restangularFields.getRequestedUrl]=_.bind(P.fetchRequestedUrl,P,c),c[b.restangularFields.addRestangularMethod]=_.bind(L,c),c[b.restangularFields.clone]=_.bind(r,c,c),c[b.restangularFields.reqParams]=_.isEmpty(e)?null:e,c[b.restangularFields.withHttpConfig]=_.bind(z,c),c[b.restangularFields.plain]=_.bind(p,c,c),c[b.restangularFields.restangularized]=!0,c[b.restangularFields.one]=_.bind(g,c,c),c[b.restangularFields.all]=_.bind(h,c,c),c[b.restangularFields.several]=_.bind(i,c,c),c[b.restangularFields.oneUrl]=_.bind(j,c,c),c[b.restangularFields.allUrl]=_.bind(k,c,c),c[b.restangularFields.fromServer]=!!f,a&&b.shouldSaveParent(d)){var l=b.getIdFromElem(a),m=b.getUrlFromElem(a),n=_.union(_.values(_.pick(b.restangularFields,["route","singleOne","parentResource"])),b.extraFields),o=_.pick(a,n);b.isValidId(l)&&b.setIdToElem(o,l,d),b.isValidId(m)&&b.setUrlToElem(o,m,d),c[b.restangularFields.parentResource]=o}else c[b.restangularFields.parentResource]=null;return c}function g(a,c,d,e){var f;if(_.isNumber(c)||_.isNumber(a))throw f="You're creating a Restangular entity with the number ",f+="instead of the route or the parent. For example, you can't call .one(12).",new Error(f);if(_.isUndefined(c))throw f="You're creating a Restangular entity either without the path. ",f+="For example you can't call .one(). Please check if your arguments are valid.",new Error(f);var g={};return b.setIdToElem(g,d,c),b.setFieldToElem(b.restangularFields.singleOne,g,e),s(a,g,c,!1)}function h(a,b){return t(a,[],b,!1)}function i(a,c){var d=[];return d[b.restangularFields.ids]=Array.prototype.splice.call(arguments,2),t(a,d,c,!1)}function j(a,c,d){if(!c)throw new Error("Route is mandatory when creating new Restangular objects.");var e={};return b.setUrlToElem(e,d,c),s(a,e,c,!1)}function k(a,c,d){if(!c)throw new Error("Route is mandatory when creating new Restangular objects.");var e={};return b.setUrlToElem(e,d,c),t(a,e,c,!1)}function l(a,c,d){return a.call=_.bind(m,a),a.get=_.bind(n,a),a[b.restangularFields.restangularCollection]=c,c&&(a.push=_.bind(m,a,"push")),a.$object=d,b.restangularizePromiseInterceptor&&b.restangularizePromiseInterceptor(a),a}function m(a){var c=d.defer(),e=arguments,f={};return this.then(function(b){var d=Array.prototype.slice.call(e,1),g=b[a];g.apply(b,d),f=b,c.resolve(b)}),l(c.promise,this[b.restangularFields.restangularCollection],f)}function n(a){var c=d.defer(),e={};return this.then(function(b){e=b[a],c.resolve(e)}),l(c.promise,this[b.restangularFields.restangularCollection],e)}function o(a,c,d,e){return _.extend(e,d),b.fullResponse?a.resolve(_.extend(c,{data:d})):void a.resolve(d)}function p(a){if(_.isArray(a)){var c=[];return _.each(a,function(a){c.push(b.isRestangularized(a)?p(a):a)}),c}return _.omit(a,_.values(_.omit(b.restangularFields,"id")))}function q(a){a[b.restangularFields.customOperation]=_.bind(K,a),_.each(["put","post","get","delete"],function(b){_.each(["do","custom"],function(c){var d,e="delete"===b?"remove":b,f=c+b.toUpperCase();d="put"!==e&&"post"!==e?K:function(a,b,c,d,e){return _.bind(K,this)(a,c,d,e,b)},a[f]=_.bind(d,a,e)})}),a[b.restangularFields.customGETLIST]=_.bind(y,a),a[b.restangularFields.doGETLIST]=a[b.restangularFields.customGETLIST]}function r(a,c){var d=angular.copy(a,c);return s(d[b.restangularFields.parentResource],d,d[b.restangularFields.route],!0)}function s(a,c,d,e,g,h){var i=b.onBeforeElemRestangularized(c,!1,d),j=f(a,i,d,h,e);return b.useCannonicalId&&(j[b.restangularFields.cannonicalId]=b.getIdFromElem(j)),g&&(j[b.restangularFields.getParentList]=function(){return g}),j[b.restangularFields.restangularCollection]=!1,j[b.restangularFields.get]=_.bind(C,j),j[b.restangularFields.getList]=_.bind(y,j),j[b.restangularFields.put]=_.bind(E,j),j[b.restangularFields.post]=_.bind(F,j),j[b.restangularFields.remove]=_.bind(D,j),j[b.restangularFields.head]=_.bind(G,j),j[b.restangularFields.trace]=_.bind(H,j),j[b.restangularFields.options]=_.bind(I,j),j[b.restangularFields.patch]=_.bind(J,j),j[b.restangularFields.save]=_.bind(A,j),q(j),b.transformElem(j,!1,d,O,!0)}function t(a,c,d,e,g){var h=b.onBeforeElemRestangularized(c,!0,d),i=f(a,h,d,g,e);return i[b.restangularFields.restangularCollection]=!0,i[b.restangularFields.post]=_.bind(F,i,null),i[b.restangularFields.remove]=_.bind(D,i),i[b.restangularFields.head]=_.bind(G,i),i[b.restangularFields.trace]=_.bind(H,i),i[b.restangularFields.putElement]=_.bind(w,i),i[b.restangularFields.options]=_.bind(I,i),i[b.restangularFields.patch]=_.bind(J,i),i[b.restangularFields.get]=_.bind(v,i),i[b.restangularFields.getList]=_.bind(y,i,null),q(i),b.transformElem(i,!0,d,O,!0)}function u(a,b,c){var d=t(a,b,c,!1);return _.each(d,function(b){s(a,b,c,!1)}),d}function v(a,b,c){return this.customGET(a.toString(),b,c)}function w(a,c,e){var f=this,g=this[a],h=d.defer(),i=[];return i=b.transformElem(i,!0,g[b.restangularFields.route],O),g.put(c,e).then(function(b){var c=r(f);c[a]=b,i=c,h.resolve(c)},function(a){h.reject(a)}),l(h.promise,!0,i)}function x(a,c,d,e,f,g){var h=b.responseExtractor(a,c,d,e,f,g),i=f.headers("ETag");return h&&i&&(h[b.restangularFields.etag]=i),h}function y(a,e,f){var g=this,h=d.defer(),i="getList",j=P.fetchUrl(this,a),k=a||g[b.restangularFields.route],m=b.fullRequestInterceptor(null,i,k,j,f||{},e||{},this[b.restangularFields.httpConfig]||{}),n=[];n=b.transformElem(n,!0,k,O);var p="getList";b.jsonp&&(p="jsonp");var q=function(c){var d=c.data,e=c.config.params,f=x(d,i,k,j,c,h);if((_.isUndefined(f)||""===f)&&(f=[]),!_.isArray(f))throw new Error("Response for getList SHOULD be an array and not an object or something else");var l=_.map(f,function(c){return g[b.restangularFields.restangularCollection]?s(g[b.restangularFields.parentResource],c,g[b.restangularFields.route],!0,f):s(g,c,a,!0,f)});l=_.extend(f,l),g[b.restangularFields.restangularCollection]?o(h,c,t(g[b.restangularFields.parentResource],l,g[b.restangularFields.route],!0,e),n):o(h,c,t(g,l,a,!0,e),n)};return P.resource(this,c,m.httpConfig,m.headers,m.params,a,this[b.restangularFields.etag],i)[p]().then(q,function(a){304===a.status&&g[b.restangularFields.restangularCollection]?o(h,a,g,n):_.every(b.errorInterceptors,function(b){return b(a,h,q)!==!1})&&h.reject(a)}),l(h.promise,!0,n)}function z(a){return this[b.restangularFields.httpConfig]=a,this}function A(a,c){return this[b.restangularFields.fromServer]?this[b.restangularFields.put](a,c):_.bind(B,this)("post",void 0,a,void 0,c)}function B(a,e,f,g,h){var i=this,j=d.defer(),k=f||{},m=e||this[b.restangularFields.route],n=P.fetchUrl(this,e),q=g||this,r=q[b.restangularFields.etag]||("post"!==a?this[b.restangularFields.etag]:null);_.isObject(q)&&b.isRestangularized(q)&&(q=p(q));var t=b.fullRequestInterceptor(q,a,m,n,h||{},k||{},this[b.restangularFields.httpConfig]||{}),u={};u=b.transformElem(u,!1,m,O);var v=function(c){var d=c.data,e=c.config.params,f=x(d,a,m,n,c,j);if(f){var g;"post"!==a||i[b.restangularFields.restangularCollection]?(g=s(i[b.restangularFields.parentResource],f,i[b.restangularFields.route],!0,null,e),g[b.restangularFields.singleOne]=i[b.restangularFields.singleOne],o(j,c,g,u)):(g=s(i[b.restangularFields.parentResource],f,m,!0,null,e),o(j,c,g,u))}else o(j,c,void 0,u)},w=function(c){304===c.status&&b.isSafe(a)?o(j,c,i,u):_.every(b.errorInterceptors,function(a){return a(c,j,v)!==!1})&&j.reject(c)},y=a,z=_.extend({},t.headers),A=b.isOverridenMethod(a);return A?(y="post",z=_.extend(z,{"X-HTTP-Method-Override":"remove"===a?"DELETE":a.toUpperCase()})):b.jsonp&&"get"===y&&(y="jsonp"),b.isSafe(a)?A?P.resource(this,c,t.httpConfig,z,t.params,e,r,y)[y]({}).then(v,w):P.resource(this,c,t.httpConfig,z,t.params,e,r,y)[y]().then(v,w):P.resource(this,c,t.httpConfig,z,t.params,e,r,y)[y](t.element).then(v,w),l(j.promise,!1,u)}function C(a,b){return _.bind(B,this)("get",void 0,a,void 0,b)}function D(a,b){return _.bind(B,this)("remove",void 0,a,void 0,b)}function E(a,b){return _.bind(B,this)("put",void 0,a,void 0,b)}function F(a,b,c,d){return _.bind(B,this)("post",a,c,b,d)}function G(a,b){return _.bind(B,this)("head",void 0,a,void 0,b)}function H(a,b){return _.bind(B,this)("trace",void 0,a,void 0,b)}function I(a,b){return _.bind(B,this)("options",void 0,a,void 0,b)}function J(a,b,c){return _.bind(B,this)("patch",void 0,b,a,c)}function K(a,b,c,d,e){return _.bind(B,this)(a,b,c,e,d)}function L(a,c,d,e,f,g){var h;h="getList"===c?_.bind(y,this,d):_.bind(K,this,c,d);var i=function(a,b,c){var d=_.defaults({params:a,headers:b,elem:c},{params:e,headers:f,elem:g});return h(d.params,d.headers,d.elem)};b.isSafe(c)?this[a]=i:this[a]=function(a,b,c){return i(b,c,a)}}function M(c){var d=angular.copy(_.omit(b,"configuration"));return a.init(d,d),c(d),e(d)}function N(a,c){var d=_.values(b.restangularFields),e={},f=(c||O).all(a);e.one=_.bind(g,c||O,c,a),e.post=_.bind(f.post,f),e.getList=_.bind(f.getList,f);for(var h in f)f.hasOwnProperty(h)&&_.isFunction(f[h])&&!_.includes(d,h)&&(e[h]=_.bind(f[h],f));return e}var O={},P=new b.urlCreatorFactory[b.urlCreator];return P.setConfig(b),a.init(O,b),O.copy=_.bind(r,O),O.service=_.bind(N,O),O.withConfig=_.bind(M,O),O.one=_.bind(g,O,null),O.all=_.bind(h,O,null),O.several=_.bind(i,O,null),O.oneUrl=_.bind(j,O,null),O.allUrl=_.bind(k,O,null),O.stripRestangular=_.bind(p,O),O.restangularizeElement=_.bind(s,O),O.restangularizeCollection=_.bind(u,O),O}return e(b)}]})}();

/***/ },
/* 194 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.3.10
	 * (c) 2010-2014 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';

	var $sanitizeMinErr = angular.$$minErr('$sanitize');

	/**
	 * @ngdoc module
	 * @name ngSanitize
	 * @description
	 *
	 * # ngSanitize
	 *
	 * The `ngSanitize` module provides functionality to sanitize HTML.
	 *
	 *
	 * <div doc-module-components="ngSanitize"></div>
	 *
	 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
	 */

	/*
	 * HTML Parser By Misko Hevery (misko@hevery.com)
	 * based on:  HTML Parser By John Resig (ejohn.org)
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 *
	 * // Use like so:
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 */


	/**
	 * @ngdoc service
	 * @name $sanitize
	 * @kind function
	 *
	 * @description
	 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
	 *   then serialized back to properly escaped html string. This means that no unsafe input can make
	 *   it into the returned string, however, since our parser is more strict than a typical browser
	 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
	 *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
	 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
	 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
	 *
	 * @param {string} html HTML input.
	 * @returns {string} Sanitized HTML.
	 *
	 * @example
	   <example module="sanitizeExample" deps="angular-sanitize.js">
	   <file name="index.html">
	     <script>
	         angular.module('sanitizeExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
	             $scope.snippet =
	               '<p style="color:blue">an html\n' +
	               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
	               'snippet</p>';
	             $scope.deliberatelyTrustDangerousSnippet = function() {
	               return $sce.trustAsHtml($scope.snippet);
	             };
	           }]);
	     </script>
	     <div ng-controller="ExampleController">
	        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Directive</td>
	           <td>How</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="bind-html-with-sanitize">
	           <td>ng-bind-html</td>
	           <td>Automatically uses $sanitize</td>
	           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind-html="snippet"></div></td>
	         </tr>
	         <tr id="bind-html-with-trust">
	           <td>ng-bind-html</td>
	           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
	           <td>
	           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
	&lt;/div&gt;</pre>
	           </td>
	           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
	         </tr>
	         <tr id="bind-default">
	           <td>ng-bind</td>
	           <td>Automatically escapes</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	       </div>
	   </file>
	   <file name="protractor.js" type="protractor">
	     it('should sanitize the html snippet by default', function() {
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
	     });

	     it('should inline raw snippet if bound to a trusted value', function() {
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
	         toBe("<p style=\"color:blue\">an html\n" +
	              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
	              "snippet</p>");
	     });

	     it('should escape snippet without any filter', function() {
	       expect(element(by.css('#bind-default div')).getInnerHtml()).
	         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
	              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
	              "snippet&lt;/p&gt;");
	     });

	     it('should update', function() {
	       element(by.model('snippet')).clear();
	       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('new <b>text</b>');
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
	         'new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
	         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
	     });
	   </file>
	   </example>
	 */
	function $SanitizeProvider() {
	  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
	    return function(html) {
	      if (typeof arguments[1] != 'undefined') {
	        arguments[1].version = 'taSanitize';
	      }
	      var buf = [];
	      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
	        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
	      }));
	      return buf.join('');
	    };
	  }];
	}

	function sanitizeText(chars) {
	  var buf = [];
	  var writer = htmlSanitizeWriter(buf, angular.noop);
	  writer.chars(chars);
	  return buf.join('');
	}


	// Regular Expressions for parsing tags and attributes
	var START_TAG_REGEXP =
	       /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
	  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
	  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
	  BEGIN_TAG_REGEXP = /^</,
	  BEGING_END_TAGE_REGEXP = /^<\//,
	  COMMENT_REGEXP = /<!--(.*?)-->/g,
	  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
	  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
	  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	  // Match everything outside of normal chars and " (quote character)
	  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;


	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements

	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var voidElements = makeMap("area,br,col,hr,img,wbr,input");

	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
	    optionalEndTagInlineElements = makeMap("rp,rt"),
	    optionalEndTagElements = angular.extend({},
	                                            optionalEndTagInlineElements,
	                                            optionalEndTagBlockElements);

	// Safe Block Elements - HTML5
	var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
	        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
	        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));

	// Inline Elements - HTML5
	var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
	        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
	        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));

	// SVG Elements
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
	var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," +
	        "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," +
	        "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," +
	        "stop,svg,switch,text,title,tspan,use");

	// Special Elements (can contain anything)
	var specialElements = makeMap("script,style");

	var validElements = angular.extend({},
	                                   voidElements,
	                                   blockElements,
	                                   inlineElements,
	                                   optionalEndTagElements,
	                                   svgElements);

	//Attributes that have href and hence need to be sanitized
	var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");

	var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,'+
	    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,'+
	    'id,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,'+
	    'scope,scrolling,shape,size,span,start,summary,target,title,type,'+
	    'valign,value,vspace,width');

	// SVG attributes (without "id" and "name" attributes)
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
	var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
	    'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' +
	    'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' +
	    'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' +
	    'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' +
	    'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' +
	    'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' +
	    'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' +
	    'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' +
	    'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' +
	    'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +
	    'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' +
	    'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' +
	    'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' +
	    'xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' +
	    'zoomAndPan');

	var validAttrs = angular.extend({},
	                                uriAttrs,
	                                svgAttrs,
	                                htmlAttrs);

	function makeMap(str) {
	  var obj = {}, items = str.split(','), i;
	  for (i = 0; i < items.length; i++) obj[items[i]] = true;
	  return obj;
	}


	/**
	 * @example
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 * @param {string} html string
	 * @param {object} handler
	 */
	function htmlParser(html, handler) {
	  if (typeof html !== 'string') {
	    if (html === null || typeof html === 'undefined') {
	      html = '';
	    } else {
	      html = '' + html;
	    }
	  }
	  var index, chars, match, stack = [], last = html, text;
	  stack.last = function() { return stack[ stack.length - 1 ]; };

	  while (html) {
	    text = '';
	    chars = true;

	    // Make sure we're not in a script or style element
	    if (!stack.last() || !specialElements[ stack.last() ]) {

	      // Comment
	      if (html.indexOf("<!--") === 0) {
	        // comments containing -- are not allowed unless they terminate the comment
	        index = html.indexOf("--", 4);

	        if (index >= 0 && html.lastIndexOf("-->", index) === index) {
	          if (handler.comment) handler.comment(html.substring(4, index));
	          html = html.substring(index + 3);
	          chars = false;
	        }
	      // DOCTYPE
	      } else if (DOCTYPE_REGEXP.test(html)) {
	        match = html.match(DOCTYPE_REGEXP);

	        if (match) {
	          html = html.replace(match[0], '');
	          chars = false;
	        }
	      // end tag
	      } else if (BEGING_END_TAGE_REGEXP.test(html)) {
	        match = html.match(END_TAG_REGEXP);

	        if (match) {
	          html = html.substring(match[0].length);
	          match[0].replace(END_TAG_REGEXP, parseEndTag);
	          chars = false;
	        }

	      // start tag
	      } else if (BEGIN_TAG_REGEXP.test(html)) {
	        match = html.match(START_TAG_REGEXP);

	        if (match) {
	          // We only have a valid start-tag if there is a '>'.
	          if (match[4]) {
	            html = html.substring(match[0].length);
	            match[0].replace(START_TAG_REGEXP, parseStartTag);
	          }
	          chars = false;
	        } else {
	          // no ending tag found --- this piece should be encoded as an entity.
	          text += '<';
	          html = html.substring(1);
	        }
	      }

	      if (chars) {
	        index = html.indexOf("<");

	        text += index < 0 ? html : html.substring(0, index);
	        html = index < 0 ? "" : html.substring(index);

	        if (handler.chars) handler.chars(decodeEntities(text));
	      }

	    } else {
	      html = html.replace(new RegExp("([^]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
	        function(all, text) {
	          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");

	          if (handler.chars) handler.chars(decodeEntities(text));

	          return "";
	      });

	      parseEndTag("", stack.last());
	    }

	    if (html == last) {
	      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
	                                        "of html: {0}", html);
	    }
	    last = html;
	  }

	  // Clean up any remaining tags
	  parseEndTag();

	  function parseStartTag(tag, tagName, rest, unary) {
	    tagName = angular.lowercase(tagName);
	    if (blockElements[ tagName ]) {
	      while (stack.last() && inlineElements[ stack.last() ]) {
	        parseEndTag("", stack.last());
	      }
	    }

	    if (optionalEndTagElements[ tagName ] && stack.last() == tagName) {
	      parseEndTag("", tagName);
	    }

	    unary = voidElements[ tagName ] || !!unary;

	    if (!unary)
	      stack.push(tagName);

	    var attrs = {};

	    rest.replace(ATTR_REGEXP,
	      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
	        var value = doubleQuotedValue
	          || singleQuotedValue
	          || unquotedValue
	          || '';

	        attrs[name] = decodeEntities(value);
	    });
	    if (handler.start) handler.start(tagName, attrs, unary);
	  }

	  function parseEndTag(tag, tagName) {
	    var pos = 0, i;
	    tagName = angular.lowercase(tagName);
	    if (tagName)
	      // Find the closest opened tag of the same type
	      for (pos = stack.length - 1; pos >= 0; pos--)
	        if (stack[ pos ] == tagName)
	          break;

	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (i = stack.length - 1; i >= pos; i--)
	        if (handler.end) handler.end(stack[ i ]);

	      // Remove the open elements from the stack
	      stack.length = pos;
	    }
	  }
	}

	var hiddenPre=document.createElement("pre");
	var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
	/**
	 * decodes all entities into regular string
	 * @param value
	 * @returns {string} A string with decoded entities.
	 */
	function decodeEntities(value) {
	  if (!value) { return ''; }

	  // Note: IE8 does not preserve spaces at the start/end of innerHTML
	  // so we must capture them and reattach them afterward
	  var parts = spaceRe.exec(value);
	  var spaceBefore = parts[1];
	  var spaceAfter = parts[3];
	  var content = parts[2];
	  if (content) {
	    hiddenPre.innerHTML=content.replace(/</g,"&lt;");
	    // innerText depends on styling as it doesn't display hidden elements.
	    // Therefore, it's better to use textContent not to cause unnecessary
	    // reflows. However, IE<9 don't support textContent so the innerText
	    // fallback is necessary.
	    content = 'textContent' in hiddenPre ?
	      hiddenPre.textContent : hiddenPre.innerText;
	  }
	  return spaceBefore + content + spaceAfter;
	}

	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param value
	 * @returns {string} escaped text
	 */
	function encodeEntities(value) {
	  return value.
	    replace(/&/g, '&amp;').
	    replace(SURROGATE_PAIR_REGEXP, function(value) {
	      var hi = value.charCodeAt(0);
	      var low = value.charCodeAt(1);
	      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	    }).
	    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
	      // unsafe chars are: \u0000-\u001f \u007f-\u009f \u00ad \u0600-\u0604 \u070f \u17b4 \u17b5 \u200c-\u200f \u2028-\u202f \u2060-\u206f \ufeff \ufff0-\uffff from jslint.com/lint.html
	      // decimal values are: 0-31, 127-159, 173, 1536-1540, 1807, 6068, 6069, 8204-8207, 8232-8239, 8288-8303, 65279, 65520-65535
	      var c = value.charCodeAt(0);
	      // if unsafe character encode
	      if(c <= 159 ||
	        c == 173 ||
	        (c >= 1536 && c <= 1540) ||
	        c == 1807 ||
	        c == 6068 ||
	        c == 6069 ||
	        (c >= 8204 && c <= 8207) ||
	        (c >= 8232 && c <= 8239) ||
	        (c >= 8288 && c <= 8303) ||
	        c == 65279 ||
	        (c >= 65520 && c <= 65535)) return '&#' + c + ';';
	      return value; // avoids multilingual issues
	    }).
	    replace(/</g, '&lt;').
	    replace(/>/g, '&gt;');
	}

	var trim = (function() {
	  // native trim is way faster: http://jsperf.com/angular-trim-test
	  // but IE doesn't have it... :-(
	  // TODO: we should move this into IE/ES5 polyfill
	  if (!String.prototype.trim) {
	    return function(value) {
	      return angular.isString(value) ? value.replace(/^\s\s*/, '').replace(/\s\s*$/, '') : value;
	    };
	  }
	  return function(value) {
	    return angular.isString(value) ? value.trim() : value;
	  };
	})();

	// Custom logic for accepting certain style options only - textAngular
	// Currently allows only the color, background-color, text-align, float, width and height attributes
	// all other attributes should be easily done through classes.
	function validStyles(styleAttr){
		var result = '';
		var styleArray = styleAttr.split(';');
		angular.forEach(styleArray, function(value){
			var v = value.split(':');
			if(v.length == 2){
				var key = trim(angular.lowercase(v[0]));
				var value = trim(angular.lowercase(v[1]));
				if(
					(key === 'color' || key === 'background-color') && (
						value.match(/^rgb\([0-9%,\. ]*\)$/i)
						|| value.match(/^rgba\([0-9%,\. ]*\)$/i)
						|| value.match(/^hsl\([0-9%,\. ]*\)$/i)
						|| value.match(/^hsla\([0-9%,\. ]*\)$/i)
						|| value.match(/^#[0-9a-f]{3,6}$/i)
						|| value.match(/^[a-z]*$/i)
					)
				||
					key === 'text-align' && (
						value === 'left'
						|| value === 'right'
						|| value === 'center'
						|| value === 'justify'
					)
				||
					key === 'float' && (
						value === 'left'
						|| value === 'right'
						|| value === 'none'
					)
				||
					(key === 'width' || key === 'height') && (
						value.match(/[0-9\.]*(px|em|rem|%)/)
					)
				|| // Reference #520
					(key === 'direction' && value.match(/^ltr|rtl|initial|inherit$/))
				) result += key + ': ' + value + ';';
			}
		});
		return result;
	}

	// this function is used to manually allow specific attributes on specific tags with certain prerequisites
	function validCustomTag(tag, attrs, lkey, value){
		// catch the div placeholder for the iframe replacement
	    if (tag === 'img' && attrs['ta-insert-video']){
	        if(lkey === 'ta-insert-video' || lkey === 'allowfullscreen' || lkey === 'frameborder' || (lkey === 'contenteditable' && value === 'false')) return true;
	    }
	    return false;
	}

	/**
	 * create an HTML/XML writer which writes to buffer
	 * @param {Array} buf use buf.jain('') to get out sanitized html string
	 * @returns {object} in the form of {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * }
	 */
	function htmlSanitizeWriter(buf, uriValidator) {
	  var ignore = false;
	  var out = angular.bind(buf, buf.push);
	  return {
	    start: function(tag, attrs, unary) {
	      tag = angular.lowercase(tag);
	      if (!ignore && specialElements[tag]) {
	        ignore = tag;
	      }
	      if (!ignore && validElements[tag] === true) {
	        out('<');
	        out(tag);
	        angular.forEach(attrs, function(value, key) {
	          var lkey=angular.lowercase(key);
	          var isImage=(tag === 'img' && lkey === 'src') || (lkey === 'background');
	          if ((lkey === 'style' && (value = validStyles(value)) !== '') || validCustomTag(tag, attrs, lkey, value) || validAttrs[lkey] === true &&
	            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
	            out(' ');
	            out(key);
	            out('="');
	            out(encodeEntities(value));
	            out('"');
	          }
	        });
	        out(unary ? '/>' : '>');
	      }
	    },
	    end: function(tag) {
	        tag = angular.lowercase(tag);
	        if (!ignore && validElements[tag] === true) {
	          out('</');
	          out(tag);
	          out('>');
	        }
	        if (tag == ignore) {
	          ignore = false;
	        }
	      },
	    chars: function(chars) {
	        if (!ignore) {
	          out(encodeEntities(chars));
	        }
	      }
	  };
	}


	// define ngSanitize module and register $sanitize service
	angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);

	/* global sanitizeText: false */

	/**
	 * @ngdoc filter
	 * @name linky
	 * @kind function
	 *
	 * @description
	 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
	 * plain email address links.
	 *
	 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
	 *
	 * @param {string} text Input text.
	 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
	 * @returns {string} Html-linkified text.
	 *
	 * @usage
	   <span ng-bind-html="linky_expression | linky"></span>
	 *
	 * @example
	   <example module="linkyExample" deps="angular-sanitize.js">
	     <file name="index.html">
	       <script>
	         angular.module('linkyExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', function($scope) {
	             $scope.snippet =
	               'Pretty text with some links:\n'+
	               'http://angularjs.org/,\n'+
	               'mailto:us@somewhere.org,\n'+
	               'another@somewhere.org,\n'+
	               'and one more: ftp://127.0.0.1/.';
	             $scope.snippetWithTarget = 'http://angularjs.org/';
	           }]);
	       </script>
	       <div ng-controller="ExampleController">
	       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Filter</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="linky-filter">
	           <td>linky filter</td>
	           <td>
	             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
	           </td>
	           <td>
	             <div ng-bind-html="snippet | linky"></div>
	           </td>
	         </tr>
	         <tr id="linky-target">
	          <td>linky target</td>
	          <td>
	            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
	          </td>
	          <td>
	            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
	          </td>
	         </tr>
	         <tr id="escaped-html">
	           <td>no filter</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	     </file>
	     <file name="protractor.js" type="protractor">
	       it('should linkify the snippet with urls', function() {
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
	       });

	       it('should not linkify snippet without the linky filter', function() {
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
	       });

	       it('should update', function() {
	         element(by.model('snippet')).clear();
	         element(by.model('snippet')).sendKeys('new http://link.');
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('new http://link.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
	             .toBe('new http://link.');
	       });

	       it('should work with the target property', function() {
	        expect(element(by.id('linky-target')).
	            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
	            toBe('http://angularjs.org/');
	        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
	       });
	     </file>
	   </example>
	 */
	angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
	  var LINKY_URL_REGEXP =
	        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"”’]/,
	      MAILTO_REGEXP = /^mailto:/;

	  return function(text, target) {
	    if (!text) return text;
	    var match;
	    var raw = text;
	    var html = [];
	    var url;
	    var i;
	    while ((match = raw.match(LINKY_URL_REGEXP))) {
	      // We can not end in these as they are sometimes found at the end of the sentence
	      url = match[0];
	      // if we did not match ftp/http/www/mailto then assume mailto
	      if (!match[2] && !match[4]) {
	        url = (match[3] ? 'http://' : 'mailto:') + url;
	      }
	      i = match.index;
	      addText(raw.substr(0, i));
	      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
	      raw = raw.substring(i + match[0].length);
	    }
	    addText(raw);
	    return $sanitize(html.join(''));

	    function addText(text) {
	      if (!text) {
	        return;
	      }
	      html.push(sanitizeText(text));
	    }

	    function addLink(url, text) {
	      html.push('<a ');
	      if (angular.isDefined(target)) {
	        html.push('target="',
	                  target,
	                  '" ');
	      }
	      html.push('href="',
	                url.replace(/"/g, '&quot;'),
	                '">');
	      addText(text);
	      html.push('</a>');
	    }
	  };
	}]);


	})(window, window.angular);


/***/ },
/* 195 */
/***/ function(module, exports) {

	/*
	@license textAngular
	Author : Austin Anderson
	License : 2013 MIT
	Version 1.4.3

	See README.md or https://github.com/fraywing/textAngular/wiki for requirements and use.
	*/

	(function(){ // encapsulate all variables so they don't become global vars
	"use strict";
	// IE version detection - http://stackoverflow.com/questions/4169160/javascript-ie-detection-why-not-use-simple-conditional-comments
	// We need this as IE sometimes plays funny tricks with the contenteditable.
	// ----------------------------------------------------------
	// If you're not in IE (or IE version is less than 5) then:
	// ie === undefined
	// If you're in IE (>=5) then you can determine which version:
	// ie === 7; // IE7
	// Thus, to detect IE:
	// if (ie) {}
	// And to detect the version:
	// ie === 6 // IE6
	// ie > 7 // IE8, IE9, IE10 ...
	// ie < 9 // Anything less than IE9
	// ----------------------------------------------------------
	/* istanbul ignore next: untestable browser check */
	var _browserDetect = {
		ie: (function(){
			var undef,
				v = 3,
				div = document.createElement('div'),
				all = div.getElementsByTagName('i');

			while (
				div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
				all[0]
			);

			return v > 4 ? v : undef;
		}()),
		webkit: /AppleWebKit\/([\d.]+)/i.test(navigator.userAgent)
	};

	// fix a webkit bug, see: https://gist.github.com/shimondoodkin/1081133
	// this is set true when a blur occurs as the blur of the ta-bind triggers before the click
	var globalContentEditableBlur = false;
	/* istanbul ignore next: Browser Un-Focus fix for webkit */
	if(_browserDetect.webkit) {
		document.addEventListener("mousedown", function(_event){
			var e = _event || window.event;
			var curelement = e.target;
			if(globalContentEditableBlur && curelement !== null){
				var isEditable = false;
				var tempEl = curelement;
				while(tempEl !== null && tempEl.tagName.toLowerCase() !== 'html' && !isEditable){
					isEditable = tempEl.contentEditable === 'true';
					tempEl = tempEl.parentNode;
				}
				if(!isEditable){
					document.getElementById('textAngular-editableFix-010203040506070809').setSelectionRange(0, 0); // set caret focus to an element that handles caret focus correctly.
					curelement.focus(); // focus the wanted element.
					if (curelement.select) {
						curelement.select(); // use select to place cursor for input elements.
					}
				}
			}
			globalContentEditableBlur = false;
		}, false); // add global click handler
		angular.element(document).ready(function () {
			angular.element(document.body).append(angular.element('<input id="textAngular-editableFix-010203040506070809" class="ta-hidden-input" aria-hidden="true" unselectable="on" tabIndex="-1">'));
		});
	}

	// Gloabl to textAngular REGEXP vars for block and list elements.

	var BLOCKELEMENTS = /^(address|article|aside|audio|blockquote|canvas|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video)$/i;
	var LISTELEMENTS = /^(ul|li|ol)$/i;
	var VALIDELEMENTS = /^(address|article|aside|audio|blockquote|canvas|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video|li)$/i;

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Compatibility
	/* istanbul ignore next: trim shim for older browsers */
	if (!String.prototype.trim) {
		String.prototype.trim = function () {
			return this.replace(/^\s+|\s+$/g, '');
		};
	}

	// tests against the current jqLite/jquery implementation if this can be an element
	function validElementString(string){
		try{
			return angular.element(string).length !== 0;
		}catch(any){
			return false;
		}
	}

	/*
		Custom stylesheet for the placeholders rules.
		Credit to: http://davidwalsh.name/add-rules-stylesheets
	*/
	var sheet, addCSSRule, removeCSSRule, _addCSSRule, _removeCSSRule, _getRuleIndex;
	/* istanbul ignore else: IE <8 test*/
	if(_browserDetect.ie > 8 || _browserDetect.ie === undefined){
		var _sheets = document.styleSheets;
		/* istanbul ignore next: preference for stylesheet loaded externally */
		for(var i = 0; i < _sheets.length; i++){
			if(_sheets[i].media.length === 0 || _sheets[i].media.mediaText.match(/(all|screen)/ig)){
				if(_sheets[i].href){
					if(_sheets[i].href.match(/textangular\.(min\.|)css/ig)){
						sheet = _sheets[i];
						break;
					}
				}
			}
		}
		/* istanbul ignore next: preference for stylesheet loaded externally */
		if(!sheet){
			// this sheet is used for the placeholders later on.
			sheet = (function() {
				// Create the <style> tag
				var style = document.createElement("style");
				/* istanbul ignore else : WebKit hack :( */
				if(_browserDetect.webkit) style.appendChild(document.createTextNode(""));

				// Add the <style> element to the page, add as first so the styles can be overridden by custom stylesheets
				document.getElementsByTagName('head')[0].appendChild(style);

				return style.sheet;
			})();
		}

		// use as: addCSSRule("header", "float: left");
		addCSSRule = function(selector, rules) {
			return _addCSSRule(sheet, selector, rules);
		};
		_addCSSRule = function(_sheet, selector, rules){
			var insertIndex;
			var insertedRule;
			// This order is important as IE 11 has both cssRules and rules but they have different lengths - cssRules is correct, rules gives an error in IE 11
			/* istanbul ignore next: browser catches */
			if(_sheet.cssRules) insertIndex = Math.max(_sheet.cssRules.length - 1, 0);
			else if(_sheet.rules) insertIndex = Math.max(_sheet.rules.length - 1, 0);

			/* istanbul ignore else: untestable IE option */
			if(_sheet.insertRule) {
				_sheet.insertRule(selector + "{" + rules + "}", insertIndex);
			}
			else {
				_sheet.addRule(selector, rules, insertIndex);
			}
			/* istanbul ignore next: browser catches */
			if(sheet.rules) insertedRule = sheet.rules[insertIndex];
			else if(sheet.cssRules) insertedRule = sheet.cssRules[insertIndex];
			// return the inserted stylesheet rule
			return insertedRule;
		};

		_getRuleIndex = function(rule, rules) {
			var i, ruleIndex;
			for (i=0; i < rules.length; i++) {
				/* istanbul ignore else: check for correct rule */
				if (rules[i].cssText === rule.cssText) {
					ruleIndex = i;
					break;
				}
			}
			return ruleIndex;
		};

		removeCSSRule = function(rule){
			_removeCSSRule(sheet, rule);
		};
		/* istanbul ignore next: tests are browser specific */
		_removeCSSRule = function(sheet, rule){
			var rules = sheet.cssRules || sheet.rules;
			if(!rules || rules.length === 0) return;
			var ruleIndex = _getRuleIndex(rule, rules);
			if(sheet.removeRule){
				sheet.removeRule(ruleIndex);
			}else{
				sheet.deleteRule(ruleIndex);
			}
		};
	}

	angular.module('textAngular.factories', [])
	.factory('taBrowserTag', [function(){
		return function(tag){
			/* istanbul ignore next: ie specific test */
			if(!tag) return (_browserDetect.ie <= 8)? 'P' : 'p';
			else if(tag === '') return (_browserDetect.ie === undefined)? 'div' : (_browserDetect.ie <= 8)? 'P' : 'p';
			else return (_browserDetect.ie <= 8)? tag.toUpperCase() : tag;
		};
	}]).factory('taApplyCustomRenderers', ['taCustomRenderers', 'taDOM', function(taCustomRenderers, taDOM){
		return function(val){
			var element = angular.element('<div></div>');
			element[0].innerHTML = val;

			angular.forEach(taCustomRenderers, function(renderer){
				var elements = [];
				// get elements based on what is defined. If both defined do secondary filter in the forEach after using selector string
				if(renderer.selector && renderer.selector !== '')
					elements = element.find(renderer.selector);
				/* istanbul ignore else: shouldn't fire, if it does we're ignoring everything */
				else if(renderer.customAttribute && renderer.customAttribute !== '')
					elements = taDOM.getByAttribute(element, renderer.customAttribute);
				// process elements if any found
				angular.forEach(elements, function(_element){
					_element = angular.element(_element);
					if(renderer.selector && renderer.selector !== '' && renderer.customAttribute && renderer.customAttribute !== ''){
						if(_element.attr(renderer.customAttribute) !== undefined) renderer.renderLogic(_element);
					} else renderer.renderLogic(_element);
				});
			});

			return element[0].innerHTML;
		};
	}]).factory('taFixChrome', function(){
		// get whaterever rubbish is inserted in chrome
		// should be passed an html string, returns an html string
		var taFixChrome = function(html){
			if(!html || !angular.isString(html) || html.length <= 0) return html;
			// grab all elements with a style attibute
			var spanMatch = /<([^>\/]+?)style=("([^"]+)"|'([^']+)')([^>]*)>/ig;
			var match, styleVal, newTag, finalHtml = '', lastIndex = 0;
			while(match = spanMatch.exec(html)){
				// one of the quoted values ' or "
				/* istanbul ignore next: quotations match */
				styleVal = match[3] || match[4];
				// test for chrome inserted junk
				if(styleVal && styleVal.match(/line-height: 1.[0-9]{3,12};|color: inherit; line-height: 1.1;/i)){
					// replace original tag with new tag
					styleVal = styleVal.replace(/( |)font-family: inherit;|( |)line-height: 1.[0-9]{3,12};|( |)color: inherit;/ig, '');
					newTag = '<' + match[1].trim();
					if(styleVal.trim().length > 0) newTag += ' style=' + match[2].substring(0,1) + styleVal + match[2].substring(0,1);
					newTag += match[5].trim() + ">";
					finalHtml += html.substring(lastIndex, match.index) + newTag;
					lastIndex = match.index + match[0].length;
				}
			}
			finalHtml += html.substring(lastIndex);
			// only replace when something has changed, else we get focus problems on inserting lists
			if(lastIndex > 0){
				// replace all empty strings
				return finalHtml.replace(/<span\s?>(.*?)<\/span>(<br(\/|)>|)/ig, '$1');
			} else return html;
		};
		return taFixChrome;
	}).factory('taSanitize', ['$sanitize', function taSanitizeFactory($sanitize){

		var convert_infos = [
			{
				property: 'font-weight',
				values: [ 'bold' ],
				tag: 'b'
			},
			{
				property: 'font-style',
				values: [ 'italic' ],
				tag: 'i'
			}
		];
		
		var styleMatch = [];
		for(var i = 0; i < convert_infos.length; i++){
			var _partialStyle = '(' + convert_infos[i].property + ':\\s*(';
			for(var j = 0; j < convert_infos[i].values.length; j++){
				/* istanbul ignore next: not needed to be tested yet */
				if(j > 0) _partialStyle += '|';
				_partialStyle += convert_infos[i].values[j];
			}
			_partialStyle += ');)';
			styleMatch.push(_partialStyle);
		}
		var styleRegexString = '(' + styleMatch.join('|') + ')';
		
		function wrapNested(html, wrapTag) {
			var depth = 0;
			var lastIndex = 0;
			var match;
			var tagRegex = /<[^>]*>/ig;
			while(match = tagRegex.exec(html)){
				lastIndex = match.index;
				if(match[0].substr(1, 1) === '/'){
					if(depth === 0) break;
					else depth--;
				}else depth++;
			}
			return wrapTag +
				html.substring(0, lastIndex) +
				// get the start tags reversed - this is safe as we construct the strings with no content except the tags
				angular.element(wrapTag)[0].outerHTML.substring(wrapTag.length) +
				html.substring(lastIndex);
		}
		
		function transformLegacyStyles(html){
			if(!html || !angular.isString(html) || html.length <= 0) return html;
			var i;
			var styleElementMatch = /<([^>\/]+?)style=("([^"]+)"|'([^']+)')([^>]*)>/ig;
			var match, subMatch, styleVal, newTag, lastNewTag = '', newHtml, finalHtml = '', lastIndex = 0;
			while(match = styleElementMatch.exec(html)){
				// one of the quoted values ' or "
				/* istanbul ignore next: quotations match */
				styleVal = match[3] || match[4];
				var styleRegex = new RegExp(styleRegexString, 'i');
				// test for style values to change
				if(angular.isString(styleVal) && styleRegex.test(styleVal)){
					// remove build tag list
					newTag = '';
					// init regex here for exec
					var styleRegexExec = new RegExp(styleRegexString, 'ig');
					// find relevand tags and build a string of them
					while(subMatch = styleRegexExec.exec(styleVal)){
						for(i = 0; i < convert_infos.length; i++){
							if(!!subMatch[(i*2) + 2]){
								newTag += '<' + convert_infos[i].tag + '>';
							}
						}
					}
					// recursively find more legacy styles in html before this tag and after the previous match (if any)
					newHtml = transformLegacyStyles(html.substring(lastIndex, match.index));
					// build up html
					if(lastNewTag.length > 0){
						finalHtml += wrapNested(newHtml, lastNewTag);
					}else finalHtml += newHtml;
					// grab the style val without the transformed values
					styleVal = styleVal.replace(new RegExp(styleRegexString, 'ig'), '');
					// build the html tag
					finalHtml += '<' + match[1].trim();
					if(styleVal.length > 0) finalHtml += ' style="' + styleVal + '"';
					finalHtml += match[5] + '>';
					// update the start index to after this tag
					lastIndex = match.index + match[0].length;
					lastNewTag = newTag;
				}
			}
			if(lastNewTag.length > 0){
				finalHtml += wrapNested(html.substring(lastIndex), lastNewTag);
			}
			else finalHtml += html.substring(lastIndex);
			return finalHtml;
		}
		
		function transformLegacyAttributes(html){
			if(!html || !angular.isString(html) || html.length <= 0) return html;
			// replace all align='...' tags with text-align attributes
			var attrElementMatch = /<([^>\/]+?)align=("([^"]+)"|'([^']+)')([^>]*)>/ig;
			var match, finalHtml = '', lastIndex = 0;
			// match all attr tags
			while(match = attrElementMatch.exec(html)){
				// add all html before this tag
				finalHtml += html.substring(lastIndex, match.index);
				// record last index after this tag
				lastIndex = match.index + match[0].length;
				// construct tag without the align attribute
				var newTag = '<' + match[1] + match[5];
				// add the style attribute
				if(/style=("([^"]+)"|'([^']+)')/ig.test(newTag)){
					/* istanbul ignore next: quotations match */
					newTag = newTag.replace(/style=("([^"]+)"|'([^']+)')/i, 'style="$2$3 text-align:' + (match[3] || match[4]) + ';"');
				}else{
					/* istanbul ignore next: quotations match */
					newTag += ' style="text-align:' + (match[3] || match[4]) + ';"';
				}
				newTag += '>';
				// add to html
				finalHtml += newTag;
			}
			// return with remaining html
			return finalHtml + html.substring(lastIndex);
		}
		
		return function taSanitize(unsafe, oldsafe, ignore){
			// unsafe html should NEVER built into a DOM object via angular.element. This allows XSS to be inserted and run.
			if ( !ignore ) {
				try {
					unsafe = transformLegacyStyles(unsafe);
				} catch (e) {
				}
			}

			// unsafe and oldsafe should be valid HTML strings
			// any exceptions (lets say, color for example) should be made here but with great care
			// setup unsafe element for modification
			unsafe = transformLegacyAttributes(unsafe);
			
			var safe;
			try {
				safe = $sanitize(unsafe);
				// do this afterwards, then the $sanitizer should still throw for bad markup
				if(ignore) safe = unsafe;
			} catch (e){
				safe = oldsafe || '';
			}
			
			// Do processing for <pre> tags, removing tabs and return carriages outside of them
			
			var _preTags = safe.match(/(<pre[^>]*>.*?<\/pre[^>]*>)/ig);
			var processedSafe = safe.replace(/(&#(9|10);)*/ig, '');
			var re = /<pre[^>]*>.*?<\/pre[^>]*>/ig;
			var index = 0;
			var lastIndex = 0;
			var origTag;
			safe = '';
			while((origTag = re.exec(processedSafe)) !== null && index < _preTags.length){
				safe += processedSafe.substring(lastIndex, origTag.index) + _preTags[index];
				lastIndex = origTag.index + origTag[0].length;
				index++;
			}
			return safe + processedSafe.substring(lastIndex);
		};
	}]).factory('taToolExecuteAction', ['$q', '$log', function($q, $log){
		// this must be called on a toolScope or instance
		return function(editor){
			if(editor !== undefined) this.$editor = function(){ return editor; };
			var deferred = $q.defer(),
				promise = deferred.promise,
				_editor = this.$editor();
			// pass into the action the deferred function and also the function to reload the current selection if rangy available
			var result;
			try{
				result = this.action(deferred, _editor.startAction());
				// We set the .finally callback here to make sure it doesn't get executed before any other .then callback.
				promise['finally'](function(){
					_editor.endAction.call(_editor);
				});
			}catch(exc){
				$log.error(exc);
			}
			if(result || result === undefined){
				// if true or undefined is returned then the action has finished. Otherwise the deferred action will be resolved manually.
				deferred.resolve();
			}
		};
	}]);
	angular.module('textAngular.DOM', ['textAngular.factories'])
	.factory('taExecCommand', ['taSelection', 'taBrowserTag', '$document', function(taSelection, taBrowserTag, $document){
		var listToDefault = function(listElement, defaultWrap){
			var $target, i;
			// if all selected then we should remove the list
			// grab all li elements and convert to taDefaultWrap tags
			var children = listElement.find('li');
			for(i = children.length - 1; i >= 0; i--){
				$target = angular.element('<' + defaultWrap + '>' + children[i].innerHTML + '</' + defaultWrap + '>');
				listElement.after($target);
			}
			listElement.remove();
			taSelection.setSelectionToElementEnd($target[0]);
		};
		var selectLi = function(liElement){
			if(/(<br(|\/)>)$/i.test(liElement.innerHTML.trim())) taSelection.setSelectionBeforeElement(angular.element(liElement).find("br")[0]);
			else taSelection.setSelectionToElementEnd(liElement);
		};
		var listToList = function(listElement, newListTag){
			var $target = angular.element('<' + newListTag + '>' + listElement[0].innerHTML + '</' + newListTag + '>');
			listElement.after($target);
			listElement.remove();
			selectLi($target.find('li')[0]);
		};
		var childElementsToList = function(elements, listElement, newListTag){
			var html = '';
			for(var i = 0; i < elements.length; i++){
				html += '<' + taBrowserTag('li') + '>' + elements[i].innerHTML + '</' + taBrowserTag('li') + '>';
			}
			var $target = angular.element('<' + newListTag + '>' + html + '</' + newListTag + '>');
			listElement.after($target);
			listElement.remove();
			selectLi($target.find('li')[0]);
		};
		return function(taDefaultWrap, topNode){
			taDefaultWrap = taBrowserTag(taDefaultWrap);
			return function(command, showUI, options, defaultTagAttributes){
				var i, $target, html, _nodes, next, optionsTagName, selectedElement;
				var defaultWrapper = angular.element('<' + taDefaultWrap + '>');
				try{
					selectedElement = taSelection.getSelectionElement();
				}catch(e){}
				var $selected = angular.element(selectedElement);
				if(selectedElement !== undefined){
					var tagName = selectedElement.tagName.toLowerCase();
					if(command.toLowerCase() === 'insertorderedlist' || command.toLowerCase() === 'insertunorderedlist'){
						var selfTag = taBrowserTag((command.toLowerCase() === 'insertorderedlist')? 'ol' : 'ul');
						if(tagName === selfTag){
							// if all selected then we should remove the list
							// grab all li elements and convert to taDefaultWrap tags
							return listToDefault($selected, taDefaultWrap);
						}else if(tagName === 'li' && $selected.parent()[0].tagName.toLowerCase() === selfTag && $selected.parent().children().length === 1){
							// catch for the previous statement if only one li exists
							return listToDefault($selected.parent(), taDefaultWrap);
						}else if(tagName === 'li' && $selected.parent()[0].tagName.toLowerCase() !== selfTag && $selected.parent().children().length === 1){
							// catch for the previous statement if only one li exists
							return listToList($selected.parent(), selfTag);
						}else if(tagName.match(BLOCKELEMENTS) && !$selected.hasClass('ta-bind')){
							// if it's one of those block elements we have to change the contents
							// if it's a ol/ul we are changing from one to the other
							if(tagName === 'ol' || tagName === 'ul'){
								return listToList($selected, selfTag);
							}else{
								var childBlockElements = false;
								angular.forEach($selected.children(), function(elem){
									if(elem.tagName.match(BLOCKELEMENTS)) {
										childBlockElements = true;
									}
								});
								if(childBlockElements){
									return childElementsToList($selected.children(), $selected, selfTag);
								}else{
									return childElementsToList([angular.element('<div>' + selectedElement.innerHTML + '</div>')[0]], $selected, selfTag);
								}
							}
						}else if(tagName.match(BLOCKELEMENTS)){
							// if we get here then all the contents of the ta-bind are selected
							_nodes = taSelection.getOnlySelectedElements();
							if(_nodes.length === 0){
								// here is if there is only text in ta-bind ie <div ta-bind>test content</div>
								$target = angular.element('<' + selfTag + '><li>' + selectedElement.innerHTML + '</li></' + selfTag + '>');
								$selected.html('');
								$selected.append($target);
							}else if(_nodes.length === 1 && (_nodes[0].tagName.toLowerCase() === 'ol' || _nodes[0].tagName.toLowerCase() === 'ul')){
								if(_nodes[0].tagName.toLowerCase() === selfTag){
									// remove
									return listToDefault(angular.element(_nodes[0]), taDefaultWrap);
								}else{
									return listToList(angular.element(_nodes[0]), selfTag);
								}
							}else{
								html = '';
								var $nodes = [];
								for(i = 0; i < _nodes.length; i++){
									/* istanbul ignore else: catch for real-world can't make it occur in testing */
									if(_nodes[i].nodeType !== 3){
										var $n = angular.element(_nodes[i]);
										/* istanbul ignore if: browser check only, phantomjs doesn't return children nodes but chrome at least does */
										if(_nodes[i].tagName.toLowerCase() === 'li') continue;
										else if(_nodes[i].tagName.toLowerCase() === 'ol' || _nodes[i].tagName.toLowerCase() === 'ul'){
											html += $n[0].innerHTML; // if it's a list, add all it's children
										}else if(_nodes[i].tagName.toLowerCase() === 'span' && (_nodes[i].childNodes[0].tagName.toLowerCase() === 'ol' || _nodes[i].childNodes[0].tagName.toLowerCase() === 'ul')){
											html += $n[0].childNodes[0].innerHTML; // if it's a list, add all it's children
										}else{
											html += '<' + taBrowserTag('li') + '>' + $n[0].innerHTML + '</' + taBrowserTag('li') + '>';
										}
										$nodes.unshift($n);
									}
								}
								$target = angular.element('<' + selfTag + '>' + html + '</' + selfTag + '>');
								$nodes.pop().replaceWith($target);
								angular.forEach($nodes, function($node){ $node.remove(); });
							}
							taSelection.setSelectionToElementEnd($target[0]);
							return;
						}
					}else if(command.toLowerCase() === 'formatblock'){
						optionsTagName = options.toLowerCase().replace(/[<>]/ig, '');
						if(optionsTagName.trim() === 'default') {
							optionsTagName = taDefaultWrap;
							options = '<' + taDefaultWrap + '>';
						}
						if(tagName === 'li') $target = $selected.parent();
						else $target = $selected;
						// find the first blockElement
						while(!$target[0].tagName || !$target[0].tagName.match(BLOCKELEMENTS) && !$target.parent().attr('contenteditable')){
							$target = $target.parent();
							/* istanbul ignore next */
							tagName = ($target[0].tagName || '').toLowerCase();
						}
						if(tagName === optionsTagName){
							// $target is wrap element
							_nodes = $target.children();
							var hasBlock = false;
							for(i = 0; i < _nodes.length; i++){
								hasBlock = hasBlock || _nodes[i].tagName.match(BLOCKELEMENTS);
							}
							if(hasBlock){
								$target.after(_nodes);
								next = $target.next();
								$target.remove();
								$target = next;
							}else{
								defaultWrapper.append($target[0].childNodes);
								$target.after(defaultWrapper);
								$target.remove();
								$target = defaultWrapper;
							}
						}else if($target.parent()[0].tagName.toLowerCase() === optionsTagName && !$target.parent().hasClass('ta-bind')){
							//unwrap logic for parent
							var blockElement = $target.parent();
							var contents = blockElement.contents();
							for(i = 0; i < contents.length; i ++){
								/* istanbul ignore next: can't test - some wierd thing with how phantomjs works */
								if(blockElement.parent().hasClass('ta-bind') && contents[i].nodeType === 3){
									defaultWrapper = angular.element('<' + taDefaultWrap + '>');
									defaultWrapper[0].innerHTML = contents[i].outerHTML;
									contents[i] = defaultWrapper[0];
								}
								blockElement.parent()[0].insertBefore(contents[i], blockElement[0]);
							}
							blockElement.remove();
						}else if(tagName.match(LISTELEMENTS)){
							// wrapping a list element
							$target.wrap(options);
						}else{
							// default wrap behaviour
							_nodes = taSelection.getOnlySelectedElements();
							if(_nodes.length === 0) _nodes = [$target[0]];
							// find the parent block element if any of the nodes are inline or text
							for(i = 0; i < _nodes.length; i++){
								if(_nodes[i].nodeType === 3 || !_nodes[i].tagName.match(BLOCKELEMENTS)){
									while(_nodes[i].nodeType === 3 || !_nodes[i].tagName || !_nodes[i].tagName.match(BLOCKELEMENTS)){
										_nodes[i] = _nodes[i].parentNode;
									}
								}
							}
							if(angular.element(_nodes[0]).hasClass('ta-bind')){
								$target = angular.element(options);
								$target[0].innerHTML = _nodes[0].innerHTML;
								_nodes[0].innerHTML = $target[0].outerHTML;
							}else if(optionsTagName === 'blockquote'){
								// blockquotes wrap other block elements
								html = '';
								for(i = 0; i < _nodes.length; i++){
									html += _nodes[i].outerHTML;
								}
								$target = angular.element(options);
								$target[0].innerHTML = html;
								_nodes[0].parentNode.insertBefore($target[0],_nodes[0]);
								for(i = _nodes.length - 1; i >= 0; i--){
									/* istanbul ignore else:  */
									if(_nodes[i].parentNode) _nodes[i].parentNode.removeChild(_nodes[i]);
								}
							}
							else {
								// regular block elements replace other block elements
								for(i = 0; i < _nodes.length; i++){
									$target = angular.element(options);
									$target[0].innerHTML = _nodes[i].innerHTML;
									_nodes[i].parentNode.insertBefore($target[0],_nodes[i]);
									_nodes[i].parentNode.removeChild(_nodes[i]);
								}
							}
						}
						taSelection.setSelectionToElementEnd($target[0]);
						return;
					}else if(command.toLowerCase() === 'createlink'){
						var tagBegin = '<a href="' + options + '" target="' +
								(defaultTagAttributes.a.target ? defaultTagAttributes.a.target : '') +
								'">',
							tagEnd = '</a>',
							_selection = taSelection.getSelection();
						if(_selection.collapsed){
							// insert text at selection, then select then just let normal exec-command run
							taSelection.insertHtml(tagBegin + options + tagEnd, topNode);
						}else if(rangy.getSelection().getRangeAt(0).canSurroundContents()){
							var node = angular.element(tagBegin + tagEnd)[0];
							rangy.getSelection().getRangeAt(0).surroundContents(node);
						}
						return;
					}else if(command.toLowerCase() === 'inserthtml'){
						taSelection.insertHtml(options, topNode);
						return;
					}
				}
				try{
					$document[0].execCommand(command, showUI, options);
				}catch(e){}
			};
		};
	}]).service('taSelection', ['$window', '$document', 'taDOM',
	/* istanbul ignore next: all browser specifics and PhantomJS dosen't seem to support half of it */
	function($window, $document, taDOM){
		// need to dereference the document else the calls don't work correctly
		var _document = $document[0];
		var rangy = $window.rangy;
		var brException = function (element, offset) {
			/* check if selection is a BR element at the beginning of a container. If so, get
			* the parentNode instead.
			* offset should be zero in this case. Otherwise, return the original
			* element.
			*/
			if (element.tagName && element.tagName.match(/^br$/i) && offset === 0 && !element.previousSibling) {
	            return {
	                element: element.parentNode,
	                offset: 0
	            };
			} else {
				return {
					element: element,
					offset: offset
				};
			}
		};
		var api = {
			getSelection: function(){
				var range = rangy.getSelection().getRangeAt(0);
				var container = range.commonAncestorContainer;
				var selection = {
					start: brException(range.startContainer, range.startOffset),
					end: brException(range.endContainer, range.endOffset),
					collapsed: range.collapsed
				};
				// Check if the container is a text node and return its parent if so
				container = container.nodeType === 3 ? container.parentNode : container;
				if (container.parentNode === selection.start.element ||
					container.parentNode === selection.end.element) {
					selection.container = container.parentNode;
				} else {
					selection.container = container;
				}
				return selection;
			},
			getOnlySelectedElements: function(){
				var range = rangy.getSelection().getRangeAt(0);
				var container = range.commonAncestorContainer;
				// Check if the container is a text node and return its parent if so
				container = container.nodeType === 3 ? container.parentNode : container;
				return range.getNodes([1], function(node){
					return node.parentNode === container;
				});
			},
			// Some basic selection functions
			getSelectionElement: function () {
				return api.getSelection().container;
			},
			setSelection: function(el, start, end){
				var range = rangy.createRange();
				
				range.setStart(el, start);
				range.setEnd(el, end);
				
				rangy.getSelection().setSingleRange(range);
			},
			setSelectionBeforeElement: function (el){
				var range = rangy.createRange();
				
				range.selectNode(el);
				range.collapse(true);
				
				rangy.getSelection().setSingleRange(range);
			},
			setSelectionAfterElement: function (el){
				var range = rangy.createRange();
				
				range.selectNode(el);
				range.collapse(false);
				
				rangy.getSelection().setSingleRange(range);
			},
			setSelectionToElementStart: function (el){
				var range = rangy.createRange();
				
				range.selectNodeContents(el);
				range.collapse(true);
				
				rangy.getSelection().setSingleRange(range);
			},
			setSelectionToElementEnd: function (el){
				var range = rangy.createRange();
				
				range.selectNodeContents(el);
				range.collapse(false);
				if(el.childNodes && el.childNodes[el.childNodes.length - 1] && el.childNodes[el.childNodes.length - 1].nodeName === 'br'){
					range.startOffset = range.endOffset = range.startOffset - 1;
				}
				rangy.getSelection().setSingleRange(range);
			},
			// from http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
			// topNode is the contenteditable normally, all manipulation MUST be inside this.
			insertHtml: function(html, topNode){
				var parent, secondParent, _childI, nodes, i, lastNode, _tempFrag;
				var element = angular.element("<div>" + html + "</div>");
				var range = rangy.getSelection().getRangeAt(0);
				var frag = _document.createDocumentFragment();
				var children = element[0].childNodes;
				var isInline = true;
				
				if(children.length > 0){
					// NOTE!! We need to do the following:
					// check for blockelements - if they exist then we have to split the current element in half (and all others up to the closest block element) and insert all children in-between.
					// If there are no block elements, or there is a mixture we need to create textNodes for the non wrapped text (we don't want them spans messing up the picture).
					nodes = [];
					for(_childI = 0; _childI < children.length; _childI++){
						if(!(
							(children[_childI].nodeName.toLowerCase() === 'p' && children[_childI].innerHTML.trim() === '') || // empty p element
							(children[_childI].nodeType === 3 && children[_childI].nodeValue.trim() === '') // empty text node
						)){
							isInline = isInline && !BLOCKELEMENTS.test(children[_childI].nodeName);
							nodes.push(children[_childI]);
						}
					}
					for(var _n = 0; _n < nodes.length; _n++) lastNode = frag.appendChild(nodes[_n]);
					if(!isInline && range.collapsed && /^(|<br(|\/)>)$/i.test(range.startContainer.innerHTML)) range.selectNode(range.startContainer);
				}else{
					isInline = true;
					// paste text of some sort
					lastNode = frag = _document.createTextNode(html);
				}
				
				// Other Edge case - selected data spans multiple blocks.
				if(isInline){
					range.deleteContents();
				}else{ // not inline insert
					if(range.collapsed && range.startContainer !== topNode){
						if(range.startContainer.innerHTML && range.startContainer.innerHTML.match(/^<[^>]*>$/i)){
							// this log is to catch when innerHTML is something like `<img ...>`
							parent = range.startContainer;
							if(range.startOffset === 1){
								// before single tag
								range.setStartAfter(parent);
								range.setEndAfter(parent);
							}else{
								// after single tag
								range.setStartBefore(parent);
								range.setEndBefore(parent);
							}
						}else{
							// split element into 2 and insert block element in middle
							if(range.startContainer.nodeType === 3 && range.startContainer.parentNode !== topNode){ // if text node
								parent = range.startContainer.parentNode;
								secondParent = parent.cloneNode();
								// split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.
								taDOM.splitNodes(parent.childNodes, parent, secondParent, range.startContainer, range.startOffset);
								
								// Escape out of the inline tags like b
								while(!VALIDELEMENTS.test(parent.nodeName)){
									angular.element(parent).after(secondParent);
									parent = parent.parentNode;
									var _lastSecondParent = secondParent;
									secondParent = parent.cloneNode();
									// split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.
									taDOM.splitNodes(parent.childNodes, parent, secondParent, _lastSecondParent);
								}
							}else{
								parent = range.startContainer;
								secondParent = parent.cloneNode();
								taDOM.splitNodes(parent.childNodes, parent, secondParent, undefined, undefined, range.startOffset);
							}
							
							angular.element(parent).after(secondParent);
							// put cursor to end of inserted content
							range.setStartAfter(parent);
							range.setEndAfter(parent);
							
							if(/^(|<br(|\/)>)$/i.test(parent.innerHTML.trim())){
								range.setStartBefore(parent);
								range.setEndBefore(parent);
								angular.element(parent).remove();
							}
							if(/^(|<br(|\/)>)$/i.test(secondParent.innerHTML.trim())) angular.element(secondParent).remove();
							if(parent.nodeName.toLowerCase() === 'li'){
								_tempFrag = _document.createDocumentFragment();
								for(i = 0; i < frag.childNodes.length; i++){
									element = angular.element('<li>');
									taDOM.transferChildNodes(frag.childNodes[i], element[0]);
									taDOM.transferNodeAttributes(frag.childNodes[i], element[0]);
									_tempFrag.appendChild(element[0]);
								}
								frag = _tempFrag;
								if(lastNode){
									lastNode = frag.childNodes[frag.childNodes.length - 1];
									lastNode = lastNode.childNodes[lastNode.childNodes.length - 1];
								}
							}
						}
					}else{
						range.deleteContents();
					}
				}
				
				range.insertNode(frag);
				if(lastNode){
					api.setSelectionToElementEnd(lastNode);
				}
			}
		};
		return api;
	}]).service('taDOM', function(){
		var taDOM = {
			// recursive function that returns an array of angular.elements that have the passed attribute set on them
			getByAttribute: function(element, attribute){
				var resultingElements = [];
				var childNodes = element.children();
				if(childNodes.length){
					angular.forEach(childNodes, function(child){
						resultingElements = resultingElements.concat(taDOM.getByAttribute(angular.element(child), attribute));
					});
				}
				if(element.attr(attribute) !== undefined) resultingElements.push(element);
				return resultingElements;
			},
			
			transferChildNodes: function(source, target){
				// clear out target
				target.innerHTML = '';
				while(source.childNodes.length > 0) target.appendChild(source.childNodes[0]);
				return target;
			},
			
			splitNodes: function(nodes, target1, target2, splitNode, subSplitIndex, splitIndex){
				if(!splitNode && isNaN(splitIndex)) throw new Error('taDOM.splitNodes requires a splitNode or splitIndex');
				var startNodes = document.createDocumentFragment();
				var endNodes = document.createDocumentFragment();
				var index = 0;
				
				while(nodes.length > 0 && (isNaN(splitIndex) || splitIndex !== index) && nodes[0] !== splitNode){
					startNodes.appendChild(nodes[0]); // this removes from the nodes array (if proper childNodes object.
					index++;
				}
				
				if(!isNaN(subSplitIndex) && subSplitIndex >= 0 && nodes[0]){
					startNodes.appendChild(document.createTextNode(nodes[0].nodeValue.substring(0, subSplitIndex)));
					nodes[0].nodeValue = nodes[0].nodeValue.substring(subSplitIndex);
				}
				while(nodes.length > 0) endNodes.appendChild(nodes[0]);
				
				taDOM.transferChildNodes(startNodes, target1);
				taDOM.transferChildNodes(endNodes, target2);
			},
			
			transferNodeAttributes: function(source, target){
				for(var i = 0; i < source.attributes.length; i++) target.setAttribute(source.attributes[i].name, source.attributes[i].value);
				return target;
			}
		};
		return taDOM;
	});
	angular.module('textAngular.validators', [])
	.directive('taMaxText', function(){
		return {
			restrict: 'A',
			require: 'ngModel',
			link: function(scope, elem, attrs, ctrl){
				var max = parseInt(scope.$eval(attrs.taMaxText));
				if (isNaN(max)){
					throw('Max text must be an integer');
				}
				attrs.$observe('taMaxText', function(value){
					max = parseInt(value);
					if (isNaN(max)){
						throw('Max text must be an integer');
					}
					if (ctrl.$dirty){
						ctrl.$validate();
					}
				});
				ctrl.$validators.taMaxText = function(viewValue){
					var source = angular.element('<div/>');
					source.html(viewValue);
					return source.text().length <= max;
				};
			}
		};
	}).directive('taMinText', function(){
		return {
			restrict: 'A',
			require: 'ngModel',
			link: function(scope, elem, attrs, ctrl){
				var min = parseInt(scope.$eval(attrs.taMinText));
				if (isNaN(min)){
					throw('Min text must be an integer');
				}
				attrs.$observe('taMinText', function(value){
					min = parseInt(value);
					if (isNaN(min)){
						throw('Min text must be an integer');
					}
					if (ctrl.$dirty){
						ctrl.$validate();
					}
				});
				ctrl.$validators.taMinText = function(viewValue){
					var source = angular.element('<div/>');
					source.html(viewValue);
					return !source.text().length || source.text().length >= min;
				};
			}
		};
	});
	angular.module('textAngular.taBind', ['textAngular.factories', 'textAngular.DOM'])
	.service('_taBlankTest', [function(){
		var INLINETAGS_NONBLANK = /<(a|abbr|acronym|bdi|bdo|big|cite|code|del|dfn|img|ins|kbd|label|map|mark|q|ruby|rp|rt|s|samp|time|tt|var)[^>]*(>|$)/i;
		return function(_defaultTest){
			return function(_blankVal){
				if(!_blankVal) return true;
				// find first non-tag match - ie start of string or after tag that is not whitespace
				var _firstMatch = /(^[^<]|>)[^<]/i.exec(_blankVal);
				var _firstTagIndex;
				if(!_firstMatch){
					// find the end of the first tag removing all the
					// Don't do a global replace as that would be waaayy too long, just replace the first 4 occurences should be enough
					_blankVal = _blankVal.toString().replace(/="[^"]*"/i, '').replace(/="[^"]*"/i, '').replace(/="[^"]*"/i, '').replace(/="[^"]*"/i, '');
					_firstTagIndex = _blankVal.indexOf('>');
				}else{
					_firstTagIndex = _firstMatch.index;
				}
				_blankVal = _blankVal.trim().substring(_firstTagIndex, _firstTagIndex + 100);
				// check for no tags entry
				if(/^[^<>]+$/i.test(_blankVal)) return false;
				// this regex is to match any number of whitespace only between two tags
				if (_blankVal.length === 0 || _blankVal === _defaultTest || /^>(\s|&nbsp;)*<\/[^>]+>$/ig.test(_blankVal)) return true;
				// this regex tests if there is a tag followed by some optional whitespace and some text after that
				else if (/>\s*[^\s<]/i.test(_blankVal) || INLINETAGS_NONBLANK.test(_blankVal)) return false;
				else return true;
			};
		};
	}])
	.directive('taButton', [function(){
		return {
			link: function(scope, element, attrs){
				element.attr('unselectable', 'on');
				element.on('mousedown', function(e, eventData){
					/* istanbul ignore else: this is for catching the jqLite testing*/
					if(eventData) angular.extend(e, eventData);
					// this prevents focusout from firing on the editor when clicking toolbar buttons
					e.preventDefault();
					return false;
				});
			}
		};
	}])
	.directive('taBind', [
			'taSanitize', '$timeout', '$window', '$document', 'taFixChrome', 'taBrowserTag',
			'taSelection', 'taSelectableElements', 'taApplyCustomRenderers', 'taOptions',
			'_taBlankTest', '$parse', 'taDOM', 'textAngularManager',
			function(
				taSanitize, $timeout, $window, $document, taFixChrome, taBrowserTag,
				taSelection, taSelectableElements, taApplyCustomRenderers, taOptions,
				_taBlankTest, $parse, taDOM, textAngularManager){
		// Uses for this are textarea or input with ng-model and ta-bind='text'
		// OR any non-form element with contenteditable="contenteditable" ta-bind="html|text" ng-model
		return {
			priority: 2, // So we override validators correctly
			require: ['ngModel','?ngModelOptions'],
			link: function(scope, element, attrs, controller){
				var ngModel = controller[0];
				var ngModelOptions = controller[1] || {};
				// the option to use taBind on an input or textarea is required as it will sanitize all input into it correctly.
				var _isContentEditable = element.attr('contenteditable') !== undefined && element.attr('contenteditable');
				var _isInputFriendly = _isContentEditable || element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input';
				var _isReadonly = false;
				var _focussed = false;
				var _skipRender = false;
				var _disableSanitizer = attrs.taUnsafeSanitizer || taOptions.disableSanitizer;
				var _lastKey;
				// see http://www.javascripter.net/faq/keycodes.htm for good information
				// NOTE Mute On|Off 173 (Opera MSIE Safari Chrome) 181 (Firefox)
				// BLOCKED_KEYS are special keys...
				// Tab, pause/break, CapsLock, Esc, Page Up, End, Home,
				// Left arrow, Up arrow, Right arrow, Down arrow, Insert, Delete,
				// f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12
				// NumLock, ScrollLock
				var BLOCKED_KEYS = /^(9|19|20|27|33|34|35|36|37|38|39|40|45|112|113|114|115|116|117|118|119|120|121|122|123|144|145)$/i;
				// UNDO_TRIGGER_KEYS - spaces, enter, delete, backspace, all punctuation
				// Backspace, Enter, Space, Delete, (; :) (Firefox), (= +) (Firefox),
				// Numpad +, Numpad -, (; :), (= +),
				// (, <), (- _), (. >), (/ ?), (` ~), ([ {), (\ |), (] }), (' ")
				// NOTE - Firefox: 173 = (- _) -- adding this to UNDO_TRIGGER_KEYS
				var UNDO_TRIGGER_KEYS = /^(8|13|32|46|59|61|107|109|173|186|187|188|189|190|191|192|219|220|221|222)$/i;
				var _pasteHandler;

				// defaults to the paragraph element, but we need the line-break or it doesn't allow you to type into the empty element
				// non IE is '<p><br/></p>', ie is '<p></p>' as for once IE gets it correct...
				var _defaultVal, _defaultTest;

				var _CTRL_KEY = 0x0001;
				var _META_KEY = 0x0002;
				var _ALT_KEY = 0x0004;
				var _SHIFT_KEY = 0x0008;
				// map events to special keys...
				// mappings is an array of maps from events to specialKeys as declared in textAngularSetup
				var _keyMappings = [
					//		ctrl/command + z
					{
						specialKey: 'UndoKey',
						forbiddenModifiers: _ALT_KEY + _SHIFT_KEY,
						mustHaveModifiers: [_META_KEY + _CTRL_KEY],
						keyCode: 90
					},
					//		ctrl/command + shift + z
					{
						specialKey: 'RedoKey',
						forbiddenModifiers: _ALT_KEY,
						mustHaveModifiers: [_META_KEY + _CTRL_KEY, _SHIFT_KEY],
						keyCode: 90
					},
					//		ctrl/command + y
					{
						specialKey: 'RedoKey',
						forbiddenModifiers: _ALT_KEY + _SHIFT_KEY,
						mustHaveModifiers: [_META_KEY + _CTRL_KEY],
						keyCode: 89
					},
					//		TabKey
					{
						specialKey: 'TabKey',
						forbiddenModifiers: _META_KEY + _SHIFT_KEY + _ALT_KEY + _CTRL_KEY,
						mustHaveModifiers: [],
						keyCode: 9
					},
					//		shift + TabKey
					{
						specialKey: 'ShiftTabKey',
						forbiddenModifiers: _META_KEY + _ALT_KEY + _CTRL_KEY,
						mustHaveModifiers: [_SHIFT_KEY],
						keyCode: 9
					}
				];
				function _mapKeys(event) {
					var specialKey;
					_keyMappings.forEach(function (map){
						if (map.keyCode === event.keyCode) {
							var netModifiers = (event.metaKey ? _META_KEY: 0) +
								(event.ctrlKey ? _CTRL_KEY: 0) +
								(event.shiftKey ? _SHIFT_KEY: 0) +
								(event.altKey ? _ALT_KEY: 0);
							if (map.forbiddenModifiers & netModifiers) return;
							if (map.mustHaveModifiers.every(function (modifier) { return netModifiers & modifier; })){
								specialKey = map.specialKey;
							}
						}
					});
					return specialKey;
				}

				// set the default to be a paragraph value
				if(attrs.taDefaultWrap === undefined) attrs.taDefaultWrap = 'p';
				/* istanbul ignore next: ie specific test */
				if(attrs.taDefaultWrap === ''){
					_defaultVal = '';
					_defaultTest = (_browserDetect.ie === undefined)? '<div><br></div>' : (_browserDetect.ie >= 11)? '<p><br></p>' : (_browserDetect.ie <= 8)? '<P>&nbsp;</P>' : '<p>&nbsp;</p>';
				}else{
					_defaultVal = (_browserDetect.ie === undefined || _browserDetect.ie >= 11)?
						'<' + attrs.taDefaultWrap + '><br></' + attrs.taDefaultWrap + '>' :
						(_browserDetect.ie <= 8)?
							'<' + attrs.taDefaultWrap.toUpperCase() + '></' + attrs.taDefaultWrap.toUpperCase() + '>' :
							'<' + attrs.taDefaultWrap + '></' + attrs.taDefaultWrap + '>';
					_defaultTest = (_browserDetect.ie === undefined || _browserDetect.ie >= 11)?
						'<' + attrs.taDefaultWrap + '><br></' + attrs.taDefaultWrap + '>' :
						(_browserDetect.ie <= 8)?
							'<' + attrs.taDefaultWrap.toUpperCase() + '>&nbsp;</' + attrs.taDefaultWrap.toUpperCase() + '>' :
							'<' + attrs.taDefaultWrap + '>&nbsp;</' + attrs.taDefaultWrap + '>';
				}

				/* istanbul ignore else */
				if(!ngModelOptions.$options) ngModelOptions.$options = {}; // ng-model-options support

				var _blankTest = _taBlankTest(_defaultTest);

				var _ensureContentWrapped = function(value){
					if(_blankTest(value)) return value;
					var domTest = angular.element("<div>" + value + "</div>");
					if(domTest.children().length === 0){
						value = "<" + attrs.taDefaultWrap + ">" + value + "</" + attrs.taDefaultWrap + ">";
					}else{
						var _children = domTest[0].childNodes;
						var i;
						var _foundBlockElement = false;
						for(i = 0; i < _children.length; i++){
							if(_foundBlockElement = _children[i].nodeName.toLowerCase().match(BLOCKELEMENTS)) break;
						}
						if(!_foundBlockElement){
							value = "<" + attrs.taDefaultWrap + ">" + value + "</" + attrs.taDefaultWrap + ">";
						}else{
							value = "";
							for(i = 0; i < _children.length; i++){
								if(!_children[i].nodeName.toLowerCase().match(BLOCKELEMENTS)){
									var _subVal = (_children[i].outerHTML || _children[i].nodeValue);
									/* istanbul ignore else: Doesn't seem to trigger on tests, is tested though */
									if(_subVal.trim() !== '')
										value += "<" + attrs.taDefaultWrap + ">" + _subVal + "</" + attrs.taDefaultWrap + ">";
									else value += _subVal;
								}else{
									value += _children[i].outerHTML;
								}
							}
						}
					}
					return value;
				};

				if(attrs.taPaste) _pasteHandler = $parse(attrs.taPaste);

				element.addClass('ta-bind');

				var _undoKeyupTimeout;

				scope['$undoManager' + (attrs.id || '')] = ngModel.$undoManager = {
					_stack: [],
					_index: 0,
					_max: 1000,
					push: function(value){
						if((typeof value === "undefined" || value === null) ||
							((typeof this.current() !== "undefined" && this.current() !== null) && value === this.current())) return value;
						if(this._index < this._stack.length - 1){
							this._stack = this._stack.slice(0,this._index+1);
						}
						this._stack.push(value);
						if(_undoKeyupTimeout) $timeout.cancel(_undoKeyupTimeout);
						if(this._stack.length > this._max) this._stack.shift();
						this._index = this._stack.length - 1;
						return value;
					},
					undo: function(){
						return this.setToIndex(this._index-1);
					},
					redo: function(){
						return this.setToIndex(this._index+1);
					},
					setToIndex: function(index){
						if(index < 0 || index > this._stack.length - 1){
							return undefined;
						}
						this._index = index;
						return this.current();
					},
					current: function(){
						return this._stack[this._index];
					}
				};

				var _redoUndoTimeout;
				var _undo = scope['$undoTaBind' + (attrs.id || '')] = function(){
					/* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */
					if(!_isReadonly && _isContentEditable){
						var content = ngModel.$undoManager.undo();
						if(typeof content !== "undefined" && content !== null){
							_setInnerHTML(content);
							_setViewValue(content, false);
							if(_redoUndoTimeout) $timeout.cancel(_redoUndoTimeout);
							_redoUndoTimeout = $timeout(function(){
								element[0].focus();
								taSelection.setSelectionToElementEnd(element[0]);
							}, 1);
						}
					}
				};

				var _redo = scope['$redoTaBind' + (attrs.id || '')] = function(){
					/* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */
					if(!_isReadonly && _isContentEditable){
						var content = ngModel.$undoManager.redo();
						if(typeof content !== "undefined" && content !== null){
							_setInnerHTML(content);
							_setViewValue(content, false);
							/* istanbul ignore next */
							if(_redoUndoTimeout) $timeout.cancel(_redoUndoTimeout);
							_redoUndoTimeout = $timeout(function(){
								element[0].focus();
								taSelection.setSelectionToElementEnd(element[0]);
							}, 1);
						}
					}
				};

				// in here we are undoing the converts used elsewhere to prevent the < > and & being displayed when they shouldn't in the code.
				var _compileHtml = function(){
					if(_isContentEditable) return element[0].innerHTML;
					if(_isInputFriendly) return element.val();
					throw ('textAngular Error: attempting to update non-editable taBind');
				};

				var _setViewValue = function(_val, triggerUndo, skipRender){
					_skipRender = skipRender || false;
					if(typeof triggerUndo === "undefined" || triggerUndo === null) triggerUndo = true && _isContentEditable; // if not contentEditable then the native undo/redo is fine
					if(typeof _val === "undefined" || _val === null) _val = _compileHtml();
					if(_blankTest(_val)){
						// this avoids us from tripping the ng-pristine flag if we click in and out with out typing
						if(ngModel.$viewValue !== '') ngModel.$setViewValue('');
						if(triggerUndo && ngModel.$undoManager.current() !== '') ngModel.$undoManager.push('');
					}else{
						_reApplyOnSelectorHandlers();
						if(ngModel.$viewValue !== _val){
							ngModel.$setViewValue(_val);
							if(triggerUndo) ngModel.$undoManager.push(_val);
						}
					}
					ngModel.$render();
				};

				//used for updating when inserting wrapped elements
				scope['updateTaBind' + (attrs.id || '')] = function(){
					if(!_isReadonly) _setViewValue(undefined, undefined, true);
				};

				// catch DOM XSS via taSanitize
				// Sanitizing both ways is identical
				var _sanitize = function(unsafe){
					return (ngModel.$oldViewValue = taSanitize(taFixChrome(unsafe), ngModel.$oldViewValue, _disableSanitizer));
				};

				// trigger the validation calls
				if(element.attr('required')) ngModel.$validators.required = function(modelValue, viewValue) {
					return !_blankTest(modelValue || viewValue);
				};
				// parsers trigger from the above keyup function or any other time that the viewValue is updated and parses it for storage in the ngModel
				ngModel.$parsers.push(_sanitize);
				ngModel.$parsers.unshift(_ensureContentWrapped);
				// because textAngular is bi-directional (which is awesome) we need to also sanitize values going in from the server
				ngModel.$formatters.push(_sanitize);
				ngModel.$formatters.unshift(_ensureContentWrapped);
				ngModel.$formatters.unshift(function(value){
					return ngModel.$undoManager.push(value || '');
				});

				//this code is used to update the models when data is entered/deleted
				if(_isInputFriendly){
					scope.events = {};
					if(!_isContentEditable){
						// if a textarea or input just add in change and blur handlers, everything else is done by angulars input directive
						element.on('change blur', scope.events.change = scope.events.blur = function(){
							if(!_isReadonly) ngModel.$setViewValue(_compileHtml());
						});

						element.on('keydown', scope.events.keydown = function(event, eventData){
							/* istanbul ignore else: this is for catching the jqLite testing*/
							if(eventData) angular.extend(event, eventData);
							// Reference to http://stackoverflow.com/questions/6140632/how-to-handle-tab-in-textarea
							/* istanbul ignore else: otherwise normal functionality */
							if(event.keyCode === 9){ // tab was pressed
								// get caret position/selection
								var start = this.selectionStart;
								var end = this.selectionEnd;

								var value = element.val();
								if(event.shiftKey){
									// find \t
									var _linebreak = value.lastIndexOf('\n', start), _tab = value.lastIndexOf('\t', start);
									if(_tab !== -1 && _tab >= _linebreak){
										// set textarea value to: text before caret + tab + text after caret
										element.val(value.substring(0, _tab) + value.substring(_tab + 1));

										// put caret at right position again (add one for the tab)
										this.selectionStart = this.selectionEnd = start - 1;
									}
								}else{
									// set textarea value to: text before caret + tab + text after caret
									element.val(value.substring(0, start) + "\t" + value.substring(end));

									// put caret at right position again (add one for the tab)
									this.selectionStart = this.selectionEnd = start + 1;
								}
								// prevent the focus lose
								event.preventDefault();
							}
						});

						var _repeat = function(string, n){
							var result = '';
							for(var _n = 0; _n < n; _n++) result += string;
							return result;
						};

						var recursiveListFormat = function(listNode, tablevel){
							var _html = '', _children = listNode.childNodes;
							tablevel++;
							_html += _repeat('\t', tablevel-1) + listNode.outerHTML.substring(0, listNode.outerHTML.indexOf('<li'));
							for(var _i = 0; _i < _children.length; _i++){
								/* istanbul ignore next: browser catch */
								if(!_children[_i].outerHTML) continue;
								if(_children[_i].nodeName.toLowerCase() === 'ul' || _children[_i].nodeName.toLowerCase() === 'ol')
									_html += '\n' + recursiveListFormat(_children[_i], tablevel);
								else
									_html += '\n' + _repeat('\t', tablevel) + _children[_i].outerHTML;
							}
							_html += '\n' + _repeat('\t', tablevel-1) + listNode.outerHTML.substring(listNode.outerHTML.lastIndexOf('<'));
							return _html;
						};
						ngModel.$formatters.unshift(function(htmlValue){
							// tabulate the HTML so it looks nicer
							var _children = angular.element('<div>' + htmlValue + '</div>')[0].childNodes;
							if(_children.length > 0){
								htmlValue = '';
								for(var i = 0; i < _children.length; i++){
									/* istanbul ignore next: browser catch */
									if(!_children[i].outerHTML) continue;
									if(htmlValue.length > 0) htmlValue += '\n';
									if(_children[i].nodeName.toLowerCase() === 'ul' || _children[i].nodeName.toLowerCase() === 'ol')
										htmlValue += '' + recursiveListFormat(_children[i], 0);
									else htmlValue += '' + _children[i].outerHTML;
								}
							}

							return htmlValue;
						});
					}else{
						// all the code specific to contenteditable divs
						var _processingPaste = false;
						/* istanbul ignore next: phantom js cannot test this for some reason */
						var processpaste = function(text) {
							/* istanbul ignore else: don't care if nothing pasted */
							if(text && text.trim().length){
								// test paste from word/microsoft product
								if(text.match(/class=["']*Mso(Normal|List)/i)){
									var textFragment = text.match(/<!--StartFragment-->([\s\S]*?)<!--EndFragment-->/i);
									if(!textFragment) textFragment = text;
									else textFragment = textFragment[1];
									textFragment = textFragment.replace(/<o:p>[\s\S]*?<\/o:p>/ig, '').replace(/class=(["']|)MsoNormal(["']|)/ig, '');
									var dom = angular.element("<div>" + textFragment + "</div>");
									var targetDom = angular.element("<div></div>");
									var _list = {
										element: null,
										lastIndent: [],
										lastLi: null,
										isUl: false
									};
									_list.lastIndent.peek = function(){
										var n = this.length;
										if (n>0) return this[n-1];
									};
									var _resetList = function(isUl){
										_list.isUl = isUl;
										_list.element = angular.element(isUl ? "<ul>" : "<ol>");
										_list.lastIndent = [];
										_list.lastIndent.peek = function(){
											var n = this.length;
											if (n>0) return this[n-1];
										};
										_list.lastLevelMatch = null;
									};
									for(var i = 0; i <= dom[0].childNodes.length; i++){
										if(!dom[0].childNodes[i] || dom[0].childNodes[i].nodeName === "#text" || dom[0].childNodes[i].tagName.toLowerCase() !== "p") continue;
										var el = angular.element(dom[0].childNodes[i]);
										var _listMatch = (el.attr('class') || '').match(/MsoList(Bullet|Number|Paragraph)(CxSp(First|Middle|Last)|)/i);

										if(_listMatch){
											if(el[0].childNodes.length < 2 || el[0].childNodes[1].childNodes.length < 1){
												continue;
											}
											var isUl = _listMatch[1].toLowerCase() === "bullet" || (_listMatch[1].toLowerCase() !== "number" && !(/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(el[0].childNodes[1].innerHTML) || /^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(el[0].childNodes[1].childNodes[0].innerHTML)));
											var _indentMatch = (el.attr('style') || '').match(/margin-left:([\-\.0-9]*)/i);
											var indent = parseFloat((_indentMatch)?_indentMatch[1]:0);
											var _levelMatch = (el.attr('style') || '').match(/mso-list:l([0-9]+) level([0-9]+) lfo[0-9+]($|;)/i);
											// prefers the mso-list syntax

											if(_levelMatch && _levelMatch[2]) indent = parseInt(_levelMatch[2]);

											if ((_levelMatch && (!_list.lastLevelMatch || _levelMatch[1] !== _list.lastLevelMatch[1])) || !_listMatch[3] || _listMatch[3].toLowerCase() === "first" || (_list.lastIndent.peek() === null) || (_list.isUl !== isUl && _list.lastIndent.peek() === indent)) {
												_resetList(isUl);
												targetDom.append(_list.element);
											} else if (_list.lastIndent.peek() != null && _list.lastIndent.peek() < indent){
												_list.element = angular.element(isUl ? "<ul>" : "<ol>");
												_list.lastLi.append(_list.element);
											} else if (_list.lastIndent.peek() != null && _list.lastIndent.peek() > indent){
												while(_list.lastIndent.peek() != null && _list.lastIndent.peek() > indent){
													if(_list.element.parent()[0].tagName.toLowerCase() === 'li'){
														_list.element = _list.element.parent();
														continue;
													}else if(/[uo]l/i.test(_list.element.parent()[0].tagName.toLowerCase())){
														_list.element = _list.element.parent();
													}else{ // else it's it should be a sibling
														break;
													}
													_list.lastIndent.pop();
												}
												_list.isUl = _list.element[0].tagName.toLowerCase() === "ul";
												if (isUl !== _list.isUl) {
													_resetList(isUl);
													targetDom.append(_list.element);
												}
											}

											_list.lastLevelMatch = _levelMatch;
											if(indent !== _list.lastIndent.peek()) _list.lastIndent.push(indent);
											_list.lastLi = angular.element("<li>");
											_list.element.append(_list.lastLi);
											_list.lastLi.html(el.html().replace(/<!(--|)\[if !supportLists\](--|)>[\s\S]*?<!(--|)\[endif\](--|)>/ig, ''));
											el.remove();
										}else{
											_resetList(false);
											targetDom.append(el);
										}
									}
									var _unwrapElement = function(node){
										node = angular.element(node);
										for(var _n = node[0].childNodes.length - 1; _n >= 0; _n--) node.after(node[0].childNodes[_n]);
										node.remove();
									};

									angular.forEach(targetDom.find('span'), function(node){
										node.removeAttribute('lang');
										if(node.attributes.length <= 0) _unwrapElement(node);
									});
									angular.forEach(targetDom.find('font'), _unwrapElement);
									text = targetDom.html();
								}else{
									// remove unnecessary chrome insert
									text = text.replace(/<(|\/)meta[^>]*?>/ig, '');
									if(text.match(/<[^>]*?(ta-bind)[^>]*?>/)){
										// entire text-angular or ta-bind has been pasted, REMOVE AT ONCE!!
										if(text.match(/<[^>]*?(text-angular)[^>]*?>/)){
											var _el = angular.element("<div>" + text + "</div>");
											_el.find('textarea').remove();
											var binds = taDOM.getByAttribute(_el, 'ta-bind');
											for(var _b = 0; _b < binds.length; _b++){
												var _target = binds[_b][0].parentNode.parentNode;
												for(var _c = 0; _c < binds[_b][0].childNodes.length; _c++){
													_target.parentNode.insertBefore(binds[_b][0].childNodes[_c], _target);
												}
												_target.parentNode.removeChild(_target);
											}
											text = _el.html().replace('<br class="Apple-interchange-newline">', '');
										}
									}else if(text.match(/^<span/)){
										// in case of pasting only a span - chrome paste, remove them. THis is just some wierd formatting
										text = text.replace(/<(|\/)span[^>]*?>/ig, '');
									}
									// Webkit on Apple tags
									text = text.replace(/<br class="Apple-interchange-newline"[^>]*?>/ig, '').replace(/<span class="Apple-converted-space">( |&nbsp;)<\/span>/ig, '&nbsp;');
								}

								if (/<li(\s.*)?>/i.test(text) && /(<ul(\s.*)?>|<ol(\s.*)?>).*<li(\s.*)?>/i.test(text) === false) {
									// insert missing parent of li element
									text = text.replace(/<li(\s.*)?>.*<\/li(\s.*)?>/i, '<ul>$&</ul>');
								}

								if(_pasteHandler) text = _pasteHandler(scope, {$html: text}) || text;

								text = taSanitize(text, '', _disableSanitizer);

								taSelection.insertHtml(text, element[0]);
								$timeout(function(){
									ngModel.$setViewValue(_compileHtml());
									_processingPaste = false;
									element.removeClass('processing-paste');
								}, 0);
							}else{
								_processingPaste = false;
								element.removeClass('processing-paste');
							}
						};

						element.on('paste', scope.events.paste = function(e, eventData){
							/* istanbul ignore else: this is for catching the jqLite testing*/
							if(eventData) angular.extend(e, eventData);
							if(_isReadonly || _processingPaste){
								e.stopPropagation();
								e.preventDefault();
								return false;
							}

							// Code adapted from http://stackoverflow.com/questions/2176861/javascript-get-clipboard-data-on-paste-event-cross-browser/6804718#6804718
							_processingPaste = true;
							element.addClass('processing-paste');
							var pastedContent;
							var clipboardData = (e.originalEvent || e).clipboardData;
							if (clipboardData && clipboardData.getData && clipboardData.types.length > 0) {// Webkit - get data from clipboard, put into editdiv, cleanup, then cancel event
								var _types = "";
								for(var _t = 0; _t < clipboardData.types.length; _t++){
									_types += " " + clipboardData.types[_t];
								}
								/* istanbul ignore next: browser tests */
								if (/text\/html/i.test(_types)) {
									pastedContent = clipboardData.getData('text/html');
								} else if (/text\/plain/i.test(_types)) {
									pastedContent = clipboardData.getData('text/plain');
								}

								processpaste(pastedContent);
								e.stopPropagation();
								e.preventDefault();
								return false;
							} else {// Everything else - empty editdiv and allow browser to paste content into it, then cleanup
								var _savedSelection = $window.rangy.saveSelection(),
									_tempDiv = angular.element('<div class="ta-hidden-input" contenteditable="true"></div>');
								$document.find('body').append(_tempDiv);
								_tempDiv[0].focus();
								$timeout(function(){
									// restore selection
									$window.rangy.restoreSelection(_savedSelection);
									processpaste(_tempDiv[0].innerHTML);
									element[0].focus();
									_tempDiv.remove();
								}, 0);
							}
						});
						element.on('cut', scope.events.cut = function(e){
							// timeout to next is needed as otherwise the paste/cut event has not finished actually changing the display
							if(!_isReadonly) $timeout(function(){
								ngModel.$setViewValue(_compileHtml());
							}, 0);
							else e.preventDefault();
						});

						element.on('keydown', scope.events.keydown = function(event, eventData){
							/* istanbul ignore else: this is for catching the jqLite testing*/
							if(eventData) angular.extend(event, eventData);
							event.specialKey = _mapKeys(event);
							var userSpecialKey;
							/* istanbul ignore next: difficult to test */
							taOptions.keyMappings.forEach(function (mapping) {
								if (event.specialKey === mapping.commandKeyCode) {
									// taOptions has remapped this binding... so
									// we disable our own
									event.specialKey = undefined;
								}
								if (mapping.testForKey(event)) {
									userSpecialKey = mapping.commandKeyCode;
								}
								if ((mapping.commandKeyCode === 'UndoKey') || (mapping.commandKeyCode === 'RedoKey')) {
									// this is necessary to fully stop the propagation.
									if (!mapping.enablePropagation) {
										event.preventDefault();
									}
								}
							});
							/* istanbul ignore next: difficult to test */
							if (typeof userSpecialKey !== 'undefined') {
								event.specialKey = userSpecialKey;
							}
							/* istanbul ignore next: difficult to test as can't seem to select */
							if ((typeof event.specialKey !== 'undefined') && (
									event.specialKey !== 'UndoKey' || event.specialKey !== 'RedoKey'
								)) {
								event.preventDefault();
								textAngularManager.sendKeyCommand(scope, event);
							}
							/* istanbul ignore else: readonly check */
							if(!_isReadonly){
								if (event.specialKey==='UndoKey') {
									_undo();
									event.preventDefault();
								}
								if (event.specialKey==='RedoKey') {
									_redo();
									event.preventDefault();
								}
								/* istanbul ignore next: difficult to test as can't seem to select */
								if(event.keyCode === 13 && !event.shiftKey){
									var $selection;
									var selection = taSelection.getSelectionElement();
									if(!selection.tagName.match(VALIDELEMENTS)) return;
									var _new = angular.element(_defaultVal);
									if (/^<br(|\/)>$/i.test(selection.innerHTML.trim()) && selection.parentNode.tagName.toLowerCase() === 'blockquote' && !selection.nextSibling) {
										// if last element in blockquote and element is blank, pull element outside of blockquote.
										$selection = angular.element(selection);
										var _parent = $selection.parent();
										_parent.after(_new);
										$selection.remove();
										if(_parent.children().length === 0) _parent.remove();
										taSelection.setSelectionToElementStart(_new[0]);
										event.preventDefault();
									}else if (/^<[^>]+><br(|\/)><\/[^>]+>$/i.test(selection.innerHTML.trim()) && selection.tagName.toLowerCase() === 'blockquote'){
										$selection = angular.element(selection);
										$selection.after(_new);
										$selection.remove();
										taSelection.setSelectionToElementStart(_new[0]);
										event.preventDefault();
									}
								}
							}
						});
						var _keyupTimeout;
						element.on('keyup', scope.events.keyup = function(event, eventData){
							/* istanbul ignore else: this is for catching the jqLite testing*/
							if(eventData) angular.extend(event, eventData);
							/* istanbul ignore next: FF specific bug fix */
							if (event.keyCode === 9) {
								var _selection = taSelection.getSelection();
								if(_selection.start.element === element[0] && element.children().length) taSelection.setSelectionToElementStart(element.children()[0]);
								return;
							}
							if(_undoKeyupTimeout) $timeout.cancel(_undoKeyupTimeout);
							if(!_isReadonly && !BLOCKED_KEYS.test(event.keyCode)){
								// if enter - insert new taDefaultWrap, if shift+enter insert <br/>
								if(_defaultVal !== '' && event.keyCode === 13){
									if(!event.shiftKey){
										// new paragraph, br should be caught correctly
										var selection = taSelection.getSelectionElement();
										while(!selection.tagName.match(VALIDELEMENTS) && selection !== element[0]){
											selection = selection.parentNode;
										}

										if(selection.tagName.toLowerCase() !== attrs.taDefaultWrap && selection.tagName.toLowerCase() !== 'li' && (selection.innerHTML.trim() === '' || selection.innerHTML.trim() === '<br>')){
											var _new = angular.element(_defaultVal);
											angular.element(selection).replaceWith(_new);
											taSelection.setSelectionToElementStart(_new[0]);
										}
									}
								}
								var val = _compileHtml();
								if(_defaultVal !== '' && val.trim() === ''){
									_setInnerHTML(_defaultVal);
									taSelection.setSelectionToElementStart(element.children()[0]);
								}else if(val.substring(0, 1) !== '<' && attrs.taDefaultWrap !== ''){
									var _savedSelection = $window.rangy.saveSelection();
									val = _compileHtml();
									val = "<" + attrs.taDefaultWrap + ">" + val + "</" + attrs.taDefaultWrap + ">";
									_setInnerHTML(val);
									$window.rangy.restoreSelection(_savedSelection);
								}
								var triggerUndo = _lastKey !== event.keyCode && UNDO_TRIGGER_KEYS.test(event.keyCode);
								if(_keyupTimeout) $timeout.cancel(_keyupTimeout);
								_keyupTimeout = $timeout(function() {
									_setViewValue(val, triggerUndo, true);
								}, ngModelOptions.$options.debounce || 400);
								if(!triggerUndo) _undoKeyupTimeout = $timeout(function(){ ngModel.$undoManager.push(val); }, 250);
								_lastKey = event.keyCode;
							}
						});

						element.on('blur', scope.events.blur = function(){
							_focussed = false;
							/* istanbul ignore else: if readonly don't update model */
							if(!_isReadonly){
								_setViewValue(undefined, undefined, true);
							}else{
								_skipRender = true; // don't redo the whole thing, just check the placeholder logic
								ngModel.$render();
							}
						});

						// Placeholders not supported on ie 8 and below
						if(attrs.placeholder && (_browserDetect.ie > 8 || _browserDetect.ie === undefined)){
							var rule;
							if(attrs.id) rule = addCSSRule('#' + attrs.id + '.placeholder-text:before', 'content: "' + attrs.placeholder + '"');
							else throw('textAngular Error: An unique ID is required for placeholders to work');

							scope.$on('$destroy', function(){
								removeCSSRule(rule);
							});
						}

						element.on('focus', scope.events.focus = function(){
							_focussed = true;
							element.removeClass('placeholder-text');
							_reApplyOnSelectorHandlers();
						});

						element.on('mouseup', scope.events.mouseup = function(){
							var _selection = taSelection.getSelection();
							if(_selection.start.element === element[0] && element.children().length) taSelection.setSelectionToElementStart(element.children()[0]);
						});

						// prevent propagation on mousedown in editor, see #206
						element.on('mousedown', scope.events.mousedown = function(event, eventData){
							/* istanbul ignore else: this is for catching the jqLite testing*/
							if(eventData) angular.extend(event, eventData);
							event.stopPropagation();
						});
					}
				}

				var selectorClickHandler = function(event){
					// emit the element-select event, pass the element
					scope.$emit('ta-element-select', this);
					event.preventDefault();
					return false;
				};
				var fileDropHandler = function(event, eventData){
					/* istanbul ignore else: this is for catching the jqLite testing*/
					if(eventData) angular.extend(event, eventData);
					// emit the drop event, pass the element, preventing should be done elsewhere
					if(!dropFired && !_isReadonly){
						dropFired = true;
						var dataTransfer;
						if(event.originalEvent) dataTransfer = event.originalEvent.dataTransfer;
						else dataTransfer = event.dataTransfer;
						scope.$emit('ta-drop-event', this, event, dataTransfer);
						$timeout(function(){
							dropFired = false;
							_setViewValue(undefined, undefined, true);
						}, 100);
					}
				};

				//used for updating when inserting wrapped elements
				var _reApplyOnSelectorHandlers = scope['reApplyOnSelectorHandlers' + (attrs.id || '')] = function(){
					/* istanbul ignore else */
					if(!_isReadonly) angular.forEach(taSelectableElements, function(selector){
							// check we don't apply the handler twice
							element.find(selector)
								.off('click', selectorClickHandler)
								.on('click', selectorClickHandler);
						});
				};

				var _setInnerHTML = function(newval){
					element[0].innerHTML = newval;
				};
				var _renderTimeout;
				var _renderInProgress = false;
				// changes to the model variable from outside the html/text inputs
				ngModel.$render = function(){
					/* istanbul ignore if: Catches rogue renders, hard to replicate in tests */
					if(_renderInProgress) return;
					else _renderInProgress = true;
					// catch model being null or undefined
					var val = ngModel.$viewValue || '';
					// if the editor isn't focused it needs to be updated, otherwise it's receiving user input
					if(!_skipRender){
						/* istanbul ignore else: in other cases we don't care */
						if(_isContentEditable && _focussed){
							// update while focussed
							element.removeClass('placeholder-text');
							if(_renderTimeout) $timeout.cancel(_renderTimeout);
							_renderTimeout = $timeout(function(){
								/* istanbul ignore if: Can't be bothered testing this... */
								if(!_focussed){
									element[0].focus();
									taSelection.setSelectionToElementEnd(element.children()[element.children().length - 1]);
								}
								_renderTimeout = undefined;
							}, 1);
						}
						if(_isContentEditable){
							// WYSIWYG Mode
							if(attrs.placeholder){
								if(val === ''){
									// blank
									_setInnerHTML(_defaultVal);
								}else{
									// not-blank
									_setInnerHTML(val);
								}
							}else{
								_setInnerHTML((val === '') ? _defaultVal : val);
							}
							// if in WYSIWYG and readOnly we kill the use of links by clicking
							if(!_isReadonly){
								_reApplyOnSelectorHandlers();
								element.on('drop', fileDropHandler);
							}else{
								element.off('drop', fileDropHandler);
							}
						}else if(element[0].tagName.toLowerCase() !== 'textarea' && element[0].tagName.toLowerCase() !== 'input'){
							// make sure the end user can SEE the html code as a display. This is a read-only display element
							_setInnerHTML(taApplyCustomRenderers(val));
						}else{
							// only for input and textarea inputs
							element.val(val);
						}
					}
					if(_isContentEditable && attrs.placeholder){
						if(val === ''){
							if(_focussed) element.removeClass('placeholder-text');
							else element.addClass('placeholder-text');
						}else{
							element.removeClass('placeholder-text');
						}
					}
					_renderInProgress = _skipRender = false;
				};

				if(attrs.taReadonly){
					//set initial value
					_isReadonly = scope.$eval(attrs.taReadonly);
					if(_isReadonly){
						element.addClass('ta-readonly');
						// we changed to readOnly mode (taReadonly='true')
						if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){
							element.attr('disabled', 'disabled');
						}
						if(element.attr('contenteditable') !== undefined && element.attr('contenteditable')){
							element.removeAttr('contenteditable');
						}
					}else{
						element.removeClass('ta-readonly');
						// we changed to NOT readOnly mode (taReadonly='false')
						if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){
							element.removeAttr('disabled');
						}else if(_isContentEditable){
							element.attr('contenteditable', 'true');
						}
					}
					// taReadonly only has an effect if the taBind element is an input or textarea or has contenteditable='true' on it.
					// Otherwise it is readonly by default
					scope.$watch(attrs.taReadonly, function(newVal, oldVal){
						if(oldVal === newVal) return;
						if(newVal){
							element.addClass('ta-readonly');
							// we changed to readOnly mode (taReadonly='true')
							if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){
								element.attr('disabled', 'disabled');
							}
							if(element.attr('contenteditable') !== undefined && element.attr('contenteditable')){
								element.removeAttr('contenteditable');
							}
							// turn ON selector click handlers
							angular.forEach(taSelectableElements, function(selector){
								element.find(selector).on('click', selectorClickHandler);
							});
							element.off('drop', fileDropHandler);
						}else{
							element.removeClass('ta-readonly');
							// we changed to NOT readOnly mode (taReadonly='false')
							if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){
								element.removeAttr('disabled');
							}else if(_isContentEditable){
								element.attr('contenteditable', 'true');
							}
							// remove the selector click handlers
							angular.forEach(taSelectableElements, function(selector){
								element.find(selector).off('click', selectorClickHandler);
							});
							element.on('drop', fileDropHandler);
						}
						_isReadonly = newVal;
					});
				}

				// Initialise the selectableElements
				// if in WYSIWYG and readOnly we kill the use of links by clicking
				if(_isContentEditable && !_isReadonly){
					angular.forEach(taSelectableElements, function(selector){
						element.find(selector).on('click', selectorClickHandler);
					});
					element.on('drop', fileDropHandler);
					element.on('blur', function(){
						/* istanbul ignore next: webkit fix */
						if(_browserDetect.webkit) { // detect webkit
							globalContentEditableBlur = true;
						}
					});
				}
			}
		};
	}]);

	// this global var is used to prevent multiple fires of the drop event. Needs to be global to the textAngular file.
	var dropFired = false;
	var textAngular = angular.module("textAngular", ['ngSanitize', 'textAngularSetup', 'textAngular.factories', 'textAngular.DOM', 'textAngular.validators', 'textAngular.taBind']); //This makes ngSanitize required

	// setup the global contstant functions for setting up the toolbar

	// all tool definitions
	var taTools = {};
	/*
		A tool definition is an object with the following key/value parameters:
			action: [function(deferred, restoreSelection)]
					a function that is executed on clicking on the button - this will allways be executed using ng-click and will
					overwrite any ng-click value in the display attribute.
					The function is passed a deferred object ($q.defer()), if this is wanted to be used `return false;` from the action and
					manually call `deferred.resolve();` elsewhere to notify the editor that the action has finished.
					restoreSelection is only defined if the rangy library is included and it can be called as `restoreSelection()` to restore the users
					selection in the WYSIWYG editor.
			display: [string]?
					Optional, an HTML element to be displayed as the button. The `scope` of the button is the tool definition object with some additional functions
					If set this will cause buttontext and iconclass to be ignored
			class: [string]?
					Optional, if set will override the taOptions.classes.toolbarButton class.
			buttontext: [string]?
					if this is defined it will replace the contents of the element contained in the `display` element
			iconclass: [string]?
					if this is defined an icon (<i>) will be appended to the `display` element with this string as it's class
			tooltiptext: [string]?
					Optional, a plain text description of the action, used for the title attribute of the action button in the toolbar by default.
			activestate: [function(commonElement)]?
					this function is called on every caret movement, if it returns true then the class taOptions.classes.toolbarButtonActive
					will be applied to the `display` element, else the class will be removed
			disabled: [function()]?
					if this function returns true then the tool will have the class taOptions.classes.disabled applied to it, else it will be removed
		Other functions available on the scope are:
			name: [string]
					the name of the tool, this is the first parameter passed into taRegisterTool
			isDisabled: [function()]
					returns true if the tool is disabled, false if it isn't
			displayActiveToolClass: [function(boolean)]
					returns true if the tool is 'active' in the currently focussed toolbar
			onElementSelect: [Object]
					This object contains the following key/value pairs and is used to trigger the ta-element-select event
					element: [String]
						an element name, will only trigger the onElementSelect action if the tagName of the element matches this string
					filter: [function(element)]?
						an optional filter that returns a boolean, if true it will trigger the onElementSelect.
					action: [function(event, element, editorScope)]
						the action that should be executed if the onElementSelect function runs
	*/
	// name and toolDefinition to add into the tools available to be added on the toolbar
	function registerTextAngularTool(name, toolDefinition){
		if(!name || name === '' || taTools.hasOwnProperty(name)) throw('textAngular Error: A unique name is required for a Tool Definition');
		if(
			(toolDefinition.display && (toolDefinition.display === '' || !validElementString(toolDefinition.display))) ||
			(!toolDefinition.display && !toolDefinition.buttontext && !toolDefinition.iconclass)
		)
			throw('textAngular Error: Tool Definition for "' + name + '" does not have a valid display/iconclass/buttontext value');
		taTools[name] = toolDefinition;
	}

	textAngular.constant('taRegisterTool', registerTextAngularTool);
	textAngular.value('taTools', taTools);

	textAngular.config([function(){
		// clear taTools variable. Just catches testing and any other time that this config may run multiple times...
		angular.forEach(taTools, function(value, key){ delete taTools[key];	});
	}]);

	textAngular.run([function(){
		/* istanbul ignore next: not sure how to test this */
		// Require Rangy and rangy savedSelection module.
		if(!window.rangy){
			throw("rangy-core.js and rangy-selectionsaverestore.js are required for textAngular to work correctly, rangy-core is not yet loaded.");
		}else{
			window.rangy.init();
			if(!window.rangy.saveSelection){
				throw("rangy-selectionsaverestore.js is required for textAngular to work correctly.");
			}
		}
	}]);

	textAngular.directive("textAngular", [
		'$compile', '$timeout', 'taOptions', 'taSelection', 'taExecCommand',
		'textAngularManager', '$window', '$document', '$animate', '$log', '$q', '$parse',
		function($compile, $timeout, taOptions, taSelection, taExecCommand,
			textAngularManager, $window, $document, $animate, $log, $q, $parse){
			return {
				require: '?ngModel',
				scope: {},
				restrict: "EA",
				priority: 2, // So we override validators correctly
				link: function(scope, element, attrs, ngModel){
					// all these vars should not be accessable outside this directive
					var _keydown, _keyup, _keypress, _mouseup, _focusin, _focusout,
						_originalContents, _toolbars,
						_serial = (attrs.serial) ? attrs.serial : Math.floor(Math.random() * 10000000000000000),
						_taExecCommand, _resizeMouseDown, _updateSelectedStylesTimeout;

					scope._name = (attrs.name) ? attrs.name : 'textAngularEditor' + _serial;

					var oneEvent = function(_element, event, action){
						$timeout(function(){
							// shim the .one till fixed
							var _func = function(){
								_element.off(event, _func);
								action.apply(this, arguments);
							};
							_element.on(event, _func);
						}, 100);
					};
					_taExecCommand = taExecCommand(attrs.taDefaultWrap);
					// get the settings from the defaults and add our specific functions that need to be on the scope
					angular.extend(scope, angular.copy(taOptions), {
						// wraps the selection in the provided tag / execCommand function. Should only be called in WYSIWYG mode.
						wrapSelection: function(command, opt, isSelectableElementTool){
							if(command.toLowerCase() === "undo"){
								scope['$undoTaBindtaTextElement' + _serial]();
							}else if(command.toLowerCase() === "redo"){
								scope['$redoTaBindtaTextElement' + _serial]();
							}else{
								// catch errors like FF erroring when you try to force an undo with nothing done
								_taExecCommand(command, false, opt, scope.defaultTagAttributes);
								if(isSelectableElementTool){
									// re-apply the selectable tool events
									scope['reApplyOnSelectorHandlerstaTextElement' + _serial]();
								}
								// refocus on the shown display element, this fixes a display bug when using :focus styles to outline the box.
								// You still have focus on the text/html input it just doesn't show up
								scope.displayElements.text[0].focus();
							}
						},
						showHtml: scope.$eval(attrs.taShowHtml) || false
					});
					// setup the options from the optional attributes
					if(attrs.taFocussedClass)			scope.classes.focussed = attrs.taFocussedClass;
					if(attrs.taTextEditorClass)			scope.classes.textEditor = attrs.taTextEditorClass;
					if(attrs.taHtmlEditorClass)			scope.classes.htmlEditor = attrs.taHtmlEditorClass;
					if(attrs.taDefaultTagAttributes){
						try	{
							//	TODO: This should use angular.merge to enhance functionality once angular 1.4 is required
							angular.extend(scope.defaultTagAttributes, angular.fromJson(attrs.taDefaultTagAttributes));
						} catch (error) {
							$log.error(error);
						}
					}
					// optional setup functions
					if(attrs.taTextEditorSetup)			scope.setup.textEditorSetup = scope.$parent.$eval(attrs.taTextEditorSetup);
					if(attrs.taHtmlEditorSetup)			scope.setup.htmlEditorSetup = scope.$parent.$eval(attrs.taHtmlEditorSetup);
					// optional fileDropHandler function
					if(attrs.taFileDrop)				scope.fileDropHandler = scope.$parent.$eval(attrs.taFileDrop);
					else								scope.fileDropHandler = scope.defaultFileDropHandler;

					_originalContents = element[0].innerHTML;
					// clear the original content
					element[0].innerHTML = '';

					// Setup the HTML elements as variable references for use later
					scope.displayElements = {
						// we still need the hidden input even with a textarea as the textarea may have invalid/old input in it,
						// wheras the input will ALLWAYS have the correct value.
						forminput: angular.element("<input type='hidden' tabindex='-1' style='display: none;'>"),
						html: angular.element("<textarea></textarea>"),
						text: angular.element("<div></div>"),
						// other toolbased elements
						scrollWindow: angular.element("<div class='ta-scroll-window'></div>"),
						popover: angular.element('<div class="popover fade bottom" style="max-width: none; width: 305px;"></div>'),
						popoverArrow: angular.element('<div class="arrow"></div>'),
						popoverContainer: angular.element('<div class="popover-content"></div>'),
						resize: {
							overlay: angular.element('<div class="ta-resizer-handle-overlay"></div>'),
							background: angular.element('<div class="ta-resizer-handle-background"></div>'),
							anchors: [
								angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-tl"></div>'),
								angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-tr"></div>'),
								angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-bl"></div>'),
								angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-br"></div>')
							],
							info: angular.element('<div class="ta-resizer-handle-info"></div>')
						}
					};

					// Setup the popover
					scope.displayElements.popover.append(scope.displayElements.popoverArrow);
					scope.displayElements.popover.append(scope.displayElements.popoverContainer);
					scope.displayElements.scrollWindow.append(scope.displayElements.popover);

					scope.displayElements.popover.on('mousedown', function(e, eventData){
						/* istanbul ignore else: this is for catching the jqLite testing*/
						if(eventData) angular.extend(e, eventData);
						// this prevents focusout from firing on the editor when clicking anything in the popover
						e.preventDefault();
						return false;
					});

					// define the popover show and hide functions
					scope.showPopover = function(_el){
						scope.displayElements.popover.css('display', 'block');
						scope.reflowPopover(_el);
						$animate.addClass(scope.displayElements.popover, 'in');
						oneEvent($document.find('body'), 'click keyup', function(){scope.hidePopover();});
					};
					scope.reflowPopover = function(_el){
						/* istanbul ignore if: catches only if near bottom of editor */
						if(scope.displayElements.text[0].offsetHeight - 51 > _el[0].offsetTop){
							scope.displayElements.popover.css('top', _el[0].offsetTop + _el[0].offsetHeight + scope.displayElements.scrollWindow[0].scrollTop + 'px');
							scope.displayElements.popover.removeClass('top').addClass('bottom');
						}else{
							scope.displayElements.popover.css('top', _el[0].offsetTop - 54 + scope.displayElements.scrollWindow[0].scrollTop + 'px');
							scope.displayElements.popover.removeClass('bottom').addClass('top');
						}
						var _maxLeft = scope.displayElements.text[0].offsetWidth - scope.displayElements.popover[0].offsetWidth;
						var _targetLeft = _el[0].offsetLeft + (_el[0].offsetWidth / 2.0) - (scope.displayElements.popover[0].offsetWidth / 2.0);
						scope.displayElements.popover.css('left', Math.max(0, Math.min(_maxLeft, _targetLeft)) + 'px');
						scope.displayElements.popoverArrow.css('margin-left', (Math.min(_targetLeft, (Math.max(0, _targetLeft - _maxLeft))) - 11) + 'px');
					};
					scope.hidePopover = function(){
						/* istanbul ignore next: dosen't test with mocked animate */
						var doneCb = function(){
							scope.displayElements.popover.css('display', '');
							scope.displayElements.popoverContainer.attr('style', '');
							scope.displayElements.popoverContainer.attr('class', 'popover-content');
						};
						$q.when($animate.removeClass(scope.displayElements.popover, 'in', doneCb)).then(doneCb);
					};

					// setup the resize overlay
					scope.displayElements.resize.overlay.append(scope.displayElements.resize.background);
					angular.forEach(scope.displayElements.resize.anchors, function(anchor){ scope.displayElements.resize.overlay.append(anchor);});
					scope.displayElements.resize.overlay.append(scope.displayElements.resize.info);
					scope.displayElements.scrollWindow.append(scope.displayElements.resize.overlay);

					// define the show and hide events
					scope.reflowResizeOverlay = function(_el){
						_el = angular.element(_el)[0];
						scope.displayElements.resize.overlay.css({
							'display': 'block',
							'left': _el.offsetLeft - 5 + 'px',
							'top': _el.offsetTop - 5 + 'px',
							'width': _el.offsetWidth + 10 + 'px',
							'height': _el.offsetHeight + 10 + 'px'
						});
						scope.displayElements.resize.info.text(_el.offsetWidth + ' x ' + _el.offsetHeight);
					};
					/* istanbul ignore next: pretty sure phantomjs won't test this */
					scope.showResizeOverlay = function(_el){
						var _body = $document.find('body');
						_resizeMouseDown = function(event){
							var startPosition = {
								width: parseInt(_el.attr('width')),
								height: parseInt(_el.attr('height')),
								x: event.clientX,
								y: event.clientY
							};
							if(startPosition.width === undefined || isNaN(startPosition.width)) startPosition.width = _el[0].offsetWidth;
							if(startPosition.height === undefined || isNaN(startPosition.height)) startPosition.height = _el[0].offsetHeight;
							scope.hidePopover();
							var ratio = startPosition.height / startPosition.width;
							var mousemove = function(event){
								// calculate new size
								var pos = {
									x: Math.max(0, startPosition.width + (event.clientX - startPosition.x)),
									y: Math.max(0, startPosition.height + (event.clientY - startPosition.y))
								};

								// DEFAULT: the aspect ratio is not locked unless the Shift key is pressed.
								//
								// attribute: ta-resize-force-aspect-ratio -- locks resize into maintaing the aspect ratio
								var bForceAspectRatio = (attrs.taResizeForceAspectRatio !== undefined);
								// attribute: ta-resize-maintain-aspect-ratio=true causes the space ratio to remain locked
								// unless the Shift key is pressed
								var bFlipKeyBinding = attrs.taResizeMaintainAspectRatio;
								var bKeepRatio =  bForceAspectRatio || (bFlipKeyBinding && !event.shiftKey);
								if(bKeepRatio) {
									var newRatio = pos.y / pos.x;
									pos.x = ratio > newRatio ? pos.x : pos.y / ratio;
									pos.y = ratio > newRatio ? pos.x * ratio : pos.y;
								}
								var el = angular.element(_el);
								el.css('height', Math.round(Math.max(0, pos.y) + 'px'));
								el.css('width', Math.round(Math.max(0, pos.x) + 'px'));

								// reflow the popover tooltip
								scope.reflowResizeOverlay(_el);
							};
							_body.on('mousemove', mousemove);
							oneEvent(_body, 'mouseup', function(event){
								event.preventDefault();
								event.stopPropagation();
								_body.off('mousemove', mousemove);
								scope.showPopover(_el);
							});
							event.stopPropagation();
							event.preventDefault();
						};

						scope.displayElements.resize.anchors[3].off('mousedown');
						scope.displayElements.resize.anchors[3].on('mousedown', _resizeMouseDown);

						scope.reflowResizeOverlay(_el);
						oneEvent(_body, 'click', function(){scope.hideResizeOverlay();});
					};
					/* istanbul ignore next: pretty sure phantomjs won't test this */
					scope.hideResizeOverlay = function(){
						scope.displayElements.resize.anchors[3].off('mousedown', _resizeMouseDown);
						scope.displayElements.resize.overlay.css('display', '');
					};

					// allow for insertion of custom directives on the textarea and div
					scope.setup.htmlEditorSetup(scope.displayElements.html);
					scope.setup.textEditorSetup(scope.displayElements.text);
					scope.displayElements.html.attr({
						'id': 'taHtmlElement' + _serial,
						'ng-show': 'showHtml',
						'ta-bind': 'ta-bind',
						'ng-model': 'html',
						'ng-model-options': element.attr('ng-model-options')
					});
					scope.displayElements.text.attr({
						'id': 'taTextElement' + _serial,
						'contentEditable': 'true',
						'ta-bind': 'ta-bind',
						'ng-model': 'html',
						'ng-model-options': element.attr('ng-model-options')
					});
					scope.displayElements.scrollWindow.attr({'ng-hide': 'showHtml'});
					if(attrs.taDefaultWrap) scope.displayElements.text.attr('ta-default-wrap', attrs.taDefaultWrap);

					if(attrs.taUnsafeSanitizer){
						scope.displayElements.text.attr('ta-unsafe-sanitizer', attrs.taUnsafeSanitizer);
						scope.displayElements.html.attr('ta-unsafe-sanitizer', attrs.taUnsafeSanitizer);
					}

					// add the main elements to the origional element
					scope.displayElements.scrollWindow.append(scope.displayElements.text);
					element.append(scope.displayElements.scrollWindow);
					element.append(scope.displayElements.html);

					scope.displayElements.forminput.attr('name', scope._name);
					element.append(scope.displayElements.forminput);

					if(attrs.tabindex){
						element.removeAttr('tabindex');
						scope.displayElements.text.attr('tabindex', attrs.tabindex);
						scope.displayElements.html.attr('tabindex', attrs.tabindex);
					}

					if (attrs.placeholder) {
						scope.displayElements.text.attr('placeholder', attrs.placeholder);
						scope.displayElements.html.attr('placeholder', attrs.placeholder);
					}

					if(attrs.taDisabled){
						scope.displayElements.text.attr('ta-readonly', 'disabled');
						scope.displayElements.html.attr('ta-readonly', 'disabled');
						scope.disabled = scope.$parent.$eval(attrs.taDisabled);
						scope.$parent.$watch(attrs.taDisabled, function(newVal){
							scope.disabled = newVal;
							if(scope.disabled){
								element.addClass(scope.classes.disabled);
							}else{
								element.removeClass(scope.classes.disabled);
							}
						});
					}

					if(attrs.taPaste){
						scope._pasteHandler = function(_html){
							return $parse(attrs.taPaste)(scope.$parent, {$html: _html});
						};
						scope.displayElements.text.attr('ta-paste', '_pasteHandler($html)');
					}

					// compile the scope with the text and html elements only - if we do this with the main element it causes a compile loop
					$compile(scope.displayElements.scrollWindow)(scope);
					$compile(scope.displayElements.html)(scope);

					scope.updateTaBindtaTextElement = scope['updateTaBindtaTextElement' + _serial];
					scope.updateTaBindtaHtmlElement = scope['updateTaBindtaHtmlElement' + _serial];

					// add the classes manually last
					element.addClass("ta-root");
					scope.displayElements.scrollWindow.addClass("ta-text ta-editor " + scope.classes.textEditor);
					scope.displayElements.html.addClass("ta-html ta-editor " + scope.classes.htmlEditor);

					// used in the toolbar actions
					scope._actionRunning = false;
					var _savedSelection = false;
					scope.startAction = function(){
						scope._actionRunning = true;
						// if rangy library is loaded return a function to reload the current selection
						_savedSelection = $window.rangy.saveSelection();
						return function(){
							if(_savedSelection) $window.rangy.restoreSelection(_savedSelection);
						};
					};
					scope.endAction = function(){
						scope._actionRunning = false;
						if(_savedSelection){
							if(scope.showHtml){
								scope.displayElements.html[0].focus();
							}else{
								scope.displayElements.text[0].focus();
							}
							// $window.rangy.restoreSelection(_savedSelection);
							$window.rangy.removeMarkers(_savedSelection);
						}
						_savedSelection = false;
						scope.updateSelectedStyles();
						// only update if in text or WYSIWYG mode
						if(!scope.showHtml) scope['updateTaBindtaTextElement' + _serial]();
					};

					// note that focusout > focusin is called everytime we click a button - except bad support: http://www.quirksmode.org/dom/events/blurfocus.html
					// cascades to displayElements.text and displayElements.html automatically.
					_focusin = function(){
						scope.focussed = true;
						element.addClass(scope.classes.focussed);
						_toolbars.focus();
						element.triggerHandler('focus');
					};
					scope.displayElements.html.on('focus', _focusin);
					scope.displayElements.text.on('focus', _focusin);
					_focusout = function(e){
						// if we are NOT runnig an action and have NOT focussed again on the text etc then fire the blur events
						if(!scope._actionRunning && $document[0].activeElement !== scope.displayElements.html[0] && $document[0].activeElement !== scope.displayElements.text[0]){
							element.removeClass(scope.classes.focussed);
							_toolbars.unfocus();
							// to prevent multiple apply error defer to next seems to work.
							$timeout(function(){
								scope._bUpdateSelectedStyles = false;
								element.triggerHandler('blur');
								scope.focussed = false;
							}, 0);
						}
						e.preventDefault();
						return false;
					};
					scope.displayElements.html.on('blur', _focusout);
					scope.displayElements.text.on('blur', _focusout);

					scope.displayElements.text.on('paste', function(event){
						element.triggerHandler('paste', event);
					});

					// Setup the default toolbar tools, this way allows the user to add new tools like plugins.
					// This is on the editor for future proofing if we find a better way to do this.
					scope.queryFormatBlockState = function(command){
						// $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea
						return !scope.showHtml && command.toLowerCase() === $document[0].queryCommandValue('formatBlock').toLowerCase();
					};
					scope.queryCommandState = function(command){
						// $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea
						return (!scope.showHtml) ? $document[0].queryCommandState(command) : '';
					};
					scope.switchView = function(){
						scope.showHtml = !scope.showHtml;
						$animate.enabled(false, scope.displayElements.html);
						$animate.enabled(false, scope.displayElements.text);
						//Show the HTML view
						if(scope.showHtml){
							//defer until the element is visible
							$timeout(function(){
								$animate.enabled(true, scope.displayElements.html);
								$animate.enabled(true, scope.displayElements.text);
								// [0] dereferences the DOM object from the angular.element
								return scope.displayElements.html[0].focus();
							}, 100);
						}else{
							//Show the WYSIWYG view
							//defer until the element is visible
							$timeout(function(){
								$animate.enabled(true, scope.displayElements.html);
								$animate.enabled(true, scope.displayElements.text);
								// [0] dereferences the DOM object from the angular.element
								return scope.displayElements.text[0].focus();
							}, 100);
						}
					};

					// changes to the model variable from outside the html/text inputs
					// if no ngModel, then the only input is from inside text-angular
					if(attrs.ngModel){
						var _firstRun = true;
						ngModel.$render = function(){
							if(_firstRun){
								// we need this firstRun to set the originalContents otherwise it gets overrided by the setting of ngModel to undefined from NaN
								_firstRun = false;
								// if view value is null or undefined initially and there was original content, set to the original content
								var _initialValue = scope.$parent.$eval(attrs.ngModel);
								if((_initialValue === undefined || _initialValue === null) && (_originalContents && _originalContents !== '')){
									// on passing through to taBind it will be sanitised
									ngModel.$setViewValue(_originalContents);
								}
							}
							scope.displayElements.forminput.val(ngModel.$viewValue);
							// if the editors aren't focused they need to be updated, otherwise they are doing the updating
							scope.html = ngModel.$viewValue || '';
						};
						// trigger the validation calls
						if(element.attr('required')) ngModel.$validators.required = function(modelValue, viewValue) {
							var value = modelValue || viewValue;
							return !(!value || value.trim() === '');
						};
					}else{
						// if no ngModel then update from the contents of the origional html.
						scope.displayElements.forminput.val(_originalContents);
						scope.html = _originalContents;
					}

					// changes from taBind back up to here
					scope.$watch('html', function(newValue, oldValue){
						if(newValue !== oldValue){
							if(attrs.ngModel && ngModel.$viewValue !== newValue) ngModel.$setViewValue(newValue);
							scope.displayElements.forminput.val(newValue);
						}
					});

					if(attrs.taTargetToolbars) _toolbars = textAngularManager.registerEditor(scope._name, scope, attrs.taTargetToolbars.split(','));
					else{
						var _toolbar = angular.element('<div text-angular-toolbar name="textAngularToolbar' + _serial + '">');
						// passthrough init of toolbar options
						if(attrs.taToolbar)						_toolbar.attr('ta-toolbar', attrs.taToolbar);
						if(attrs.taToolbarClass)				_toolbar.attr('ta-toolbar-class', attrs.taToolbarClass);
						if(attrs.taToolbarGroupClass)			_toolbar.attr('ta-toolbar-group-class', attrs.taToolbarGroupClass);
						if(attrs.taToolbarButtonClass)			_toolbar.attr('ta-toolbar-button-class', attrs.taToolbarButtonClass);
						if(attrs.taToolbarActiveButtonClass)	_toolbar.attr('ta-toolbar-active-button-class', attrs.taToolbarActiveButtonClass);
						if(attrs.taFocussedClass)				_toolbar.attr('ta-focussed-class', attrs.taFocussedClass);

						element.prepend(_toolbar);
						$compile(_toolbar)(scope.$parent);
						_toolbars = textAngularManager.registerEditor(scope._name, scope, ['textAngularToolbar' + _serial]);
					}

					scope.$on('$destroy', function(){
						textAngularManager.unregisterEditor(scope._name);
					});

					// catch element select event and pass to toolbar tools
					scope.$on('ta-element-select', function(event, element){
						if(_toolbars.triggerElementSelect(event, element)){
							scope['reApplyOnSelectorHandlerstaTextElement' + _serial]();
						}
					});

					scope.$on('ta-drop-event', function(event, element, dropEvent, dataTransfer){
						scope.displayElements.text[0].focus();
						if(dataTransfer && dataTransfer.files && dataTransfer.files.length > 0){
							angular.forEach(dataTransfer.files, function(file){
								// taking advantage of boolean execution, if the fileDropHandler returns true, nothing else after it is executed
								// If it is false then execute the defaultFileDropHandler if the fileDropHandler is NOT the default one
								// Once one of these has been executed wrap the result as a promise, if undefined or variable update the taBind, else we should wait for the promise
								try{
									$q.when(scope.fileDropHandler(file, scope.wrapSelection) ||
										(scope.fileDropHandler !== scope.defaultFileDropHandler &&
										$q.when(scope.defaultFileDropHandler(file, scope.wrapSelection)))).then(function(){
											scope['updateTaBindtaTextElement' + _serial]();
										});
								}catch(error){
									$log.error(error);
								}
							});
							dropEvent.preventDefault();
							dropEvent.stopPropagation();
						/* istanbul ignore else, the updates if moved text */
						}else{
							$timeout(function(){
								scope['updateTaBindtaTextElement' + _serial]();
							}, 0);
						}
					});

					// the following is for applying the active states to the tools that support it
					scope._bUpdateSelectedStyles = false;
					/* istanbul ignore next: browser window/tab leave check */
					angular.element(window).on('blur', function(){
						scope._bUpdateSelectedStyles = false;
						scope.focussed = false;
					});
					// loop through all the tools polling their activeState function if it exists
					scope.updateSelectedStyles = function(){
						var _selection;
						/* istanbul ignore next: This check is to ensure multiple timeouts don't exist */
						if(_updateSelectedStylesTimeout) $timeout.cancel(_updateSelectedStylesTimeout);
						// test if the common element ISN'T the root ta-text node
						if((_selection = taSelection.getSelectionElement()) !== undefined && _selection.parentNode !== scope.displayElements.text[0]){
							_toolbars.updateSelectedStyles(angular.element(_selection));
						}else _toolbars.updateSelectedStyles();
						// used to update the active state when a key is held down, ie the left arrow
						/* istanbul ignore else: browser only check */
						if(scope._bUpdateSelectedStyles) _updateSelectedStylesTimeout = $timeout(scope.updateSelectedStyles, 200);
					};
					// start updating on keydown
					_keydown = function(){
						/* istanbul ignore next: ie catch */
						if(!scope.focussed){
							scope._bUpdateSelectedStyles = false;
							return;
						}
						/* istanbul ignore else: don't run if already running */
						if(!scope._bUpdateSelectedStyles){
							scope._bUpdateSelectedStyles = true;
							scope.$apply(function(){
								scope.updateSelectedStyles();
							});
						}
					};
					scope.displayElements.html.on('keydown', _keydown);
					scope.displayElements.text.on('keydown', _keydown);
					// stop updating on key up and update the display/model
					_keyup = function(){
						scope._bUpdateSelectedStyles = false;
					};
					scope.displayElements.html.on('keyup', _keyup);
					scope.displayElements.text.on('keyup', _keyup);
					// stop updating on key up and update the display/model
					_keypress = function(event, eventData){
						/* istanbul ignore else: this is for catching the jqLite testing*/
						if(eventData) angular.extend(event, eventData);
						scope.$apply(function(){
							if(_toolbars.sendKeyCommand(event)){
								/* istanbul ignore else: don't run if already running */
								if(!scope._bUpdateSelectedStyles){
									scope.updateSelectedStyles();
								}
								event.preventDefault();
								return false;
							}
						});
					};
					scope.displayElements.html.on('keypress', _keypress);
					scope.displayElements.text.on('keypress', _keypress);
					// update the toolbar active states when we click somewhere in the text/html boxed
					_mouseup = function(){
						// ensure only one execution of updateSelectedStyles()
						scope._bUpdateSelectedStyles = false;
						scope.$apply(function(){
							scope.updateSelectedStyles();
						});
					};
					scope.displayElements.html.on('mouseup', _mouseup);
					scope.displayElements.text.on('mouseup', _mouseup);
				}
			};
		}
	]);
	textAngular.service('textAngularManager', ['taToolExecuteAction', 'taTools', 'taRegisterTool', function(taToolExecuteAction, taTools, taRegisterTool){
		// this service is used to manage all textAngular editors and toolbars.
		// All publicly published functions that modify/need to access the toolbar or editor scopes should be in here
		// these contain references to all the editors and toolbars that have been initialised in this app
		var toolbars = {}, editors = {};
		// when we focus into a toolbar, we need to set the TOOLBAR's $parent to be the toolbars it's linked to.
		// We also need to set the tools to be updated to be the toolbars...
		return {
			// register an editor and the toolbars that it is affected by
			registerEditor: function(name, scope, targetToolbars){
				// targetToolbars are optional, we don't require a toolbar to function
				if(!name || name === '') throw('textAngular Error: An editor requires a name');
				if(!scope) throw('textAngular Error: An editor requires a scope');
				if(editors[name]) throw('textAngular Error: An Editor with name "' + name + '" already exists');
				// _toolbars is an ARRAY of toolbar scopes
				var _toolbars = [];
				angular.forEach(targetToolbars, function(_name){
					if(toolbars[_name]) _toolbars.push(toolbars[_name]);
					// if it doesn't exist it may not have been compiled yet and it will be added later
				});
				editors[name] = {
					scope: scope,
					toolbars: targetToolbars,
					_registerToolbar: function(toolbarScope){
						// add to the list late
						if(this.toolbars.indexOf(toolbarScope.name) >= 0) _toolbars.push(toolbarScope);
					},
					// this is a suite of functions the editor should use to update all it's linked toolbars
					editorFunctions: {
						disable: function(){
							// disable all linked toolbars
							angular.forEach(_toolbars, function(toolbarScope){ toolbarScope.disabled = true; });
						},
						enable: function(){
							// enable all linked toolbars
							angular.forEach(_toolbars, function(toolbarScope){ toolbarScope.disabled = false; });
						},
						focus: function(){
							// this should be called when the editor is focussed
							angular.forEach(_toolbars, function(toolbarScope){
								toolbarScope._parent = scope;
								toolbarScope.disabled = false;
								toolbarScope.focussed = true;
								scope.focussed = true;
							});
						},
						unfocus: function(){
							// this should be called when the editor becomes unfocussed
							angular.forEach(_toolbars, function(toolbarScope){
								toolbarScope.disabled = true;
								toolbarScope.focussed = false;
							});
							scope.focussed = false;
						},
						updateSelectedStyles: function(selectedElement){
							// update the active state of all buttons on liked toolbars
							angular.forEach(_toolbars, function(toolbarScope){
								angular.forEach(toolbarScope.tools, function(toolScope){
									if(toolScope.activeState){
										toolbarScope._parent = scope;
										toolScope.active = toolScope.activeState(selectedElement);
									}
								});
							});
						},
						sendKeyCommand: function(event){
							// we return true if we applied an action, false otherwise
							var result = false;
							if(event.ctrlKey || event.metaKey || event.specialKey) angular.forEach(taTools, function(tool, name){
								if(tool.commandKeyCode && (tool.commandKeyCode === event.which || tool.commandKeyCode === event.specialKey)){
									for(var _t = 0; _t < _toolbars.length; _t++){
										if(_toolbars[_t].tools[name] !== undefined){
											taToolExecuteAction.call(_toolbars[_t].tools[name], scope);
											result = true;
											break;
										}
									}
								}
							});
							return result;
						},
						triggerElementSelect: function(event, element){
							// search through the taTools to see if a match for the tag is made.
							// if there is, see if the tool is on a registered toolbar and not disabled.
							// NOTE: This can trigger on MULTIPLE tools simultaneously.
							var elementHasAttrs = function(_element, attrs){
								var result = true;
								for(var i = 0; i < attrs.length; i++) result = result && _element.attr(attrs[i]);
								return result;
							};
							var workerTools = [];
							var unfilteredTools = {};
							var result = false;
							element = angular.element(element);
							// get all valid tools by element name, keep track if one matches the
							var onlyWithAttrsFilter = false;
							angular.forEach(taTools, function(tool, name){
								if(
									tool.onElementSelect &&
									tool.onElementSelect.element &&
									tool.onElementSelect.element.toLowerCase() === element[0].tagName.toLowerCase() &&
									(!tool.onElementSelect.filter || tool.onElementSelect.filter(element))
								){
									// this should only end up true if the element matches the only attributes
									onlyWithAttrsFilter = onlyWithAttrsFilter ||
										(angular.isArray(tool.onElementSelect.onlyWithAttrs) && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs));
									if(!tool.onElementSelect.onlyWithAttrs || elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs)) unfilteredTools[name] = tool;
								}
							});
							// if we matched attributes to filter on, then filter, else continue
							if(onlyWithAttrsFilter){
								angular.forEach(unfilteredTools, function(tool, name){
									if(tool.onElementSelect.onlyWithAttrs && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs)) workerTools.push({'name': name, 'tool': tool});
								});
								// sort most specific (most attrs to find) first
								workerTools.sort(function(a,b){
									return b.tool.onElementSelect.onlyWithAttrs.length - a.tool.onElementSelect.onlyWithAttrs.length;
								});
							}else{
								angular.forEach(unfilteredTools, function(tool, name){
									workerTools.push({'name': name, 'tool': tool});
								});
							}
							// Run the actions on the first visible filtered tool only
							if(workerTools.length > 0){
								for(var _i = 0; _i < workerTools.length; _i++){
									var tool = workerTools[_i].tool;
									var name = workerTools[_i].name;
									for(var _t = 0; _t < _toolbars.length; _t++){
										if(_toolbars[_t].tools[name] !== undefined){
											tool.onElementSelect.action.call(_toolbars[_t].tools[name], event, element, scope);
											result = true;
											break;
										}
									}
									if(result) break;
								}
							}
							return result;
						}
					}
				};
				return editors[name].editorFunctions;
			},
			// retrieve editor by name, largely used by testing suites only
			retrieveEditor: function(name){
				return editors[name];
			},
			unregisterEditor: function(name){
				delete editors[name];
			},
			// registers a toolbar such that it can be linked to editors
			registerToolbar: function(scope){
				if(!scope) throw('textAngular Error: A toolbar requires a scope');
				if(!scope.name || scope.name === '') throw('textAngular Error: A toolbar requires a name');
				if(toolbars[scope.name]) throw('textAngular Error: A toolbar with name "' + scope.name + '" already exists');
				toolbars[scope.name] = scope;
				angular.forEach(editors, function(_editor){
					_editor._registerToolbar(scope);
				});
			},
			// retrieve toolbar by name, largely used by testing suites only
			retrieveToolbar: function(name){
				return toolbars[name];
			},
			// retrieve toolbars by editor name, largely used by testing suites only
			retrieveToolbarsViaEditor: function(name){
				var result = [], _this = this;
				angular.forEach(this.retrieveEditor(name).toolbars, function(name){
					result.push(_this.retrieveToolbar(name));
				});
				return result;
			},
			unregisterToolbar: function(name){
				delete toolbars[name];
			},
			// functions for updating the toolbar buttons display
			updateToolsDisplay: function(newTaTools){
				// pass a partial struct of the taTools, this allows us to update the tools on the fly, will not change the defaults.
				var _this = this;
				angular.forEach(newTaTools, function(_newTool, key){
					_this.updateToolDisplay(key, _newTool);
				});
			},
			// this function resets all toolbars to their default tool definitions
			resetToolsDisplay: function(){
				var _this = this;
				angular.forEach(taTools, function(_newTool, key){
					_this.resetToolDisplay(key);
				});
			},
			// update a tool on all toolbars
			updateToolDisplay: function(toolKey, _newTool){
				var _this = this;
				angular.forEach(toolbars, function(toolbarScope, toolbarKey){
					_this.updateToolbarToolDisplay(toolbarKey, toolKey, _newTool);
				});
			},
			// resets a tool to the default/starting state on all toolbars
			resetToolDisplay: function(toolKey){
				var _this = this;
				angular.forEach(toolbars, function(toolbarScope, toolbarKey){
					_this.resetToolbarToolDisplay(toolbarKey, toolKey);
				});
			},
			// update a tool on a specific toolbar
			updateToolbarToolDisplay: function(toolbarKey, toolKey, _newTool){
				if(toolbars[toolbarKey]) toolbars[toolbarKey].updateToolDisplay(toolKey, _newTool);
				else throw('textAngular Error: No Toolbar with name "' + toolbarKey + '" exists');
			},
			// reset a tool on a specific toolbar to it's default starting value
			resetToolbarToolDisplay: function(toolbarKey, toolKey){
				if(toolbars[toolbarKey]) toolbars[toolbarKey].updateToolDisplay(toolKey, taTools[toolKey], true);
				else throw('textAngular Error: No Toolbar with name "' + toolbarKey + '" exists');
			},
			// removes a tool from all toolbars and it's definition
			removeTool: function(toolKey){
				delete taTools[toolKey];
				angular.forEach(toolbars, function(toolbarScope){
					delete toolbarScope.tools[toolKey];
					for(var i = 0; i < toolbarScope.toolbar.length; i++){
						var toolbarIndex;
						for(var j = 0; j < toolbarScope.toolbar[i].length; j++){
							if(toolbarScope.toolbar[i][j] === toolKey){
								toolbarIndex = {
									group: i,
									index: j
								};
								break;
							}
							if(toolbarIndex !== undefined) break;
						}
						if(toolbarIndex !== undefined){
							toolbarScope.toolbar[toolbarIndex.group].slice(toolbarIndex.index, 1);
							toolbarScope._$element.children().eq(toolbarIndex.group).children().eq(toolbarIndex.index).remove();
						}
					}
				});
			},
			// toolkey, toolDefinition are required. If group is not specified will pick the last group, if index isnt defined will append to group
			addTool: function(toolKey, toolDefinition, group, index){
				taRegisterTool(toolKey, toolDefinition);
				angular.forEach(toolbars, function(toolbarScope){
					toolbarScope.addTool(toolKey, toolDefinition, group, index);
				});
			},
			// adds a Tool but only to one toolbar not all
			addToolToToolbar: function(toolKey, toolDefinition, toolbarKey, group, index){
				taRegisterTool(toolKey, toolDefinition);
				toolbars[toolbarKey].addTool(toolKey, toolDefinition, group, index);
			},
			// this is used when externally the html of an editor has been changed and textAngular needs to be notified to update the model.
			// this will call a $digest if not already happening
			refreshEditor: function(name){
				if(editors[name]){
					editors[name].scope.updateTaBindtaTextElement();
					/* istanbul ignore else: phase catch */
					if(!editors[name].scope.$$phase) editors[name].scope.$digest();
				}else throw('textAngular Error: No Editor with name "' + name + '" exists');
			},
			// this is used by taBind to send a key command in response to a special key event
			sendKeyCommand: function(scope, event){
				angular.forEach(editors, function(_editor){
					/* istanbul ignore else: if nothing to do, do nothing */
					if (_editor.editorFunctions.sendKeyCommand(event)){
						/* istanbul ignore else: don't run if already running */
						if(!scope._bUpdateSelectedStyles){
							scope.updateSelectedStyles();
						}
						event.preventDefault();
						return false;
					}
				});
			}
		};
	}]);
	textAngular.directive('textAngularToolbar', [
		'$compile', 'textAngularManager', 'taOptions', 'taTools', 'taToolExecuteAction', '$window',
		function($compile, textAngularManager, taOptions, taTools, taToolExecuteAction, $window){
			return {
				scope: {
					name: '@' // a name IS required
				},
				restrict: "EA",
				link: function(scope, element, attrs){
					if(!scope.name || scope.name === '') throw('textAngular Error: A toolbar requires a name');
					angular.extend(scope, angular.copy(taOptions));
					if(attrs.taToolbar)						scope.toolbar = scope.$parent.$eval(attrs.taToolbar);
					if(attrs.taToolbarClass)				scope.classes.toolbar = attrs.taToolbarClass;
					if(attrs.taToolbarGroupClass)			scope.classes.toolbarGroup = attrs.taToolbarGroupClass;
					if(attrs.taToolbarButtonClass)			scope.classes.toolbarButton = attrs.taToolbarButtonClass;
					if(attrs.taToolbarActiveButtonClass)	scope.classes.toolbarButtonActive = attrs.taToolbarActiveButtonClass;
					if(attrs.taFocussedClass)				scope.classes.focussed = attrs.taFocussedClass;

					scope.disabled = true;
					scope.focussed = false;
					scope._$element = element;
					element[0].innerHTML = '';
					element.addClass("ta-toolbar " + scope.classes.toolbar);

					scope.$watch('focussed', function(){
						if(scope.focussed) element.addClass(scope.classes.focussed);
						else element.removeClass(scope.classes.focussed);
					});

					var setupToolElement = function(toolDefinition, toolScope){
						var toolElement;
						if(toolDefinition && toolDefinition.display){
							toolElement = angular.element(toolDefinition.display);
						}
						else toolElement = angular.element("<button type='button'>");

						if(toolDefinition && toolDefinition["class"]) toolElement.addClass(toolDefinition["class"]);
						else toolElement.addClass(scope.classes.toolbarButton);

						toolElement.attr('name', toolScope.name);
						// important to not take focus from the main text/html entry
						toolElement.attr('ta-button', 'ta-button');
						toolElement.attr('ng-disabled', 'isDisabled()');
						toolElement.attr('tabindex', '-1');
						toolElement.attr('ng-click', 'executeAction()');
						toolElement.attr('ng-class', 'displayActiveToolClass(active)');

						if (toolDefinition && toolDefinition.tooltiptext) {
							toolElement.attr('title', toolDefinition.tooltiptext);
						}
						if(toolDefinition && !toolDefinition.display && !toolScope._display){
							// first clear out the current contents if any
							toolElement[0].innerHTML = '';
							// add the buttonText
							if(toolDefinition.buttontext) toolElement[0].innerHTML = toolDefinition.buttontext;
							// add the icon to the front of the button if there is content
							if(toolDefinition.iconclass){
								var icon = angular.element('<i>'), content = toolElement[0].innerHTML;
								icon.addClass(toolDefinition.iconclass);
								toolElement[0].innerHTML = '';
								toolElement.append(icon);
								if(content && content !== '') toolElement.append('&nbsp;' + content);
							}
						}

						toolScope._lastToolDefinition = angular.copy(toolDefinition);

						return $compile(toolElement)(toolScope);
					};

					// Keep a reference for updating the active states later
					scope.tools = {};
					// create the tools in the toolbar
					// default functions and values to prevent errors in testing and on init
					scope._parent = {
						disabled: true,
						showHtml: false,
						queryFormatBlockState: function(){ return false; },
						queryCommandState: function(){ return false; }
					};
					var defaultChildScope = {
						$window: $window,
						$editor: function(){
							// dynamically gets the editor as it is set
							return scope._parent;
						},
						isDisabled: function(){
							// to set your own disabled logic set a function or boolean on the tool called 'disabled'
							return ( // this bracket is important as without it it just returns the first bracket and ignores the rest
								// when the button's disabled function/value evaluates to true
								(typeof this.$eval('disabled') !== 'function' && this.$eval('disabled')) || this.$eval('disabled()') ||
								// all buttons except the HTML Switch button should be disabled in the showHtml (RAW html) mode
								(this.name !== 'html' && this.$editor().showHtml) ||
								// if the toolbar is disabled
								this.$parent.disabled ||
								// if the current editor is disabled
								this.$editor().disabled
							);
						},
						displayActiveToolClass: function(active){
							return (active)? scope.classes.toolbarButtonActive : '';
						},
						executeAction: taToolExecuteAction
					};

					angular.forEach(scope.toolbar, function(group){
						// setup the toolbar group
						var groupElement = angular.element("<div>");
						groupElement.addClass(scope.classes.toolbarGroup);
						angular.forEach(group, function(tool){
							// init and add the tools to the group
							// a tool name (key name from taTools struct)
							//creates a child scope of the main angularText scope and then extends the childScope with the functions of this particular tool
							// reference to the scope and element kept
							scope.tools[tool] = angular.extend(scope.$new(true), taTools[tool], defaultChildScope, {name: tool});
							scope.tools[tool].$element = setupToolElement(taTools[tool], scope.tools[tool]);
							// append the tool compiled with the childScope to the group element
							groupElement.append(scope.tools[tool].$element);
						});
						// append the group to the toolbar
						element.append(groupElement);
					});

					// update a tool
					// if a value is set to null, remove from the display
					// when forceNew is set to true it will ignore all previous settings, used to reset to taTools definition
					// to reset to defaults pass in taTools[key] as _newTool and forceNew as true, ie `updateToolDisplay(key, taTools[key], true);`
					scope.updateToolDisplay = function(key, _newTool, forceNew){
						var toolInstance = scope.tools[key];
						if(toolInstance){
							// get the last toolDefinition, then override with the new definition
							if(toolInstance._lastToolDefinition && !forceNew) _newTool = angular.extend({}, toolInstance._lastToolDefinition, _newTool);
							if(_newTool.buttontext === null && _newTool.iconclass === null && _newTool.display === null)
								throw('textAngular Error: Tool Definition for updating "' + key + '" does not have a valid display/iconclass/buttontext value');

							// if tool is defined on this toolbar, update/redo the tool
							if(_newTool.buttontext === null){
								delete _newTool.buttontext;
							}
							if(_newTool.iconclass === null){
								delete _newTool.iconclass;
							}
							if(_newTool.display === null){
								delete _newTool.display;
							}

							var toolElement = setupToolElement(_newTool, toolInstance);
							toolInstance.$element.replaceWith(toolElement);
							toolInstance.$element = toolElement;
						}
					};

					// we assume here that all values passed are valid and correct
					scope.addTool = function(key, _newTool, groupIndex, index){
						scope.tools[key] = angular.extend(scope.$new(true), taTools[key], defaultChildScope, {name: key});
						scope.tools[key].$element = setupToolElement(taTools[key], scope.tools[key]);
						var group;
						if(groupIndex === undefined) groupIndex = scope.toolbar.length - 1;
						group = angular.element(element.children()[groupIndex]);

						if(index === undefined){
							group.append(scope.tools[key].$element);
							scope.toolbar[groupIndex][scope.toolbar[groupIndex].length - 1] = key;
						}else{
							group.children().eq(index).after(scope.tools[key].$element);
							scope.toolbar[groupIndex][index] = key;
						}
					};

					textAngularManager.registerToolbar(scope);

					scope.$on('$destroy', function(){
						textAngularManager.unregisterToolbar(scope.name);
					});
				}
			};
		}
	]);
	})();

/***/ },
/* 196 */
/***/ function(module, exports) {

	/*
	@license textAngular
	Author : Austin Anderson
	License : 2013 MIT
	Version 1.3.7

	See README.md or https://github.com/fraywing/textAngular/wiki for requirements and use.
	*/


	angular.module('textAngularSetup', [])
	// Here we set up the global display defaults, to set your own use a angular $provider#decorator.
	.value('taOptions',  {
		//////////////////////////////////////////////////////////////////////////////////////
	    // forceTextAngularSanitize
	    // set false to allow the textAngular-sanitize provider to be replaced
	    // with angular-sanitize or a custom provider.
		forceTextAngularSanitize: true,
		///////////////////////////////////////////////////////////////////////////////////////
		// keyMappings
		// allow customizable keyMappings for specialized key boards or languages
		//
		// keyMappings provides key mappings that are attached to a given commandKeyCode.
		// To modify a specific keyboard binding, simply provide function which returns true
		// for the event you wish to map to.
		// Or to disable a specific keyboard binding, provide a function which returns false.
		// Note: 'RedoKey' and 'UndoKey' are internally bound to the redo and undo functionality.
		// At present, the following commandKeyCodes are in use:
		// 98, 'TabKey', 'ShiftTabKey', 105, 117, 'UndoKey', 'RedoKey'
		//
		// To map to an new commandKeyCode, add a new key mapping such as:
		// {commandKeyCode: 'CustomKey', testForKey: function (event) {
		//  if (event.keyCode=57 && event.ctrlKey && !event.shiftKey && !event.altKey) return true;
		// } }
		// to the keyMappings. This example maps ctrl+9 to 'CustomKey'
		// Then where taRegisterTool(...) is called, add a commandKeyCode: 'CustomKey' and your
		// tool will be bound to ctrl+9.
		//
		// To disble one of the already bound commandKeyCodes such as 'RedoKey' or 'UndoKey' add:
		// {commandKeyCode: 'RedoKey', testForKey: function (event) { return false; } },
		// {commandKeyCode: 'UndoKey', testForKey: function (event) { return false; } },
		// to disable them.
		//
		keyMappings : [],
		toolbar: [
			['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'pre', 'quote'],
			['bold', 'italics', 'underline', 'strikeThrough', 'ul', 'ol', 'redo', 'undo', 'clear'],
			['justifyLeft','justifyCenter','justifyRight','justifyFull','indent','outdent'],
			['html', 'insertImage', 'insertLink', 'insertVideo', 'wordcount', 'charcount']
		],
		classes: {
			focussed: "focussed",
			toolbar: "btn-toolbar",
			toolbarGroup: "btn-group",
			toolbarButton: "btn btn-default",
			toolbarButtonActive: "active",
			disabled: "disabled",
			textEditor: 'form-control',
			htmlEditor: 'form-control'
		},
		defaultTagAttributes : {
			a: {target:""}
		},
		setup: {
			// wysiwyg mode
			textEditorSetup: function($element){ /* Do some processing here */ },
			// raw html
			htmlEditorSetup: function($element){ /* Do some processing here */ }
		},
		defaultFileDropHandler:
			/* istanbul ignore next: untestable image processing */
			function(file, insertAction){
				var reader = new FileReader();
				if(file.type.substring(0, 5) === 'image'){
					reader.onload = function() {
						if(reader.result !== '') insertAction('insertImage', reader.result, true);
					};

					reader.readAsDataURL(file);
					// NOTE: For async procedures return a promise and resolve it when the editor should update the model.
					return true;
				}
				return false;
			}
	})

	// This is the element selector string that is used to catch click events within a taBind, prevents the default and $emits a 'ta-element-select' event
	// these are individually used in an angular.element().find() call. What can go here depends on whether you have full jQuery loaded or just jQLite with angularjs.
	// div is only used as div.ta-insert-video caught in filter.
	.value('taSelectableElements', ['a','img'])

	// This is an array of objects with the following options:
	//				selector: <string> a jqLite or jQuery selector string
	//				customAttribute: <string> an attribute to search for
	//				renderLogic: <function(element)>
	// Both or one of selector and customAttribute must be defined.
	.value('taCustomRenderers', [
		{
			// Parse back out: '<div class="ta-insert-video" ta-insert-video src="' + urlLink + '" allowfullscreen="true" width="300" frameborder="0" height="250"></div>'
			// To correct video element. For now only support youtube
			selector: 'img',
			customAttribute: 'ta-insert-video',
			renderLogic: function(element){
				var iframe = angular.element('<iframe></iframe>');
				var attributes = element.prop("attributes");
				// loop through element attributes and apply them on iframe
				angular.forEach(attributes, function(attr) {
					iframe.attr(attr.name, attr.value);
				});
				iframe.attr('src', iframe.attr('ta-insert-video'));
				element.replaceWith(iframe);
			}
		}
	])

	.value('taTranslations', {
		// moved to sub-elements
		//toggleHTML: "Toggle HTML",
		//insertImage: "Please enter a image URL to insert",
		//insertLink: "Please enter a URL to insert",
		//insertVideo: "Please enter a youtube URL to embed",
		html: {
			tooltip: 'Toggle html / Rich Text'
		},
		// tooltip for heading - might be worth splitting
		heading: {
			tooltip: 'Heading '
		},
		p: {
			tooltip: 'Paragraph'
		},
		pre: {
			tooltip: 'Preformatted text'
		},
		ul: {
			tooltip: 'Unordered List'
		},
		ol: {
			tooltip: 'Ordered List'
		},
		quote: {
			tooltip: 'Quote/unquote selection or paragraph'
		},
		undo: {
			tooltip: 'Undo'
		},
		redo: {
			tooltip: 'Redo'
		},
		bold: {
			tooltip: 'Bold'
		},
		italic: {
			tooltip: 'Italic'
		},
		underline: {
			tooltip: 'Underline'
		},
		strikeThrough:{
			tooltip: 'Strikethrough'
		},
		justifyLeft: {
			tooltip: 'Align text left'
		},
		justifyRight: {
			tooltip: 'Align text right'
		},
		justifyFull: {
			tooltip: 'Justify text'
		},
		justifyCenter: {
			tooltip: 'Center'
		},
		indent: {
			tooltip: 'Increase indent'
		},
		outdent: {
			tooltip: 'Decrease indent'
		},
		clear: {
			tooltip: 'Clear formatting'
		},
		insertImage: {
			dialogPrompt: 'Please enter an image URL to insert',
			tooltip: 'Insert image',
			hotkey: 'the - possibly language dependent hotkey ... for some future implementation'
		},
		insertVideo: {
			tooltip: 'Insert video',
			dialogPrompt: 'Please enter a youtube URL to embed'
		},
		insertLink: {
			tooltip: 'Insert / edit link',
			dialogPrompt: "Please enter a URL to insert"
		},
		editLink: {
			reLinkButton: {
				tooltip: "Relink"
			},
			unLinkButton: {
				tooltip: "Unlink"
			},
			targetToggle: {
				buttontext: "Open in New Window"
			}
		},
		wordcount: {
			tooltip: 'Display words Count'
		},
			charcount: {
			tooltip: 'Display characters Count'
		}
	})
	.factory('taToolFunctions', ['$window','taTranslations', function($window, taTranslations) {
		return {
			imgOnSelectAction: function(event, $element, editorScope){
				// setup the editor toolbar
				// Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic/display
				var finishEdit = function(){
					editorScope.updateTaBindtaTextElement();
					editorScope.hidePopover();
				};
				event.preventDefault();
				editorScope.displayElements.popover.css('width', '375px');
				var container = editorScope.displayElements.popoverContainer;
				container.empty();
				var buttonGroup = angular.element('<div class="btn-group" style="padding-right: 6px;">');
				var fullButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">100% </button>');
				fullButton.on('click', function(event){
					event.preventDefault();
					$element.css({
						'width': '100%',
						'height': ''
					});
					finishEdit();
				});
				var halfButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">50% </button>');
				halfButton.on('click', function(event){
					event.preventDefault();
					$element.css({
						'width': '50%',
						'height': ''
					});
					finishEdit();
				});
				var quartButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">25% </button>');
				quartButton.on('click', function(event){
					event.preventDefault();
					$element.css({
						'width': '25%',
						'height': ''
					});
					finishEdit();
				});
				var resetButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">Reset</button>');
				resetButton.on('click', function(event){
					event.preventDefault();
					$element.css({
						width: '',
						height: ''
					});
					finishEdit();
				});
				buttonGroup.append(fullButton);
				buttonGroup.append(halfButton);
				buttonGroup.append(quartButton);
				buttonGroup.append(resetButton);
				container.append(buttonGroup);

				buttonGroup = angular.element('<div class="btn-group" style="padding-right: 6px;">');
				var floatLeft = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-left"></i></button>');
				floatLeft.on('click', function(event){
					event.preventDefault();
					// webkit
					$element.css('float', 'left');
					// firefox
					$element.css('cssFloat', 'left');
					// IE < 8
					$element.css('styleFloat', 'left');
					finishEdit();
				});
				var floatRight = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-right"></i></button>');
				floatRight.on('click', function(event){
					event.preventDefault();
					// webkit
					$element.css('float', 'right');
					// firefox
					$element.css('cssFloat', 'right');
					// IE < 8
					$element.css('styleFloat', 'right');
					finishEdit();
				});
				var floatNone = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-justify"></i></button>');
				floatNone.on('click', function(event){
					event.preventDefault();
					// webkit
					$element.css('float', '');
					// firefox
					$element.css('cssFloat', '');
					// IE < 8
					$element.css('styleFloat', '');
					finishEdit();
				});
				buttonGroup.append(floatLeft);
				buttonGroup.append(floatNone);
				buttonGroup.append(floatRight);
				container.append(buttonGroup);

				buttonGroup = angular.element('<div class="btn-group">');
				var remove = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-trash-o"></i></button>');
				remove.on('click', function(event){
					event.preventDefault();
					$element.remove();
					finishEdit();
				});
				buttonGroup.append(remove);
				container.append(buttonGroup);

				editorScope.showPopover($element);
				editorScope.showResizeOverlay($element);
			},
			aOnSelectAction: function(event, $element, editorScope){
				// setup the editor toolbar
				// Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic
				event.preventDefault();
				editorScope.displayElements.popover.css('width', '436px');
				var container = editorScope.displayElements.popoverContainer;
				container.empty();
				container.css('line-height', '28px');
				var link = angular.element('<a href="' + $element.attr('href') + '" target="_blank">' + $element.attr('href') + '</a>');
				link.css({
					'display': 'inline-block',
					'max-width': '200px',
					'overflow': 'hidden',
					'text-overflow': 'ellipsis',
					'white-space': 'nowrap',
					'vertical-align': 'middle'
				});
				container.append(link);
				var buttonGroup = angular.element('<div class="btn-group pull-right">');
				var reLinkButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on" title="' + taTranslations.editLink.reLinkButton.tooltip + '"><i class="fa fa-edit icon-edit"></i></button>');
				reLinkButton.on('click', function(event){
					event.preventDefault();
					var urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, $element.attr('href'));
					if(urlLink && urlLink !== '' && urlLink !== 'http://'){
						$element.attr('href', urlLink);
						editorScope.updateTaBindtaTextElement();
					}
					editorScope.hidePopover();
				});
				buttonGroup.append(reLinkButton);
				var unLinkButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on" title="' + taTranslations.editLink.unLinkButton.tooltip + '"><i class="fa fa-unlink icon-unlink"></i></button>');
				// directly before this click event is fired a digest is fired off whereby the reference to $element is orphaned off
				unLinkButton.on('click', function(event){
					event.preventDefault();
					$element.replaceWith($element.contents());
					editorScope.updateTaBindtaTextElement();
					editorScope.hidePopover();
				});
				buttonGroup.append(unLinkButton);
				var targetToggle = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on">' + taTranslations.editLink.targetToggle.buttontext + '</button>');
				if($element.attr('target') === '_blank'){
					targetToggle.addClass('active');
				}
				targetToggle.on('click', function(event){
					event.preventDefault();
					$element.attr('target', ($element.attr('target') === '_blank') ? '' : '_blank');
					targetToggle.toggleClass('active');
					editorScope.updateTaBindtaTextElement();
				});
				buttonGroup.append(targetToggle);
				container.append(buttonGroup);
				editorScope.showPopover($element);
			},
			extractYoutubeVideoId: function(url) {
				var re = /(?:youtube(?:-nocookie)?\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/i;
				var match = url.match(re);
				return (match && match[1]) || null;
			}
		};
	}])
	.run(['taRegisterTool', '$window', 'taTranslations', 'taSelection', 'taToolFunctions', '$sanitize', 'taOptions', function(taRegisterTool, $window, taTranslations, taSelection, taToolFunctions, $sanitize, taOptions){
		// test for the version of $sanitize that is in use
		// You can disable this check by setting taOptions.textAngularSanitize == false
		var gv = {}; $sanitize('', gv);
		/* istanbul ignore next, throws error */
		if ((taOptions.forceTextAngularSanitize===true) && (gv.version !== 'taSanitize')) {
			throw angular.$$minErr('textAngular')("textAngularSetup", "The textAngular-sanitize provider has been replaced by another -- have you included angular-sanitize by mistake?");
		}
		taRegisterTool("html", {
			iconclass: 'fa fa-code',
			tooltiptext: taTranslations.html.tooltip,
			action: function(){
				this.$editor().switchView();
			},
			activeState: function(){
				return this.$editor().showHtml;
			}
		});
		// add the Header tools
		// convenience functions so that the loop works correctly
		var _retActiveStateFunction = function(q){
			return function(){ return this.$editor().queryFormatBlockState(q); };
		};
		var headerAction = function(){
			return this.$editor().wrapSelection("formatBlock", "<" + this.name.toUpperCase() +">");
		};
		angular.forEach(['h1','h2','h3','h4','h5','h6'], function(h){
			taRegisterTool(h.toLowerCase(), {
				buttontext: h.toUpperCase(),
				tooltiptext: taTranslations.heading.tooltip + h.charAt(1),
				action: headerAction,
				activeState: _retActiveStateFunction(h.toLowerCase())
			});
		});
		taRegisterTool('p', {
			buttontext: 'P',
			tooltiptext: taTranslations.p.tooltip,
			action: function(){
				return this.$editor().wrapSelection("formatBlock", "<P>");
			},
			activeState: function(){ return this.$editor().queryFormatBlockState('p'); }
		});
		// key: pre -> taTranslations[key].tooltip, taTranslations[key].buttontext
		taRegisterTool('pre', {
			buttontext: 'pre',
			tooltiptext: taTranslations.pre.tooltip,
			action: function(){
				return this.$editor().wrapSelection("formatBlock", "<PRE>");
			},
			activeState: function(){ return this.$editor().queryFormatBlockState('pre'); }
		});
		taRegisterTool('ul', {
			iconclass: 'fa fa-list-ul',
			tooltiptext: taTranslations.ul.tooltip,
			action: function(){
				return this.$editor().wrapSelection("insertUnorderedList", null);
			},
			activeState: function(){ return this.$editor().queryCommandState('insertUnorderedList'); }
		});
		taRegisterTool('ol', {
			iconclass: 'fa fa-list-ol',
			tooltiptext: taTranslations.ol.tooltip,
			action: function(){
				return this.$editor().wrapSelection("insertOrderedList", null);
			},
			activeState: function(){ return this.$editor().queryCommandState('insertOrderedList'); }
		});
		taRegisterTool('quote', {
			iconclass: 'fa fa-quote-right',
			tooltiptext: taTranslations.quote.tooltip,
			action: function(){
				return this.$editor().wrapSelection("formatBlock", "<BLOCKQUOTE>");
			},
			activeState: function(){ return this.$editor().queryFormatBlockState('blockquote'); }
		});
		taRegisterTool('undo', {
			iconclass: 'fa fa-undo',
			tooltiptext: taTranslations.undo.tooltip,
			action: function(){
				return this.$editor().wrapSelection("undo", null);
			}
		});
		taRegisterTool('redo', {
			iconclass: 'fa fa-repeat',
			tooltiptext: taTranslations.redo.tooltip,
			action: function(){
				return this.$editor().wrapSelection("redo", null);
			}
		});
		taRegisterTool('bold', {
			iconclass: 'fa fa-bold',
			tooltiptext: taTranslations.bold.tooltip,
			action: function(){
				return this.$editor().wrapSelection("bold", null);
			},
			activeState: function(){
				return this.$editor().queryCommandState('bold');
			},
			commandKeyCode: 98
		});
		taRegisterTool('justifyLeft', {
			iconclass: 'fa fa-align-left',
			tooltiptext: taTranslations.justifyLeft.tooltip,
			action: function(){
				return this.$editor().wrapSelection("justifyLeft", null);
			},
			activeState: function(commonElement){
				/* istanbul ignore next: */
				if (commonElement && commonElement.nodeName === '#document') return false;
				var result = false;
				if (commonElement)
					result =
						commonElement.css('text-align') === 'left' ||
						commonElement.attr('align') === 'left' ||
						(
							commonElement.css('text-align') !== 'right' &&
							commonElement.css('text-align') !== 'center' &&
							commonElement.css('text-align') !== 'justify' && !this.$editor().queryCommandState('justifyRight') && !this.$editor().queryCommandState('justifyCenter')
						) && !this.$editor().queryCommandState('justifyFull');
				result = result || this.$editor().queryCommandState('justifyLeft');
				return result;
			}
		});
		taRegisterTool('justifyRight', {
			iconclass: 'fa fa-align-right',
			tooltiptext: taTranslations.justifyRight.tooltip,
			action: function(){
				return this.$editor().wrapSelection("justifyRight", null);
			},
			activeState: function(commonElement){
				/* istanbul ignore next: */
				if (commonElement && commonElement.nodeName === '#document') return false;
				var result = false;
				if(commonElement) result = commonElement.css('text-align') === 'right';
				result = result || this.$editor().queryCommandState('justifyRight');
				return result;
			}
		});
		taRegisterTool('justifyFull', {
			iconclass: 'fa fa-align-justify',
			tooltiptext: taTranslations.justifyFull.tooltip,
			action: function(){
				return this.$editor().wrapSelection("justifyFull", null);
			},
			activeState: function(commonElement){
				var result = false;
				if(commonElement) result = commonElement.css('text-align') === 'justify';
				result = result || this.$editor().queryCommandState('justifyFull');
				return result;
			}
		});
		taRegisterTool('justifyCenter', {
			iconclass: 'fa fa-align-center',
			tooltiptext: taTranslations.justifyCenter.tooltip,
			action: function(){
				return this.$editor().wrapSelection("justifyCenter", null);
			},
			activeState: function(commonElement){
				/* istanbul ignore next: */
				if (commonElement && commonElement.nodeName === '#document') return false;
				var result = false;
				if(commonElement) result = commonElement.css('text-align') === 'center';
				result = result || this.$editor().queryCommandState('justifyCenter');
				return result;
			}
		});
		taRegisterTool('indent', {
			iconclass: 'fa fa-indent',
			tooltiptext: taTranslations.indent.tooltip,
			action: function(){
				return this.$editor().wrapSelection("indent", null);
			},
			activeState: function(){
				return this.$editor().queryFormatBlockState('blockquote');
			},
			commandKeyCode: 'TabKey'
		});
		taRegisterTool('outdent', {
			iconclass: 'fa fa-outdent',
			tooltiptext: taTranslations.outdent.tooltip,
			action: function(){
				return this.$editor().wrapSelection("outdent", null);
			},
			activeState: function(){
				return false;
			},
			commandKeyCode: 'ShiftTabKey'
		});
		taRegisterTool('italics', {
			iconclass: 'fa fa-italic',
			tooltiptext: taTranslations.italic.tooltip,
			action: function(){
				return this.$editor().wrapSelection("italic", null);
			},
			activeState: function(){
				return this.$editor().queryCommandState('italic');
			},
			commandKeyCode: 105
		});
		taRegisterTool('underline', {
			iconclass: 'fa fa-underline',
			tooltiptext: taTranslations.underline.tooltip,
			action: function(){
				return this.$editor().wrapSelection("underline", null);
			},
			activeState: function(){
				return this.$editor().queryCommandState('underline');
			},
			commandKeyCode: 117
		});
		taRegisterTool('strikeThrough', {
			iconclass: 'fa fa-strikethrough',
			tooltiptext: taTranslations.strikeThrough.tooltip,
			action: function(){
				return this.$editor().wrapSelection("strikeThrough", null);
			},
			activeState: function(){
				return document.queryCommandState('strikeThrough');
			}
		});
		taRegisterTool('clear', {
			iconclass: 'fa fa-ban',
			tooltiptext: taTranslations.clear.tooltip,
			action: function(deferred, restoreSelection){
				var i;
				this.$editor().wrapSelection("removeFormat", null);
				var possibleNodes = angular.element(taSelection.getSelectionElement());
				// remove lists
				var removeListElements = function(list){
					list = angular.element(list);
					var prevElement = list;
					angular.forEach(list.children(), function(liElem){
						var newElem = angular.element('<p></p>');
						newElem.html(angular.element(liElem).html());
						prevElement.after(newElem);
						prevElement = newElem;
					});
					list.remove();
				};
				angular.forEach(possibleNodes.find("ul"), removeListElements);
				angular.forEach(possibleNodes.find("ol"), removeListElements);
				if(possibleNodes[0].tagName.toLowerCase() === 'li'){
					var _list = possibleNodes[0].parentNode.childNodes;
					var _preLis = [], _postLis = [], _found = false;
					for(i = 0; i < _list.length; i++){
						if(_list[i] === possibleNodes[0]){
							_found = true;
						}else if(!_found) _preLis.push(_list[i]);
						else _postLis.push(_list[i]);
					}
					var _parent = angular.element(possibleNodes[0].parentNode);
					var newElem = angular.element('<p></p>');
					newElem.html(angular.element(possibleNodes[0]).html());
					if(_preLis.length === 0 || _postLis.length === 0){
						if(_postLis.length === 0) _parent.after(newElem);
						else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);

						if(_preLis.length === 0 && _postLis.length === 0) _parent.remove();
						else angular.element(possibleNodes[0]).remove();
					}else{
						var _firstList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');
						var _secondList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');
						for(i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));
						for(i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));
						_parent.after(_secondList);
						_parent.after(newElem);
						_parent.after(_firstList);
						_parent.remove();
					}
					taSelection.setSelectionToElementEnd(newElem[0]);
				}
				// clear out all class attributes. These do not seem to be cleared via removeFormat
				var $editor = this.$editor();
				var recursiveRemoveClass = function(node){
					node = angular.element(node);
					if(node[0] !== $editor.displayElements.text[0]) node.removeAttr('class');
					angular.forEach(node.children(), recursiveRemoveClass);
				};
				angular.forEach(possibleNodes, recursiveRemoveClass);
				// check if in list. If not in list then use formatBlock option
				if(possibleNodes[0].tagName.toLowerCase() !== 'li' &&
					possibleNodes[0].tagName.toLowerCase() !== 'ol' &&
					possibleNodes[0].tagName.toLowerCase() !== 'ul') this.$editor().wrapSelection("formatBlock", "default");
				restoreSelection();
			}
		});


		taRegisterTool('insertImage', {
			iconclass: 'fa fa-picture-o',
			tooltiptext: taTranslations.insertImage.tooltip,
			action: function(){
				var imageLink;
				imageLink = $window.prompt(taTranslations.insertImage.dialogPrompt, 'http://');
				if(imageLink && imageLink !== '' && imageLink !== 'http://'){
					return this.$editor().wrapSelection('insertImage', imageLink, true);
				}
			},
			onElementSelect: {
				element: 'img',
				action: taToolFunctions.imgOnSelectAction
			}
		});
		taRegisterTool('insertVideo', {
			iconclass: 'fa fa-youtube-play',
			tooltiptext: taTranslations.insertVideo.tooltip,
			action: function(){
				var urlPrompt;
				urlPrompt = $window.prompt(taTranslations.insertVideo.dialogPrompt, 'https://');
				if (urlPrompt && urlPrompt !== '' && urlPrompt !== 'https://') {

					videoId = taToolFunctions.extractYoutubeVideoId(urlPrompt);

					/* istanbul ignore else: if it's invalid don't worry - though probably should show some kind of error message */
					if(videoId){
						// create the embed link
						var urlLink = "https://www.youtube.com/embed/" + videoId;
						// create the HTML
						// for all options see: http://stackoverflow.com/questions/2068344/how-do-i-get-a-youtube-video-thumbnail-from-the-youtube-api
						// maxresdefault.jpg seems to be undefined on some.
						var embed = '<img class="ta-insert-video" src="https://img.youtube.com/vi/' + videoId + '/hqdefault.jpg" ta-insert-video="' + urlLink + '" contenteditable="false" allowfullscreen="true" frameborder="0" />';
						// insert
						return this.$editor().wrapSelection('insertHTML', embed, true);
					}
				}
			},
			onElementSelect: {
				element: 'img',
				onlyWithAttrs: ['ta-insert-video'],
				action: taToolFunctions.imgOnSelectAction
			}
		});
		taRegisterTool('insertLink', {
			tooltiptext: taTranslations.insertLink.tooltip,
			iconclass: 'fa fa-link',
			action: function(){
				var urlLink;
				urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, 'http://');
				if(urlLink && urlLink !== '' && urlLink !== 'http://'){
					return this.$editor().wrapSelection('createLink', urlLink, true);
				}
			},
			activeState: function(commonElement){
				if(commonElement) return commonElement[0].tagName === 'A';
				return false;
			},
			onElementSelect: {
				element: 'a',
				action: taToolFunctions.aOnSelectAction
			}
		});
		taRegisterTool('wordcount', {
			display: '<div id="toolbarWC" style="display:block; min-width:100px;">Words: <span ng-bind="wordcount"></span></div>',
			disabled: true,
			wordcount: 0,
			activeState: function(){ // this fires on keyup
				var textElement = this.$editor().displayElements.text;
				/* istanbul ignore next: will default to '' when undefined */
				var workingHTML = textElement[0].innerHTML || '';
				var noOfWords = 0;

				/* istanbul ignore if: will default to '' when undefined */
				if (workingHTML.replace(/\s*<[^>]*?>\s*/g, '') !== '') {
					noOfWords = workingHTML.replace(/<\/?(b|i|em|strong|span|u|strikethrough|a|img|small|sub|sup|label)( [^>*?])?>/gi, '') // remove inline tags without adding spaces
											.replace(/(<[^>]*?>\s*<[^>]*?>)/ig, ' ') // replace adjacent tags with possible space between with a space
											.replace(/(<[^>]*?>)/ig, '') // remove any singular tags
											.replace(/\s+/ig, ' ') // condense spacing
											.match(/\S+/g).length; // count remaining non-space strings
				}

				//Set current scope
				this.wordcount = noOfWords;
				//Set editor scope
				this.$editor().wordcount = noOfWords;

				return false;
			}
		});
		taRegisterTool('charcount', {
			display: '<div id="toolbarCC" style="display:block; min-width:120px;">Characters: <span ng-bind="charcount"></span></div>',
			disabled: true,
			charcount: 0,
			activeState: function(){ // this fires on keyup
				var textElement = this.$editor().displayElements.text;
				var sourceText = textElement[0].innerText || textElement[0].textContent; // to cover the non-jquery use case.

				// Caculate number of chars
				var noOfChars = sourceText.replace(/(\r\n|\n|\r)/gm,"").replace(/^\s+/g,' ').replace(/\s+$/g, ' ').length;
				//Set current scope
				this.charcount = noOfChars;
				//Set editor scope
				this.$editor().charcount = noOfChars;
				return false;
			}
		});
	}]);


/***/ },
/* 197 */
/***/ function(module, exports) {

	/*!
	 * ui-select
	 * http://github.com/angular-ui/ui-select
	 * Version: 0.18.1 - 2016-07-10T00:30:49.391Z
	 * License: MIT
	 */


	(function () { 
	"use strict";
	var KEY = {
	    TAB: 9,
	    ENTER: 13,
	    ESC: 27,
	    SPACE: 32,
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40,
	    SHIFT: 16,
	    CTRL: 17,
	    ALT: 18,
	    PAGE_UP: 33,
	    PAGE_DOWN: 34,
	    HOME: 36,
	    END: 35,
	    BACKSPACE: 8,
	    DELETE: 46,
	    COMMAND: 91,

	    MAP: { 91 : "COMMAND", 8 : "BACKSPACE" , 9 : "TAB" , 13 : "ENTER" , 16 : "SHIFT" , 17 : "CTRL" , 18 : "ALT" , 19 : "PAUSEBREAK" , 20 : "CAPSLOCK" , 27 : "ESC" , 32 : "SPACE" , 33 : "PAGE_UP", 34 : "PAGE_DOWN" , 35 : "END" , 36 : "HOME" , 37 : "LEFT" , 38 : "UP" , 39 : "RIGHT" , 40 : "DOWN" , 43 : "+" , 44 : "PRINTSCREEN" , 45 : "INSERT" , 46 : "DELETE", 48 : "0" , 49 : "1" , 50 : "2" , 51 : "3" , 52 : "4" , 53 : "5" , 54 : "6" , 55 : "7" , 56 : "8" , 57 : "9" , 59 : ";", 61 : "=" , 65 : "A" , 66 : "B" , 67 : "C" , 68 : "D" , 69 : "E" , 70 : "F" , 71 : "G" , 72 : "H" , 73 : "I" , 74 : "J" , 75 : "K" , 76 : "L", 77 : "M" , 78 : "N" , 79 : "O" , 80 : "P" , 81 : "Q" , 82 : "R" , 83 : "S" , 84 : "T" , 85 : "U" , 86 : "V" , 87 : "W" , 88 : "X" , 89 : "Y" , 90 : "Z", 96 : "0" , 97 : "1" , 98 : "2" , 99 : "3" , 100 : "4" , 101 : "5" , 102 : "6" , 103 : "7" , 104 : "8" , 105 : "9", 106 : "*" , 107 : "+" , 109 : "-" , 110 : "." , 111 : "/", 112 : "F1" , 113 : "F2" , 114 : "F3" , 115 : "F4" , 116 : "F5" , 117 : "F6" , 118 : "F7" , 119 : "F8" , 120 : "F9" , 121 : "F10" , 122 : "F11" , 123 : "F12", 144 : "NUMLOCK" , 145 : "SCROLLLOCK" , 186 : ";" , 187 : "=" , 188 : "," , 189 : "-" , 190 : "." , 191 : "/" , 192 : "`" , 219 : "[" , 220 : "\\" , 221 : "]" , 222 : "'"
	    },

	    isControl: function (e) {
	        var k = e.which;
	        switch (k) {
	        case KEY.COMMAND:
	        case KEY.SHIFT:
	        case KEY.CTRL:
	        case KEY.ALT:
	            return true;
	        }

	        if (e.metaKey || e.ctrlKey || e.altKey) return true;

	        return false;
	    },
	    isFunctionKey: function (k) {
	        k = k.which ? k.which : k;
	        return k >= 112 && k <= 123;
	    },
	    isVerticalMovement: function (k){
	      return ~[KEY.UP, KEY.DOWN].indexOf(k);
	    },
	    isHorizontalMovement: function (k){
	      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);
	    },
	    toSeparator: function (k) {
	      var sep = {ENTER:"\n",TAB:"\t",SPACE:" "}[k];
	      if (sep) return sep;
	      // return undefined for special keys other than enter, tab or space.
	      // no way to use them to cut strings.
	      return KEY[k] ? undefined : k;
	    }
	  };

	/**
	 * Add querySelectorAll() to jqLite.
	 *
	 * jqLite find() is limited to lookups by tag name.
	 * TODO This will change with future versions of AngularJS, to be removed when this happens
	 *
	 * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586
	 * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598
	 */
	if (angular.element.prototype.querySelectorAll === undefined) {
	  angular.element.prototype.querySelectorAll = function(selector) {
	    return angular.element(this[0].querySelectorAll(selector));
	  };
	}

	/**
	 * Add closest() to jqLite.
	 */
	if (angular.element.prototype.closest === undefined) {
	  angular.element.prototype.closest = function( selector) {
	    var elem = this[0];
	    var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;

	    while (elem) {
	      if (matchesSelector.bind(elem)(selector)) {
	        return elem;
	      } else {
	        elem = elem.parentElement;
	      }
	    }
	    return false;
	  };
	}

	var latestId = 0;

	var uis = angular.module('ui.select', [])

	.constant('uiSelectConfig', {
	  theme: 'bootstrap',
	  searchEnabled: true,
	  sortable: false,
	  placeholder: '', // Empty by default, like HTML tag <select>
	  refreshDelay: 1000, // In milliseconds
	  closeOnSelect: true,
	  skipFocusser: false,
	  dropdownPosition: 'auto',
	  removeSelected: true,
	  generateId: function() {
	    return latestId++;
	  },
	  appendToBody: false
	})

	// See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913
	.service('uiSelectMinErr', function() {
	  var minErr = angular.$$minErr('ui.select');
	  return function() {
	    var error = minErr.apply(this, arguments);
	    var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
	    return new Error(message);
	  };
	})

	// Recreates old behavior of ng-transclude. Used internally.
	.directive('uisTranscludeAppend', function () {
	  return {
	    link: function (scope, element, attrs, ctrl, transclude) {
	        transclude(scope, function (clone) {
	          element.append(clone);
	        });
	      }
	    };
	})

	/**
	 * Highlights text that matches $select.search.
	 *
	 * Taken from AngularUI Bootstrap Typeahead
	 * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340
	 */
	.filter('highlight', function() {
	  function escapeRegexp(queryToEscape) {
	    return ('' + queryToEscape).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	  }

	  return function(matchItem, query) {
	    return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
	  };
	})

	/**
	 * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/
	 *
	 * Taken from AngularUI Bootstrap Position:
	 * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70
	 */
	.factory('uisOffset',
	  ['$document', '$window',
	  function ($document, $window) {

	  return function(element) {
	    var boundingClientRect = element[0].getBoundingClientRect();
	    return {
	      width: boundingClientRect.width || element.prop('offsetWidth'),
	      height: boundingClientRect.height || element.prop('offsetHeight'),
	      top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
	      left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
	    };
	  };
	}]);

	uis.directive('uiSelectChoices',
	  ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', '$window',
	  function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile, $window) {

	  return {
	    restrict: 'EA',
	    require: '^uiSelect',
	    replace: true,
	    transclude: true,
	    templateUrl: function(tElement) {
	      // Needed so the uiSelect can detect the transcluded content
	      tElement.addClass('ui-select-choices');

	      // Gets theme attribute from parent (ui-select)
	      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
	      return theme + '/choices.tpl.html';
	    },

	    compile: function(tElement, tAttrs) {

	      if (!tAttrs.repeat) throw uiSelectMinErr('repeat', "Expected 'repeat' expression.");

	      // var repeat = RepeatParser.parse(attrs.repeat);
	      var groupByExp = tAttrs.groupBy;
	      var groupFilterExp = tAttrs.groupFilter;

	      if (groupByExp) {
	        var groups = tElement.querySelectorAll('.ui-select-choices-group');
	        if (groups.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
	        groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
	      }

	      var parserResult = RepeatParser.parse(tAttrs.repeat);

	      var choices = tElement.querySelectorAll('.ui-select-choices-row');
	      if (choices.length !== 1) {
	        throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
	      }

	      choices.attr('ng-repeat', parserResult.repeatExpression(groupByExp))
	             .attr('ng-if', '$select.open'); //Prevent unnecessary watches when dropdown is closed
	    

	      var rowsInner = tElement.querySelectorAll('.ui-select-choices-row-inner');
	      if (rowsInner.length !== 1) {
	        throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
	      }
	      rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat

	      // If IE8 then need to target rowsInner to apply the ng-click attr as choices will not capture the event. 
	      var clickTarget = $window.document.addEventListener ? choices : rowsInner;
	      clickTarget.attr('ng-click', '$select.select(' + parserResult.itemName + ',$select.skipFocusser,$event)');
	      
	      return function link(scope, element, attrs, $select) {

	       
	        $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult

	        $select.disableChoiceExpression = attrs.uiDisableChoice;
	        $select.onHighlightCallback = attrs.onHighlight;

	        $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;        

	        scope.$on('$destroy', function() {
	          choices.remove();
	        });

	        scope.$watch('$select.search', function(newValue) {
	          if(newValue && !$select.open && $select.multiple) $select.activate(false, true);
	          $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
	          if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {
	            $select.refresh(attrs.refresh);
	          } else {
	            $select.items = [];
	          }
	        });

	        attrs.$observe('refreshDelay', function() {
	          // $eval() is needed otherwise we get a string instead of a number
	          var refreshDelay = scope.$eval(attrs.refreshDelay);
	          $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
	        });
	      };
	    }
	  };
	}]);

	/**
	 * Contains ui-select "intelligence".
	 *
	 * The goal is to limit dependency on the DOM whenever possible and
	 * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.
	 */
	uis.controller('uiSelectCtrl',
	  ['$scope', '$element', '$timeout', '$filter', '$$uisDebounce', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector', '$window',
	  function($scope, $element, $timeout, $filter, $$uisDebounce, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector, $window) {

	  var ctrl = this;

	  var EMPTY_SEARCH = '';

	  ctrl.placeholder = uiSelectConfig.placeholder;
	  ctrl.searchEnabled = uiSelectConfig.searchEnabled;
	  ctrl.sortable = uiSelectConfig.sortable;
	  ctrl.refreshDelay = uiSelectConfig.refreshDelay;
	  ctrl.paste = uiSelectConfig.paste;

	  ctrl.removeSelected = uiSelectConfig.removeSelected; //If selected item(s) should be removed from dropdown list
	  ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function
	  ctrl.skipFocusser = false; //Set to true to avoid returning focus to ctrl when item is selected
	  ctrl.search = EMPTY_SEARCH;

	  ctrl.activeIndex = 0; //Dropdown of choices
	  ctrl.items = []; //All available choices

	  ctrl.open = false;
	  ctrl.focus = false;
	  ctrl.disabled = false;
	  ctrl.selected = undefined;

	  ctrl.dropdownPosition = 'auto';

	  ctrl.focusser = undefined; //Reference to input element used to handle focus events
	  ctrl.resetSearchInput = true;
	  ctrl.multiple = undefined; // Initialized inside uiSelect directive link function
	  ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function
	  ctrl.tagging = {isActivated: false, fct: undefined};
	  ctrl.taggingTokens = {isActivated: false, tokens: undefined};
	  ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function
	  ctrl.clickTriggeredSelect = false;
	  ctrl.$filter = $filter;
	  ctrl.$element = $element;

	  // Use $injector to check for $animate and store a reference to it
	  ctrl.$animate = (function () {
	    try {
	      return $injector.get('$animate');
	    } catch (err) {
	      // $animate does not exist
	      return null;
	    }
	  })();

	  ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
	  if (ctrl.searchInput.length !== 1) {
	    throw uiSelectMinErr('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
	  }

	  ctrl.isEmpty = function() {
	    return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '' || (ctrl.multiple && ctrl.selected.length === 0);
	  };

	  function _findIndex(collection, predicate, thisArg){
	    if (collection.findIndex){
	      return collection.findIndex(predicate, thisArg);
	    } else {
	      var list = Object(collection);
	      var length = list.length >>> 0;
	      var value;

	      for (var i = 0; i < length; i++) {
	        value = list[i];
	        if (predicate.call(thisArg, value, i, list)) {
	          return i;
	        }
	      }
	      return -1;
	    }
	  }

	  // Most of the time the user does not want to empty the search input when in typeahead mode
	  function _resetSearchInput() {
	    if (ctrl.resetSearchInput || (ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput)) {
	      ctrl.search = EMPTY_SEARCH;
	      //reset activeIndex
	      if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
	        ctrl.activeIndex = _findIndex(ctrl.items, function(item){
	          return angular.equals(this, item);
	        }, ctrl.selected);
	      }
	    }
	  }

	    function _groupsFilter(groups, groupNames) {
	      var i, j, result = [];
	      for(i = 0; i < groupNames.length ;i++){
	        for(j = 0; j < groups.length ;j++){
	          if(groups[j].name == [groupNames[i]]){
	            result.push(groups[j]);
	          }
	        }
	      }
	      return result;
	    }

	  // When the user clicks on ui-select, displays the dropdown list
	  ctrl.activate = function(initSearchValue, avoidReset) {
	    if (!ctrl.disabled  && !ctrl.open) {
	      if(!avoidReset) _resetSearchInput();

	      $scope.$broadcast('uis:activate');

	      ctrl.open = true;

	      ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;

	      // ensure that the index is set to zero for tagging variants
	      // that where first option is auto-selected
	      if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {
	        ctrl.activeIndex = 0;
	      }

	      var container = $element.querySelectorAll('.ui-select-choices-content');
	      var searchInput = $element.querySelectorAll('.ui-select-search');
	      if (ctrl.$animate && ctrl.$animate.on && ctrl.$animate.enabled(container[0])) {
	        var animateHandler = function(elem, phase) {
	          if (phase === 'start' && ctrl.items.length === 0) {
	            // Only focus input after the animation has finished
	            ctrl.$animate.off('removeClass', searchInput[0], animateHandler);
	            $timeout(function () {
	              ctrl.focusSearchInput(initSearchValue);
	            });
	          } else if (phase === 'close') {
	            // Only focus input after the animation has finished
	            ctrl.$animate.off('enter', container[0], animateHandler);
	            $timeout(function () {
	              ctrl.focusSearchInput(initSearchValue);
	            });
	          }
	        };

	        if (ctrl.items.length > 0) {
	          ctrl.$animate.on('enter', container[0], animateHandler);
	        } else {
	          ctrl.$animate.on('removeClass', searchInput[0], animateHandler);
	        }
	      } else {
	        $timeout(function () {
	          ctrl.focusSearchInput(initSearchValue);
	          if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {
	            _ensureHighlightVisible();
	          }
	        });
	      }
	    }
	  };

	  ctrl.focusSearchInput = function (initSearchValue) {
	    ctrl.search = initSearchValue || ctrl.search;
	    ctrl.searchInput[0].focus();
	  };

	  ctrl.findGroupByName = function(name) {
	    return ctrl.groups && ctrl.groups.filter(function(group) {
	      return group.name === name;
	    })[0];
	  };

	  ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {
	    function updateGroups(items) {
	      var groupFn = $scope.$eval(groupByExp);
	      ctrl.groups = [];
	      angular.forEach(items, function(item) {
	        var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
	        var group = ctrl.findGroupByName(groupName);
	        if(group) {
	          group.items.push(item);
	        }
	        else {
	          ctrl.groups.push({name: groupName, items: [item]});
	        }
	      });
	      if(groupFilterExp){
	        var groupFilterFn = $scope.$eval(groupFilterExp);
	        if( angular.isFunction(groupFilterFn)){
	          ctrl.groups = groupFilterFn(ctrl.groups);
	        } else if(angular.isArray(groupFilterFn)){
	          ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
	        }
	      }
	      ctrl.items = [];
	      ctrl.groups.forEach(function(group) {
	        ctrl.items = ctrl.items.concat(group.items);
	      });
	    }

	    function setPlainItems(items) {
	      ctrl.items = items;
	    }

	    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;

	    ctrl.parserResult = RepeatParser.parse(repeatAttr);

	    ctrl.isGrouped = !!groupByExp;
	    ctrl.itemProperty = ctrl.parserResult.itemName;

	    //If collection is an Object, convert it to Array

	    var originalSource = ctrl.parserResult.source;

	    //When an object is used as source, we better create an array and use it as 'source'
	    var createArrayFromObject = function(){
	      var origSrc = originalSource($scope);
	      $scope.$uisSource = Object.keys(origSrc).map(function(v){
	        var result = {};
	        result[ctrl.parserResult.keyName] = v;
	        result.value = origSrc[v];
	        return result;
	      });
	    };

	    if (ctrl.parserResult.keyName){ // Check for (key,value) syntax
	      createArrayFromObject();
	      ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);
	      $scope.$watch(originalSource, function(newVal, oldVal){
	        if (newVal !== oldVal) createArrayFromObject();
	      }, true);
	    }

	    ctrl.refreshItems = function (data){
	      data = data || ctrl.parserResult.source($scope);
	      var selectedItems = ctrl.selected;
	      //TODO should implement for single mode removeSelected
	      if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.multiple || !ctrl.removeSelected) {
	        ctrl.setItemsFn(data);
	      }else{
	        if ( data !== undefined && data !== null ) {
	          var filteredItems = data.filter(function(i) {
	            return angular.isArray(selectedItems) ? selectedItems.every(function(selectedItem) {
	              return !angular.equals(i, selectedItem);
	            }) : !angular.equals(i, selectedItems);
	          });
	          ctrl.setItemsFn(filteredItems);
	        }
	      }
	      if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){
	        $scope.calculateDropdownPos();
	      }

	      $scope.$broadcast('uis:refresh');
	    };

	    // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259
	    $scope.$watchCollection(ctrl.parserResult.source, function(items) {
	      if (items === undefined || items === null) {
	        // If the user specifies undefined or null => reset the collection
	        // Special case: items can be undefined if the user did not initialized the collection on the scope
	        // i.e $scope.addresses = [] is missing
	        ctrl.items = [];
	      } else {
	        if (!angular.isArray(items)) {
	          throw uiSelectMinErr('items', "Expected an array but got '{0}'.", items);
	        } else {
	          //Remove already selected items (ex: while searching)
	          //TODO Should add a test
	          ctrl.refreshItems(items);

	          //update the view value with fresh data from items, if there is a valid model value
	          if(angular.isDefined(ctrl.ngModel.$modelValue)) {
	            ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
	          }
	        }
	      }
	    });

	  };

	  var _refreshDelayPromise;

	  /**
	   * Typeahead mode: lets the user refresh the collection using his own function.
	   *
	   * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31
	   */
	  ctrl.refresh = function(refreshAttr) {
	    if (refreshAttr !== undefined) {

	      // Debounce
	      // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155
	      // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177
	      if (_refreshDelayPromise) {
	        $timeout.cancel(_refreshDelayPromise);
	      }
	      _refreshDelayPromise = $timeout(function() {
	        $scope.$eval(refreshAttr);
	      }, ctrl.refreshDelay);
	    }
	  };

	  ctrl.isActive = function(itemScope) {
	    if ( !ctrl.open ) {
	      return false;
	    }
	    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
	    var isActive =  itemIndex == ctrl.activeIndex;

	    if ( !isActive || itemIndex < 0 ) {
	      return false;
	    }

	    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
	      itemScope.$eval(ctrl.onHighlightCallback);
	    }

	    return isActive;
	  };

	  var _isItemSelected = function (item) {
	    return (ctrl.selected && angular.isArray(ctrl.selected) &&
	        ctrl.selected.filter(function (selection) { return angular.equals(selection, item); }).length > 0);
	  };

	  var disabledItems = [];

	  function _updateItemDisabled(item, isDisabled) {
	    var disabledItemIndex = disabledItems.indexOf(item);
	    if (isDisabled && disabledItemIndex === -1) {
	      disabledItems.push(item);
	    }

	    if (!isDisabled && disabledItemIndex > -1) {
	      disabledItems.splice(disabledItemIndex, 0);
	    }
	  }

	  function _isItemDisabled(item) {
	    return disabledItems.indexOf(item) > -1;
	  }
	  
	  ctrl.isDisabled = function(itemScope) {

	    if (!ctrl.open) return;

	    var item = itemScope[ctrl.itemProperty];
	    var itemIndex = ctrl.items.indexOf(item);
	    var isDisabled = false;
	    
	    if (itemIndex >= 0 && (angular.isDefined(ctrl.disableChoiceExpression) || ctrl.multiple)) {

	      if (item.isTag) return false;

	      if (ctrl.multiple) {
	        isDisabled = _isItemSelected(item);
	      }

	      if (!isDisabled && angular.isDefined(ctrl.disableChoiceExpression)) {
	        isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression));
	      }
	      
	      _updateItemDisabled(item, isDisabled);
	    }

	    return isDisabled;
	  };


	  // When the user selects an item with ENTER or clicks the dropdown
	  ctrl.select = function(item, skipFocusser, $event) {
	    if (item === undefined || !_isItemDisabled(item)) {

	      if ( ! ctrl.items && ! ctrl.search && ! ctrl.tagging.isActivated) return;

	      if (!item || !_isItemDisabled(item)) {
	        if(ctrl.tagging.isActivated) {
	          // if taggingLabel is disabled and item is undefined we pull from ctrl.search
	          if ( ctrl.taggingLabel === false ) {
	            if ( ctrl.activeIndex < 0 ) {
	              if (item === undefined) {
	                item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
	              }
	              if (!item || angular.equals( ctrl.items[0], item ) ) {
	                return;
	              }
	            } else {
	              // keyboard nav happened first, user selected from dropdown
	              item = ctrl.items[ctrl.activeIndex];
	            }
	          } else {
	            // tagging always operates at index zero, taggingLabel === false pushes
	            // the ctrl.search value without having it injected
	            if ( ctrl.activeIndex === 0 ) {
	              // ctrl.tagging pushes items to ctrl.items, so we only have empty val
	              // for `item` if it is a detected duplicate
	              if ( item === undefined ) return;

	              // create new item on the fly if we don't already have one;
	              // use tagging function if we have one
	              if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {
	                item = ctrl.tagging.fct(item);
	                if (!item) return;
	              // if item type is 'string', apply the tagging label
	              } else if ( typeof item === 'string' ) {
	                // trim the trailing space
	                item = item.replace(ctrl.taggingLabel,'').trim();
	              }
	            }
	          }
	          // search ctrl.selected for dupes potentially caused by tagging and return early if found
	          if (_isItemSelected(item)) {
	            ctrl.close(skipFocusser);
	            return;
	          }
	        }

	        $scope.$broadcast('uis:select', item);

	        var locals = {};
	        locals[ctrl.parserResult.itemName] = item;

	        $timeout(function(){
	          ctrl.onSelectCallback($scope, {
	            $item: item,
	            $model: ctrl.parserResult.modelMapper($scope, locals)
	          });
	        });

	        if (ctrl.closeOnSelect) {
	          ctrl.close(skipFocusser);
	        }
	        if ($event && $event.type === 'click') {
	          ctrl.clickTriggeredSelect = true;
	        }
	      }
	    }
	  };

	  // Closes the dropdown
	  ctrl.close = function(skipFocusser) {
	    if (!ctrl.open) return;
	    if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();
	    _resetSearchInput();
	    ctrl.open = false;

	    $scope.$broadcast('uis:close', skipFocusser);

	  };

	  ctrl.setFocus = function(){
	    if (!ctrl.focus) ctrl.focusInput[0].focus();
	  };

	  ctrl.clear = function($event) {
	    ctrl.select(undefined);
	    $event.stopPropagation();
	    $timeout(function() {
	      ctrl.focusser[0].focus();
	    }, 0, false);
	  };

	  // Toggle dropdown
	  ctrl.toggle = function(e) {
	    if (ctrl.open) {
	      ctrl.close();
	      e.preventDefault();
	      e.stopPropagation();
	    } else {
	      ctrl.activate();
	    }
	  };

	  // Set default function for locked choices - avoids unnecessary 
	  // logic if functionality is not being used
	  ctrl.isLocked = function () {
	    return false;
	  };

	  $scope.$watch(function () {
	    return angular.isDefined(ctrl.lockChoiceExpression) && ctrl.lockChoiceExpression !== "";
	  }, _initaliseLockedChoices);

	  function _initaliseLockedChoices(doInitalise) {
	    if(!doInitalise) return;
	    
	    var lockedItems = [];

	    function _updateItemLocked(item, isLocked) {
	      var lockedItemIndex = lockedItems.indexOf(item);
	      if (isLocked && lockedItemIndex === -1) {
	        lockedItems.push(item);
	        }

	      if (!isLocked && lockedItemIndex > -1) {
	        lockedItems.splice(lockedItemIndex, 0);
	      }
	    }

	    function _isItemlocked(item) {
	      return lockedItems.indexOf(item) > -1;
	    }

	    ctrl.isLocked = function (itemScope, itemIndex) {
	      var isLocked = false,
	          item = ctrl.selected[itemIndex];

	      if(item) {
	        if (itemScope) {
	          isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression));
	          _updateItemLocked(item, isLocked);
	        } else {
	          isLocked = _isItemlocked(item);
	        }
	      }

	      return isLocked;
	    };
	  }
	  

	  var sizeWatch = null;
	  var updaterScheduled = false;
	  ctrl.sizeSearchInput = function() {

	    var input = ctrl.searchInput[0],
	        container = ctrl.searchInput.parent().parent()[0],
	        calculateContainerWidth = function() {
	          // Return the container width only if the search input is visible
	          return container.clientWidth * !!input.offsetParent;
	        },
	        updateIfVisible = function(containerWidth) {
	          if (containerWidth === 0) {
	            return false;
	          }
	          var inputWidth = containerWidth - input.offsetLeft - 10;
	          if (inputWidth < 50) inputWidth = containerWidth;
	          ctrl.searchInput.css('width', inputWidth+'px');
	          return true;
	        };

	    ctrl.searchInput.css('width', '10px');
	    $timeout(function() { //Give tags time to render correctly
	      if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
	        sizeWatch = $scope.$watch(function() {
	          if (!updaterScheduled) {
	            updaterScheduled = true;
	            $scope.$$postDigest(function() {
	              updaterScheduled = false;
	              if (updateIfVisible(calculateContainerWidth())) {
	                sizeWatch();
	                sizeWatch = null;
	              }
	            });
	          }
	        }, angular.noop);
	      }
	    });
	  };

	  function _handleDropDownSelection(key) {
	    var processed = true;
	    switch (key) {
	      case KEY.DOWN:
	        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        else if (ctrl.activeIndex < ctrl.items.length - 1) { ctrl.activeIndex++; }
	        break;
	      case KEY.UP:
	        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) { ctrl.activeIndex--; }
	        break;
	      case KEY.TAB:
	        if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);
	        break;
	      case KEY.ENTER:
	        if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){
	          ctrl.select(ctrl.items[ctrl.activeIndex], ctrl.skipFocusser); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode
	        } else {
	          ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        }
	        break;
	      case KEY.ESC:
	        ctrl.close();
	        break;
	      default:
	        processed = false;
	    }
	    return processed;
	  }

	  // Bind to keyboard shortcuts
	  ctrl.searchInput.on('keydown', function(e) {

	    var key = e.which;

	    if (~[KEY.ENTER,KEY.ESC].indexOf(key)){
	      e.preventDefault();
	      e.stopPropagation();
	    }

	    // if(~[KEY.ESC,KEY.TAB].indexOf(key)){
	    //   //TODO: SEGURO?
	    //   ctrl.close();
	    // }

	    $scope.$apply(function() {

	      var tagged = false;

	      if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
	        _handleDropDownSelection(key);
	        if ( ctrl.taggingTokens.isActivated ) {
	          for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
	            if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {
	              // make sure there is a new value to push via tagging
	              if ( ctrl.search.length > 0 ) {
	                tagged = true;
	              }
	            }
	          }
	          if ( tagged ) {
	            $timeout(function() {
	              ctrl.searchInput.triggerHandler('tagged');
	              var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();
	              if ( ctrl.tagging.fct ) {
	                newItem = ctrl.tagging.fct( newItem );
	              }
	              if (newItem) ctrl.select(newItem, true);
	            });
	          }
	        }
	      }

	    });

	    if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){
	      _ensureHighlightVisible();
	    }

	    if (key === KEY.ENTER || key === KEY.ESC) {
	      e.preventDefault();
	      e.stopPropagation();
	    }

	  });

	  ctrl.searchInput.on('paste', function (e) {
	    var data;

	    if (window.clipboardData && window.clipboardData.getData) { // IE
	      data = window.clipboardData.getData('Text');
	    } else {
	      data = (e.originalEvent || e).clipboardData.getData('text/plain');
	    }

	    // Prepend the current input field text to the paste buffer.
	    data = ctrl.search + data;

	    if (data && data.length > 0) {
	      // If tagging try to split by tokens and add items
	      if (ctrl.taggingTokens.isActivated) {
	        var items = [];
	        for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {  // split by first token that is contained in data
	          var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[i]) || ctrl.taggingTokens.tokens[i];
	          if (data.indexOf(separator) > -1) {
	            items = data.split(separator);
	            break;  // only split by one token
	          }
	        }
	        if (items.length === 0) {
	          items = [data];
	        }
	        var oldsearch = ctrl.search;
	        angular.forEach(items, function (item) {
	          var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;
	          if (newItem) {
	            ctrl.select(newItem, true);
	          }
	        });
	        ctrl.search = oldsearch || EMPTY_SEARCH;
	        e.preventDefault();
	        e.stopPropagation();
	      } else if (ctrl.paste) {
	        ctrl.paste(data);
	        ctrl.search = EMPTY_SEARCH;
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    }
	  });

	  ctrl.searchInput.on('tagged', function() {
	    $timeout(function() {
	      _resetSearchInput();
	    });
	  });

	  // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431
	  function _ensureHighlightVisible() {
	    var container = $element.querySelectorAll('.ui-select-choices-content');
	    var choices = container.querySelectorAll('.ui-select-choices-row');
	    if (choices.length < 1) {
	      throw uiSelectMinErr('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
	    }

	    if (ctrl.activeIndex < 0) {
	      return;
	    }

	    var highlighted = choices[ctrl.activeIndex];
	    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
	    var height = container[0].offsetHeight;

	    if (posY > height) {
	      container[0].scrollTop += posY - height;
	    } else if (posY < highlighted.clientHeight) {
	      if (ctrl.isGrouped && ctrl.activeIndex === 0)
	        container[0].scrollTop = 0; //To make group header visible when going all the way up
	      else
	        container[0].scrollTop -= highlighted.clientHeight - posY;
	    }
	  }

	  var onResize = $$uisDebounce(function() {
	    ctrl.sizeSearchInput();
	  }, 50);

	  angular.element($window).bind('resize', onResize);

	  $scope.$on('$destroy', function() {
	    ctrl.searchInput.off('keyup keydown tagged blur paste');
	    angular.element($window).off('resize', onResize);
	  });
	}]);

	uis.directive('uiSelect',
	  ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',
	  function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {

	  return {
	    restrict: 'EA',
	    templateUrl: function(tElement, tAttrs) {
	      var theme = tAttrs.theme || uiSelectConfig.theme;
	      return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
	    },
	    replace: true,
	    transclude: true,
	    require: ['uiSelect', '^ngModel'],
	    scope: true,

	    controller: 'uiSelectCtrl',
	    controllerAs: '$select',
	    compile: function(tElement, tAttrs) {

	      // Allow setting ngClass on uiSelect
	      var match = /{(.*)}\s*{(.*)}/.exec(tAttrs.ngClass);
	      if(match) {
	        var combined = '{'+ match[1] +', '+ match[2] +'}';
	        tAttrs.ngClass = combined;
	        tElement.attr('ng-class', combined);
	      }

	      //Multiple or Single depending if multiple attribute presence
	      if (angular.isDefined(tAttrs.multiple))
	        tElement.append('<ui-select-multiple/>').removeAttr('multiple');
	      else
	        tElement.append('<ui-select-single/>');

	      if (tAttrs.inputId)
	        tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;

	      return function(scope, element, attrs, ctrls, transcludeFn) {

	        var $select = ctrls[0];
	        var ngModel = ctrls[1];

	        $select.generatedId = uiSelectConfig.generateId();
	        $select.baseTitle = attrs.title || 'Select box';
	        $select.focusserTitle = $select.baseTitle + ' focus';
	        $select.focusserId = 'focusser-' + $select.generatedId;

	        $select.closeOnSelect = function() {
	          if (angular.isDefined(attrs.closeOnSelect)) {
	            return $parse(attrs.closeOnSelect)();
	          } else {
	            return uiSelectConfig.closeOnSelect;
	          }
	        }();

	        scope.$watch('skipFocusser', function() {
	            var skipFocusser = scope.$eval(attrs.skipFocusser);
	            $select.skipFocusser = skipFocusser !== undefined ? skipFocusser : uiSelectConfig.skipFocusser;
	        });

	        $select.onSelectCallback = $parse(attrs.onSelect);
	        $select.onRemoveCallback = $parse(attrs.onRemove);

	        //Set reference to ngModel from uiSelectCtrl
	        $select.ngModel = ngModel;

	        $select.choiceGrouped = function(group){
	          return $select.isGrouped && group && group.name;
	        };

	        if(attrs.tabindex){
	          attrs.$observe('tabindex', function(value) {
	            $select.focusInput.attr('tabindex', value);
	            element.removeAttr('tabindex');
	          });
	        }

	        scope.$watch(function () { return scope.$eval(attrs.searchEnabled); }, function(newVal) {
	          $select.searchEnabled = newVal !== undefined ? newVal : uiSelectConfig.searchEnabled;
	        });

	        scope.$watch('sortable', function() {
	            var sortable = scope.$eval(attrs.sortable);
	            $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
	        });

	        attrs.$observe('limit', function() {
	          //Limit the number of selections allowed
	          $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;
	        });

	        scope.$watch('removeSelected', function() {
	            var removeSelected = scope.$eval(attrs.removeSelected);
	            $select.removeSelected = removeSelected !== undefined ? removeSelected : uiSelectConfig.removeSelected;
	        });

	        attrs.$observe('disabled', function() {
	          // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string
	          $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
	        });

	        attrs.$observe('resetSearchInput', function() {
	          // $eval() is needed otherwise we get a string instead of a boolean
	          var resetSearchInput = scope.$eval(attrs.resetSearchInput);
	          $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
	        });

	        attrs.$observe('paste', function() {
	          $select.paste = scope.$eval(attrs.paste);
	        });

	        attrs.$observe('tagging', function() {
	          if(attrs.tagging !== undefined)
	          {
	            // $eval() is needed otherwise we get a string instead of a boolean
	            var taggingEval = scope.$eval(attrs.tagging);
	            $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};
	          }
	          else
	          {
	            $select.tagging = {isActivated: false, fct: undefined};
	          }
	        });

	        attrs.$observe('taggingLabel', function() {
	          if(attrs.tagging !== undefined )
	          {
	            // check eval for FALSE, in this case, we disable the labels
	            // associated with tagging
	            if ( attrs.taggingLabel === 'false' ) {
	              $select.taggingLabel = false;
	            }
	            else
	            {
	              $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
	            }
	          }
	        });

	        attrs.$observe('taggingTokens', function() {
	          if (attrs.tagging !== undefined) {
	            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];
	            $select.taggingTokens = {isActivated: true, tokens: tokens };
	          }
	        });

	        //Automatically gets focus when loaded
	        if (angular.isDefined(attrs.autofocus)){
	          $timeout(function(){
	            $select.setFocus();
	          });
	        }

	        //Gets focus based on scope event name (e.g. focus-on='SomeEventName')
	        if (angular.isDefined(attrs.focusOn)){
	          scope.$on(attrs.focusOn, function() {
	              $timeout(function(){
	                $select.setFocus();
	              });
	          });
	        }

	        function onDocumentClick(e) {
	          if (!$select.open) return; //Skip it if dropdown is close

	          var contains = false;

	          if (window.jQuery) {
	            // Firefox 3.6 does not support element.contains()
	            // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
	            contains = window.jQuery.contains(element[0], e.target);
	          } else {
	            contains = element[0].contains(e.target);
	          }

	          if (!contains && !$select.clickTriggeredSelect) {
	            var skipFocusser;
	            if (!$select.skipFocusser) {
	              //Will lose focus only with certain targets
	              var focusableControls = ['input','button','textarea','select'];
	              var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select
	              skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select
	              if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea
	            } else {
	              skipFocusser = true;
	            }
	            $select.close(skipFocusser);
	            scope.$digest();
	          }
	          $select.clickTriggeredSelect = false;
	        }

	        // See Click everywhere but here event http://stackoverflow.com/questions/12931369
	        $document.on('click', onDocumentClick);

	        scope.$on('$destroy', function() {
	          $document.off('click', onDocumentClick);
	        });

	        // Move transcluded elements to their correct position in main template
	        transcludeFn(scope, function(clone) {
	          // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html

	          // One day jqLite will be replaced by jQuery and we will be able to write:
	          // var transcludedElement = clone.filter('.my-class')
	          // instead of creating a hackish DOM element:
	          var transcluded = angular.element('<div>').append(clone);

	          var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
	          transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr
	          transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes
	          if (transcludedMatch.length !== 1) {
	            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
	          }
	          element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);

	          var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
	          transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr
	          transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes
	          if (transcludedChoices.length !== 1) {
	            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
	          }
	          element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);

	          var transcludedNoChoice = transcluded.querySelectorAll('.ui-select-no-choice');
	          transcludedNoChoice.removeAttr('ui-select-no-choice'); //To avoid loop in case directive as attr
	          transcludedNoChoice.removeAttr('data-ui-select-no-choice'); // Properly handle HTML5 data-attributes
	          if (transcludedNoChoice.length == 1) {
	            element.querySelectorAll('.ui-select-no-choice').replaceWith(transcludedNoChoice);
	          }
	        });

	        // Support for appending the select field to the body when its open
	        var appendToBody = scope.$eval(attrs.appendToBody);
	        if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
	          scope.$watch('$select.open', function(isOpen) {
	            if (isOpen) {
	              positionDropdown();
	            } else {
	              resetDropdown();
	            }
	          });

	          // Move the dropdown back to its original location when the scope is destroyed. Otherwise
	          // it might stick around when the user routes away or the select field is otherwise removed
	          scope.$on('$destroy', function() {
	            resetDropdown();
	          });
	        }

	        // Hold on to a reference to the .ui-select-container element for appendToBody support
	        var placeholder = null,
	            originalWidth = '';

	        function positionDropdown() {
	          // Remember the absolute position of the element
	          var offset = uisOffset(element);

	          // Clone the element into a placeholder element to take its original place in the DOM
	          placeholder = angular.element('<div class="ui-select-placeholder"></div>');
	          placeholder[0].style.width = offset.width + 'px';
	          placeholder[0].style.height = offset.height + 'px';
	          element.after(placeholder);

	          // Remember the original value of the element width inline style, so it can be restored
	          // when the dropdown is closed
	          originalWidth = element[0].style.width;

	          // Now move the actual dropdown element to the end of the body
	          $document.find('body').append(element);

	          element[0].style.position = 'absolute';
	          element[0].style.left = offset.left + 'px';
	          element[0].style.top = offset.top + 'px';
	          element[0].style.width = offset.width + 'px';
	        }

	        function resetDropdown() {
	          if (placeholder === null) {
	            // The dropdown has not actually been display yet, so there's nothing to reset
	            return;
	          }

	          // Move the dropdown element back to its original location in the DOM
	          placeholder.replaceWith(element);
	          placeholder = null;

	          element[0].style.position = '';
	          element[0].style.left = '';
	          element[0].style.top = '';
	          element[0].style.width = originalWidth;

	          // Set focus back on to the moved element
	          $select.setFocus();
	        }

	        // Hold on to a reference to the .ui-select-dropdown element for direction support.
	        var dropdown = null,
	            directionUpClassName = 'direction-up';

	        // Support changing the direction of the dropdown if there isn't enough space to render it.
	        scope.$watch('$select.open', function() {

	          if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){
	            scope.calculateDropdownPos();
	          }

	        });

	        var setDropdownPosUp = function(offset, offsetDropdown){

	          offset = offset || uisOffset(element);
	          offsetDropdown = offsetDropdown || uisOffset(dropdown);

	          dropdown[0].style.position = 'absolute';
	          dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';
	          element.addClass(directionUpClassName);

	        };

	        var setDropdownPosDown = function(offset, offsetDropdown){

	          element.removeClass(directionUpClassName);

	          offset = offset || uisOffset(element);
	          offsetDropdown = offsetDropdown || uisOffset(dropdown);

	          dropdown[0].style.position = '';
	          dropdown[0].style.top = '';

	        };

	        var calculateDropdownPosAfterAnimation = function() {
	          // Delay positioning the dropdown until all choices have been added so its height is correct.
	          $timeout(function() {
	            if ($select.dropdownPosition === 'up') {
	              //Go UP
	              setDropdownPosUp();
	            } else {
	              //AUTO
	              element.removeClass(directionUpClassName);

	              var offset = uisOffset(element);
	              var offsetDropdown = uisOffset(dropdown);

	              //https://code.google.com/p/chromium/issues/detail?id=342307#c4
	              var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).

	              // Determine if the direction of the dropdown needs to be changed.
	              if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {
	                //Go UP
	                setDropdownPosUp(offset, offsetDropdown);
	              }else{
	                //Go DOWN
	                setDropdownPosDown(offset, offsetDropdown);
	              }
	            }

	            // Display the dropdown once it has been positioned.
	            dropdown[0].style.opacity = 1;
	          });
	        };

	        scope.calculateDropdownPos = function() {
	          if ($select.open) {
	            dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');

	            if (dropdown.length === 0) {
	              return;
	            }

	            // Hide the dropdown so there is no flicker until $timeout is done executing.
	            dropdown[0].style.opacity = 0;

	            if (!uisOffset(dropdown).height && $select.$animate && $select.$animate.on && $select.$animate.enabled(dropdown)) {
	              var needsCalculated = true;

	              $select.$animate.on('enter', dropdown, function (elem, phase) {
	                if (phase === 'close' && needsCalculated) {
	                  calculateDropdownPosAfterAnimation();
	                  needsCalculated = false;
	                }
	              });
	            } else {
	              calculateDropdownPosAfterAnimation();
	            }
	          } else {
	            if (dropdown === null || dropdown.length === 0) {
	              return;
	            }

	            // Reset the position of the dropdown.
	            dropdown[0].style.opacity = 0;
	            dropdown[0].style.position = '';
	            dropdown[0].style.top = '';
	            element.removeClass(directionUpClassName);
	          }
	        };
	      };
	    }
	  };
	}]);

	uis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {
	  return {
	    restrict: 'EA',
	    require: '^uiSelect',
	    replace: true,
	    transclude: true,
	    templateUrl: function(tElement) {
	      // Needed so the uiSelect can detect the transcluded content
	      tElement.addClass('ui-select-match');

	      var parent = tElement.parent();
	      // Gets theme attribute from parent (ui-select)
	      var theme = getAttribute(parent, 'theme') || uiSelectConfig.theme;
	      var multi = angular.isDefined(getAttribute(parent, 'multiple'));

	      return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');      
	    },
	    link: function(scope, element, attrs, $select) {
	      $select.lockChoiceExpression = attrs.uiLockChoice;
	      attrs.$observe('placeholder', function(placeholder) {
	        $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
	      });

	      function setAllowClear(allow) {
	        $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;
	      }

	      attrs.$observe('allowClear', setAllowClear);
	      setAllowClear(attrs.allowClear);

	      if($select.multiple){
	        $select.sizeSearchInput();
	      }

	    }
	  };

	  function getAttribute(elem, attribute) {
	    if (elem[0].hasAttribute(attribute))
	      return elem.attr(attribute);

	    if (elem[0].hasAttribute('data-' + attribute))
	      return elem.attr('data-' + attribute);

	    if (elem[0].hasAttribute('x-' + attribute))
	      return elem.attr('x-' + attribute);
	  }
	}]);

	uis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {
	  return {
	    restrict: 'EA',
	    require: ['^uiSelect', '^ngModel'],

	    controller: ['$scope','$timeout', function($scope, $timeout){

	      var ctrl = this,
	          $select = $scope.$select,
	          ngModel;

	      if (angular.isUndefined($select.selected))
	        $select.selected = [];

	      //Wait for link fn to inject it
	      $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });

	      ctrl.activeMatchIndex = -1;

	      ctrl.updateModel = function(){
	        ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes
	        ctrl.refreshComponent();
	      };

	      ctrl.refreshComponent = function(){
	        //Remove already selected items
	        //e.g. When user clicks on a selection, the selected array changes and
	        //the dropdown should remove that item
	        if($select.refreshItems){
	          $select.refreshItems();
	        }
	        if($select.sizeSearchInput){
	          $select.sizeSearchInput();
	        }
	      };

	      // Remove item from multiple select
	      ctrl.removeChoice = function(index){

	        // if the choice is locked, don't remove it
	        if($select.isLocked(null, index)) return false;

	        var removedChoice = $select.selected[index];

	        var locals = {};
	        locals[$select.parserResult.itemName] = removedChoice;

	        $select.selected.splice(index, 1);
	        ctrl.activeMatchIndex = -1;
	        $select.sizeSearchInput();

	        // Give some time for scope propagation.
	        $timeout(function(){
	          $select.onRemoveCallback($scope, {
	            $item: removedChoice,
	            $model: $select.parserResult.modelMapper($scope, locals)
	          });
	        });

	        ctrl.updateModel();

	        return true;
	      };

	      ctrl.getPlaceholder = function(){
	        //Refactor single?
	        if($select.selected && $select.selected.length) return;
	        return $select.placeholder;
	      };


	    }],
	    controllerAs: '$selectMultiple',

	    link: function(scope, element, attrs, ctrls) {

	      var $select = ctrls[0];
	      var ngModel = scope.ngModel = ctrls[1];
	      var $selectMultiple = scope.$selectMultiple;

	      //$select.selected = raw selected objects (ignoring any property binding)

	      $select.multiple = true;

	      //Input that will handle focus
	      $select.focusInput = $select.searchInput;

	      //Properly check for empty if set to multiple
	      ngModel.$isEmpty = function(value) {
	        return !value || value.length === 0;
	      };

	      //From view --> model
	      ngModel.$parsers.unshift(function () {
	        var locals = {},
	            result,
	            resultMultiple = [];
	        for (var j = $select.selected.length - 1; j >= 0; j--) {
	          locals = {};
	          locals[$select.parserResult.itemName] = $select.selected[j];
	          result = $select.parserResult.modelMapper(scope, locals);
	          resultMultiple.unshift(result);
	        }
	        return resultMultiple;
	      });

	      // From model --> view
	      ngModel.$formatters.unshift(function (inputValue) {
	        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
	            locals = {},
	            result;
	        if (!data) return inputValue;
	        var resultMultiple = [];
	        var checkFnMultiple = function(list, value){
	          if (!list || !list.length) return;
	          for (var p = list.length - 1; p >= 0; p--) {
	            locals[$select.parserResult.itemName] = list[p];
	            result = $select.parserResult.modelMapper(scope, locals);
	            if($select.parserResult.trackByExp){
	                var propsItemNameMatches = /(\w*)\./.exec($select.parserResult.trackByExp);
	                var matches = /\.([^\s]+)/.exec($select.parserResult.trackByExp);
	                if(propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName){
	                  if(matches && matches.length>0 && result[matches[1]] == value[matches[1]]){
	                      resultMultiple.unshift(list[p]);
	                      return true;
	                  }
	                }
	            }
	            if (angular.equals(result,value)){
	              resultMultiple.unshift(list[p]);
	              return true;
	            }
	          }
	          return false;
	        };
	        if (!inputValue) return resultMultiple; //If ngModel was undefined
	        for (var k = inputValue.length - 1; k >= 0; k--) {
	          //Check model array of currently selected items
	          if (!checkFnMultiple($select.selected, inputValue[k])){
	            //Check model array of all items available
	            if (!checkFnMultiple(data, inputValue[k])){
	              //If not found on previous lists, just add it directly to resultMultiple
	              resultMultiple.unshift(inputValue[k]);
	            }
	          }
	        }
	        return resultMultiple;
	      });

	      //Watch for external model changes
	      scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {
	        if (oldValue != newValue){
	          //update the view value with fresh data from items, if there is a valid model value
	          if(angular.isDefined(ngModel.$modelValue)) {
	            ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
	          }
	          $selectMultiple.refreshComponent();
	        }
	      });

	      ngModel.$render = function() {
	        // Make sure that model value is array
	        if(!angular.isArray(ngModel.$viewValue)){
	          // Have tolerance for null or undefined values
	          if(angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null){
	            ngModel.$viewValue = [];
	          } else {
	            throw uiSelectMinErr('multiarr', "Expected model value to be array but got '{0}'", ngModel.$viewValue);
	          }
	        }
	        $select.selected = ngModel.$viewValue;
	        $selectMultiple.refreshComponent();
	        scope.$evalAsync(); //To force $digest
	      };

	      scope.$on('uis:select', function (event, item) {
	        if($select.selected.length >= $select.limit) {
	          return;
	        }
	        $select.selected.push(item);
	        $selectMultiple.updateModel();
	      });

	      scope.$on('uis:activate', function () {
	        $selectMultiple.activeMatchIndex = -1;
	      });

	      scope.$watch('$select.disabled', function(newValue, oldValue) {
	        // As the search input field may now become visible, it may be necessary to recompute its size
	        if (oldValue && !newValue) $select.sizeSearchInput();
	      });

	      $select.searchInput.on('keydown', function(e) {
	        var key = e.which;
	        scope.$apply(function() {
	          var processed = false;
	          // var tagged = false; //Checkme
	          if(KEY.isHorizontalMovement(key)){
	            processed = _handleMatchSelection(key);
	          }
	          if (processed  && key != KEY.TAB) {
	            //TODO Check si el tab selecciona aun correctamente
	            //Crear test
	            e.preventDefault();
	            e.stopPropagation();
	          }
	        });
	      });
	      function _getCaretPosition(el) {
	        if(angular.isNumber(el.selectionStart)) return el.selectionStart;
	        // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise
	        else return el.value.length;
	      }
	      // Handles selected options in "multiple" mode
	      function _handleMatchSelection(key){
	        var caretPosition = _getCaretPosition($select.searchInput[0]),
	            length = $select.selected.length,
	            // none  = -1,
	            first = 0,
	            last  = length-1,
	            curr  = $selectMultiple.activeMatchIndex,
	            next  = $selectMultiple.activeMatchIndex+1,
	            prev  = $selectMultiple.activeMatchIndex-1,
	            newIndex = curr;

	        if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;

	        $select.close();

	        function getNewActiveMatchIndex(){
	          switch(key){
	            case KEY.LEFT:
	              // Select previous/first item
	              if(~$selectMultiple.activeMatchIndex) return prev;
	              // Select last item
	              else return last;
	              break;
	            case KEY.RIGHT:
	              // Open drop-down
	              if(!~$selectMultiple.activeMatchIndex || curr === last){
	                $select.activate();
	                return false;
	              }
	              // Select next/last item
	              else return next;
	              break;
	            case KEY.BACKSPACE:
	              // Remove selected item and select previous/first
	              if(~$selectMultiple.activeMatchIndex){
	                if($selectMultiple.removeChoice(curr)) {
	                  return prev;
	                } else {
	                  return curr;
	                }
	                
	              } else {
	                // If nothing yet selected, select last item
	                return last;  
	              }              
	              break;
	            case KEY.DELETE:
	              // Remove selected item and select next item
	              if(~$selectMultiple.activeMatchIndex){
	                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
	                return curr;
	              }
	              else return false;
	          }
	        }

	        newIndex = getNewActiveMatchIndex();

	        if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;
	        else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));

	        return true;
	      }

	      $select.searchInput.on('keyup', function(e) {

	        if ( ! KEY.isVerticalMovement(e.which) ) {
	          scope.$evalAsync( function () {
	            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
	          });
	        }
	        // Push a "create new" item into array if there is a search string
	        if ( $select.tagging.isActivated && $select.search.length > 0 ) {

	          // return early with these keys
	          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {
	            return;
	          }
	          // always reset the activeIndex to the first item when tagging
	          $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
	          // taggingLabel === false bypasses all of this
	          if ($select.taggingLabel === false) return;

	          var items = angular.copy( $select.items );
	          var stashArr = angular.copy( $select.items );
	          var newItem;
	          var item;
	          var hasTag = false;
	          var dupeIndex = -1;
	          var tagItems;
	          var tagItem;

	          // case for object tagging via transform `$select.tagging.fct` function
	          if ( $select.tagging.fct !== undefined) {
	            tagItems = $select.$filter('filter')(items,{'isTag': true});
	            if ( tagItems.length > 0 ) {
	              tagItem = tagItems[0];
	            }
	            // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous
	            if ( items.length > 0 && tagItem ) {
	              hasTag = true;
	              items = items.slice(1,items.length);
	              stashArr = stashArr.slice(1,stashArr.length);
	            }
	            newItem = $select.tagging.fct($select.search);
	            // verify the new tag doesn't match the value of a possible selection choice or an already selected item.
	            if (
	              stashArr.some(function (origItem) {
	                 return angular.equals(origItem, newItem);
	              }) ||
	              $select.selected.some(function (origItem) {
	                return angular.equals(origItem, newItem);
	              })
	            ) {
	              scope.$evalAsync(function () {
	                $select.activeIndex = 0;
	                $select.items = items;
	              });
	              return;
	            }
	            if (newItem) newItem.isTag = true;
	          // handle newItem string and stripping dupes in tagging string context
	          } else {
	            // find any tagging items already in the $select.items array and store them
	            tagItems = $select.$filter('filter')(items,function (item) {
	              return item.match($select.taggingLabel);
	            });
	            if ( tagItems.length > 0 ) {
	              tagItem = tagItems[0];
	            }
	            item = items[0];
	            // remove existing tag item if found (should only ever be one tag item)
	            if ( item !== undefined && items.length > 0 && tagItem ) {
	              hasTag = true;
	              items = items.slice(1,items.length);
	              stashArr = stashArr.slice(1,stashArr.length);
	            }
	            newItem = $select.search+' '+$select.taggingLabel;
	            if ( _findApproxDupe($select.selected, $select.search) > -1 ) {
	              return;
	            }
	            // verify the the tag doesn't match the value of an existing item from
	            // the searched data set or the items already selected
	            if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {
	              // if there is a tag from prev iteration, strip it / queue the change
	              // and return early
	              if ( hasTag ) {
	                items = stashArr;
	                scope.$evalAsync( function () {
	                  $select.activeIndex = 0;
	                  $select.items = items;
	                });
	              }
	              return;
	            }
	            if ( _findCaseInsensitiveDupe(stashArr) ) {
	              // if there is a tag from prev iteration, strip it
	              if ( hasTag ) {
	                $select.items = stashArr.slice(1,stashArr.length);
	              }
	              return;
	            }
	          }
	          if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);
	          // dupe found, shave the first item
	          if ( dupeIndex > -1 ) {
	            items = items.slice(dupeIndex+1,items.length-1);
	          } else {
	            items = [];
	            if (newItem) items.push(newItem);
	            items = items.concat(stashArr);
	          }
	          scope.$evalAsync( function () {
	            $select.activeIndex = 0;
	            $select.items = items;

	            if ($select.isGrouped) {
	              // update item references in groups, so that indexOf will work after angular.copy
	              var itemsWithoutTag = newItem ? items.slice(1) : items;
	              $select.setItemsFn(itemsWithoutTag);
	              if (newItem) {
	                // add tag item as a new group
	                $select.items.unshift(newItem);
	                $select.groups.unshift({name: '', items: [newItem], tagging: true});
	              }
	            }
	          });
	        }
	      });
	      function _findCaseInsensitiveDupe(arr) {
	        if ( arr === undefined || $select.search === undefined ) {
	          return false;
	        }
	        var hasDupe = arr.filter( function (origItem) {
	          if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {
	            return false;
	          }
	          return origItem.toUpperCase() === $select.search.toUpperCase();
	        }).length > 0;

	        return hasDupe;
	      }
	      function _findApproxDupe(haystack, needle) {
	        var dupeIndex = -1;
	        if(angular.isArray(haystack)) {
	          var tempArr = angular.copy(haystack);
	          for (var i = 0; i <tempArr.length; i++) {
	            // handle the simple string version of tagging
	            if ( $select.tagging.fct === undefined ) {
	              // search the array for the match
	              if ( tempArr[i]+' '+$select.taggingLabel === needle ) {
	              dupeIndex = i;
	              }
	            // handle the object tagging implementation
	            } else {
	              var mockObj = tempArr[i];
	              if (angular.isObject(mockObj)) {
	                mockObj.isTag = true;
	              }
	              if ( angular.equals(mockObj, needle) ) {
	                dupeIndex = i;
	              }
	            }
	          }
	        }
	        return dupeIndex;
	      }

	      $select.searchInput.on('blur', function() {
	        $timeout(function() {
	          $selectMultiple.activeMatchIndex = -1;
	        });
	      });

	    }
	  };
	}]);

	uis.directive('uiSelectNoChoice',
	    ['uiSelectConfig', function (uiSelectConfig) {
	        return {
	            restrict: 'EA',
	            require: '^uiSelect',
	            replace: true,
	            transclude: true,
	            templateUrl: function (tElement) {
	                // Needed so the uiSelect can detect the transcluded content
	                tElement.addClass('ui-select-no-choice');
	      
	                // Gets theme attribute from parent (ui-select)
	                var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
	                return theme + '/no-choice.tpl.html';
	            }
	        };
	    }]);

	uis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {
	  return {
	    restrict: 'EA',
	    require: ['^uiSelect', '^ngModel'],
	    link: function(scope, element, attrs, ctrls) {

	      var $select = ctrls[0];
	      var ngModel = ctrls[1];

	      //From view --> model
	      ngModel.$parsers.unshift(function (inputValue) {
	        var locals = {},
	            result;
	        locals[$select.parserResult.itemName] = inputValue;
	        result = $select.parserResult.modelMapper(scope, locals);
	        return result;
	      });

	      //From model --> view
	      ngModel.$formatters.unshift(function (inputValue) {
	        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
	            locals = {},
	            result;
	        if (data){
	          var checkFnSingle = function(d){
	            locals[$select.parserResult.itemName] = d;
	            result = $select.parserResult.modelMapper(scope, locals);
	            return result === inputValue;
	          };
	          //If possible pass same object stored in $select.selected
	          if ($select.selected && checkFnSingle($select.selected)) {
	            return $select.selected;
	          }
	          for (var i = data.length - 1; i >= 0; i--) {
	            if (checkFnSingle(data[i])) return data[i];
	          }
	        }
	        return inputValue;
	      });

	      //Update viewValue if model change
	      scope.$watch('$select.selected', function(newValue) {
	        if (ngModel.$viewValue !== newValue) {
	          ngModel.$setViewValue(newValue);
	        }
	      });

	      ngModel.$render = function() {
	        $select.selected = ngModel.$viewValue;
	      };

	      scope.$on('uis:select', function (event, item) {
	        $select.selected = item;
	      });

	      scope.$on('uis:close', function (event, skipFocusser) {
	        $timeout(function(){
	          $select.focusser.prop('disabled', false);
	          if (!skipFocusser) $select.focusser[0].focus();
	        },0,false);
	      });

	      scope.$on('uis:activate', function () {
	        focusser.prop('disabled', true); //Will reactivate it on .close()
	      });

	      //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954
	      var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
	      $compile(focusser)(scope);
	      $select.focusser = focusser;

	      //Input that will handle focus
	      $select.focusInput = focusser;

	      element.parent().append(focusser);
	      focusser.bind("focus", function(){
	        scope.$evalAsync(function(){
	          $select.focus = true;
	        });
	      });
	      focusser.bind("blur", function(){
	        scope.$evalAsync(function(){
	          $select.focus = false;
	        });
	      });
	      focusser.bind("keydown", function(e){

	        if (e.which === KEY.BACKSPACE) {
	          e.preventDefault();
	          e.stopPropagation();
	          $select.select(undefined);
	          scope.$apply();
	          return;
	        }

	        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
	          return;
	        }

	        if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){
	          e.preventDefault();
	          e.stopPropagation();
	          $select.activate();
	        }

	        scope.$digest();
	      });

	      focusser.bind("keyup input", function(e){

	        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
	          return;
	        }

	        $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input
	        focusser.val('');
	        scope.$digest();

	      });


	    }
	  };
	}]);

	// Make multiple matches sortable
	uis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {
	  return {
	    require: ['^^uiSelect', '^ngModel'],
	    link: function(scope, element, attrs, ctrls) {
	      if (scope[attrs.uiSelectSort] === null) {
	        throw uiSelectMinErr('sort', 'Expected a list to sort');
	      }

	      var $select = ctrls[0];
	      var $ngModel = ctrls[1];

	      var options = angular.extend({
	          axis: 'horizontal'
	        },
	        scope.$eval(attrs.uiSelectSortOptions));

	      var axis = options.axis;
	      var draggingClassName = 'dragging';
	      var droppingClassName = 'dropping';
	      var droppingBeforeClassName = 'dropping-before';
	      var droppingAfterClassName = 'dropping-after';

	      scope.$watch(function(){
	        return $select.sortable;
	      }, function(newValue){
	        if (newValue) {
	          element.attr('draggable', true);
	        } else {
	          element.removeAttr('draggable');
	        }
	      });

	      element.on('dragstart', function(event) {
	        element.addClass(draggingClassName);

	        (event.dataTransfer || event.originalEvent.dataTransfer).setData('text', scope.$index.toString());
	      });

	      element.on('dragend', function() {
	        removeClass(draggingClassName);
	      });

	      var move = function(from, to) {
	        /*jshint validthis: true */
	        this.splice(to, 0, this.splice(from, 1)[0]);
	      };

	      var removeClass = function(className) {
	        angular.forEach($select.$element.querySelectorAll('.' + className), function(el){
	          angular.element(el).removeClass(className);
	        });
	      };

	      var dragOverHandler = function(event) {
	        event.preventDefault();

	        var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);

	        if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {
	          removeClass(droppingAfterClassName);
	          element.addClass(droppingBeforeClassName);

	        } else {
	          removeClass(droppingBeforeClassName);
	          element.addClass(droppingAfterClassName);
	        }
	      };

	      var dropTimeout;

	      var dropHandler = function(event) {
	        event.preventDefault();

	        var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text'), 10);

	        // prevent event firing multiple times in firefox
	        $timeout.cancel(dropTimeout);
	        dropTimeout = $timeout(function() {
	          _dropHandler(droppedItemIndex);
	        }, 20);
	      };

	      var _dropHandler = function(droppedItemIndex) {
	        var theList = scope.$eval(attrs.uiSelectSort);
	        var itemToMove = theList[droppedItemIndex];
	        var newIndex = null;

	        if (element.hasClass(droppingBeforeClassName)) {
	          if (droppedItemIndex < scope.$index) {
	            newIndex = scope.$index - 1;
	          } else {
	            newIndex = scope.$index;
	          }
	        } else {
	          if (droppedItemIndex < scope.$index) {
	            newIndex = scope.$index;
	          } else {
	            newIndex = scope.$index + 1;
	          }
	        }

	        move.apply(theList, [droppedItemIndex, newIndex]);

	        $ngModel.$setViewValue(Date.now());

	        scope.$apply(function() {
	          scope.$emit('uiSelectSort:change', {
	            array: theList,
	            item: itemToMove,
	            from: droppedItemIndex,
	            to: newIndex
	          });
	        });

	        removeClass(droppingClassName);
	        removeClass(droppingBeforeClassName);
	        removeClass(droppingAfterClassName);

	        element.off('drop', dropHandler);
	      };

	      element.on('dragenter', function() {
	        if (element.hasClass(draggingClassName)) {
	          return;
	        }

	        element.addClass(droppingClassName);

	        element.on('dragover', dragOverHandler);
	        element.on('drop', dropHandler);
	      });

	      element.on('dragleave', function(event) {
	        if (event.target != element) {
	          return;
	        }

	        removeClass(droppingClassName);
	        removeClass(droppingBeforeClassName);
	        removeClass(droppingAfterClassName);

	        element.off('dragover', dragOverHandler);
	        element.off('drop', dropHandler);
	      });
	    }
	  };
	}]);

	/**
	 * Debounces functions
	 *
	 * Taken from UI Bootstrap $$debounce source code
	 * See https://github.com/angular-ui/bootstrap/blob/master/src/debounce/debounce.js
	 *
	 */
	uis.factory('$$uisDebounce', ['$timeout', function($timeout) {
	  return function(callback, debounceTime) {
	    var timeoutPromise;

	    return function() {
	      var self = this;
	      var args = Array.prototype.slice.call(arguments);
	      if (timeoutPromise) {
	        $timeout.cancel(timeoutPromise);
	      }

	      timeoutPromise = $timeout(function() {
	        callback.apply(self, args);
	      }, debounceTime);
	    };
	  };
	}]);

	/**
	 * Parses "repeat" attribute.
	 *
	 * Taken from AngularJS ngRepeat source code
	 * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211
	 *
	 * Original discussion about parsing "repeat" attribute instead of fully relying on ng-repeat:
	 * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697
	 */

	uis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {
	  var self = this;

	  /**
	   * Example:
	   * expression = "address in addresses | filter: {street: $select.search} track by $index"
	   * itemName = "address",
	   * source = "addresses | filter: {street: $select.search}",
	   * trackByExp = "$index",
	   */
	  self.parse = function(expression) {


	    var match;
	    //var isObjectCollection = /\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(expression);
	    // If an array is used as collection

	    // if (isObjectCollection){
	    // 000000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000055555555555000000000000000000000066666666600000000
	    match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(\s*[\s\S]+?)?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);

	    // 1 Alias
	    // 2 Item
	    // 3 Key on (key,value)
	    // 4 Value on (key,value)
	    // 5 Source expression (including filters)
	    // 6 Track by

	    if (!match) {
	      throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
	              expression);
	    }
	    
	    var source = match[5], 
	        filters = '';

	    // When using (key,value) ui-select requires filters to be extracted, since the object
	    // is converted to an array for $select.items 
	    // (in which case the filters need to be reapplied)
	    if (match[3]) {
	      // Remove any enclosing parenthesis
	      source = match[5].replace(/(^\()|(\)$)/g, '');
	      // match all after | but not after ||
	      var filterMatch = match[5].match(/^\s*(?:[\s\S]+?)(?:[^\|]|\|\|)+([\s\S]*)\s*$/);
	      if(filterMatch && filterMatch[1].trim()) {
	        filters = filterMatch[1];
	        source = source.replace(filters, '');
	      }      
	    }

	    return {
	      itemName: match[4] || match[2], // (lhs) Left-hand side,
	      keyName: match[3], //for (key, value) syntax
	      source: $parse(source),
	      filters: filters,
	      trackByExp: match[6],
	      modelMapper: $parse(match[1] || match[4] || match[2]),
	      repeatExpression: function (grouped) {
	        var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');
	        if (this.trackByExp) {
	          expression += ' track by ' + this.trackByExp;
	        }
	        return expression;
	      } 
	    };

	  };

	  self.getGroupNgRepeatExpression = function() {
	    return '$group in $select.groups';
	  };

	}]);

	}());
	angular.module("ui.select").run(["$templateCache", function($templateCache) {$templateCache.put("bootstrap/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" role=\"listbox\" ng-show=\"$select.open && $select.items.length > 0\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><a href=\"\" class=\"ui-select-choices-row-inner\"></a></div></li></ul>");
	$templateCache.put("bootstrap/match-multiple.tpl.html","<span class=\"ui-select-match\"><span ng-repeat=\"$item in $select.selected track by $index\"><span class=\"ui-select-match-item btn btn-default btn-xs\" tabindex=\"-1\" type=\"button\" ng-disabled=\"$select.disabled\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span class=\"close ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&nbsp;&times;</span> <span uis-transclude-append=\"\"></span></span></span></span>");
	$templateCache.put("bootstrap/match.tpl.html","<div class=\"ui-select-match\" ng-hide=\"$select.open && $select.searchEnabled\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i></a></span></div>");
	$templateCache.put("bootstrap/no-choice.tpl.html","<ul class=\"ui-select-no-choice dropdown-menu\" ng-show=\"$select.items.length == 0\"><li ng-transclude=\"\"></li></ul>");
	$templateCache.put("bootstrap/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\" ng-class=\"{open: $select.open}\"><div><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" class=\"ui-select-search input-xs\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-click=\"$select.activate()\" ng-model=\"$select.search\" role=\"combobox\" aria-label=\"{{ $select.baseTitle }}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
	$templateCache.put("bootstrap/select.tpl.html","<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"form-control ui-select-search\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.searchEnabled && $select.open\"><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
	$templateCache.put("select2/choices.tpl.html","<ul tabindex=\"-1\" class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{\'select2-result-with-children\': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }\"><li role=\"option\" ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>");
	$templateCache.put("select2/match-multiple.tpl.html","<span class=\"ui-select-match\"><li class=\"ui-select-match-item select2-search-choice\" ng-repeat=\"$item in $select.selected track by $index\" ng-class=\"{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span uis-transclude-append=\"\"></span> <a href=\"javascript:;\" class=\"ui-select-match-close select2-search-choice-close\" ng-click=\"$selectMultiple.removeChoice($index)\" tabindex=\"-1\"></a></li></span>");
	$templateCache.put("select2/match.tpl.html","<a class=\"select2-choice ui-select-match\" ng-class=\"{\'select2-default\': $select.isEmpty()}\" ng-click=\"$select.toggle($event)\" aria-label=\"{{ $select.baseTitle }} select\"><span ng-show=\"$select.isEmpty()\" class=\"select2-chosen\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"select2-chosen\" ng-transclude=\"\"></span> <abbr ng-if=\"$select.allowClear && !$select.isEmpty()\" class=\"select2-search-choice-close\" ng-click=\"$select.clear($event)\"></abbr> <span class=\"select2-arrow ui-select-toggle\"><b></b></span></a>");
	$templateCache.put("select2/no-choice.tpl.html","<div class=\"ui-select-no-choice dropdown\" ng-show=\"$select.items.length == 0\"><div class=\"dropdown-content\"><div data-selectable=\"\" ng-transclude=\"\"></div></div></div>");
	$templateCache.put("select2/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}\"><ul class=\"select2-choices\"><span class=\"ui-select-match\"></span><li class=\"select2-search-field\"><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"select2-input ui-select-search\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-model=\"$select.search\" ng-click=\"$select.activate()\" style=\"width: 34px;\" ondrop=\"return false;\"></li></ul><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open || $select.items.length === 0}\"><div class=\"ui-select-choices\"></div></div></div>");
	$templateCache.put("select2/select.tpl.html","<div class=\"ui-select-container select2 select2-container\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"select2-search\" ng-show=\"$select.searchEnabled\"><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div></div>");
	$templateCache.put("selectize/choices.tpl.html","<div ng-show=\"$select.open\" class=\"ui-select-choices ui-select-dropdown selectize-dropdown single\"><div class=\"ui-select-choices-content selectize-dropdown-content\"><div class=\"ui-select-choices-group optgroup\" role=\"listbox\"><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label optgroup-header\" ng-bind=\"$group.name\"></div><div role=\"option\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\"><div class=\"option ui-select-choices-row-inner\" data-selectable=\"\"></div></div></div></div></div>");
	$templateCache.put("selectize/match.tpl.html","<div ng-hide=\"$select.searchEnabled && ($select.open || $select.isEmpty())\" class=\"ui-select-match\" ng-transclude=\"\"></div>");
	$templateCache.put("selectize/no-choice.tpl.html","<div class=\"ui-select-no-choice selectize-dropdown\" ng-show=\"$select.items.length == 0\"><div class=\"selectize-dropdown-content\"><div data-selectable=\"\" ng-transclude=\"\"></div></div></div>");
	$templateCache.put("selectize/select.tpl.html","<div class=\"ui-select-container selectize-control single\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\"><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" tabindex=\"-1\" class=\"ui-select-search ui-select-toggle\" ng-click=\"$select.toggle($event)\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-hide=\"!$select.searchEnabled || (!$select.isEmpty() && !$select.open)\" ng-disabled=\"$select.disabled\" aria-label=\"{{ $select.baseTitle }}\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");}]);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(197);
	module.exports = 'ui.select';


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 200 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 201 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 202 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ }
/******/ ]);